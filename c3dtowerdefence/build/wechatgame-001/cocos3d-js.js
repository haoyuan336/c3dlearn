"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var _global = "undefined" == typeof window ? global : window, cc$1 = _global.cc = _global.cc || {};

cc$1.internal = cc$1.internal || {}, cc$1._global = _global, _global.CC_BUILD = !0, 
_global.CC_TEST = !1, _global.CC_EDITOR = !1, _global.CC_PREVIEW = !1, _global.CC_DEV = !1, 
_global.CC_DEBUG = !0, _global.CC_JSB = !1, _global.CC_WECHAT = !0, _global.CC_ALIPAY = !1, 
_global.CC_XIAOMI = !1, _global.CC_BAIDU = !1, _global.CC_BYTEDANCE = !1, _global.CC_COCOSPLAY = !1, 
_global.CC_MINIGAME = !0, _global.CC_RUNTIME_BASED = !1, _global.CC_SUPPORT_JIT = !1, 
_global.CC_PHYSICS_BUILTIN = !0, _global.CC_PHYSICS_CANNON = !1, _global.CC_PHYSICS_AMMO = !1;

_global.CocosEngine = cc$1.ENGINE_VERSION = "1.1.2", Object.defineProperty(_global, "CC_PHYSICS_BUILT_IN", {
    get: function get() {
        return console.warn("CC_PHYSICS_BUILT_IN is deprecated, please using CC_PHYSICS_BUILTIN instead."), 
        _global.CC_PHYSICS_BUILTIN;
    }
});

var debugInfos = {
    1100: "Expected 'data' dict, but not found. Config file: %s",
    1101: "Please load the resource first : %s",
    1200: "cocos2d: Director: Error in gettimeofday",
    1204: "running scene should not null",
    1205: "the scene should not null",
    1206: "loadScene: The scene index to load (%s) is out of range.",
    1207: "loadScene: Unknown name type to load: '%s'",
    1208: "loadScene: Failed to load scene '%s' because '%s' is already loading",
    1209: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
    1210: "Failed to preload '%s', %s",
    1211: "loadScene: The scene index to load (%s) is out of range.",
    1212: "loadScene: Unknown name type to load: '%s'",
    1213: "loadScene: Failed to load scene '%s' because '%s' is already loading",
    1214: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
    1215: "Failed to preload '%s', %s",
    1216: "Director.runSceneImmediate: scene is not valid",
    1300: "element type is wrong!",
    1400: "'%s' is deprecated, please use '%s' instead.",
    1401: "The first argument should be the destination object",
    1402: "The 'visible' property of %s is deprecated, use 'enabled' instead please.",
    1403: "Sorry, cc.audioEngine.willPlayMusic is removed.",
    1404: "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
    1405: "The '%s' will be removed in v2.0, please use '%s' instead.",
    1406: "'%s.%s' is removed",
    1407: "cc.pool is being removed from v2.0, you are getting cc.js.Pool instead",
    1502: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    1503: "cc.Scheduler.pauseTarget():target should be non-null",
    1504: "cc.Scheduler.resumeTarget():target should be non-null",
    1505: "cc.Scheduler.isTargetPaused():target should be non-null",
    1506: "warning: you CANNOT change update priority in scheduled function",
    1507: "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
    1508: "Argument callback must not be empty",
    1509: "Argument target must be non-nullptr",
    1510: "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
    1511: "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
    1512: "cc.Scheduler: updateFunc parameter is deprecated in scheduleUpdate function, and will be removed in v2.0",
    1513: "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
    1605: "child already added. It can't be added again",
    1606: "child must be non-null",
    1607: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    1608: "boundingBox is deprecated. Use getBoundingBox instead",
    1609: "argument tag is an invalid tag",
    1619: "callback function must be non-null",
    1620: "interval must be positive",
    1623: "Set '%s' to normal node (not persist root node).",
    1624: "Replacing with the same sgNode",
    1625: "The replacement sgNode should not contain any child.",
    1626: "Should not set alpha via 'color', set 'opacity' please.",
    1627: "Not support for asynchronous creating node in SG",
    1632: "Node name can not include '/'.",
    1633: "Internal error, should not remove unknown node from parent.",
    1634: "addChild: The child to add must be instance of cc.Node, not %s.",
    1635: "reorderChild: this child is not in children list.",
    1636: "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
    1637: "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
    1638: "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
    1800: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    1801: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    1802: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    1803: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    1900: "Invalid parameter.",
    2200: "Resolution not valid",
    2201: "should set resolutionPolicy",
    2300: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
    3103: "textureUtil.addImage(): path should be non-null",
    3119: "Lazy init texture with image element failed due to image loading failure: %s",
    3300: "Rect width exceeds maximum margin: %s",
    3301: "Rect height exceeds maximum margin: %s",
    3500: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    3501: "Invalid listener type!",
    3502: "Can't set fixed priority with scene graph based listener.",
    3503: "Invalid parameters.",
    3504: "listener must be a cc.EventListener object when adding a fixed priority listener",
    3505: "The listener has been registered, please don't register it again.",
    3506: "Unsupported listener target.",
    3507: "Invalid scene graph priority!",
    3508: "If program goes here, there should be event in dispatch.",
    3509: "_inDispatch should be 1 here.",
    3510: "%s's scene graph node not contains in the parent's children",
    3511: "event is undefined",
    3512: "Event manager only support scene graph priority for ui nodes which contain UIComponent",
    3600: "cc.Class will automatically call super constructor of %s, you should not call it manually.",
    3601: "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
    3602: "Unknown editor property '%s' in class '%s'.",
    3603: "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
    3604: "Can only indicate one type attribute for %s.",
    3605: "The default value of %s is not instance of %s.",
    3606: "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
    3607: "The default value of %s must be an empty string.",
    3608: "The type of %s must be CCString, not String.",
    3609: "The type of %s must be CCBoolean, not Boolean.",
    3610: "The type of %s must be CCFloat or CCInteger, not Number.",
    3611: "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
    3612: "%s Just set the default value to 'new %s()' and it will be handled properly.",
    3613: "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
    3614: "Should not define constructor for cc.Component %s.",
    3615: "Each script can have at most one Component.",
    3616: "Should not specify class name %s for Component which defines in project.",
    3617: "Can not instantiate CCClass '%s' with arguments.",
    3618: "ctor of '%s' can not be another CCClass",
    3619: "ctor of '%s' must be function type",
    3620: "this._super declared in '%s.%s' but no super method defined",
    3621: "Unknown type of %s.%s, maybe you want is '%s'.",
    3622: "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
    3623: "Can not use 'editor' attribute, '%s' not inherits from Components.",
    3624: "'%s' overrided '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
    3625: "[isChildClassOf] superclass should be function type, not",
    3626: "Can't remove '%s' because '%s' depends on it.",
    3627: "Should not add renderer component (%s) to a Canvas node.",
    3628: "Should not add %s to a node which size is already used by its other component.",
    3629: "attribute must be type object",
    3633: "Properties function of '%s' should return an object!",
    3634: "Disallow to use '.' in property name",
    3635: "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
    3636: "Do not set default value to non-empty object, unless the object defines its own 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
    3637: "Can not declare %s.%s, it is already defined in the prototype of %s",
    3638: "'%s': the getter of '%s' is already defined!",
    3639: "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
    3640: "'%s': the setter of '%s' is already defined!",
    3641: "Can not construct %s because it contains object property.",
    3642: "Cannot define %s.%s because static member name can not be '%s'.",
    3643: "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
    3644: "Please define 'type' parameter of %s.%s as the actual constructor.",
    3645: "Please define 'type' parameter of %s.%s as the constructor of %s.",
    3646: "Unknown 'type' parameter of %s.%s：%s",
    3647: "The length of range array must be equal or greater than 2",
    3648: "Can not declare %s.%s method, it is already defined in the properties of %s.",
    3649: "CCClass %s have conflict between its ctor and __ctor__.",
    3651: 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
    3652: 'Failed to construct a dummy instance of the "%s" class using `new` behind the scenes. This is for getting default values declared in TypeScript. Please ensure the class will be able to construct during script\'s initialization. %s.',
    3653: 'Please do not specifiy "default" attribute in decorator of "%s" property in "%s" class.\nDefault value must be initialized at their declaration:\n \n// Before:\n@property({ default: 0 }) // <--\n@integer\nvalue;\n// After:\n@integer\nvalue = 0;    // <--',
    3654: 'Please specifiy a default value for "%s" property at its declaration:\n \n// Before:\n@property(...)\nvalue;\n// After:\n@property(...)\nvalue = 0',
    3655: 'Can not specifiy "get" or "set"  attribute in decorator for "%s" property in "%s" class.\nPlease use:\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}',
    3656: "The default value of %s.%s must be an empty string. (changed since 1.8)",
    3657: "The value assigned to %s should be Texture2D object, not url string. Since 1.8,\nyou can declare a texture object directly in properties by using:\n \n{\n    default: null,\n    type: cc.Texture2D  // use 'type:' instead of 'url:'\n}",
    3658: "browser does not support getters",
    3659: "Violation error: extending enumerations shall have non-overlaped member names or member values",
    3660: "You are explicitly specifying `undefined` type to cc property \"%s\" of cc class \"%s\".\nIs this intended? If not, this may indicate a circular reference.\nFor example:\n \n// foo.ts\nimport { _decorator } from 'cc';\nimport { Bar } from './bar';  // Given that './bar' also reference 'foo.ts'.\n                              // When importing './bar', execution of './bar' is hung on to wait execution of 'foo.ts',\n                              // the `Bar` imported here is `undefined` until './bar' finish its execution.\n                              // It leads to that\n@_decorator.ccclass           //  ↓\nexport class Foo {            //  ↓\n    @_decorator.type(Bar)     //  → is equivalent to `@_decorator.type(undefined)`\n    public bar: Bar;          // To eliminate this error, either:\n                              // - Refactor your module structure(recommended), or\n                              // - specify the type as cc class name: `@_decorator.type('Bar'/* or any name you specified for `Bar` */)`\n}",
    3661: 'Register a cc-class through `cc.Class({ /* ... */ })` is deprecated (when registering cc-class "%s"). Use ES6 class syntax and decorators for that purpose instead.',
    3700: "internal error: _prefab is undefined",
    3701: "Failed to load prefab asset for node '%s'",
    3800: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
    3801: "The node can not be made persist because it's not under root node.",
    3802: "The node can not be made persist because it's not in current scene.",
    3803: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
    3804: "getComponent: Type must be non-nil",
    3805: "Can't add component '%s' because %s already contains the same component.",
    3806: "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
    3807: "addComponent: Failed to get class '%s'",
    3808: "addComponent: Should not add component ('%s') when the scripts are still loading.",
    3809: "addComponent: The component to add must be a constructor",
    3810: "addComponent: The component to add must be child class of cc.Component",
    3811: "_addComponentAt: The component to add must be a constructor",
    3812: "_addComponentAt: Index out of range",
    3813: "removeComponent: Component must be non-nil",
    3814: "Argument must be non-nil",
    3815: "Component not owned by this entity",
    3816: "Node '%s' is already activating",
    3817: "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
    3818: "Failed to read or parse project.json",
    3819: "Warning: target element is not a DIV or CANVAS",
    3820: "The renderer doesn't support the renderMode %s",
    3821: "Cannot change hierarchy while activating or deactivating the parent.",
    3822: "addComponent: Cannot add any component to the scene.",
    3900: "Invalid clip to add",
    3901: "Invalid clip to remove",
    3902: "clip is defaultClip, set force to true to force remove clip and animation state",
    3903: "animation state is playing, set force to true to force stop and remove clip and animation state",
    3904: "motion path of target [%s] in prop [%s] frame [%s] is not valid",
    3905: "sprite frames must be an Array.",
    3906: "Can't find easing type [%s]",
    3907: "animator not added or already removed",
    3908: "animation not added or already removed",
    3912: "already-playing",
    4e3: "Sorry, the cc.Font has been modified from Raw Asset to Asset. Please load the font asset before using.",
    4003: "Label font size can't be shirnked less than 0!",
    4004: "force notify all fonts loaded!",
    4011: "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
    4012: "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
    4013: "Sorry, lineHeight of system font not supported on JSB.",
    4100: "Property padding is deprecated, please use paddingLeft, paddingRight, paddingTop and paddingBottom instead",
    4200: "MaskType: IMAGE_STENCIL only support WebGL mode.",
    4201: "The alphaThreshold invalid in Canvas Mode.",
    4202: "The inverted invalid in Canvas Mode.",
    4300: "can not found the %s page.",
    4400: "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
    4600: "Script attached to '%s' is missing or invalid.",
    4700: "The dom control is not created!",
    4800: "unknown asset type",
    4901: "loadRes: should not specify the extname in %s %s",
    4902: "No need to release non-cached asset.",
    4903: "Can not get class '%s'",
    4914: "Resources url '%s' does not exist.",
    4915: "Pack indices and data do not match in size",
    4916: "Failed to download package for %s",
    4920: "Sorry, you shouldn't use id as item identity any more, please use url or uuid instead, the current id is being set as url: (%s)",
    4921: "Invalid pipe or invalid index provided!",
    4922: "The pipe to be inserted is already in the pipeline!",
    4923: "Uuid Loader: Parse asset [ %s ] failed : %s",
    4924: "JSON Loader: Input item doesn't contain string content",
    4925: "Uuid Loader: Deserialize asset [ %s ] failed : %s",
    4926: "Audio Downloader: no web audio context.",
    4927: "Audio Downloader: audio not supported on this browser!",
    4928: "Load %s failed!",
    4929: "Load Webp ( %s ) failed",
    4930: "Load image ( %s ) failed",
    4931: "Download Uuid: can not find type of raw asset[ %s ]: %s",
    4932: 'Since v1.10, for any atlas ("%s") in the "resources" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.',
    4933: "Download Font [ %s ] failed, using Arial or system default font instead",
    4934: "Please assure that the full path of sub asset is correct!",
    4935: "Failed to skip prefab asset while deserializing PrefabInfo",
    5e3: "You are trying to destroy a object twice or more.",
    5001: "object not yet destroyed",
    5100: "Not a plist file!",
    5200: "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
    5201: "browser don't support web audio",
    5202: "This feature supports WebGL render mode only.",
    5300: "Type of target to deserialize not matched with data: target is %s, data is %s",
    5301: "Can not find script '%s'",
    5302: "Can not find class '%s'",
    5400: "'%s' is deprecated, use '%s' instead please.",
    5401: "'%s' is deprecated, use '%s' instead please.",
    5402: "cc.js.addon called on non-object:",
    5403: "cc.js.mixin: arguments must be type object:",
    5404: "The base class to extend from must be non-nil",
    5405: "The class to extend must be non-nil",
    5406: "Class should be extended before assigning any prototype members.",
    5500: "'notify' can't work with 'get/set' !",
    5501: "'notify' must work with 'default' !",
    5502: "Invalid url of %s.%s",
    5503: "The 'url' attribute of '%s.%s' is undefined when loading script.",
    5504: "The 'url' type of '%s.%s' must be child class of cc.RawAsset.",
    5505: "The 'url' type of '%s.%s' must not be child class of cc.Asset, otherwise you should use 'type: %s' instead.",
    5506: "Can not specify 'type' attribute for '%s.%s', because its 'url' is already defined.",
    5507: "The 'default' attribute of '%s.%s' must be an array",
    5508: "Invalid type of %s.%s",
    5510: "The 'type' attribute of '%s.%s' can not be 'Number', use 'Float' or 'Integer' instead please.",
    5511: "The 'type' attribute of '%s.%s' is undefined when loading script",
    5512: "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
    5513: "The 'default' value of '%s.%s' should not be used with a 'get' function.",
    5514: "The 'default' value of '%s.%s' should not be used with a 'set' function.",
    5515: "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
    5516: "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
    5517: "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
    5600: "Argument must be non-nil",
    5601: "Can not get current scene.",
    5602: "Scene is destroyed",
    5603: "reference node is destroyed",
    5700: "no %s or %s on %s",
    5800: "%s.lerp not yet implemented.",
    5801: "%s.clone not yet implemented.",
    5802: "%s.equals not yet implemented.",
    5900: "MotionStreak only support WebGL mode.",
    5901: "cc.MotionStreak.getOpacity has not been supported.",
    5902: "cc.MotionStreak.setOpacity has not been supported.",
    6e3: "Custom should not be false if file is not specified.",
    6001: "The new %s must not be NaN",
    6017: "Incomplete or corrupt PNG file",
    6018: "Invalid filter algorithm: %s",
    6019: "Invalid byte order value.",
    6020: "You forgot your towel!",
    6021: "Unknown Field Tag: %s",
    6022: "Too many bits requested",
    6023: "No bits requested",
    6024: "Cannot recover from missing StripByteCounts",
    6025: "Cannot handle sub-byte bits per sample",
    6026: "Cannot handle sub-byte bits per pixel",
    6027: "Palette image missing color map",
    6028: "Unknown Photometric Interpretation: %s",
    6029: "Unkown error",
    6030: "cc.ParticleSystem: error decoding or ungzipping textureImageData",
    6031: "cc.ParticleSystem: unknown image format with Data",
    6032: "cc.ParticleSystem.initWithDictionary() : error loading the texture",
    6200: "Canvas doesn't support mesh slot!",
    6300: "only cc.DrawNode is accepted as stencil",
    6301: "Stencil buffer is not enabled.",
    6302: "Nesting more than %d stencils is not supported. Everything will be drawn without stencil for this node and its children.",
    6400: "asset.url is not usable in core process",
    6401: "asset.urls is not usable in core process",
    6402: "AssetLibrary has already been initialized!",
    6500: "Widget target must be one of the parent nodes of it",
    6501: "%s's widget target must have UITransformComponent, Please add it in target",
    6600: "collider not added or already removed",
    6601: "Can't find testFunc for (%s, $s).",
    6700: "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time",
    6701: "Should not add Canvas to a node which already contains a renderer component (%s).",
    6702: "Should not add Canvas to a node which size is already used by its other component.",
    6703: "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext",
    6704: "Polygon's point must greater than 2",
    6705: "Argument must be non-nil",
    6800: "Callback of event must be non-nil",
    6801: "The message must be provided",
    6900: "The thing you want to instantiate must be an object",
    6901: "The thing you want to instantiate is nil",
    6902: "The thing you want to instantiate is destroyed",
    6903: "The instantiate method for given asset do not implemented",
    6904: "Can not instantiate array",
    6905: "Can not instantiate DOM element",
    7e3: "Failed to init asset's raw path.",
    7001: "Should not load '%s' from script dynamically, unless it is placed in the 'resources' folder.",
    7002: "Sorry can not load '%s' because it is not placed in the 'resources' folder.",
    7003: "Failed to init builtin asset's raw path.",
    7100: "%s already defined in Enum.",
    7101: "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
    7200: "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
    7201: "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
    7202: "Add component TiledLayer into node failed.",
    7203: "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
    7210: "TMX Hexa zOrder not supported",
    7211: "TMX invalid value",
    7214: "propertiesForGID is deprecated. Please use getPropertiesForGID instead.",
    7215: "cocos2d: Warning: TMX Layer %s has no tiles",
    7216: "cocos2d: TMXFormat: Unsupported TMX version: %s",
    7217: "cocos2d: TMXFomat: Unsupported orientation: %s",
    7218: "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
    7219: "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
    7221: "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
    7222: "Parse %s failed.",
    7236: "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
    7237: "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
    7238: "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
    7239: "cc.TMXLayer.setTileGID(): invalid gid: %s",
    7240: "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
    7241: "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
    7401: "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
    7402: "Failed to set _animationIndex for '%s' because the index is out of range.",
    7501: "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
    7502: "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
    7503: "Failed to set _animationIndex for '%s' because the index is out of range.",
    7504: "Can not render dynamic created SkeletonData",
    7505: "Invalid type of atlasFile, atlas should be registered as raw asset.",
    7506: "Failed to load spine atlas '$s'",
    7507: "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
    7508: "The atlas asset of '%s' is not exists!",
    7509: "Spine: Animation not found: %s",
    7510: "Spine: Animation not found: %s",
    7600: "The context of RenderTexture is invalid.",
    7601: "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
    7602: "Could not attach texture to the framebuffer",
    7603: "clearDepth isn't supported on Cocos2d-Html5",
    7604: "saveToFile isn't supported on Cocos2d-Html5",
    7605: "newCCImage isn't supported on Cocos2d-Html5",
    7700: "On the web is always keep the aspect ratio",
    7701: "Can't know status",
    7702: "Video player's duration is not ready to get now!",
    7800: "Web does not support loading",
    7801: "Web does not support query history",
    7802: "Web does not support query history",
    7803: "The current browser does not support the GoBack",
    7804: "The current browser does not support the GoForward",
    7805: "Web does not support zoom",
    7900: "cc.math.Matrix3.assign(): current matrix equals matIn",
    7901: "cc.math.mat4Assign(): pOut equals pIn",
    7902: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
    7903: "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
    7904: "cc.math.Matrix4.extractPlane: Invalid plane index",
    7905: "cc.math.mat4Assign(): pOut equals pIn",
    7906: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
    7907: "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
    7908: "Invalid matrix mode specified",
    7909: "current quaternion is an invalid value",
    8e3: "Can't handle this field type or size",
    8001: "No bytes requested",
    8002: "Too many bytes requested",
    8003: "Missing StripByteCounts!",
    8100: "cocos2d: ERROR: Failed to compile shader:\n %s",
    8101: "cocos2d: ERROR: Failed to compile vertex shader",
    8102: "cocos2d: ERROR: Failed to compile fragment shader",
    8103: "cc.GLProgram.link(): Cannot link invalid program",
    8104: "cocos2d: ERROR: Failed to link program: %s",
    8105: "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
    8106: "Please load the resource firset : %s",
    8107: "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
    8108: "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
    8109: "modelView matrix is undefined.",
    8200: "Please set node's active instead of rigidbody's enabled.",
    8300: "Should only one camera exists, please check your project.",
    8301: "Camera does not support Canvas Mode.",
    8400: "Wrong type arguments, 'filePath' must be a String.",
    8401: "Since 1.10, `%s` accept %s instance directly, not a URL string. Please directly reference the %s object in your script, or load %s by loader first. Don't use %s's URL anymore.",
    9e3: "Stencil manager does not support level bigger than %d in this device.",
    9001: "Stencil manager is already empty, cannot pop any mask",
    9100: "texture size exceeds current device limits %d/%d",
    9200: "Priority can't be set in Canvas node",
    9300: "The current buffer beyond the limit in ui static component, please reduce the amount",
    9301: "The UI has not been initialized",
    9302: "Can't getGFXSampler with out device",
    9600: "[Physics]: please check to see if physics modules are included",
    9610: "[Physics]: cannon.js physics system doesn't support capsule collider",
    9611: "[Physics]: builtin physics system doesn't support mesh collider",
    9612: "[Physics]: builtin physics system doesn't support cylinder collider",
    9620: "[Physics][Ammo]: changing the mesh is not supported after the initialization is completed",
    10001: "The sub-mesh contains %d vertices, which beyonds the capability (%d vertices most) of renderer of your platform.",
    10002: "Sub-mesh may include at most %d morph targets, but you specified %d.",
    "0100": "%s not yet implemented.",
    "0200": "You should specify a valid DOM canvas element."
}, logList = null, ccLog = console.log, ccWarn = console.log, ccError = console.log, ccAssert = function ccAssert(condition, message) {
    if (!condition) {
        for (var _len = arguments.length, optionalParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) optionalParams[_key - 2] = arguments[_key];
        console.log("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
    }
};

function formatString(message) {
    for (var _len2 = arguments.length, optionalParams = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) optionalParams[_key2 - 1] = arguments[_key2];
    return cc.js.formatStr.apply(null, [ message ].concat(optionalParams));
}

function log(message) {
    for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) optionalParams[_key3 - 1] = arguments[_key3];
    return ccLog.apply(void 0, [ message ].concat(optionalParams));
}

function warn(message) {
    for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) optionalParams[_key4 - 1] = arguments[_key4];
    return ccWarn.apply(void 0, [ message ].concat(optionalParams));
}

function error(message) {
    for (var _len5 = arguments.length, optionalParams = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) optionalParams[_key5 - 1] = arguments[_key5];
    return ccError.apply(void 0, [ message ].concat(optionalParams));
}

function assert(value, message) {
    for (var _len6 = arguments.length, optionalParams = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) optionalParams[_key6 - 2] = arguments[_key6];
    return ccAssert.apply(void 0, [ value, message ].concat(optionalParams));
}

function _resetDebugSetting(mode) {
    if (ccLog = ccWarn = ccError = ccAssert = function ccAssert() {}, mode !== DebugMode.NONE) {
        if (mode > DebugMode.ERROR) {
            var logToWebPage = function logToWebPage(msg) {
                if (cc.game.canvas) {
                    if (!logList) {
                        var logDiv = document.createElement("Div");
                        logDiv.setAttribute("id", "logInfoDiv"), logDiv.setAttribute("width", "200"), logDiv.setAttribute("height", cc.game.canvas.height);
                        var logDivStyle = logDiv.style;
                        logDivStyle.zIndex = "99999", logDivStyle.position = "absolute", logDivStyle.top = logDivStyle.left = "0", 
                        (logList = document.createElement("textarea")).setAttribute("rows", "20"), logList.setAttribute("cols", "30"), 
                        logList.setAttribute("disabled", "true");
                        var logListStyle = logList.style;
                        logListStyle.backgroundColor = "transparent", logListStyle.borderBottom = "1px solid #cccccc", 
                        logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px", 
                        logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none", 
                        logListStyle.padding = "0px", logListStyle.margin = "0px", logDiv.appendChild(logList), 
                        cc.game.canvas.parentNode.appendChild(logDiv);
                    }
                    logList.value = logList.value + msg + "\r\n", logList.scrollTop = logList.scrollHeight;
                }
            };
            ccError = function ccError(message) {
                for (var _len7 = arguments.length, optionalParams = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) optionalParams[_key7 - 1] = arguments[_key7];
                logToWebPage("ERROR :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
            }, ccAssert = function ccAssert(condition, message) {
                if (!condition) {
                    for (var _len8 = arguments.length, optionalParams = new Array(_len8 > 2 ? _len8 - 2 : 0), _key8 = 2; _key8 < _len8; _key8++) optionalParams[_key8 - 2] = arguments[_key8];
                    logToWebPage("ASSERT: " + formatString.apply(void 0, [ message ].concat(optionalParams)));
                }
            }, mode !== DebugMode.ERROR_FOR_WEB_PAGE && (ccWarn = function ccWarn(message) {
                for (var _len9 = arguments.length, optionalParams = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) optionalParams[_key9 - 1] = arguments[_key9];
                logToWebPage("WARN :  " + formatString.apply(void 0, [ message ].concat(optionalParams)));
            }), mode === DebugMode.INFO_FOR_WEB_PAGE && (ccLog = function ccLog(message) {
                for (var _len10 = arguments.length, optionalParams = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) optionalParams[_key10 - 1] = arguments[_key10];
                logToWebPage(formatString.apply(void 0, [ message ].concat(optionalParams)));
            });
        } else console && console.log.apply && (console.error || (console.error = console.log), 
        console.warn || (console.warn = console.log), ccError = console.error.bind ? console.error.bind(console) : function(message) {
            for (var _len11 = arguments.length, optionalParams = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) optionalParams[_key11 - 1] = arguments[_key11];
            return console.error.apply(console, [ message ].concat(optionalParams));
        }, ccAssert = function ccAssert(condition, message) {
            if (!condition) {
                for (var _len12 = arguments.length, optionalParams = new Array(_len12 > 2 ? _len12 - 2 : 0), _key12 = 2; _key12 < _len12; _key12++) optionalParams[_key12 - 2] = arguments[_key12];
                var errorText = formatString.apply(void 0, [ message ].concat(optionalParams));
                throw new Error(errorText);
            }
        });
        mode !== DebugMode.ERROR && (ccWarn = console.warn.bind ? console.warn.bind(console) : function(message) {
            for (var _len13 = arguments.length, optionalParams = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) optionalParams[_key13 - 1] = arguments[_key13];
            return console.warn.apply(console, [ message ].concat(optionalParams));
        }), mode === DebugMode.INFO && (ccLog = console.log.bind ? console.log.bind(console) : function ccLog(message) {
            for (var _len15 = arguments.length, optionalParams = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) optionalParams[_key15 - 1] = arguments[_key15];
            return console.log.apply(console, [ message ].concat(optionalParams));
        });
    }
}

function _throw(error_) {
    var stack = error_.stack;
    error(stack || error_);
}

function getTypedFormatter(type) {
    return function(id) {
        for (var msg = debugInfos[id] || "unknown id", _len16 = arguments.length, args = new Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) args[_key16 - 1] = arguments[_key16];
        return 0 === args.length ? msg : formatString.apply(void 0, [ msg ].concat(args));
    };
}

var logFormatter = getTypedFormatter();

function logID(id) {
    for (var _len17 = arguments.length, optionalParams = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) optionalParams[_key17 - 1] = arguments[_key17];
    log(logFormatter.apply(void 0, [ id ].concat(optionalParams)));
}

var warnFormatter = getTypedFormatter();

function warnID(id) {
    for (var _len18 = arguments.length, optionalParams = new Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) optionalParams[_key18 - 1] = arguments[_key18];
    warn(warnFormatter.apply(void 0, [ id ].concat(optionalParams)));
}

var errorFormatter = getTypedFormatter();

function errorID(id) {
    for (var _len19 = arguments.length, optionalParams = new Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) optionalParams[_key19 - 1] = arguments[_key19];
    error(errorFormatter.apply(void 0, [ id ].concat(optionalParams)));
}

var DebugMode, assertFormatter = getTypedFormatter();

function assertID(condition, id) {
    if (!condition) {
        for (var _len20 = arguments.length, optionalParams = new Array(_len20 > 2 ? _len20 - 2 : 0), _key20 = 2; _key20 < _len20; _key20++) optionalParams[_key20 - 2] = arguments[_key20];
        assert(!1, assertFormatter.apply(void 0, [ id ].concat(optionalParams)));
    }
}

function getError(errorId) {
    for (var _len21 = arguments.length, param = new Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) param[_key21 - 1] = arguments[_key21];
    return errorFormatter.apply(void 0, [ errorId ].concat(param));
}

function isDisplayStats() {
    return !!cc.profiler && cc.profiler.isShowingStats();
}

function setDisplayStats(displayStats) {
    cc.profiler && (displayStats ? cc.profiler.showStats() : cc.profiler.hideStats(), 
    cc.game.config.showFPS = !!displayStats);
}

!function(DebugMode) {
    DebugMode[DebugMode.NONE = 0] = "NONE", DebugMode[DebugMode.INFO = 1] = "INFO", 
    DebugMode[DebugMode.WARN = 2] = "WARN", DebugMode[DebugMode.ERROR = 3] = "ERROR", 
    DebugMode[DebugMode.INFO_FOR_WEB_PAGE = 4] = "INFO_FOR_WEB_PAGE", DebugMode[DebugMode.WARN_FOR_WEB_PAGE = 5] = "WARN_FOR_WEB_PAGE", 
    DebugMode[DebugMode.ERROR_FOR_WEB_PAGE = 6] = "ERROR_FOR_WEB_PAGE";
}(DebugMode || (DebugMode = {}));

var debug = Object.freeze({
    __proto__: null,
    log: log,
    warn: warn,
    error: error,
    assert: assert,
    _resetDebugSetting: _resetDebugSetting,
    _throw: _throw,
    logID: logID,
    warnID: warnID,
    errorID: errorID,
    assertID: assertID,
    get DebugMode() {
        return DebugMode;
    },
    getError: getError,
    isDisplayStats: isDisplayStats,
    setDisplayStats: setDisplayStats
}), EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/, DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/, NORMALIZE_RE = /[^\.\/]+\/\.\.\//;

function join() {
    for (var result = "", _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) segments[_key] = arguments[_key];
    for (var _i = 0, _segments = segments; _i < _segments.length; _i++) {
        var segment = _segments[_i];
        result = (result + ("" === result ? "" : "/") + segment).replace(/(\/|\\\\)$/, "");
    }
    return result;
}

function extname(path) {
    var temp = EXTNAME_RE.exec(path);
    return temp ? temp[1] : "";
}

function mainFileName(fileName) {
    if (fileName) {
        var idx = fileName.lastIndexOf(".");
        if (-1 !== idx) return fileName.substring(0, idx);
    }
    return fileName;
}

function basename(path, extName) {
    var index = path.indexOf("?");
    index > 0 && (path = path.substring(0, index));
    var result = /(\/|\\)([^\/\\]+)$/g.exec(path.replace(/(\/|\\)$/, ""));
    if (!result) return "";
    var baseName = result[2];
    return extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase() ? baseName.substring(0, baseName.length - extName.length) : baseName;
}

function dirname(path) {
    var temp = DIRNAME_RE.exec(path);
    return temp ? temp[2] : "";
}

function changeExtname(path, extName) {
    extName = extName || "";
    var index = path.indexOf("?"), tempStr = "";
    return index > 0 && (tempStr = path.substring(index), path = path.substring(0, index)), 
    (index = path.lastIndexOf(".")) < 0 ? path + extName + tempStr : path.substring(0, index) + extName + tempStr;
}

function changeBasename(path, baseName, isSameExt) {
    if (0 === baseName.indexOf(".")) return changeExtname(path, baseName);
    var index = path.indexOf("?"), tempStr = "", ext = isSameExt ? extname(path) : "";
    return index > 0 && (tempStr = path.substring(index), path = path.substring(0, index)), 
    index = (index = path.lastIndexOf("/")) <= 0 ? 0 : index + 1, path.substring(0, index) + baseName + ext + tempStr;
}

function _normalize(url) {
    var oldUrl = url = String(url);
    do {
        oldUrl = url, url = url.replace(NORMALIZE_RE, "");
    } while (oldUrl.length !== url.length);
    return url;
}

function stripSep(path) {
    return path.replace(/[\/\\]$/, "");
}

function getSeperator() {
    return cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/";
}

var path = Object.freeze({
    __proto__: null,
    join: join,
    extname: extname,
    mainFileName: mainFileName,
    basename: basename,
    dirname: dirname,
    changeExtname: changeExtname,
    changeBasename: changeBasename,
    _normalize: _normalize,
    stripSep: stripSep,
    getSeperator: getSeperator
});

cc.log = log, cc.warn = warn, cc.error = error, cc.assert = assert, cc._throw = _throw, 
cc.logID = logID, cc.warnID = warnID, cc.errorID = errorID, cc.assertID = assertID, 
cc.debug = debug, cc.path = {
    join: join,
    extname: extname,
    mainFileName: mainFileName,
    basename: basename,
    dirname: dirname,
    changeExtname: changeExtname,
    changeBasename: changeBasename,
    _normalize: _normalize,
    stripSep: stripSep,
    get sep() {
        return getSeperator();
    }
};

var enums = {
    SHAPE_RAY: 1,
    SHAPE_LINE: 2,
    SHAPE_SPHERE: 4,
    SHAPE_AABB: 8,
    SHAPE_OBB: 16,
    SHAPE_PLANE: 32,
    SHAPE_TRIANGLE: 64,
    SHAPE_FRUSTUM: 128,
    SHAPE_FRUSTUM_ACCURATE: 256,
    SHAPE_CAPSULE: 512
};

function sign(v) {
    return (v > 0) - (v < 0);
}

function countTrailingZeros(v) {
    var c = 32;
    return (v &= -v) && c--, 65535 & v && (c -= 16), 16711935 & v && (c -= 8), 252645135 & v && (c -= 4), 
    858993459 & v && (c -= 2), 1431655765 & v && (c -= 1), c;
}

function nextPow2(v) {
    return v += 0 === v, --v, v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, 
    (v |= v >>> 16) + 1;
}

var REVERSE_TABLE = new Array(256);

!function(tab) {
    for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) r <<= 1, r |= 1 & v, --s;
        tab[i] = r << s & 255;
    }
}(REVERSE_TABLE);

var bits = Object.freeze({
    __proto__: null,
    INT_BITS: 32,
    INT_MAX: 2147483647,
    INT_MIN: -1 << 31,
    sign: sign,
    abs: function abs(v) {
        var mask = v >> 31;
        return (v ^ mask) - mask;
    },
    min: function min(x, y) {
        return y ^ (x ^ y) & -(x < y);
    },
    max: function max(x, y) {
        return x ^ (x ^ y) & -(x < y);
    },
    isPow2: function isPow2(v) {
        return !(v & v - 1 || !v);
    },
    log2: function log2(v) {
        var r, shift;
        return r = (v > 65535) << 4, r |= shift = ((v >>>= r) > 255) << 3, r |= shift = ((v >>>= shift) > 15) << 2, 
        (r |= shift = ((v >>>= shift) > 3) << 1) | (v >>>= shift) >> 1;
    },
    log10: function log10(v) {
        return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    },
    popCount: function popCount(v) {
        return 16843009 * ((v = (858993459 & (v -= v >>> 1 & 1431655765)) + (v >>> 2 & 858993459)) + (v >>> 4) & 252645135) >>> 24;
    },
    countTrailingZeros: countTrailingZeros,
    nextPow2: nextPow2,
    prevPow2: function prevPow2(v) {
        return v |= v >>> 1, v |= v >>> 2, v |= v >>> 4, v |= v >>> 8, (v |= v >>> 16) - (v >>> 1);
    },
    parity: function parity(v) {
        return v ^= v >>> 16, v ^= v >>> 8, v ^= v >>> 4, 27030 >>> (v &= 15) & 1;
    },
    reverse: function reverse(v) {
        return REVERSE_TABLE[255 & v] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    },
    interleave2: function interleave2(x, y) {
        return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x &= 65535) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y &= 65535) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
    },
    deinterleave2: function deinterleave2(v, n) {
        return (v = 65535 & ((v = 16711935 & ((v = 252645135 & ((v = 858993459 & ((v = v >>> n & 1431655765) | v >>> 1)) | v >>> 2)) | v >>> 4)) | v >>> 16)) << 16 >> 16;
    },
    interleave3: function interleave3(x, y, z) {
        return x = 1227133513 & ((x = 3272356035 & ((x = 251719695 & ((x = 4278190335 & ((x &= 1023) | x << 16)) | x << 8)) | x << 4)) | x << 2), 
        (x |= (y = 1227133513 & ((y = 3272356035 & ((y = 251719695 & ((y = 4278190335 & ((y &= 1023) | y << 16)) | y << 8)) | y << 4)) | y << 2)) << 1) | (z = 1227133513 & ((z = 3272356035 & ((z = 251719695 & ((z = 4278190335 & ((z &= 1023) | z << 16)) | z << 8)) | z << 4)) | z << 2)) << 2;
    },
    deinterleave3: function deinterleave3(v, n) {
        return (v = 1023 & ((v = 4278190335 & ((v = 251719695 & ((v = 3272356035 & ((v = v >>> n & 1227133513) | v >>> 2)) | v >>> 4)) | v >>> 8)) | v >>> 16)) << 22 >> 22;
    },
    nextCombination: function nextCombination(v) {
        var t = v | v - 1;
        return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    }
});

function _typeof(obj) {
    return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    })(obj);
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
    }
}

function _createClass(Constructor, protoProps, staticProps) {
    return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
    Constructor;
}

function _defineProperty(obj, key, value) {
    return key in obj ? Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : obj[key] = value, obj;
}

function _inherits(subClass, superClass) {
    if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: !0,
            configurable: !0
        }
    }), superClass && _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    })(o);
}

function _setPrototypeOf(o, p) {
    return (_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        return o.__proto__ = p, o;
    })(o, p);
}

function _assertThisInitialized(self) {
    if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}

function _possibleConstructorReturn(self, call) {
    return !call || "object" != typeof call && "function" != typeof call ? _assertThisInitialized(self) : call;
}

function _superPropBase(object, property) {
    for (;!Object.prototype.hasOwnProperty.call(object, property) && null !== (object = _getPrototypeOf(object)); ) ;
    return object;
}

function _get(target, property, receiver) {
    return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (base) {
            var desc = Object.getOwnPropertyDescriptor(base, property);
            return desc.get ? desc.get.call(receiver) : desc.value;
        }
    })(target, property, receiver || target);
}

function set(target, property, value, receiver) {
    return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function set(target, property, value, receiver) {
        var desc, base = _superPropBase(target, property);
        if (base) {
            if ((desc = Object.getOwnPropertyDescriptor(base, property)).set) return desc.set.call(receiver, value), 
            !0;
            if (!desc.writable) return !1;
        }
        if (desc = Object.getOwnPropertyDescriptor(receiver, property)) {
            if (!desc.writable) return !1;
            desc.value = value, Object.defineProperty(receiver, property, desc);
        } else _defineProperty(receiver, property, value);
        return !0;
    })(target, property, value, receiver);
}

function _set(target, property, value, receiver, isStrict) {
    if (!set(target, property, value, receiver || target) && isStrict) throw new Error("failed to set property");
    return value;
}

function _slicedToArray(arr, i) {
    return function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
    }(arr) || function _iterableToArrayLimit(arr, i) {
        if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(arr))) return;
        var _arr = [], _n = !0, _d = !1, _e = void 0;
        try {
            for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
            !i || _arr.length !== i); _n = !0) ;
        } catch (err) {
            _d = !0, _e = err;
        } finally {
            try {
                _n || null == _i.return || _i.return();
            } finally {
                if (_d) throw _e;
            }
        }
        return _arr;
    }(arr, i) || _unsupportedIterableToArray(arr, i) || function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
}

function _toConsumableArray(arr) {
    return function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }(arr) || function _iterableToArray(iter) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(iter)) return Array.from(iter);
    }(arr) || _unsupportedIterableToArray(arr) || function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
}

function _unsupportedIterableToArray(o, minLen) {
    if (o) {
        if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(n) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
    }
}

function _arrayLikeToArray(arr, len) {
    (null == len || len > arr.length) && (len = arr.length);
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
}

function _createForOfIteratorHelperLoose(o) {
    var i = 0;
    if ("undefined" == typeof Symbol || null == o[Symbol.iterator]) {
        if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function() {
            return i >= o.length ? {
                done: !0
            } : {
                done: !1,
                value: o[i++]
            };
        };
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (i = o[Symbol.iterator]()).next.bind(i);
}

function _initializerDefineProperty(target, property, descriptor, context) {
    descriptor && Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    return Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
    })), desc.enumerable = !!desc.enumerable, desc.configurable = !!desc.configurable, 
    ("value" in desc || desc.initializer) && (desc.writable = !0), desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
    }), desc), context && void 0 !== desc.initializer && (desc.value = desc.initializer ? desc.initializer.call(context) : void 0, 
    desc.initializer = void 0), void 0 === desc.initializer && (Object.defineProperty(target, property, desc), 
    desc = null), desc;
}

var MutableForwardIterator = function() {
    function MutableForwardIterator(array) {
        _classCallCheck(this, MutableForwardIterator), this.i = 0, this.array = array;
    }
    return _createClass(MutableForwardIterator, [ {
        key: "remove",
        value: function remove(value) {
            var index = this.array.indexOf(value);
            index >= 0 && this.removeAt(index);
        }
    }, {
        key: "removeAt",
        value: function removeAt(i) {
            this.array.splice(i, 1), i <= this.i && --this.i;
        }
    }, {
        key: "fastRemove",
        value: function fastRemove(value) {
            var index = this.array.indexOf(value);
            index >= 0 && this.fastRemoveAt(index);
        }
    }, {
        key: "fastRemoveAt",
        value: function fastRemoveAt(i) {
            var array = this.array;
            array[i] = array[array.length - 1], --array.length, i <= this.i && --this.i;
        }
    }, {
        key: "push",
        value: function push(item) {
            this.array.push(item);
        }
    }, {
        key: "length",
        get: function get() {
            return this.array.length;
        },
        set: function set(value) {
            this.array.length = value, this.i >= value && (this.i = value - 1);
        }
    } ]), MutableForwardIterator;
}();

function removeAt(array, index) {
    array.splice(index, 1);
}

function remove(array, value) {
    var index = array.indexOf(value);
    return index >= 0 && (removeAt(array, index), !0);
}

function contains(array, value) {
    return array.indexOf(value) >= 0;
}

var jsarray = Object.freeze({
    __proto__: null,
    removeAt: removeAt,
    fastRemoveAt: function fastRemoveAt(array, index) {
        var length = array.length;
        index < 0 || index >= length || (array[index] = array[length - 1], array.length = length - 1);
    },
    remove: remove,
    fastRemove: function fastRemove(array, value) {
        var index = array.indexOf(value);
        index >= 0 && (array[index] = array[array.length - 1], --array.length);
    },
    removeIf: function removeIf(array, predicate) {
        var index = array.findIndex(predicate);
        if (index >= 0) {
            var _value = array[index];
            return removeAt(array, index), _value;
        }
    },
    verifyType: function verifyType(array, type) {
        if (array && array.length > 0) for (var _step, _iterator = _createForOfIteratorHelperLoose(array); !(_step = _iterator()).done; ) {
            if (!(_step.value instanceof type)) return cc.logID(1300), !1;
        }
        return !0;
    },
    removeArray: function removeArray(array, minusArr) {
        for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
    },
    appendObjectsAt: function appendObjectsAt(array, addObjs, index) {
        return array.splice.apply(array, [ index, 0 ].concat(_toConsumableArray(addObjs))), 
        array;
    },
    contains: contains,
    copy: function copy(array) {
        for (var len = array.length, arr_clone = new Array(len), i = 0; i < len; i += 1) arr_clone[i] = array[i];
        return arr_clone;
    },
    MutableForwardIterator: MutableForwardIterator
}), IDGenerator = function() {
    function IDGenerator(category) {
        _classCallCheck(this, IDGenerator), this.id = void 0, this.prefix = void 0, this.id = 0 | 998 * Math.random(), 
        this.prefix = category ? category + "." : "";
    }
    return _createClass(IDGenerator, [ {
        key: "getNewId",
        value: function getNewId() {
            return this.prefix + ++this.id;
        }
    } ]), IDGenerator;
}();

IDGenerator.global = new IDGenerator("global");

var tempCIDGenerator = new IDGenerator("TmpCId.");

function isNumber(object) {
    return "number" == typeof object || object instanceof Number;
}

function isString(object) {
    return "string" == typeof object || object instanceof String;
}

var descriptor, value = (descriptor = {
    value: void 0,
    enumerable: !1,
    writable: !1,
    configurable: !0
}, function(object, propertyName, value_, writable, enumerable) {
    descriptor.value = value_, descriptor.writable = writable, descriptor.enumerable = enumerable, 
    Object.defineProperty(object, propertyName, descriptor), descriptor.value = void 0;
}), getset = function() {
    var descriptor = {
        get: void 0,
        set: void 0,
        enumerable: !1
    };
    return function(object, propertyName, getter, setter) {
        var enumerable = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], configurable = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
        "boolean" == typeof setter && (enumerable = setter, setter = void 0), descriptor.get = getter, 
        descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
        Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0, 
        descriptor.set = void 0;
    };
}(), get = function() {
    var descriptor = {
        get: void 0,
        enumerable: !1,
        configurable: !1
    };
    return function(object, propertyName, getter, enumerable, configurable) {
        descriptor.get = getter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
        Object.defineProperty(object, propertyName, descriptor), descriptor.get = void 0;
    };
}(), set$1 = function() {
    var descriptor = {
        set: void 0,
        enumerable: !1,
        configurable: !1
    };
    return function(object, propertyName, setter, enumerable, configurable) {
        descriptor.set = setter, descriptor.enumerable = enumerable, descriptor.configurable = configurable, 
        Object.defineProperty(object, propertyName, descriptor), descriptor.set = void 0;
    };
}();

function createMap(forceDictMode) {
    var map = Object.create(null);
    if (forceDictMode) {
        map["."] = !0, map["/"] = !0, delete map["."], delete map["/"];
    }
    return map;
}

function getClassName(objOrCtor) {
    if ("function" == typeof objOrCtor) {
        var prototype = objOrCtor.prototype;
        if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
        var retval = "";
        if (objOrCtor.name && (retval = objOrCtor.name), objOrCtor.toString) {
            var arr, str = objOrCtor.toString();
            (arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/)) && 2 === arr.length && (retval = arr[1]);
        }
        return "Object" !== retval ? retval : "";
    }
    return objOrCtor && objOrCtor.constructor ? getClassName(objOrCtor.constructor) : "";
}

function obsolete(object, obsoleted, newExpr, writable) {
    var extractPropName = /([^.]+)$/, oldProp = extractPropName.exec(obsoleted)[0], newProp = extractPropName.exec(newExpr)[0];
    function getter() {
        return this[newProp];
    }
    writable ? getset(object, oldProp, getter, (function setter(value_) {
        this[newProp] = value_;
    })) : get(object, oldProp, getter);
}

function obsoletes(obj, objName, props, writable) {
    for (var obsoleted in props) {
        obsolete(obj, objName + "." + obsoleted, props[obsoleted], writable);
    }
}

var REGEXP_NUM_OR_STR = /(%d)|(%s)/, REGEXP_STR = /%s/;

function formatStr(msg) {
    for (var _len = arguments.length, subst = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) subst[_key - 1] = arguments[_key];
    if (0 === arguments.length) return "";
    if (0 === subst.length) return "" + msg;
    var hasSubstitution = "string" == typeof msg && REGEXP_NUM_OR_STR.test(msg);
    if (hasSubstitution) for (var _step, _iterator = _createForOfIteratorHelperLoose(subst); !(_step = _iterator()).done; ) {
        var arg = _step.value, regExpToTest = "number" == typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
        regExpToTest.test(msg) ? msg = msg.replace(regExpToTest, arg) : msg += " " + arg;
    } else for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(subst); !(_step2 = _iterator2()).done; ) {
        var _arg = _step2.value;
        msg += " " + _arg;
    }
    return msg;
}

function shiftArguments() {
    for (var len = arguments.length - 1, args = new Array(len), i = 0; i < len; ++i) args[i] = arguments[i + 1];
    return args;
}

function getPropertyDescriptor(object, propertyName) {
    for (;object; ) {
        var pd = Object.getOwnPropertyDescriptor(object, propertyName);
        if (pd) return pd;
        object = Object.getPrototypeOf(object);
    }
    return null;
}

function _copyprop(name, source, target) {
    var pd = getPropertyDescriptor(source, name);
    pd && Object.defineProperty(target, name, pd);
}

function addon(object) {
    object = object || {};
    for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) sources[_key2 - 1] = arguments[_key2];
    for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
        var source = _sources[_i];
        if (source) {
            if ("object" !== _typeof(source)) {
                cc.errorID(5402, source);
                continue;
            }
            for (var name in source) name in object || _copyprop(name, source, object);
        }
    }
    return object;
}

function mixin(object) {
    object = object || {};
    for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) sources[_key3 - 1] = arguments[_key3];
    for (var _i2 = 0, _sources2 = sources; _i2 < _sources2.length; _i2++) {
        var source = _sources2[_i2];
        if (source) {
            if ("object" !== _typeof(source)) {
                cc.errorID(5403, source);
                continue;
            }
            for (var name in source) _copyprop(name, source, object);
        }
    }
    return object;
}

function extend(cls, base) {
    for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
    return cls.prototype = Object.create(base.prototype, {
        constructor: {
            value: cls,
            writable: !0,
            configurable: !0
        }
    }), cls;
}

function getSuper(constructor) {
    var proto = constructor.prototype, dunderProto = proto && Object.getPrototypeOf(proto);
    return dunderProto && dunderProto.constructor;
}

function isChildClassOf(subclass, superclass) {
    if (subclass && superclass) {
        if ("function" != typeof subclass) return !1;
        if ("function" != typeof superclass) return !1;
        if (subclass === superclass) return !0;
        for (;;) {
            if (!(subclass = getSuper(subclass))) return !1;
            if (subclass === superclass) return !0;
        }
    }
    return !1;
}

function clear(object) {
    for (var _i3 = 0, _Object$keys = Object.keys(object); _i3 < _Object$keys.length; _i3++) {
        delete object[_Object$keys[_i3]];
    }
}

var _idToClass = {}, _nameToClass = {};

function _setClassId(id, constructor) {
    var key = "__cid__", table = _idToClass;
    if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
    value(constructor.prototype, key, id), id) {
        var registered = table[id];
        if (registered && registered !== constructor) {
            var error = "A Class already exists with the same " + key + ' : "' + id + '".';
            cc.error(error);
        } else table[id] = constructor;
    }
}

function setClassName(className, constructor) {
    if (function doSetClassName(id, constructor) {
        var key = "__classname__", table = _nameToClass;
        if (constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]], 
        value(constructor.prototype, key, id), id) {
            var registered = table[id];
            if (registered && registered !== constructor) {
                var error = "A Class already exists with the same " + key + ' : "' + id + '".';
                cc.error(error);
            } else table[id] = constructor;
        }
    }(className, constructor), !constructor.prototype.hasOwnProperty("__cid__")) {
        var id = className || tempCIDGenerator.getNewId();
        id && _setClassId(id, constructor);
    }
}

function unregisterClass() {
    for (var _len4 = arguments.length, constructors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) constructors[_key4] = arguments[_key4];
    for (var _i4 = 0, _constructors = constructors; _i4 < _constructors.length; _i4++) {
        var _constructor = _constructors[_i4], p = _constructor.prototype, classId = p.__cid__;
        classId && delete _idToClass[classId];
        var classname = p.__classname__;
        classname && delete _nameToClass[classname];
    }
}

function _getClassById(classId) {
    return _idToClass[classId];
}

function getClassByName(classname) {
    return _nameToClass[classname];
}

function _getClassId(obj, allowTempId) {
    if (allowTempId = void 0 === allowTempId || allowTempId, "function" == typeof obj && obj.prototype.hasOwnProperty("__cid__")) return obj.prototype.__cid__;
    if (obj && obj.constructor) {
        var prototype = obj.constructor.prototype;
        if (prototype && prototype.hasOwnProperty("__cid__")) return obj.__cid__;
    }
    return "";
}

var Pool = function() {
    function Pool(_0, _1) {
        _classCallCheck(this, Pool), this.count = void 0, this._pool = void 0, this._cleanup = void 0;
        var size = void 0 === _1 ? _0 : _1, cleanupFunc = void 0 === _1 ? null : _0;
        this.count = 0, this._pool = new Array(size), this._cleanup = cleanupFunc;
    }
    return _createClass(Pool, [ {
        key: "get",
        value: function get() {
            return this._get();
        }
    } ]), _createClass(Pool, [ {
        key: "_get",
        value: function _get() {
            if (this.count > 0) {
                --this.count;
                var cache = this._pool[this.count];
                return this._pool[this.count] = null, cache;
            }
            return null;
        }
    }, {
        key: "put",
        value: function put(obj) {
            var pool = this._pool;
            if (this.count < pool.length) {
                if (this._cleanup && !1 === this._cleanup(obj)) return;
                pool[this.count] = obj, ++this.count;
            }
        }
    }, {
        key: "resize",
        value: function resize(length) {
            length >= 0 && (this._pool.length = length, this.count > length && (this.count = length));
        }
    } ]), Pool;
}(), array = jsarray, js = {
    IDGenerator: IDGenerator,
    Pool: Pool,
    array: jsarray,
    isNumber: isNumber,
    isString: isString,
    getPropertyDescriptor: getPropertyDescriptor,
    addon: addon,
    mixin: mixin,
    extend: extend,
    getSuper: getSuper,
    isChildClassOf: isChildClassOf,
    clear: clear,
    value: value,
    getset: getset,
    get: get,
    set: set$1,
    unregisterClass: unregisterClass,
    getClassName: getClassName,
    setClassName: setClassName,
    getClassByName: getClassByName,
    _getClassId: _getClassId,
    _setClassId: _setClassId,
    _getClassById: _getClassById,
    obsolete: obsolete,
    obsoletes: obsoletes,
    formatStr: formatStr,
    shiftArguments: shiftArguments,
    createMap: createMap
};

cc.js = js;

for (var js$1 = Object.freeze({
    __proto__: null,
    array: array,
    js: js,
    IDGenerator: IDGenerator,
    Pool: Pool,
    isNumber: isNumber,
    isString: isString,
    value: value,
    getset: getset,
    get: get,
    set: set$1,
    createMap: createMap,
    getClassName: getClassName,
    obsolete: obsolete,
    obsoletes: obsoletes,
    formatStr: formatStr,
    shiftArguments: shiftArguments,
    getPropertyDescriptor: getPropertyDescriptor,
    addon: addon,
    mixin: mixin,
    extend: extend,
    getSuper: getSuper,
    isChildClassOf: isChildClassOf,
    clear: clear,
    _idToClass: _idToClass,
    _nameToClass: _nameToClass,
    _setClassId: _setClassId,
    setClassName: setClassName,
    unregisterClass: unregisterClass,
    _getClassById: _getClassById,
    getClassByName: getClassByName,
    _getClassId: _getClassId
}), BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/, values = new Array(123), i = 0; i < 123; ++i) values[i] = 64;

for (var _i = 0; _i < 64; ++_i) values["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charCodeAt(_i)] = _i;

var BASE64_VALUES = values;

function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
    function define(np, propName, getter, setter) {
        var pd = Object.getOwnPropertyDescriptor(np, propName);
        if (pd) pd.get && (np[getter] = pd.get), pd.set && setter && (np[setter] = pd.set); else {
            var getterFunc = np[getter];
            getset(np, propName, getterFunc, np[setter]);
        }
    }
    for (var propName, np = ctor.prototype, _i2 = 0; _i2 < sameNameGetSets.length; _i2++) {
        var suffix = (propName = sameNameGetSets[_i2])[0].toUpperCase() + propName.slice(1);
        define(np, propName, "get" + suffix, "set" + suffix);
    }
    for (propName in diffNameGetSets) {
        var gs = diffNameGetSets[propName];
        define(np, propName, gs[0], gs[1]);
    }
}

function nextPOT(x) {
    return x -= 1, x |= x >> 1, x |= x >> 2, x |= x >> 4, x |= x >> 8, (x |= x >> 16) + 1;
}

function pushToMap(map, key, value, pushFront) {
    var exists = map[key];
    exists ? Array.isArray(exists) ? pushFront ? (exists.push(exists[0]), exists[0] = value) : exists.push(value) : map[key] = pushFront ? [ value, exists ] : [ exists, value ] : map[key] = value;
}

function contains$1(refNode, otherNode) {
    if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
    if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
    var node = otherNode.parentNode;
    if (node) do {
        if (node === refNode) return !0;
        node = node.parentNode;
    } while (null !== node);
    return !1;
}

function isDomNode(obj) {
    return "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "function" == typeof Node ? obj instanceof Node : obj && "object" === _typeof(obj) && "number" == typeof obj.nodeType && "string" == typeof obj.nodeName;
}

function callInNextTick(callback, p1, p2) {
    callback && setTimeout((function() {
        callback(p1, p2);
    }), 0);
}

function tryCatchFunctor_EDITOR(funcName) {
    return Function("target", "try {\n  target." + funcName + "();\n}\ncatch (e) {\n  cc._throw(e);\n}");
}

function isPlainEmptyObj_DEV(obj) {
    if (!obj || obj.constructor !== Object) return !1;
    for (var k in obj) return !1;
    return !0;
}

function cloneable_DEV(obj) {
    return obj && "function" == typeof obj.clone && (obj.constructor && obj.constructor.prototype.hasOwnProperty("clone") || obj.hasOwnProperty("clone"));
}

cc.misc = {
    BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
    BASE64_VALUES: BASE64_VALUES,
    propertyDefine: propertyDefine,
    nextPOT: nextPOT,
    pushToMap: pushToMap,
    contains: contains$1,
    isDomNode: isDomNode,
    callInNextTick: callInNextTick,
    tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
    isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
    cloneable_DEV: cloneable_DEV
};

var misc = Object.freeze({
    __proto__: null,
    BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
    BASE64_VALUES: BASE64_VALUES,
    propertyDefine: propertyDefine,
    nextPOT: nextPOT,
    pushToMap: pushToMap,
    contains: contains$1,
    isDomNode: isDomNode,
    callInNextTick: callInNextTick,
    tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR,
    isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
    cloneable_DEV: cloneable_DEV
});

function BitMask(obj) {
    if ("__bitmask__" in obj) return obj;
    value(obj, "__bitmask__", null, !0);
    for (var lastIndex = -1, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
        var key = keys[i], val = obj[key];
        if (-1 === val) val = ++lastIndex, obj[key] = val; else if ("number" == typeof val) lastIndex = val; else if ("string" == typeof val && Number.isInteger(parseFloat(key))) continue;
        var reverseKey = "" + val;
        key !== reverseKey && value(obj, reverseKey, key);
    }
    return obj;
}

function Enum(obj) {
    if ("__enums__" in obj) return obj;
    value(obj, "__enums__", null, !0);
    for (var lastIndex = -1, keys = Object.keys(obj), i = 0; i < keys.length; i++) {
        var key = keys[i], val = obj[key];
        if (-1 === val) val = ++lastIndex, obj[key] = val; else if ("number" == typeof val) lastIndex = val; else if ("string" == typeof val && Number.isInteger(parseFloat(key))) continue;
        var reverseKey = "" + val;
        key !== reverseKey && value(obj, reverseKey, key);
    }
    return obj;
}

function ccenum(enumx) {
    "__enums__" in enumx || value(enumx, "__enums__", null, !0);
}

BitMask.isBitMask = function(BitMaskType) {
    return BitMaskType && BitMaskType.hasOwnProperty("__bitmask__");
}, BitMask.getList = function(BitMaskDef) {
    if (BitMaskDef.__bitmask__) return BitMaskDef.__bitmask__;
    var bitlist = BitMaskDef.__bitmask__ = [];
    for (var name in BitMaskDef) {
        var v = BitMaskDef[name];
        Number.isInteger(v) && bitlist.push({
            name: name,
            value: v
        });
    }
    return bitlist.sort((function(a, b) {
        return a.value - b.value;
    })), bitlist;
}, cc.BitMask = BitMask, Enum.isEnum = function(enumType) {
    return enumType && enumType.hasOwnProperty("__enums__");
}, Enum.getList = function(enumDef) {
    if (enumDef.__enums__) return enumDef.__enums__;
    var enums = enumDef.__enums__ = [];
    for (var name in enumDef) {
        var v = enumDef[name];
        Number.isInteger(v) && enums.push({
            name: name,
            value: v
        });
    }
    return enums.sort((function(a, b) {
        return a.value - b.value;
    })), enums;
}, cc.Enum = Enum;

var ValueType = function() {
    function ValueType() {
        _classCallCheck(this, ValueType);
    }
    return _createClass(ValueType, [ {
        key: "clone",
        value: function clone() {
            return errorID(100, getClassName(this) + ".clone"), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            return !1;
        }
    }, {
        key: "set",
        value: function set(other) {
            errorID(100, getClassName(this) + ".set");
        }
    }, {
        key: "toString",
        value: function toString() {
            return "" + {};
        }
    } ]), ValueType;
}();

setClassName("cc.ValueType", ValueType), cc.ValueType = ValueType;

function createAttrsSingle(owner, ownerConstructor, superAttrs) {
    var AttrsCtor;
    AttrsCtor = function AttrsCtor() {}, superAttrs && extend(AttrsCtor, superAttrs.constructor);
    var attrs = new AttrsCtor;
    return value(owner, "__attrs__", attrs), attrs;
}

function createAttrs(subclass) {
    for (var superClass, chains = cc.Class.getInheritanceChain(subclass), i = chains.length - 1; i >= 0; i--) {
        var cls = chains[i];
        cls.hasOwnProperty("__attrs__") && cls.__attrs__ || createAttrsSingle(cls, 0, (superClass = chains[i + 1]) && superClass.__attrs__);
    }
    return createAttrsSingle(subclass, 0, (superClass = chains[0]) && superClass.__attrs__), 
    subclass.__attrs__;
}

function attr(constructor, propertyName, newAttributes) {
    var attrs, setter;
    if ("function" == typeof constructor) setter = (attrs = getClassAttrs(constructor)).constructor.prototype; else {
        var instance = constructor;
        if (!(attrs = instance.__attrs__)) attrs = createAttrsSingle(instance, 0, getClassAttrs(constructor = instance.constructor));
        setter = attrs;
    }
    if (void 0 === newAttributes) {
        var prefix = propertyName + "$_$", ret = {};
        for (var key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
        return ret;
    }
    if ("object" === _typeof(newAttributes)) for (var _key in newAttributes) 95 !== _key.charCodeAt(0) && (setter[propertyName + "$_$" + _key] = newAttributes[_key]);
}

function getClassAttrs(constructor) {
    return constructor.hasOwnProperty("__attrs__") && constructor.__attrs__ || createAttrs(constructor);
}

function getClassAttrsProto(constructor) {
    return getClassAttrs(constructor).constructor.prototype;
}

function setClassAttr(ctor, propName, key, value) {
    getClassAttrsProto(ctor)[propName + "$_$" + key] = value;
}

var PrimitiveType = function() {
    function PrimitiveType(name, defaultValue) {
        _classCallCheck(this, PrimitiveType), this.name = void 0, this.default = void 0, 
        this.name = name, this.default = defaultValue;
    }
    return _createClass(PrimitiveType, [ {
        key: "toString",
        value: function toString() {
            return this.name;
        }
    } ]), PrimitiveType;
}(), CCInteger = new PrimitiveType("Integer", 0);

cc.Integer = CCInteger, cc.CCInteger = CCInteger;

var CCFloat = new PrimitiveType("Float", 0);

cc.Float = CCFloat, cc.CCFloat = CCFloat;

var CCBoolean = new PrimitiveType("Boolean", !1);

cc.Boolean = CCBoolean, cc.CCBoolean = CCBoolean;

var CCString = new PrimitiveType("String", "");

function getTypeChecker(type, attributeName) {
    return function(constructor, mainPropertyName) {
        var propInfo = '"' + getClassName(constructor) + "." + mainPropertyName + '"', mainPropAttrs = attr(constructor, mainPropertyName);
        if (!mainPropAttrs.saveUrlAsAsset) {
            var mainPropAttrsType = mainPropAttrs.type;
            if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat ? mainPropAttrsType = "Number" : mainPropAttrsType !== CCString && mainPropAttrsType !== CCBoolean || (mainPropAttrsType = mainPropAttrsType.toString()), 
            mainPropAttrsType !== type) return void warnID(3604, propInfo);
        }
        if (mainPropAttrs.hasOwnProperty("default")) {
            var defaultVal = mainPropAttrs.default;
            if (void 0 !== defaultVal) if (!(Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal))) {
                var defaultType = _typeof(defaultVal), type_lowerCase = type.toLowerCase();
                if (defaultType === type_lowerCase) {
                    if (!mainPropAttrs.saveUrlAsAsset) if ("object" === type_lowerCase) {
                        if (!defaultVal || defaultVal instanceof mainPropAttrs.ctor) return;
                        warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
                    } else "Number" !== type && warnID(3606, attributeName, propInfo, type);
                } else {
                    if ("function" === defaultType) return;
                    type === CCString.default && null == defaultVal ? isChildClassOf(mainPropAttrs.ctor, cc.RawAsset) || warnID(3607, propInfo) : warnID(3611, attributeName, propInfo, defaultType);
                }
                delete mainPropAttrs.type;
            }
        }
    };
}

cc.String = CCString, cc.CCString = CCString;

var attributeUtils = Object.freeze({
    __proto__: null,
    DELIMETER: "$_$",
    createAttrsSingle: createAttrsSingle,
    createAttrs: createAttrs,
    attr: attr,
    getClassAttrs: getClassAttrs,
    getClassAttrsProto: getClassAttrsProto,
    setClassAttr: setClassAttr,
    PrimitiveType: PrimitiveType,
    CCInteger: CCInteger,
    CCFloat: CCFloat,
    CCBoolean: CCBoolean,
    CCString: CCString,
    getTypeChecker: getTypeChecker,
    getObjTypeChecker: function getObjTypeChecker(typeCtor) {
        return function(classCtor, mainPropName) {
            getTypeChecker("Object", "type")(classCtor, mainPropName);
            var defaultDef = getClassAttrs(classCtor)[mainPropName + "$_$default"], defaultVal = cc.Class.getDefault(defaultDef);
            if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, cc.ValueType)) {
                var typename = getClassName(typeCtor), info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);
                defaultDef ? log(info) : warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
            }
        };
    }
}), SerializableAttrs = {
    url: {
        canUsedInGet: !0
    },
    default: {},
    serializable: {},
    editorOnly: {},
    formerlySerializedAs: {}
};

function parseNotify(val, propName, notify, properties) {
    if (!val.get && !val.set && val.hasOwnProperty("default")) {
        var newKey = "_N$" + propName;
        val.get = function() {
            return this[newKey];
        }, val.set = function(value) {
            var oldValue = this[newKey];
            this[newKey] = value, notify.call(this, oldValue);
        };
        var newValue = {};
        for (var attr in properties[newKey] = newValue, SerializableAttrs) {
            var v = SerializableAttrs[attr];
            val.hasOwnProperty(attr) && (newValue[attr] = val[attr], v.canUsedInGet || delete val[attr]);
        }
    }
}

function checkUrl(val, className, propName, url) {
    Array.isArray(url) && url.length > 0 && (url = url[0]), val.type = url;
}

function parseType(val, type, className, propName) {
    if (Array.isArray(type)) {
        if (!(type.length > 0)) return errorID(5508, className, propName);
        if (cc.RawAsset.isRawAssetType(type[0])) return val.url = type[0], void delete val.type;
        val.type = type = type[0];
    }
}

function getFullFormOfProperty(options, propname_dev, classname_dev) {
    if (!(options && options.constructor === Object)) {
        if (Array.isArray(options) && options.length > 0) {
            options[0];
            return {
                default: [],
                type: options,
                _short: !0
            };
        }
        if ("function" == typeof options) {
            var _type = options;
            return cc.RawAsset.isRawAssetType(_type) ? {
                default: "",
                url: _type,
                _short: !0
            } : {
                default: isChildClassOf(_type, cc.ValueType) ? new _type : null,
                type: _type,
                _short: !0
            };
        }
        return options instanceof PrimitiveType ? {
            default: options.default,
            _short: !0
        } : {
            default: options,
            _short: !0
        };
    }
    return null;
}

function validateMethodWithProps(func, funcName, className, cls, base) {
    return "function" == typeof func || null === func;
}

var requiringFrames = [];

function peek() {
    return requiringFrames[requiringFrames.length - 1];
}

cc._RF = {
    push: function push(module, uuid, script, importMeta) {
        void 0 === script && (script = uuid, uuid = ""), requiringFrames.push({
            uuid: uuid,
            script: script,
            module: module,
            exports: module.exports,
            beh: null,
            importMeta: importMeta
        });
    },
    pop: function pop() {
        var frameInfo = requiringFrames.pop(), module = frameInfo.module, exports = module.exports;
        if (exports === frameInfo.exports) {
            for (var anykey in exports) return;
            module.exports = exports = frameInfo.cls;
        }
    },
    peek: peek
};

var BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];

function pushUnique(array, item) {
    array.indexOf(item) < 0 && array.push(item);
}

var deferredInitializer = {
    datas: null,
    push: function push(data) {
        if (this.datas) this.datas.push(data); else {
            this.datas = [ data ];
            var self = this;
            setTimeout((function() {
                self.init();
            }), 0);
        }
    },
    init: function init() {
        var datas = this.datas;
        if (datas) {
            for (var i = 0; i < datas.length; ++i) {
                var data = datas[i], cls = data.cls, properties = data.props;
                "function" == typeof properties && (properties = properties());
                var _name = getClassName(cls);
                properties ? declareProperties(cls, _name, properties, cls.$super, data.mixins) : errorID(3633, _name);
            }
            this.datas = null;
        }
    }
};

var tmpArray = [];

function defineProp(cls, className, propName, val, es6) {
    setClassAttr(cls, propName, "default", val.default), function appendProp(cls, name) {
        pushUnique(cls.__props__, name);
    }(cls, propName);
    var attrs = parseAttributes(cls, val, className, propName);
    if (attrs) {
        for (var onAfterProp = tmpArray, i = 0; i < attrs.length; i++) {
            var attr$1 = attrs[i];
            attr(cls, propName, attr$1), !1 === attr$1.serializable && pushUnique(cls.__values__, propName), 
            attr$1._onAfterProp && onAfterProp.push(attr$1._onAfterProp);
        }
        for (var c = 0; c < onAfterProp.length; c++) onAfterProp[c](cls, propName);
        tmpArray.length = 0, attrs.length = 0;
    }
}

function defineGetSet(cls, name, propName, val, es6) {
    var getter = val.get, setter = val.set, proto = cls.prototype, setterUndefined = !Object.getOwnPropertyDescriptor(proto, propName);
    if (getter) {
        for (var attrs = parseAttributes(cls, val, name, propName), i = 0; i < attrs.length; i++) attr(cls, propName, attrs[i]);
        attrs.length = 0, setClassAttr(cls, propName, "serializable", !1), es6 || get(proto, propName, getter, setterUndefined, setterUndefined);
    }
    setter && (es6 || set$1(proto, propName, setter, setterUndefined, setterUndefined));
}

function getDefault(defaultVal) {
    return "function" == typeof defaultVal ? defaultVal() : defaultVal;
}

function mixinWithInherited(dest, src, filter) {
    for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, getPropertyDescriptor(src, prop));
}

function doDefine(className, baseClass, mixins, options) {
    var ctors, fireClass, __ctor__ = options.__ctor__, ctor = options.ctor, __es6__ = options.__ES6__;
    __es6__ ? (ctors = [ ctor ], fireClass = ctor) : (ctors = __ctor__ ? [ __ctor__ ] : function _getAllCtors(baseClass, mixins, options) {
        for (var ctors = [], baseOrMixins = [ baseClass ].concat(mixins), b = 0; b < baseOrMixins.length; b++) {
            var baseOrMixin = baseOrMixins[b];
            if (baseOrMixin) for (var baseCtors = (cls = baseOrMixin, CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ]), c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
        }
        var cls;
        var ctor = options.ctor;
        ctor && ctors.push(ctor);
        return ctors;
    }(baseClass, mixins, options), fireClass = _createCtor(ctors, baseClass, className, options), 
    value(fireClass, "extend", (function(options) {
        return options.extends = this, CCClass(options);
    }), !0)), value(fireClass, "__ctors__", ctors.length > 0 ? ctors : null, !0);
    var prototype = fireClass.prototype;
    if (baseClass && (__es6__ || (extend(fireClass, baseClass), prototype = fireClass.prototype), 
    fireClass.$super = baseClass), mixins) {
        for (var _loop = function _loop(m) {
            var mixin = mixins[m];
            mixinWithInherited(prototype, mixin.prototype), mixinWithInherited(fireClass, mixin, (function(prop) {
                return mixin.hasOwnProperty(prop) && !0;
            })), CCClass._isCCClass(mixin) && mixinWithInherited(getClassAttrs(fireClass).constructor.prototype, getClassAttrs(mixin).constructor.prototype);
        }, m = mixins.length - 1; m >= 0; m--) _loop(m);
        prototype.constructor = fireClass;
    }
    return __es6__ || (prototype.__initProps__ = compileProps), setClassName(className, fireClass), 
    fireClass;
}

function compileProps(actualClass) {
    var attrs = getClassAttrs(actualClass), propList = actualClass.__props__;
    null === propList && (deferredInitializer.init(), propList = actualClass.__props__);
    var initProps = function getInitProps(attrs, propList) {
        for (var advancedProps = [], advancedValues = [], simpleProps = [], simpleValues = [], i = 0; i < propList.length; ++i) {
            var prop = propList[i], attrKey = prop + "$_$default";
            if (attrKey in attrs) {
                var def = attrs[attrKey];
                "object" === _typeof(def) && def || "function" == typeof def ? (advancedProps.push(prop), 
                advancedValues.push(def)) : (simpleProps.push(prop), simpleValues.push(def));
            }
        }
        return function() {
            for (var _i = 0; _i < simpleProps.length; ++_i) this[simpleProps[_i]] = simpleValues[_i];
            for (var _i2 = 0; _i2 < advancedProps.length; _i2++) {
                var _prop = advancedProps[_i2], expression = void 0, _def = advancedValues[_i2];
                expression = "object" === _typeof(_def) ? _def instanceof cc.ValueType ? _def.clone() : Array.isArray(_def) ? [] : {} : _def(), 
                this[_prop] = expression;
            }
        };
    }(attrs, propList);
    actualClass.prototype.__initProps__ = initProps, initProps.call(this);
}

var _createCtor = function(ctors, baseClass, className, options) {
    var _Class5, superCallBounded = baseClass && function boundSuperCalls(baseClass, options, className) {
        var hasSuperCall = !1;
        for (var funcName in options) if (!(BUILTIN_ENTRIES.indexOf(funcName) >= 0)) {
            var func = options[funcName];
            if ("function" == typeof func) {
                var pd = getPropertyDescriptor(baseClass.prototype, funcName);
                if (pd) {
                    var superFunc = pd.value;
                    if ("function" == typeof superFunc) {
                        SuperCallReg.test(func) && (hasSuperCall = !0, options[funcName] = function(superFunc, func) {
                            return function() {
                                var tmp = this._super;
                                this._super = superFunc;
                                var ret = func.apply(this, arguments);
                                return this._super = tmp, ret;
                            };
                        }(superFunc, func));
                        continue;
                    }
                }
            }
        }
        return hasSuperCall;
    }(baseClass, options), ctorLen = ctors.length;
    return _Class5 = ctorLen > 0 ? superCallBounded ? 2 === ctorLen ? function Class() {
        this._super = null, this.__initProps__(_Class5), ctors[0].apply(this, arguments), 
        ctors[1].apply(this, arguments);
    } : function _Class() {
        this._super = null, this.__initProps__(_Class5);
        for (var i = 0; i < ctors.length; ++i) ctors[i].apply(this, arguments);
    } : 3 === ctorLen ? function _Class2() {
        this.__initProps__(_Class5), ctors[0].apply(this, arguments), ctors[1].apply(this, arguments), 
        ctors[2].apply(this, arguments);
    } : function _Class3() {
        this.__initProps__(_Class5);
        for (var ctors = _Class5.__ctors__, i = 0; i < ctors.length; ++i) ctors[i].apply(this, arguments);
    } : function _Class4() {
        superCallBounded && (this._super = null), this.__initProps__(_Class5);
    };
};

var SuperCallReg = /xyz/.test(function() {}.toString()) ? /\b\._super\b/ : /.*/;

function declareProperties(cls, className, properties, baseClass, mixins, es6) {
    if (cls.__props__ = [], baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice()), 
    mixins) for (var m = 0; m < mixins.length; ++m) {
        var mixin = mixins[m];
        mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter((function(x) {
            return cls.__props__.indexOf(x) < 0;
        }))));
    }
    if (properties) for (var propName in function preprocessAttrs(properties, className, cls, es6) {
        for (var propName in properties) {
            var val = properties[propName], fullForm = getFullFormOfProperty(val);
            if (fullForm && (val = properties[propName] = fullForm), val) {
                var notify = val.notify;
                notify && parseNotify(val, propName, notify, properties), "type" in val && parseType(val, val.type, className, propName), 
                "url" in val && checkUrl(val, 0, 0, val.url), "type" in val && val.type;
            }
        }
    }(properties, className), properties) {
        var val = properties[propName];
        "default" in val ? defineProp(cls, className, propName, val) : defineGetSet(cls, className, propName, val, es6);
    }
    var attrs = getClassAttrs(cls);
    cls.__values__ = cls.__props__.filter((function(prop) {
        return !1 !== attrs[prop + "$_$serializable"];
    }));
}

function CCClass(options) {
    var name = (options = options || {}).name, base = options.extends, mixins = options.mixins, cls = function define(className, baseClass, mixins, options) {
        var Component = cc.Component, frame = peek();
        if (frame && isChildClassOf(baseClass, Component)) {
            if (isChildClassOf(frame.cls, Component)) return errorID(3615), null;
            className = className || frame.script;
        }
        var cls = doDefine(className, baseClass, mixins, options), isRenderPipeline = isChildClassOf(baseClass, cc.RenderPipeline), isRenderFlow = isChildClassOf(baseClass, cc.RenderFlow), isRenderStage = isChildClassOf(baseClass, cc.RenderStage);
        if (isRenderPipeline || isRenderFlow || isRenderStage || !1) {
            var renderName = "";
            isRenderPipeline ? renderName = "render_pipeline" : isRenderFlow ? renderName = "render_flow" : isRenderStage && (renderName = "render_stage"), 
            renderName && _setClassId(className, cls);
        }
        if (frame) if (isChildClassOf(baseClass, Component)) {
            var uuid = frame.uuid;
            uuid && _setClassId(uuid, cls), frame.cls = cls;
        } else isChildClassOf(frame.cls, Component) || (frame.cls = cls);
        return cls;
    }(name, base, mixins, options);
    name || (name = cc.js.getClassName(cls)), cls._sealed = !0, base && (base._sealed = !1);
    var properties = options.properties;
    "function" == typeof properties || base && null === base.__props__ || mixins && mixins.some((function(x) {
        return null === x.__props__;
    })) ? (deferredInitializer.push({
        cls: cls,
        props: properties,
        mixins: mixins
    }), cls.__props__ = cls.__values__ = null) : declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
    var staticPropName, statics = options.statics;
    if (statics) for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
    for (var funcName in options) if (!(BUILTIN_ENTRIES.indexOf(funcName) >= 0)) {
        var func = options[funcName];
        validateMethodWithProps(func) && value(cls.prototype, funcName, func, !0, !0);
    }
    var editor = options.editor;
    return editor && isChildClassOf(base, cc.Component) && cc.Component._registerEditorProps(cls, editor), 
    cls;
}

CCClass._isCCClass = function(constructor) {
    return constructor && constructor.hasOwnProperty && constructor.hasOwnProperty("__ctors__");
}, CCClass.fastDefine = function(className, constructor, serializableFields) {
    setClassName(className, constructor);
    for (var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields), attrProtos = getClassAttrsProto(constructor), i = 0; i < props.length; i++) {
        var key = props[i];
        attrProtos[key + "$_$visible"] = !1, attrProtos[key + "$_$default"] = serializableFields[key];
    }
}, CCClass.Attr = attributeUtils, CCClass.attr = attr, CCClass.getInheritanceChain = function getInheritanceChain(constructor) {
    for (var chain = []; constructor = getSuper(constructor); ) constructor !== Object && chain.push(constructor);
    return chain;
};

var PrimitiveTypes = {
    Integer: "Number",
    Float: "Number",
    Boolean: "Boolean",
    String: "String"
}, tmpAttrs = [];

function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
    var attrsProto = null, attrsProtoKey = "";
    function getAttrsProto() {
        return attrsProtoKey = propertyName + "$_$", attrsProto = getClassAttrsProto(constructor);
    }
    tmpAttrs.length = 0;
    var result = tmpAttrs;
    "type" in attributes && void 0 === attributes.type && warnID(3660, propertyName, className);
    var type = attributes.type;
    if (type) if (PrimitiveTypes[type]) result.push({
        type: type,
        _onAfterProp: void 0
    }); else if ("Object" === type) ; else if ("object" === _typeof(type)) Enum.isEnum(type) ? result.push({
        type: "Enum",
        enumList: Enum.getList(type)
    }) : BitMask.isBitMask(type) && result.push({
        type: "BitMask",
        bitmaskList: BitMask.getList(type)
    }); else if ("function" == typeof type) {
        result.push({
            type: "Object",
            ctor: type,
            _onAfterProp: void 0
        });
    }
    var parseSimpleAttribute = function parseSimpleAttribute(attributeName, expectType) {
        if (attributeName in attributes) {
            var val = attributes[attributeName];
            _typeof(val) === expectType && ((attrsProto || getAttrsProto())[attrsProtoKey + attributeName] = val);
        }
    };
    attributes.editorOnly && ((attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = !0), 
    attributes.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = !0), 
    !1 === attributes.serializable && ((attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = !1), 
    parseSimpleAttribute("formerlySerializedAs", "string");
    var range = attributes.range;
    return range && Array.isArray(range) && range.length >= 2 && ((attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0], 
    (attrsProto || getAttrsProto())[attrsProtoKey + "max"] = range[1], range.length > 2 && ((attrsProto || getAttrsProto())[attrsProtoKey + "step"] = range[2])), 
    parseSimpleAttribute("min", "number"), parseSimpleAttribute("max", "number"), parseSimpleAttribute("step", "number"), 
    result;
}

CCClass.isArray = function(defaultVal) {
    return defaultVal = getDefault(defaultVal), Array.isArray(defaultVal);
}, CCClass.getDefault = getDefault, CCClass.escapeForJS = function escapeForJS(s) {
    return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
}, CCClass.IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/, CCClass.getNewValueTypeCode = !1, 
cc.Class = CCClass;

var _d2r = Math.PI / 180, _r2d = 180 / Math.PI, EPSILON = 1e-6;

function equals(a, b) {
    return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
}

function approx(a, b, maxDiff) {
    return maxDiff = maxDiff || EPSILON, Math.abs(a - b) <= maxDiff;
}

function clamp(val, min, max) {
    if (min > max) {
        var temp = min;
        min = max, max = temp;
    }
    return val < min ? min : val > max ? max : val;
}

function clamp01(val) {
    return val < 0 ? 0 : val > 1 ? 1 : val;
}

function lerp(from, to, ratio) {
    return from + (to - from) * ratio;
}

function toRadian(a) {
    return a * _d2r;
}

function toDegree(a) {
    return a * _r2d;
}

var random = Math.random;

function randomRange(min, max) {
    return Math.random() * (max - min) + min;
}

function randomRangeInt(min, max) {
    return Math.floor(randomRange(min, max));
}

function pseudoRandom(seed) {
    return (seed = (9301 * seed + 49297) % 233280) / 233280;
}

function pseudoRandomRange(seed, min, max) {
    return pseudoRandom(seed) * (max - min) + min;
}

function pseudoRandomRangeInt(seed, min, max) {
    return Math.floor(pseudoRandomRange(seed, min, max));
}

function nextPow2$1(val) {
    return --val, val |= val >> 1, val |= val >> 2, val |= val >> 4, val |= val >> 8, 
    val |= val >> 16, ++val;
}

function repeat(t, length) {
    return t - Math.floor(t / length) * length;
}

function pingPong(t, length) {
    return t = repeat(t, 2 * length), t = length - Math.abs(t - length);
}

function inverseLerp(from, to, value) {
    return (value - from) / (to - from);
}

function absMaxComponent(v) {
    return Math.abs(v.x) > Math.abs(v.y) ? Math.abs(v.x) > Math.abs(v.z) ? v.x : v.z : Math.abs(v.y) > Math.abs(v.z) ? v.y : v.z;
}

function absMax(a, b) {
    return Math.abs(a) > Math.abs(b) ? a : b;
}

var Vec2 = function(_ValueType) {
    function Vec2(x, y) {
        var _this;
        return _classCallCheck(this, Vec2), _this = _possibleConstructorReturn(this, _getPrototypeOf(Vec2).call(this)), 
        x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y) : (_this.x = x || 0, 
        _this.y = y || 0), _this;
    }
    return _inherits(Vec2, ValueType), _createClass(Vec2, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Vec2(a.x, a.y);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.x = a.x, out.y = a.y, out;
        }
    }, {
        key: "set",
        value: function set(out, x, y) {
            return out.x = x, out.y = y, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.x = a.x + b.x, out.y = a.y + b.y, out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.x = a.x - b.x, out.y = a.y - b.y, out;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return out.x = a.x * b.x, out.y = a.y * b.y, out;
        }
    }, {
        key: "divide",
        value: function divide(out, a, b) {
            return out.x = a.x / b.x, out.y = a.y / b.y, out;
        }
    }, {
        key: "ceil",
        value: function ceil(out, a) {
            return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out;
        }
    }, {
        key: "floor",
        value: function floor(out, a) {
            return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out;
        }
    }, {
        key: "min",
        value: function min(out, a, b) {
            return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out;
        }
    }, {
        key: "max",
        value: function max(out, a, b) {
            return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out;
        }
    }, {
        key: "round",
        value: function round(out, a) {
            return out.x = Math.round(a.x), out.y = Math.round(a.y), out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.x = a.x * b, out.y = a.y * b, out;
        }
    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, a, b, scale) {
            return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out;
        }
    }, {
        key: "distance",
        value: function distance(a, b) {
            var x = b.x - a.x, y = b.y - a.y;
            return Math.sqrt(x * x + y * y);
        }
    }, {
        key: "squaredDistance",
        value: function squaredDistance(a, b) {
            var x = b.x - a.x, y = b.y - a.y;
            return x * x + y * y;
        }
    }, {
        key: "len",
        value: function len(a) {
            var x = a.x, y = a.y;
            return Math.sqrt(x * x + y * y);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr(a) {
            var x = a.x, y = a.y;
            return x * x + y * y;
        }
    }, {
        key: "negate",
        value: function negate(out, a) {
            return out.x = -a.x, out.y = -a.y, out;
        }
    }, {
        key: "inverse",
        value: function inverse(out, a) {
            return out.x = 1 / a.x, out.y = 1 / a.y, out;
        }
    }, {
        key: "inverseSafe",
        value: function inverseSafe(out, a) {
            var x = a.x, y = a.y;
            return Math.abs(x) < EPSILON ? out.x = 0 : out.x = 1 / x, Math.abs(y) < EPSILON ? out.y = 0 : out.y = 1 / y, 
            out;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            var x = a.x, y = a.y, len = x * x + y * y;
            return len > 0 && (len = 1 / Math.sqrt(len), out.x = x * len, out.y = y * len), 
            out;
        }
    }, {
        key: "dot",
        value: function dot(a, b) {
            return a.x * b.x + a.y * b.y;
        }
    }, {
        key: "cross",
        value: function cross(out, a, b) {
            return out.x = out.y = 0, out.z = a.x * b.y - a.y * b.x, out;
        }
    }, {
        key: "lerp",
        value: function lerp(out, a, b, t) {
            var x = a.x, y = a.y;
            return out.x = x + t * (b.x - x), out.y = y + t * (b.y - y), out;
        }
    }, {
        key: "random",
        value: function random$1(out, scale) {
            scale = scale || 1;
            var r = 2 * random() * Math.PI;
            return out.x = Math.cos(r) * scale, out.y = Math.sin(r) * scale, out;
        }
    }, {
        key: "transformMat3",
        value: function transformMat3(out, a, m) {
            var x = a.x, y = a.y;
            return out.x = m.m00 * x + m.m03 * y + m.m06, out.y = m.m01 * x + m.m04 * y + m.m07, 
            out;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(out, a, m) {
            var x = a.x, y = a.y;
            return out.x = m.m00 * x + m.m04 * y + m.m12, out.y = m.m01 * x + m.m05 * y + m.m13, 
            out;
        }
    }, {
        key: "str",
        value: function str(a) {
            return "Vec2(".concat(a.x, ", ").concat(a.y, ")");
        }
    }, {
        key: "toArray",
        value: function toArray(out, v) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out;
        }
    }, {
        key: "fromArray",
        value: function fromArray(out, arr) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.x === b.x && a.y === b.y;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y));
        }
    }, {
        key: "angle",
        value: function angle(a, b) {
            Vec2.normalize(v2_1, a), Vec2.normalize(v2_2, b);
            var cosine = Vec2.dot(v2_1, v2_2);
            return cosine > 1 ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
        }
    } ]), _createClass(Vec2, [ {
        key: "clone",
        value: function clone() {
            return new Vec2(this.x, this.y);
        }
    }, {
        key: "set",
        value: function set(x, y) {
            return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y) : (this.x = x || 0, 
            this.y = y || 0), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y));
        }
    }, {
        key: "equals2f",
        value: function equals2f(x, y) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return other && this.x === other.x && this.y === other.y;
        }
    }, {
        key: "strictEquals2f",
        value: function strictEquals2f(x, y) {
            return this.x === x && this.y === y;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ")");
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            var x = this.x, y = this.y;
            return this.x = x + ratio * (to.x - x), this.y = y + ratio * (to.y - y), this;
        }
    }, {
        key: "clampf",
        value: function clampf(minInclusive, maxInclusive) {
            return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
            this;
        }
    }, {
        key: "add",
        value: function add(other) {
            return this.x = this.x + other.x, this.y = this.y + other.y, this;
        }
    }, {
        key: "add2f",
        value: function add2f(x, y) {
            return this.x = this.x + x, this.y = this.y + y, this;
        }
    }, {
        key: "subtract",
        value: function subtract(other) {
            return this.x = this.x - other.x, this.y = this.y - other.y, this;
        }
    }, {
        key: "subtract2f",
        value: function subtract2f(x, y) {
            return this.x = this.x - x, this.y = this.y - y, this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return "object" === _typeof(scalar) && console.warn("should use Vec2.multiply for vector * vector operation"), 
            this.x = this.x * scalar, this.y = this.y * scalar, this;
        }
    }, {
        key: "multiply",
        value: function multiply(other) {
            return "object" !== _typeof(other) && console.warn("should use Vec2.scale for vector * scalar operation"), 
            this.x = this.x * other.x, this.y = this.y * other.y, this;
        }
    }, {
        key: "multiply2f",
        value: function multiply2f(x, y) {
            return this.x = this.x * x, this.y = this.y * y, this;
        }
    }, {
        key: "divide",
        value: function divide(other) {
            return this.x = this.x / other.x, this.y = this.y / other.y, this;
        }
    }, {
        key: "divide2f",
        value: function divide2f(x, y) {
            return this.x = this.x / x, this.y = this.y / y, this;
        }
    }, {
        key: "negative",
        value: function negative() {
            return this.x = -this.x, this.y = -this.y, this;
        }
    }, {
        key: "dot",
        value: function dot(other) {
            return this.x * other.x + this.y * other.y;
        }
    }, {
        key: "cross",
        value: function cross(other) {
            return this.x * other.y - this.y * other.x;
        }
    }, {
        key: "length",
        value: function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr() {
            return this.x * this.x + this.y * this.y;
        }
    }, {
        key: "normalize",
        value: function normalize() {
            var x = this.x, y = this.y, len = x * x + y * y;
            return len > 0 && (len = 1 / Math.sqrt(len), this.x = this.x * len, this.y = this.y * len), 
            this;
        }
    }, {
        key: "angle",
        value: function angle(other) {
            var magSqr1 = this.lengthSqr(), magSqr2 = other.lengthSqr();
            if (0 === magSqr1 || 0 === magSqr2) return console.warn("Can't get angle between zero vector"), 
            0;
            var theta = this.dot(other) / Math.sqrt(magSqr1 * magSqr2);
            return theta = clamp(theta, -1, 1), Math.acos(theta);
        }
    }, {
        key: "signAngle",
        value: function signAngle(other) {
            var angle = this.angle(other);
            return this.cross(other) < 0 ? -angle : angle;
        }
    }, {
        key: "rotate",
        value: function rotate(radians) {
            var x = this.x, y = this.y, sin = Math.sin(radians), cos = Math.cos(radians);
            return this.x = cos * x - sin * y, this.y = sin * x + cos * y, this;
        }
    }, {
        key: "project",
        value: function project(other) {
            var scalar = this.dot(other) / other.dot(other);
            return this.x = other.x * scalar, this.y = other.y * scalar, this;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(matrix) {
            var x = this.x, y = this.y;
            return this.x = matrix.m00 * x + matrix.m04 * y + matrix.m12, this.y = matrix.m01 * x + matrix.m05 * y + matrix.m13, 
            this;
        }
    } ]), Vec2;
}();

Vec2.ZERO = Object.freeze(new Vec2(0, 0)), Vec2.ONE = Object.freeze(new Vec2(1, 1)), 
Vec2.NEG_ONE = Object.freeze(new Vec2(-1, -1)), Vec2.UNIT_X = Object.freeze(new Vec2(1, 0)), 
Vec2.UNIT_Y = Object.freeze(new Vec2(0, 1));

var v2_1 = new Vec2, v2_2 = new Vec2;

function v2(x, y) {
    return new Vec2(x, y);
}

CCClass.fastDefine("cc.Vec2", Vec2, {
    x: 0,
    y: 0
}), cc.Vec2 = Vec2, cc.v2 = v2;

var Vec3 = function(_ValueType) {
    function Vec3(x, y, z) {
        var _this;
        return _classCallCheck(this, Vec3), _this = _possibleConstructorReturn(this, _getPrototypeOf(Vec3).call(this)), 
        x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y, _this.z = x.z) : (_this.x = x || 0, 
        _this.y = y || 0, _this.z = z || 0), _this;
    }
    return _inherits(Vec3, ValueType), _createClass(Vec3, null, [ {
        key: "zero",
        value: function zero(out) {
            return out.x = 0, out.y = 0, out.z = 0, out;
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new Vec3(a.x, a.y, a.z);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.x = a.x, out.y = a.y, out.z = a.z, out;
        }
    }, {
        key: "set",
        value: function set(out, x, y, z) {
            return out.x = x, out.y = y, out.z = z, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out;
        }
    }, {
        key: "divide",
        value: function divide(out, a, b) {
            return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out;
        }
    }, {
        key: "ceil",
        value: function ceil(out, a) {
            return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out;
        }
    }, {
        key: "floor",
        value: function floor(out, a) {
            return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
            out;
        }
    }, {
        key: "min",
        value: function min(out, a, b) {
            return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
            out;
        }
    }, {
        key: "max",
        value: function max(out, a, b) {
            return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
            out;
        }
    }, {
        key: "round",
        value: function round(out, a) {
            return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
            out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out;
        }
    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, a, b, scale) {
            return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
            out;
        }
    }, {
        key: "distance",
        value: function distance(a, b) {
            var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z;
            return Math.sqrt(x * x + y * y + z * z);
        }
    }, {
        key: "squaredDistance",
        value: function squaredDistance(a, b) {
            var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z;
            return x * x + y * y + z * z;
        }
    }, {
        key: "len",
        value: function len(a) {
            var x = a.x, y = a.y, z = a.z;
            return Math.sqrt(x * x + y * y + z * z);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr(a) {
            var x = a.x, y = a.y, z = a.z;
            return x * x + y * y + z * z;
        }
    }, {
        key: "negate",
        value: function negate(out, a) {
            return out.x = -a.x, out.y = -a.y, out.z = -a.z, out;
        }
    }, {
        key: "invert",
        value: function invert(out, a) {
            return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out;
        }
    }, {
        key: "invertSafe",
        value: function invertSafe(out, a) {
            var x = a.x, y = a.y, z = a.z;
            return Math.abs(x) < EPSILON ? out.x = 0 : out.x = 1 / x, Math.abs(y) < EPSILON ? out.y = 0 : out.y = 1 / y, 
            Math.abs(z) < EPSILON ? out.z = 0 : out.z = 1 / z, out;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            var x = a.x, y = a.y, z = a.z, len = x * x + y * y + z * z;
            return len > 0 && (len = 1 / Math.sqrt(len), out.x = x * len, out.y = y * len, out.z = z * len), 
            out;
        }
    }, {
        key: "dot",
        value: function dot(a, b) {
            return a.x * b.x + a.y * b.y + a.z * b.z;
        }
    }, {
        key: "cross",
        value: function cross(out, a, b) {
            var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
            return out.x = ay * bz - az * by, out.y = az * bx - ax * bz, out.z = ax * by - ay * bx, 
            out;
        }
    }, {
        key: "lerp",
        value: function lerp(out, a, b, t) {
            return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
            out;
        }
    }, {
        key: "random",
        value: function random$1(out, scale) {
            scale = scale || 1;
            var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
            return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
            out.z = cosTheta * scale, out;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(out, a, m) {
            var x = a.x, y = a.y, z = a.z, rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
            return rhw = rhw ? Math.abs(1 / rhw) : 1, out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw, 
            out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw, out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw, 
            out;
        }
    }, {
        key: "transformMat4Normal",
        value: function transformMat4Normal(out, a, m) {
            var x = a.x, y = a.y, z = a.z, rhw = m.m03 * x + m.m07 * y + m.m11 * z;
            return rhw = rhw ? Math.abs(1 / rhw) : 1, out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw, 
            out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw, out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw, 
            out;
        }
    }, {
        key: "transformMat3",
        value: function transformMat3(out, a, m) {
            var x = a.x, y = a.y, z = a.z;
            return out.x = x * m.m00 + y * m.m03 + z * m.m06, out.y = x * m.m01 + y * m.m04 + z * m.m07, 
            out.z = x * m.m02 + y * m.m05 + z * m.m08, out;
        }
    }, {
        key: "transformAffine",
        value: function transformAffine(out, v, m) {
            var x = v.x, y = v.y, z = v.z;
            return out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12, out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13, 
            out.x = m.m02 * x + m.m06 * y + m.m10 * z + m.m14, out;
        }
    }, {
        key: "transformQuat",
        value: function transformQuat(out, a, q) {
            var ix = q.w * a.x + q.y * a.z - q.z * a.y, iy = q.w * a.y + q.z * a.x - q.x * a.z, iz = q.w * a.z + q.x * a.y - q.y * a.x, iw = -q.x * a.x - q.y * a.y - q.z * a.z;
            return out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y, out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z, 
            out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x, out;
        }
    }, {
        key: "transformRTS",
        value: function transformRTS(out, a, r, t, s) {
            var x = a.x * s.x, y = a.y * s.y, z = a.z * s.z, ix = r.w * x + r.y * z - r.z * y, iy = r.w * y + r.z * x - r.x * z, iz = r.w * z + r.x * y - r.y * x, iw = -r.x * x - r.y * y - r.z * z;
            return out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x, out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y, 
            out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z, out;
        }
    }, {
        key: "transformInverseRTS",
        value: function transformInverseRTS(out, a, r, t, s) {
            var x = a.x - t.x, y = a.y - t.y, z = a.z - t.z, ix = r.w * x - r.y * z + r.z * y, iy = r.w * y - r.z * x + r.x * z, iz = r.w * z - r.x * y + r.y * x, iw = r.x * x + r.y * y + r.z * z;
            return out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x, out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y, 
            out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z, out;
        }
    }, {
        key: "rotateX",
        value: function rotateX(out, v, o, a) {
            var x = v.x - o.x, y = v.y - o.y, z = v.z - o.z, cos = Math.cos(a), sin = Math.sin(a), rx = x, ry = y * cos - z * sin, rz = y * sin + z * cos;
            return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
        }
    }, {
        key: "rotateY",
        value: function rotateY(out, v, o, a) {
            var x = v.x - o.x, y = v.y - o.y, z = v.z - o.z, cos = Math.cos(a), sin = Math.sin(a), rx = z * sin + x * cos, ry = y, rz = z * cos - x * sin;
            return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
        }
    }, {
        key: "rotateZ",
        value: function rotateZ(out, v, o, a) {
            var x = v.x - o.x, y = v.y - o.y, z = v.z - o.z, cos = Math.cos(a), sin = Math.sin(a), rx = x * cos - y * sin, ry = x * sin + y * cos, rz = z;
            return out.x = rx + o.x, out.y = ry + o.y, out.z = rz + o.z, out;
        }
    }, {
        key: "toArray",
        value: function toArray(out, v) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out;
        }
    }, {
        key: "fromArray",
        value: function fromArray(out, arr) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.x === b.x && a.y === b.y && a.z === b.z;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON, a0 = a.x, a1 = a.y, a2 = a.z, b0 = b.x, b1 = b.y, b2 = b.z;
            return Math.abs(a0 - b0) <= epsilon * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1, Math.abs(a2), Math.abs(b2));
        }
    }, {
        key: "angle",
        value: function angle(a, b) {
            Vec3.normalize(v3_1, a), Vec3.normalize(v3_2, b);
            var cosine = Vec3.dot(v3_1, v3_2);
            return cosine > 1 ? 0 : cosine < -1 ? Math.PI : Math.acos(cosine);
        }
    }, {
        key: "projectOnPlane",
        value: function projectOnPlane(out, a, n) {
            return Vec3.subtract(out, a, Vec3.project(out, a, n));
        }
    }, {
        key: "project",
        value: function project(out, a, b) {
            var sqrLen = Vec3.lengthSqr(b);
            return sqrLen < 1e-6 ? Vec3.set(out, 0, 0, 0) : Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
        }
    } ]), _createClass(Vec3, [ {
        key: "clone",
        value: function clone() {
            return new Vec3(this.x, this.y, this.z);
        }
    }, {
        key: "set",
        value: function set(x, y, z) {
            return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z) : (this.x = x || 0, 
            this.y = y || 0, this.z = z || 0), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z));
        }
    }, {
        key: "equals3f",
        value: function equals3f(x, y, z) {
            var epsilon = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : EPSILON;
            return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return this.x === other.x && this.y === other.y && this.z === other.z;
        }
    }, {
        key: "strictEquals3f",
        value: function strictEquals3f(x, y, z) {
            return this.x === x && this.y === y && this.z === z;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ")");
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return this.x = this.x + ratio * (to.x - this.x), this.y = this.y + ratio * (to.y - this.y), 
            this.z = this.z + ratio * (to.z - this.z), this;
        }
    }, {
        key: "add",
        value: function add(other) {
            return this.x = this.x + other.x, this.y = this.y + other.y, this.z = this.z + other.z, 
            this;
        }
    }, {
        key: "add3f",
        value: function add3f(x, y, z) {
            return this.x = this.x + x, this.y = this.y + y, this.z = this.z + z, this;
        }
    }, {
        key: "subtract",
        value: function subtract(other) {
            return this.x = this.x - other.x, this.y = this.y - other.y, this.z = this.z - other.z, 
            this;
        }
    }, {
        key: "subtract3f",
        value: function subtract3f(x, y, z) {
            return this.x = this.x - x, this.y = this.y - y, this.z = this.z - z, this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return "object" === _typeof(scalar) && console.warn("should use Vec3.multiply for vector * vector operation"), 
            this.x = this.x * scalar, this.y = this.y * scalar, this.z = this.z * scalar, this;
        }
    }, {
        key: "multiply",
        value: function multiply(other) {
            return "object" !== _typeof(other) && console.warn("should use Vec3.scale for vector * scalar operation"), 
            this.x = this.x * other.x, this.y = this.y * other.y, this.z = this.z * other.z, 
            this;
        }
    }, {
        key: "multiply3f",
        value: function multiply3f(x, y, z) {
            return this.x = this.x * x, this.y = this.y * y, this.z = this.z * z, this;
        }
    }, {
        key: "divide",
        value: function divide(other) {
            return this.x = this.x / other.x, this.y = this.y / other.y, this.z = this.z / other.z, 
            this;
        }
    }, {
        key: "divide3f",
        value: function divide3f(x, y, z) {
            return this.x = this.x / x, this.y = this.y / y, this.z = this.z / z, this;
        }
    }, {
        key: "negative",
        value: function negative() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
    }, {
        key: "clampf",
        value: function clampf(minInclusive, maxInclusive) {
            return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
            this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this;
        }
    }, {
        key: "dot",
        value: function dot(other) {
            return this.x * other.x + this.y * other.y + this.z * other.z;
        }
    }, {
        key: "cross",
        value: function cross(other) {
            var ax = this.x, ay = this.y, az = this.z, bx = other.x, by = other.y, bz = other.z;
            return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
            this;
        }
    }, {
        key: "length",
        value: function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
    }, {
        key: "normalize",
        value: function normalize() {
            var x = this.x, y = this.y, z = this.z, len = x * x + y * y + z * z;
            return len > 0 && (len = 1 / Math.sqrt(len), this.x = x * len, this.y = y * len, 
            this.z = z * len), this;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(matrix) {
            var x = this.x, y = this.y, z = this.z, rhw = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15;
            return rhw = rhw ? 1 / rhw : 1, this.x = (matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12) * rhw, 
            this.y = (matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13) * rhw, 
            this.z = (matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14) * rhw, 
            this;
        }
    } ]), Vec3;
}();

Vec3.UNIT_X = Object.freeze(new Vec3(1, 0, 0)), Vec3.UNIT_Y = Object.freeze(new Vec3(0, 1, 0)), 
Vec3.UNIT_Z = Object.freeze(new Vec3(0, 0, 1)), Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0)), 
Vec3.UP = Object.freeze(new Vec3(0, 1, 0)), Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1)), 
Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0)), Vec3.ONE = Object.freeze(new Vec3(1, 1, 1)), 
Vec3.NEG_ONE = Object.freeze(new Vec3(-1, -1, -1));

var v3_1 = new Vec3, v3_2 = new Vec3;

function v3(x, y, z) {
    return new Vec3(x, y, z);
}

CCClass.fastDefine("cc.Vec3", Vec3, {
    x: 0,
    y: 0,
    z: 0
}), cc.Vec3 = Vec3, cc.v3 = v3;

var Vec4 = function(_ValueType) {
    function Vec4(x, y, z, w) {
        var _this;
        return _classCallCheck(this, Vec4), _this = _possibleConstructorReturn(this, _getPrototypeOf(Vec4).call(this)), 
        x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, 
        _this.y = y || 0, _this.z = z || 0, _this.w = w || 0), _this;
    }
    return _inherits(Vec4, ValueType), _createClass(Vec4, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Vec4(a.x, a.y, a.z, a.w);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
        }
    }, {
        key: "set",
        value: function set(out, x, y, z, w) {
            return out.x = x, out.y = y, out.z = z, out.w = w, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.x = a.x + b.x, out.y = a.y + b.y, out.z = a.z + b.z, out.w = a.w + b.w, 
            out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.x = a.x - b.x, out.y = a.y - b.y, out.z = a.z - b.z, out.w = a.w - b.w, 
            out;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return out.x = a.x * b.x, out.y = a.y * b.y, out.z = a.z * b.z, out.w = a.w * b.w, 
            out;
        }
    }, {
        key: "divide",
        value: function divide(out, a, b) {
            return out.x = a.x / b.x, out.y = a.y / b.y, out.z = a.z / b.z, out.w = a.w / b.w, 
            out;
        }
    }, {
        key: "ceil",
        value: function ceil(out, a) {
            return out.x = Math.ceil(a.x), out.y = Math.ceil(a.y), out.z = Math.ceil(a.z), out.w = Math.ceil(a.w), 
            out;
        }
    }, {
        key: "floor",
        value: function floor(out, a) {
            return out.x = Math.floor(a.x), out.y = Math.floor(a.y), out.z = Math.floor(a.z), 
            out.w = Math.floor(a.w), out;
        }
    }, {
        key: "min",
        value: function min(out, a, b) {
            return out.x = Math.min(a.x, b.x), out.y = Math.min(a.y, b.y), out.z = Math.min(a.z, b.z), 
            out.w = Math.min(a.w, b.w), out;
        }
    }, {
        key: "max",
        value: function max(out, a, b) {
            return out.x = Math.max(a.x, b.x), out.y = Math.max(a.y, b.y), out.z = Math.max(a.z, b.z), 
            out.w = Math.max(a.w, b.w), out;
        }
    }, {
        key: "round",
        value: function round(out, a) {
            return out.x = Math.round(a.x), out.y = Math.round(a.y), out.z = Math.round(a.z), 
            out.w = Math.round(a.w), out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
        }
    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, a, b, scale) {
            return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
            out.w = a.w + b.w * scale, out;
        }
    }, {
        key: "distance",
        value: function distance(a, b) {
            var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
            return Math.sqrt(x * x + y * y + z * z + w * w);
        }
    }, {
        key: "squaredDistance",
        value: function squaredDistance(a, b) {
            var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
            return x * x + y * y + z * z + w * w;
        }
    }, {
        key: "len",
        value: function len(a) {
            var x = a.x, y = a.y, z = a.z, w = a.w;
            return Math.sqrt(x * x + y * y + z * z + w * w);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr(a) {
            var x = a.x, y = a.y, z = a.z, w = a.w;
            return x * x + y * y + z * z + w * w;
        }
    }, {
        key: "negate",
        value: function negate(out, a) {
            return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = -a.w, out;
        }
    }, {
        key: "inverse",
        value: function inverse(out, a) {
            return out.x = 1 / a.x, out.y = 1 / a.y, out.z = 1 / a.z, out.w = 1 / a.w, out;
        }
    }, {
        key: "inverseSafe",
        value: function inverseSafe(out, a) {
            var x = a.x, y = a.y, z = a.z, w = a.w;
            return Math.abs(x) < EPSILON ? out.x = 0 : out.x = 1 / x, Math.abs(y) < EPSILON ? out.y = 0 : out.y = 1 / y, 
            Math.abs(z) < EPSILON ? out.z = 0 : out.z = 1 / z, Math.abs(w) < EPSILON ? out.w = 0 : out.w = 1 / w, 
            out;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            var x = a.x, y = a.y, z = a.z, w = a.w, len = x * x + y * y + z * z + w * w;
            return len > 0 && (len = 1 / Math.sqrt(len), out.x = x * len, out.y = y * len, out.z = z * len, 
            out.w = w * len), out;
        }
    }, {
        key: "dot",
        value: function dot(a, b) {
            return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }
    }, {
        key: "lerp",
        value: function lerp(out, a, b, t) {
            return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
            out.w = a.w + t * (b.w - a.w), out;
        }
    }, {
        key: "random",
        value: function random$1(out, scale) {
            scale = scale || 1;
            var phi = 2 * random() * Math.PI, cosTheta = 2 * random() - 1, sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
            return out.x = sinTheta * Math.cos(phi) * scale, out.y = sinTheta * Math.sin(phi) * scale, 
            out.z = cosTheta * scale, out.w = 0, out;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(out, a, m) {
            var x = a.x, y = a.y, z = a.z, w = a.w;
            return out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w, out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w, 
            out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w, out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w, 
            out;
        }
    }, {
        key: "transformAffine",
        value: function transformAffine(out, v, m) {
            var x = v.x, y = v.y, z = v.z, w = v.w;
            return out.x = m.m00 * x + m.m01 * y + m.m02 * z + m.m03 * w, out.y = m.m04 * x + m.m05 * y + m.m06 * z + m.m07 * w, 
            out.x = m.m08 * x + m.m09 * y + m.m10 * z + m.m11 * w, out.w = v.w, out;
        }
    }, {
        key: "transformQuat",
        value: function transformQuat(out, a, q) {
            var x = a.x, y = a.y, z = a.z, _x = q.x, _y = q.y, _z = q.z, _w = q.w, ix = _w * x + _y * z - _z * y, iy = _w * y + _z * x - _x * z, iz = _w * z + _x * y - _y * x, iw = -_x * x - _y * y - _z * z;
            return out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y, out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z, 
            out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x, out.w = a.w, out;
        }
    }, {
        key: "toArray",
        value: function toArray(out, v) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = v.x, out[ofs + 1] = v.y, out[ofs + 2] = v.z, out[ofs + 3] = v.w, 
            out;
        }
    }, {
        key: "fromArray",
        value: function fromArray(out, arr) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out.w = arr[ofs + 3], 
            out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
        }
    } ]), _createClass(Vec4, [ {
        key: "clone",
        value: function clone() {
            return new Vec4(this.x, this.y, this.z, this.w);
        }
    }, {
        key: "set",
        value: function set(x, y, z, w) {
            return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z, 
            this.w = x.w) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 0), 
            this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
        }
    }, {
        key: "equals4f",
        value: function equals4f(x, y, z, w) {
            var epsilon = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : EPSILON;
            return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(w));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        }
    }, {
        key: "strictEquals4f",
        value: function strictEquals4f(x, y, z, w) {
            return this.x === x && this.y === y && this.z === z && this.w === w;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            return this.x = x + ratio * (to.x - x), this.y = y + ratio * (to.y - y), this.z = z + ratio * (to.z - z), 
            this.w = w + ratio * (to.w - w), this;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.z.toFixed(2), ", ").concat(this.w.toFixed(2), ")");
        }
    }, {
        key: "clampf",
        value: function clampf(minInclusive, maxInclusive) {
            return this.x = clamp(this.x, minInclusive.x, maxInclusive.x), this.y = clamp(this.y, minInclusive.y, maxInclusive.y), 
            this.z = clamp(this.z, minInclusive.z, maxInclusive.z), this.w = clamp(this.w, minInclusive.w, maxInclusive.w), 
            this;
        }
    }, {
        key: "add",
        value: function add(other) {
            return this.x = this.x + other.x, this.y = this.y + other.y, this.z = this.z + other.z, 
            this.w = this.w + other.w, this;
        }
    }, {
        key: "add4f",
        value: function add4f(x, y, z, w) {
            return this.x = this.x + x, this.y = this.y + y, this.z = this.z + z, this.w = this.w + w, 
            this;
        }
    }, {
        key: "subtract",
        value: function subtract(other) {
            return this.x = this.x - other.x, this.y = this.y - other.y, this.z = this.z - other.z, 
            this.w = this.w - other.w, this;
        }
    }, {
        key: "subtract4f",
        value: function subtract4f(x, y, z, w) {
            return this.x = this.x - x, this.y = this.y - y, this.z = this.z - z, this.w = this.w - w, 
            this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return "object" === _typeof(scalar) && console.warn("should use Vec4.multiply for vector * vector operation"), 
            this.x = this.x * scalar, this.y = this.y * scalar, this.z = this.z * scalar, this.w = this.w * scalar, 
            this;
        }
    }, {
        key: "multiply",
        value: function multiply(other) {
            return "object" !== _typeof(other) && console.warn("should use Vec4.scale for vector * scalar operation"), 
            this.x = this.x * other.x, this.y = this.y * other.y, this.z = this.z * other.z, 
            this.w = this.w * other.w, this;
        }
    }, {
        key: "multiply4f",
        value: function multiply4f(x, y, z, w) {
            return this.x = this.x * x, this.y = this.y * y, this.z = this.z * z, this.w = this.w * w, 
            this;
        }
    }, {
        key: "divide",
        value: function divide(other) {
            return this.x = this.x / other.x, this.y = this.y / other.y, this.z = this.z / other.z, 
            this.w = this.w / other.w, this;
        }
    }, {
        key: "divide4f",
        value: function divide4f(x, y, z, w) {
            return this.x = this.x / x, this.y = this.y / y, this.z = this.z / z, this.w = this.w / w, 
            this;
        }
    }, {
        key: "negative",
        value: function negative() {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
    }, {
        key: "dot",
        value: function dot(vector) {
            return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
        }
    }, {
        key: "cross",
        value: function cross(vector) {
            var ax = this.x, ay = this.y, az = this.z, bx = vector.x, by = vector.y, bz = vector.z;
            return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, 
            this;
        }
    }, {
        key: "length",
        value: function length() {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            return Math.sqrt(x * x + y * y + z * z + w * w);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr() {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            return x * x + y * y + z * z + w * w;
        }
    }, {
        key: "normalize",
        value: function normalize() {
            var x = this.x, y = this.y, z = this.z, w = this.w, len = x * x + y * y + z * z + w * w;
            return len > 0 && (len = 1 / Math.sqrt(len), this.x = x * len, this.y = y * len, 
            this.z = z * len, this.w = w * len), this;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(matrix) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            return this.x = matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12 * w, 
            this.y = matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13 * w, this.z = matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14 * w, 
            this.w = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15 * w, this;
        }
    } ]), Vec4;
}();

function v4(x, y, z, w) {
    return new Vec4(x, y, z, w);
}

Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0)), Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1)), 
Vec4.NEG_ONE = Object.freeze(new Vec4(-1, -1, -1, -1)), CCClass.fastDefine("cc.Vec4", Vec4, {
    x: 0,
    y: 0,
    z: 0,
    w: 0
}), cc.Vec4 = Vec4, cc.v4 = v4;

var Mat3 = function(_ValueType) {
    function Mat3() {
        var _this, m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
        return _classCallCheck(this, Mat3), _this = _possibleConstructorReturn(this, _getPrototypeOf(Mat3).call(this)), 
        "object" === _typeof(m00) ? (_this.m00 = m00.m00, _this.m01 = m00.m01, _this.m02 = m00.m02, 
        _this.m03 = m00.m03, _this.m04 = m00.m04, _this.m05 = m00.m05, _this.m06 = m00.m06, 
        _this.m07 = m00.m07, _this.m08 = m00.m08) : (_this.m00 = m00, _this.m01 = m01, _this.m02 = m02, 
        _this.m03 = m03, _this.m04 = m04, _this.m05 = m05, _this.m06 = m06, _this.m07 = m07, 
        _this.m08 = m08), _this;
    }
    return _inherits(Mat3, ValueType), _createClass(Mat3, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
            out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out;
        }
    }, {
        key: "set",
        value: function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
            return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m10, out.m04 = m11, 
            out.m05 = m12, out.m06 = m20, out.m07 = m21, out.m08 = m22, out;
        }
    }, {
        key: "identity",
        value: function identity(out) {
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
            out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
        }
    }, {
        key: "transpose",
        value: function transpose(out, a) {
            if (out === a) {
                var a01 = a.m01, a02 = a.m02, a12 = a.m05;
                out.m01 = a.m03, out.m02 = a.m06, out.m03 = a01, out.m05 = a.m07, out.m06 = a02, 
                out.m07 = a12;
            } else out.m00 = a.m00, out.m01 = a.m03, out.m02 = a.m06, out.m03 = a.m01, out.m04 = a.m04, 
            out.m05 = a.m07, out.m06 = a.m02, out.m07 = a.m05, out.m08 = a.m08;
            return out;
        }
    }, {
        key: "invert",
        value: function invert(out, a) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, b01 = a22 * a11 - a12 * a21, b11 = -a22 * a10 + a12 * a20, b21 = a21 * a10 - a11 * a20, det = a00 * b01 + a01 * b11 + a02 * b21;
            return 0 === det ? (out.m00 = 0, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
            out.m05 = 0, out.m06 = 0, out.m07 = 0, out.m08 = 0, out) : (det = 1 / det, out.m00 = b01 * det, 
            out.m01 = (-a22 * a01 + a02 * a21) * det, out.m02 = (a12 * a01 - a02 * a11) * det, 
            out.m03 = b11 * det, out.m04 = (a22 * a00 - a02 * a20) * det, out.m05 = (-a12 * a00 + a02 * a10) * det, 
            out.m06 = b21 * det, out.m07 = (-a21 * a00 + a01 * a20) * det, out.m08 = (a11 * a00 - a01 * a10) * det, 
            out);
        }
    }, {
        key: "determinant",
        value: function determinant(a) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m03, b11 = b.m04, b12 = b.m05, b20 = b.m06, b21 = b.m07, b22 = b.m08;
            return out.m00 = b00 * a00 + b01 * a10 + b02 * a20, out.m01 = b00 * a01 + b01 * a11 + b02 * a21, 
            out.m02 = b00 * a02 + b01 * a12 + b02 * a22, out.m03 = b10 * a00 + b11 * a10 + b12 * a20, 
            out.m04 = b10 * a01 + b11 * a11 + b12 * a21, out.m05 = b10 * a02 + b11 * a12 + b12 * a22, 
            out.m06 = b20 * a00 + b21 * a10 + b22 * a20, out.m07 = b20 * a01 + b21 * a11 + b22 * a21, 
            out.m08 = b20 * a02 + b21 * a12 + b22 * a22, out;
        }
    }, {
        key: "multiplyMat4",
        value: function multiplyMat4(out, a, b) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, b00 = b.m00, b01 = b.m01, b02 = b.m02, b10 = b.m04, b11 = b.m05, b12 = b.m06, b20 = b.m08, b21 = b.m09, b22 = b.m10;
            return out.m00 = b00 * a00 + b01 * a10 + b02 * a20, out.m01 = b00 * a01 + b01 * a11 + b02 * a21, 
            out.m02 = b00 * a02 + b01 * a12 + b02 * a22, out.m03 = b10 * a00 + b11 * a10 + b12 * a20, 
            out.m04 = b10 * a01 + b11 * a11 + b12 * a21, out.m05 = b10 * a02 + b11 * a12 + b12 * a22, 
            out.m06 = b20 * a00 + b21 * a10 + b22 * a20, out.m07 = b20 * a01 + b21 * a11 + b22 * a21, 
            out.m08 = b20 * a02 + b21 * a12 + b22 * a22, out;
        }
    }, {
        key: "transfrom",
        value: function transfrom(out, a, v) {
            Mat3.transform(out, a, v);
        }
    }, {
        key: "transform",
        value: function transform(out, a, v) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, x = v.x, y = v.y;
            return out.m00 = a00, out.m01 = a01, out.m02 = a02, out.m03 = a10, out.m04 = a11, 
            out.m05 = a12, out.m06 = x * a00 + y * a10 + a20, out.m07 = x * a01 + y * a11 + a21, 
            out.m08 = x * a02 + y * a12 + a22, out;
        }
    }, {
        key: "scale",
        value: function scale(out, a, v) {
            var x = v.x, y = v.y;
            return out.m00 = x * a.m00, out.m01 = x * a.m01, out.m02 = x * a.m02, out.m03 = y * a.m03, 
            out.m04 = y * a.m04, out.m05 = y * a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
            out;
        }
    }, {
        key: "rotate",
        value: function rotate(out, a, rad) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08, s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = c * a00 + s * a10, out.m01 = c * a01 + s * a11, out.m02 = c * a02 + s * a12, 
            out.m03 = c * a10 - s * a00, out.m04 = c * a11 - s * a01, out.m05 = c * a12 - s * a02, 
            out.m06 = a20, out.m07 = a21, out.m08 = a22, out;
        }
    }, {
        key: "fromMat4",
        value: function fromMat4(out, a) {
            return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m04, out.m04 = a.m05, 
            out.m05 = a.m06, out.m06 = a.m08, out.m07 = a.m09, out.m08 = a.m10, out;
        }
    }, {
        key: "fromViewUp",
        value: function fromViewUp(out, view, up) {
            return Vec3.lengthSqr(view) < 1e-12 ? (Mat3.identity(out), out) : (up = up || Vec3.UNIT_Y, 
            Vec3.normalize(v3_1$1, Vec3.cross(v3_1$1, up, view)), Vec3.lengthSqr(v3_1$1) < 1e-12 ? (Mat3.identity(out), 
            out) : (Vec3.cross(v3_2$1, view, v3_1$1), Mat3.set(out, v3_1$1.x, v3_1$1.y, v3_1$1.z, v3_2$1.x, v3_2$1.y, v3_2$1.z, view.x, view.y, view.z), 
            out));
        }
    }, {
        key: "fromTranslation",
        value: function fromTranslation(out, v) {
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 1, out.m05 = 0, 
            out.m06 = v.x, out.m07 = v.y, out.m08 = 1, out;
        }
    }, {
        key: "fromScaling",
        value: function fromScaling(out, v) {
            return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = v.y, out.m05 = 0, 
            out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
        }
    }, {
        key: "fromRotation",
        value: function fromRotation(out, rad) {
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = -s, out.m04 = c, out.m05 = 0, 
            out.m06 = 0, out.m07 = 0, out.m08 = 1, out;
        }
    }, {
        key: "fromQuat",
        value: function fromQuat(out, q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return out.m00 = 1 - yy - zz, out.m03 = yx - wz, out.m06 = zx + wy, out.m01 = yx + wz, 
            out.m04 = 1 - xx - zz, out.m07 = zy - wx, out.m02 = zx - wy, out.m05 = zy + wx, 
            out.m08 = 1 - xx - yy, out;
        }
    }, {
        key: "inverseTransposeMat4",
        value: function inverseTransposeMat4(out, a) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            return det ? (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
            out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det, out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
            out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det, 
            out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
            out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det, out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
            out) : null;
        }
    }, {
        key: "toArray",
        value: function toArray(out, m) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
            out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
            out[ofs + 8] = m.m08, out;
        }
    }, {
        key: "fromArray",
        value: function fromArray(out, arr) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out.m00 = arr[ofs + 0], out.m01 = arr[ofs + 1], out.m02 = arr[ofs + 2], out.m03 = arr[ofs + 3], 
            out.m04 = arr[ofs + 4], out.m05 = arr[ofs + 5], out.m06 = arr[ofs + 6], out.m07 = arr[ofs + 7], 
            out.m08 = arr[ofs + 8], out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
            out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
            out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
            out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
            out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
            out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
            out.m08 = a.m08 * b, out;
        }
    }, {
        key: "multiplyScalarAndAdd",
        value: function multiplyScalarAndAdd(out, a, b, scale) {
            return out.m00 = b.m00 * scale + a.m00, out.m01 = b.m01 * scale + a.m01, out.m02 = b.m02 * scale + a.m02, 
            out.m03 = b.m03 * scale + a.m03, out.m04 = b.m04 * scale + a.m04, out.m05 = b.m05 * scale + a.m05, 
            out.m06 = b.m06 * scale + a.m06, out.m07 = b.m07 * scale + a.m07, out.m08 = b.m08 * scale + a.m08, 
            out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1, Math.abs(a.m08), Math.abs(b.m08));
        }
    } ]), _createClass(Mat3, [ {
        key: "clone",
        value: function clone() {
            var t = this;
            return new Mat3(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08);
        }
    }, {
        key: "set",
        value: function set() {
            var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
            return "object" === _typeof(m00) ? (this.m00 = m00.m00, this.m01 = m00.m01, this.m02 = m00.m02, 
            this.m03 = m00.m03, this.m04 = m00.m04, this.m05 = m00.m05, this.m06 = m00.m06, 
            this.m07 = m00.m07, this.m08 = m00.m08) : (this.m00 = m00, this.m01 = m01, this.m02 = m02, 
            this.m03 = m03, this.m04 = m04, this.m05 = m05, this.m06 = m06, this.m07 = m07, 
            this.m08 = m08), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1, Math.abs(this.m08), Math.abs(other.m08));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08;
        }
    }, {
        key: "toString",
        value: function toString() {
            var t = this;
            return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ",\n" + t.m03 + ",\n" + t.m04 + ", " + t.m05 + ",\n" + t.m06 + ", " + t.m07 + ",\n" + t.m08 + "\n]";
        }
    }, {
        key: "identity",
        value: function identity() {
            return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 1, this.m05 = 0, 
            this.m06 = 0, this.m07 = 0, this.m08 = 1, this;
        }
    }, {
        key: "transpose",
        value: function transpose() {
            var a01 = this.m01, a02 = this.m02, a12 = this.m05;
            return this.m01 = this.m03, this.m02 = this.m06, this.m03 = a01, this.m05 = this.m07, 
            this.m06 = a02, this.m07 = a12, this;
        }
    }, {
        key: "invert",
        value: function invert() {
            var a00 = this.m00, a01 = this.m01, a02 = this.m02, a10 = this.m03, a11 = this.m04, a12 = this.m05, a20 = this.m06, a21 = this.m07, a22 = this.m08, b01 = a22 * a11 - a12 * a21, b11 = -a22 * a10 + a12 * a20, b21 = a21 * a10 - a11 * a20, det = a00 * b01 + a01 * b11 + a02 * b21;
            return 0 === det ? (this.set(0, 0, 0, 0, 0, 0, 0, 0, 0), this) : (det = 1 / det, 
            this.m00 = b01 * det, this.m01 = (-a22 * a01 + a02 * a21) * det, this.m02 = (a12 * a01 - a02 * a11) * det, 
            this.m03 = b11 * det, this.m04 = (a22 * a00 - a02 * a20) * det, this.m05 = (-a12 * a00 + a02 * a10) * det, 
            this.m06 = b21 * det, this.m07 = (-a21 * a00 + a01 * a20) * det, this.m08 = (a11 * a00 - a01 * a10) * det, 
            this);
        }
    }, {
        key: "determinant",
        value: function determinant() {
            var a00 = this.m00, a01 = this.m01, a02 = this.m02, a10 = this.m03, a11 = this.m04, a12 = this.m05, a20 = this.m06, a21 = this.m07, a22 = this.m08;
            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
    }, {
        key: "add",
        value: function add(mat) {
            return this.m00 = this.m00 + mat.m00, this.m01 = this.m01 + mat.m01, this.m02 = this.m02 + mat.m02, 
            this.m03 = this.m03 + mat.m03, this.m04 = this.m04 + mat.m04, this.m05 = this.m05 + mat.m05, 
            this.m06 = this.m06 + mat.m06, this.m07 = this.m07 + mat.m07, this.m08 = this.m08 + mat.m08, 
            this;
        }
    }, {
        key: "subtract",
        value: function subtract(mat) {
            return this.m00 = this.m00 - mat.m00, this.m01 = this.m01 - mat.m01, this.m02 = this.m02 - mat.m02, 
            this.m03 = this.m03 - mat.m03, this.m04 = this.m04 - mat.m04, this.m05 = this.m05 - mat.m05, 
            this.m06 = this.m06 - mat.m06, this.m07 = this.m07 - mat.m07, this.m08 = this.m08 - mat.m08, 
            this;
        }
    }, {
        key: "multiply",
        value: function multiply(mat) {
            var a00 = this.m00, a01 = this.m01, a02 = this.m02, a10 = this.m03, a11 = this.m04, a12 = this.m05, a20 = this.m06, a21 = this.m07, a22 = this.m08, b00 = mat.m00, b01 = mat.m01, b02 = mat.m02, b10 = mat.m03, b11 = mat.m04, b12 = mat.m05, b20 = mat.m06, b21 = mat.m07, b22 = mat.m08;
            return this.m00 = b00 * a00 + b01 * a10 + b02 * a20, this.m01 = b00 * a01 + b01 * a11 + b02 * a21, 
            this.m02 = b00 * a02 + b01 * a12 + b02 * a22, this.m03 = b10 * a00 + b11 * a10 + b12 * a20, 
            this.m04 = b10 * a01 + b11 * a11 + b12 * a21, this.m05 = b10 * a02 + b11 * a12 + b12 * a22, 
            this.m06 = b20 * a00 + b21 * a10 + b22 * a20, this.m07 = b20 * a01 + b21 * a11 + b22 * a21, 
            this.m08 = b20 * a02 + b21 * a12 + b22 * a22, this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return this.m00 = this.m00 * scalar, this.m01 = this.m01 * scalar, this.m02 = this.m02 * scalar, 
            this.m03 = this.m03 * scalar, this.m04 = this.m04 * scalar, this.m05 = this.m05 * scalar, 
            this.m06 = this.m06 * scalar, this.m07 = this.m07 * scalar, this.m08 = this.m08 * scalar, 
            this;
        }
    }, {
        key: "scale",
        value: function scale(vec) {
            var x = vec.x, y = vec.y;
            return this.m00 = x * this.m00, this.m01 = x * this.m01, this.m02 = x * this.m02, 
            this.m03 = y * this.m03, this.m04 = y * this.m04, this.m05 = y * this.m05, this.m06 = this.m06, 
            this.m07 = this.m07, this.m08 = this.m08, this;
        }
    }, {
        key: "rotate",
        value: function rotate(rad) {
            var a00 = this.m00, a01 = this.m01, a02 = this.m02, a10 = this.m03, a11 = this.m04, a12 = this.m05, a20 = this.m06, a21 = this.m07, a22 = this.m08, s = Math.sin(rad), c = Math.cos(rad);
            return this.m00 = c * a00 + s * a10, this.m01 = c * a01 + s * a11, this.m02 = c * a02 + s * a12, 
            this.m03 = c * a10 - s * a00, this.m04 = c * a11 - s * a01, this.m05 = c * a12 - s * a02, 
            this.m06 = a20, this.m07 = a21, this.m08 = a22, this;
        }
    }, {
        key: "fromQuat",
        value: function fromQuat(q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return this.m00 = 1 - yy - zz, this.m03 = yx - wz, this.m06 = zx + wy, this.m01 = yx + wz, 
            this.m04 = 1 - xx - zz, this.m07 = zy - wx, this.m02 = zx - wy, this.m05 = zy + wx, 
            this.m08 = 1 - xx - yy, this;
        }
    } ]), Mat3;
}();

Mat3.IDENTITY = Object.freeze(new Mat3);

var v3_1$1 = new Vec3, v3_2$1 = new Vec3;

CCClass.fastDefine("cc.Mat3", Mat3, {
    m00: 1,
    m01: 0,
    m02: 0,
    m03: 0,
    m04: 1,
    m05: 0,
    m06: 0,
    m07: 0,
    m08: 1
}), cc.Mat3 = Mat3;

var Quat = function(_ValueType) {
    function Quat(x, y, z, w) {
        var _this;
        return _classCallCheck(this, Quat), _this = _possibleConstructorReturn(this, _getPrototypeOf(Quat).call(this)), 
        x && "object" === _typeof(x) ? (_this.x = x.x, _this.y = x.y, _this.z = x.z, _this.w = x.w) : (_this.x = x || 0, 
        _this.y = y || 0, _this.z = z || 0, _this.w = null != w ? w : 1), _this;
    }
    return _inherits(Quat, ValueType), _createClass(Quat, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Quat(a.x, a.y, a.z, a.w);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.x = a.x, out.y = a.y, out.z = a.z, out.w = a.w, out;
        }
    }, {
        key: "set",
        value: function set(out, x, y, z, w) {
            return out.x = x, out.y = y, out.z = z, out.w = w, out;
        }
    }, {
        key: "identity",
        value: function identity(out) {
            return out.x = 0, out.y = 0, out.z = 0, out.w = 1, out;
        }
    }, {
        key: "rotationTo",
        value: function rotationTo(out, a, b) {
            var dot = Vec3.dot(a, b);
            return dot < -.999999 ? (Vec3.cross(v3_1$2, Vec3.UNIT_X, a), v3_1$2.length() < 1e-6 && Vec3.cross(v3_1$2, Vec3.UNIT_Y, a), 
            Vec3.normalize(v3_1$2, v3_1$2), Quat.fromAxisAngle(out, v3_1$2, Math.PI), out) : dot > .999999 ? (out.x = 0, 
            out.y = 0, out.z = 0, out.w = 1, out) : (Vec3.cross(v3_1$2, a, b), out.x = v3_1$2.x, 
            out.y = v3_1$2.y, out.z = v3_1$2.z, out.w = 1 + dot, Quat.normalize(out, out));
        }
    }, {
        key: "getAxisAngle",
        value: function getAxisAngle(outAxis, q) {
            var rad = 2 * Math.acos(q.w), s = Math.sin(rad / 2);
            return 0 !== s ? (outAxis.x = q.x / s, outAxis.y = q.y / s, outAxis.z = q.z / s) : (outAxis.x = 1, 
            outAxis.y = 0, outAxis.z = 0), rad;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            var x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y, y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z, z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x, w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
            return out.x = x, out.y = y, out.z = z, out.w = w, out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.x = a.x * b, out.y = a.y * b, out.z = a.z * b, out.w = a.w * b, out;
        }
    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, a, b, scale) {
            return out.x = a.x + b.x * scale, out.y = a.y + b.y * scale, out.z = a.z + b.z * scale, 
            out.w = a.w + b.w * scale, out;
        }
    }, {
        key: "rotateX",
        value: function rotateX(out, a, rad) {
            rad *= .5;
            var bx = Math.sin(rad), bw = Math.cos(rad), x = a.x, y = a.y, z = a.z, w = a.w;
            return out.x = x * bw + w * bx, out.y = y * bw + z * bx, out.z = z * bw - y * bx, 
            out.w = w * bw - x * bx, out;
        }
    }, {
        key: "rotateY",
        value: function rotateY(out, a, rad) {
            rad *= .5;
            var by = Math.sin(rad), bw = Math.cos(rad), x = a.x, y = a.y, z = a.z, w = a.w;
            return out.x = x * bw - z * by, out.y = y * bw + w * by, out.z = z * bw + x * by, 
            out.w = w * bw - y * by, out;
        }
    }, {
        key: "rotateZ",
        value: function rotateZ(out, a, rad) {
            rad *= .5;
            var bz = Math.sin(rad), bw = Math.cos(rad), x = a.x, y = a.y, z = a.z, w = a.w;
            return out.x = x * bw + y * bz, out.y = y * bw - x * bz, out.z = z * bw + w * bz, 
            out.w = w * bw - z * bz, out;
        }
    }, {
        key: "rotateAround",
        value: function rotateAround(out, rot, axis, rad) {
            return Quat.invert(qt_1, rot), Vec3.transformQuat(v3_1$2, axis, qt_1), Quat.fromAxisAngle(qt_1, v3_1$2, rad), 
            Quat.multiply(out, rot, qt_1), out;
        }
    }, {
        key: "rotateAroundLocal",
        value: function rotateAroundLocal(out, rot, axis, rad) {
            return Quat.fromAxisAngle(qt_1, axis, rad), Quat.multiply(out, rot, qt_1), out;
        }
    }, {
        key: "calculateW",
        value: function calculateW(out, a) {
            return out.x = a.x, out.y = a.y, out.z = a.z, out.w = Math.sqrt(Math.abs(1 - a.x * a.x - a.y * a.y - a.z * a.z)), 
            out;
        }
    }, {
        key: "dot",
        value: function dot(a, b) {
            return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        }
    }, {
        key: "lerp",
        value: function lerp(out, a, b, t) {
            return out.x = a.x + t * (b.x - a.x), out.y = a.y + t * (b.y - a.y), out.z = a.z + t * (b.z - a.z), 
            out.w = a.w + t * (b.w - a.w), out;
        }
    }, {
        key: "slerp",
        value: function slerp(out, a, b, t) {
            var scale0 = 0, scale1 = 0, bx = b.x, by = b.y, bz = b.z, bw = b.w, cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
            if (cosom < 0 && (cosom = -cosom, bx = -bx, by = -by, bz = -bz, bw = -bw), 1 - cosom > 1e-6) {
                var omega = Math.acos(cosom), sinom = Math.sin(omega);
                scale0 = Math.sin((1 - t) * omega) / sinom, scale1 = Math.sin(t * omega) / sinom;
            } else scale0 = 1 - t, scale1 = t;
            return out.x = scale0 * a.x + scale1 * bx, out.y = scale0 * a.y + scale1 * by, out.z = scale0 * a.z + scale1 * bz, 
            out.w = scale0 * a.w + scale1 * bw, out;
        }
    }, {
        key: "sqlerp",
        value: function sqlerp(out, a, b, c, d, t) {
            return Quat.slerp(qt_1, a, d, t), Quat.slerp(qt_2, b, c, t), Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t)), 
            out;
        }
    }, {
        key: "invert",
        value: function invert(out, a) {
            var dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w, invDot = dot ? 1 / dot : 0;
            return out.x = -a.x * invDot, out.y = -a.y * invDot, out.z = -a.z * invDot, out.w = a.w * invDot, 
            out;
        }
    }, {
        key: "conjugate",
        value: function conjugate(out, a) {
            return out.x = -a.x, out.y = -a.y, out.z = -a.z, out.w = a.w, out;
        }
    }, {
        key: "len",
        value: function len(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr(a) {
            return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            var len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
            return len > 0 && (len = 1 / Math.sqrt(len), out.x = a.x * len, out.y = a.y * len, 
            out.z = a.z * len, out.w = a.w * len), out;
        }
    }, {
        key: "fromAxes",
        value: function fromAxes(out, xAxis, yAxis, zAxis) {
            return Mat3.set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z), 
            Quat.normalize(out, Quat.fromMat3(out, m3_1));
        }
    }, {
        key: "fromViewUp",
        value: function fromViewUp(out, view, up) {
            return Mat3.fromViewUp(m3_1, view, up), Quat.normalize(out, Quat.fromMat3(out, m3_1));
        }
    }, {
        key: "fromAxisAngle",
        value: function fromAxisAngle(out, axis, rad) {
            rad *= .5;
            var s = Math.sin(rad);
            return out.x = s * axis.x, out.y = s * axis.y, out.z = s * axis.z, out.w = Math.cos(rad), 
            out;
        }
    }, {
        key: "fromMat3",
        value: function fromMat3(out, m) {
            var m00 = m.m00, m01 = m.m03, m02 = m.m06, m10 = m.m01, m11 = m.m04, m12 = m.m07, m20 = m.m02, m21 = m.m05, m22 = m.m08, trace = m00 + m11 + m22;
            if (trace > 0) {
                var s = .5 / Math.sqrt(trace + 1);
                out.w = .25 / s, out.x = (m21 - m12) * s, out.y = (m02 - m20) * s, out.z = (m10 - m01) * s;
            } else if (m00 > m11 && m00 > m22) {
                var _s = 2 * Math.sqrt(1 + m00 - m11 - m22);
                out.w = (m21 - m12) / _s, out.x = .25 * _s, out.y = (m01 + m10) / _s, out.z = (m02 + m20) / _s;
            } else if (m11 > m22) {
                var _s2 = 2 * Math.sqrt(1 + m11 - m00 - m22);
                out.w = (m02 - m20) / _s2, out.x = (m01 + m10) / _s2, out.y = .25 * _s2, out.z = (m12 + m21) / _s2;
            } else {
                var _s3 = 2 * Math.sqrt(1 + m22 - m00 - m11);
                out.w = (m10 - m01) / _s3, out.x = (m02 + m20) / _s3, out.y = (m12 + m21) / _s3, 
                out.z = .25 * _s3;
            }
            return out;
        }
    }, {
        key: "fromEuler",
        value: function fromEuler(out, x, y, z) {
            x *= halfToRad, y *= halfToRad, z *= halfToRad;
            var sx = Math.sin(x), cx = Math.cos(x), sy = Math.sin(y), cy = Math.cos(y), sz = Math.sin(z), cz = Math.cos(z);
            return out.x = sx * cy * cz + cx * sy * sz, out.y = cx * sy * cz + sx * cy * sz, 
            out.z = cx * cy * sz - sx * sy * cz, out.w = cx * cy * cz - sx * sy * sz, out;
        }
    }, {
        key: "toAxisX",
        value: function toAxisX(out, q) {
            var fy = 2 * q.y, fz = 2 * q.z;
            return out.x = 1 - fy * q.y - fz * q.z, out.y = fy * q.x + fz * q.w, out.z = fz * q.x + fy * q.w, 
            out;
        }
    }, {
        key: "toAxisY",
        value: function toAxisY(out, q) {
            var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
            return out.x = fy * q.x - fz * q.w, out.y = 1 - fx * q.x - fz * q.z, out.z = fz * q.y + fx * q.w, 
            out;
        }
    }, {
        key: "toAxisZ",
        value: function toAxisZ(out, q) {
            var fx = 2 * q.x, fy = 2 * q.y, fz = 2 * q.z;
            return out.x = fz * q.x - fy * q.w, out.y = fz * q.y - fx * q.w, out.z = 1 - fx * q.x - fy * q.y, 
            out;
        }
    }, {
        key: "toEuler",
        value: function toEuler(out, q, outerZ) {
            var x = q.x, y = q.y, z = q.z, w = q.w, bank = 0, heading = 0, attitude = 0, test = x * y + z * w;
            if (test > .499999) bank = 0, heading = toDegree(2 * Math.atan2(x, w)), attitude = 90; else if (test < -.499999) bank = 0, 
            heading = -toDegree(2 * Math.atan2(x, w)), attitude = -90; else {
                var sqx = x * x, sqy = y * y, sqz = z * z;
                bank = toDegree(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz)), heading = toDegree(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz)), 
                attitude = toDegree(Math.asin(2 * test)), outerZ && (bank = -180 * Math.sign(bank + 1e-6) + bank, 
                heading = -180 * Math.sign(heading + 1e-6) + heading, attitude = 180 * Math.sign(attitude + 1e-6) - attitude);
            }
            return out.x = bank, out.y = heading, out.z = attitude, out;
        }
    }, {
        key: "toArray",
        value: function toArray(out, q) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = q.x, out[ofs + 1] = q.y, out[ofs + 2] = q.z, out[ofs + 3] = q.w, 
            out;
        }
    }, {
        key: "fromArray",
        value: function fromArray(out, arr) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out.x = arr[ofs + 0], out.y = arr[ofs + 1], out.z = arr[ofs + 2], out.w = arr[ofs + 3], 
            out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
        }
    } ]), _createClass(Quat, [ {
        key: "clone",
        value: function clone() {
            return new Quat(this.x, this.y, this.z, this.w);
        }
    }, {
        key: "set",
        value: function set(x, y, z, w) {
            return x && "object" === _typeof(x) ? (this.x = x.x, this.y = x.y, this.z = x.z, 
            this.w = x.w) : (this.x = x || 0, this.y = y || 0, this.z = z || 0, this.w = w || 1), 
            this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
        }
    }, {
        key: "getEulerAngles",
        value: function getEulerAngles(out) {
            return Quat.toEuler(out, this);
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return this.x = this.x + ratio * (to.x - this.x), this.y = this.y + ratio * (to.y - this.y), 
            this.z = this.z + ratio * (to.z - this.z), this.w = this.w + ratio * (to.w - this.w), 
            this;
        }
    }, {
        key: "slerp",
        value: function slerp(to, ratio) {
            return Quat.slerp(this, this, to, ratio);
        }
    }, {
        key: "length",
        value: function length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
    }, {
        key: "lengthSqr",
        value: function lengthSqr() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
    } ]), Quat;
}();

Quat.IDENTITY = Object.freeze(new Quat);

var qt_1 = new Quat, qt_2 = new Quat, v3_1$2 = new Vec3, m3_1 = new Mat3, halfToRad = .5 * Math.PI / 180;

function quat() {
    var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, w = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
    return new Quat(x, y, z, w);
}

CCClass.fastDefine("cc.Quat", Quat, {
    x: 0,
    y: 0,
    z: 0,
    w: 1
}), cc.Quat = Quat, cc.quat = quat;

var Mat4 = function(_ValueType) {
    function Mat4() {
        var _this, m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, m09 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, m10 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, m11 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, m12 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, m13 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, m14 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0, m15 = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1;
        return _classCallCheck(this, Mat4), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mat4).call(this))).m00 = void 0, 
        _this.m01 = void 0, _this.m02 = void 0, _this.m03 = void 0, _this.m04 = void 0, 
        _this.m05 = void 0, _this.m06 = void 0, _this.m07 = void 0, _this.m08 = void 0, 
        _this.m09 = void 0, _this.m10 = void 0, _this.m11 = void 0, _this.m12 = void 0, 
        _this.m13 = void 0, _this.m14 = void 0, _this.m15 = void 0, "object" === _typeof(m00) ? (_this.m00 = m00.m00, 
        _this.m01 = m00.m01, _this.m02 = m00.m02, _this.m03 = m00.m03, _this.m04 = m00.m04, 
        _this.m05 = m00.m05, _this.m06 = m00.m06, _this.m07 = m00.m07, _this.m08 = m00.m08, 
        _this.m09 = m00.m09, _this.m10 = m00.m10, _this.m11 = m00.m11, _this.m12 = m00.m12, 
        _this.m13 = m00.m13, _this.m14 = m00.m14, _this.m15 = m00.m15) : (_this.m00 = m00, 
        _this.m01 = m01, _this.m02 = m02, _this.m03 = m03, _this.m04 = m04, _this.m05 = m05, 
        _this.m06 = m06, _this.m07 = m07, _this.m08 = m08, _this.m09 = m09, _this.m10 = m10, 
        _this.m11 = m11, _this.m12 = m12, _this.m13 = m13, _this.m14 = m14, _this.m15 = m15), 
        _this;
    }
    return _inherits(Mat4, ValueType), _createClass(Mat4, null, [ {
        key: "clone",
        value: function clone(a) {
            return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, out.m04 = a.m04, 
            out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, out.m09 = a.m09, 
            out.m10 = a.m10, out.m11 = a.m11, out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, 
            out.m15 = a.m15, out;
        }
    }, {
        key: "set",
        value: function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
            return out.m00 = m00, out.m01 = m01, out.m02 = m02, out.m03 = m03, out.m04 = m10, 
            out.m05 = m11, out.m06 = m12, out.m07 = m13, out.m08 = m20, out.m09 = m21, out.m10 = m22, 
            out.m11 = m23, out.m12 = m30, out.m13 = m31, out.m14 = m32, out.m15 = m33, out;
        }
    }, {
        key: "identity",
        value: function identity(out) {
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
            out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "transpose",
        value: function transpose(out, a) {
            if (out === a) {
                var a01 = a.m01, a02 = a.m02, a03 = a.m03, a12 = a.m06, a13 = a.m07, a23 = a.m11;
                out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a01, out.m06 = a.m09, 
                out.m07 = a.m13, out.m08 = a02, out.m09 = a12, out.m11 = a.m14, out.m12 = a03, out.m13 = a13, 
                out.m14 = a23;
            } else out.m00 = a.m00, out.m01 = a.m04, out.m02 = a.m08, out.m03 = a.m12, out.m04 = a.m01, 
            out.m05 = a.m05, out.m06 = a.m09, out.m07 = a.m13, out.m08 = a.m02, out.m09 = a.m06, 
            out.m10 = a.m10, out.m11 = a.m14, out.m12 = a.m03, out.m13 = a.m07, out.m14 = a.m11, 
            out.m15 = a.m15;
            return out;
        }
    }, {
        key: "invert",
        value: function invert(out, a) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            return 0 === det ? (out.m00 = 0, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
            out.m05 = 0, out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 0, out.m11 = 0, 
            out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 0, out) : (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
            out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
            out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det, out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det, 
            out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det, out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det, 
            out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det, out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
            out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
            out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det, out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det, 
            out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det, out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det, 
            out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det, out);
        }
    }, {
        key: "determinant",
        value: function determinant(a) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
            return (a00 * a11 - a01 * a10) * (a22 * a33 - a23 * a32) - (a00 * a12 - a02 * a10) * (a21 * a33 - a23 * a31) + (a00 * a13 - a03 * a10) * (a21 * a32 - a22 * a31) + (a01 * a12 - a02 * a11) * (a20 * a33 - a23 * a30) - (a01 * a13 - a03 * a11) * (a20 * a32 - a22 * a30) + (a02 * a13 - a03 * a12) * (a20 * a31 - a21 * a30);
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
            return out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
            out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
            b0 = b.m04, b1 = b.m05, b2 = b.m06, b3 = b.m07, out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
            out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
            out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b.m08, b1 = b.m09, b2 = b.m10, 
            b3 = b.m11, out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
            out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
            b0 = b.m12, b1 = b.m13, b2 = b.m14, b3 = b.m15, out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
            out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
            out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
        }
    }, {
        key: "transform",
        value: function transform(out, a, v) {
            var x = v.x, y = v.y, z = v.z;
            if (a === out) out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12, out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13, 
            out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14, out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15; else {
                var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
                a.m12, a.m13, a.m14, a.m15;
                out.m00 = a00, out.m01 = a01, out.m02 = a02, out.m03 = a03, out.m04 = a10, out.m05 = a11, 
                out.m06 = a12, out.m07 = a13, out.m08 = a20, out.m09 = a21, out.m10 = a22, out.m11 = a23, 
                out.m12 = a00 * x + a10 * y + a20 * z + a.m12, out.m13 = a01 * x + a11 * y + a21 * z + a.m13, 
                out.m14 = a02 * x + a12 * y + a22 * z + a.m14, out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
            }
            return out;
        }
    }, {
        key: "translate",
        value: function translate(out, a, v) {
            return console.warn("function changed"), a === out ? (out.m12 += v.x, out.m13 += v.y, 
            out.m14 += v.z) : (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
            out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, out.m08 = a.m08, 
            out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, out.m12 += v.x, out.m13 += v.y, 
            out.m14 += v.z, out.m15 = a.m15), out;
        }
    }, {
        key: "scale",
        value: function scale(out, a, v) {
            var x = v.x, y = v.y, z = v.z;
            return out.m00 = a.m00 * x, out.m01 = a.m01 * x, out.m02 = a.m02 * x, out.m03 = a.m03 * x, 
            out.m04 = a.m04 * y, out.m05 = a.m05 * y, out.m06 = a.m06 * y, out.m07 = a.m07 * y, 
            out.m08 = a.m08 * z, out.m09 = a.m09 * z, out.m10 = a.m10 * z, out.m11 = a.m11 * z, 
            out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15, out;
        }
    }, {
        key: "rotate",
        value: function rotate(out, a, rad, axis) {
            var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
            if (Math.abs(len) < EPSILON) return null;
            x *= len = 1 / len, y *= len, z *= len;
            var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c, a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            return out.m00 = a00 * b00 + a10 * b01 + a20 * b02, out.m01 = a01 * b00 + a11 * b01 + a21 * b02, 
            out.m02 = a02 * b00 + a12 * b01 + a22 * b02, out.m03 = a03 * b00 + a13 * b01 + a23 * b02, 
            out.m04 = a00 * b10 + a10 * b11 + a20 * b12, out.m05 = a01 * b10 + a11 * b11 + a21 * b12, 
            out.m06 = a02 * b10 + a12 * b11 + a22 * b12, out.m07 = a03 * b10 + a13 * b11 + a23 * b12, 
            out.m08 = a00 * b20 + a10 * b21 + a20 * b22, out.m09 = a01 * b20 + a11 * b21 + a21 * b22, 
            out.m10 = a02 * b20 + a12 * b21 + a22 * b22, out.m11 = a03 * b20 + a13 * b21 + a23 * b22, 
            a !== out && (out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), 
            out;
        }
    }, {
        key: "rotateX",
        value: function rotateX(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
            return a !== out && (out.m00 = a.m00, out.m01 = a.m01, out.m02 = a.m02, out.m03 = a.m03, 
            out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m04 = a10 * c + a20 * s, 
            out.m05 = a11 * c + a21 * s, out.m06 = a12 * c + a22 * s, out.m07 = a13 * c + a23 * s, 
            out.m08 = a20 * c - a10 * s, out.m09 = a21 * c - a11 * s, out.m10 = a22 * c - a12 * s, 
            out.m11 = a23 * c - a13 * s, out;
        }
    }, {
        key: "rotateY",
        value: function rotateY(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
            return a !== out && (out.m04 = a.m04, out.m05 = a.m05, out.m06 = a.m06, out.m07 = a.m07, 
            out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c - a20 * s, 
            out.m01 = a01 * c - a21 * s, out.m02 = a02 * c - a22 * s, out.m03 = a03 * c - a23 * s, 
            out.m08 = a00 * s + a20 * c, out.m09 = a01 * s + a21 * c, out.m10 = a02 * s + a22 * c, 
            out.m11 = a03 * s + a23 * c, out;
        }
    }, {
        key: "rotateZ",
        value: function rotateZ(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07;
            return a !== out && (out.m08 = a.m08, out.m09 = a.m09, out.m10 = a.m10, out.m11 = a.m11, 
            out.m12 = a.m12, out.m13 = a.m13, out.m14 = a.m14, out.m15 = a.m15), out.m00 = a00 * c + a10 * s, 
            out.m01 = a01 * c + a11 * s, out.m02 = a02 * c + a12 * s, out.m03 = a03 * c + a13 * s, 
            out.m04 = a10 * c - a00 * s, out.m05 = a11 * c - a01 * s, out.m06 = a12 * c - a02 * s, 
            out.m07 = a13 * c - a03 * s, out;
        }
    }, {
        key: "fromTranslation",
        value: function fromTranslation(out, v) {
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = v.x, 
            out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
        }
    }, {
        key: "fromScaling",
        value: function fromScaling(out, v) {
            return out.m00 = v.x, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = v.y, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = v.z, out.m11 = 0, 
            out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromRotation",
        value: function fromRotation(out, rad, axis) {
            var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
            if (Math.abs(len) < EPSILON) return null;
            x *= len = 1 / len, y *= len, z *= len;
            var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c;
            return out.m00 = x * x * t + c, out.m01 = y * x * t + z * s, out.m02 = z * x * t - y * s, 
            out.m03 = 0, out.m04 = x * y * t - z * s, out.m05 = y * y * t + c, out.m06 = z * y * t + x * s, 
            out.m07 = 0, out.m08 = x * z * t + y * s, out.m09 = y * z * t - x * s, out.m10 = z * z * t + c, 
            out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromXRotation",
        value: function fromXRotation(out, rad) {
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = 1, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = c, 
            out.m06 = s, out.m07 = 0, out.m08 = 0, out.m09 = -s, out.m10 = c, out.m11 = 0, out.m12 = 0, 
            out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromYRotation",
        value: function fromYRotation(out, rad) {
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = c, out.m01 = 0, out.m02 = -s, out.m03 = 0, out.m04 = 0, out.m05 = 1, 
            out.m06 = 0, out.m07 = 0, out.m08 = s, out.m09 = 0, out.m10 = c, out.m11 = 0, out.m12 = 0, 
            out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromZRotation",
        value: function fromZRotation(out, rad) {
            var s = Math.sin(rad), c = Math.cos(rad);
            return out.m00 = c, out.m01 = s, out.m02 = 0, out.m03 = 0, out.m04 = -s, out.m05 = c, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 1, out.m11 = 0, out.m12 = 0, 
            out.m13 = 0, out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "fromRT",
        value: function fromRT(out, q, v) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return out.m00 = 1 - (yy + zz), out.m01 = xy + wz, out.m02 = xz - wy, out.m03 = 0, 
            out.m04 = xy - wz, out.m05 = 1 - (xx + zz), out.m06 = yz + wx, out.m07 = 0, out.m08 = xz + wy, 
            out.m09 = yz - wx, out.m10 = 1 - (xx + yy), out.m11 = 0, out.m12 = v.x, out.m13 = v.y, 
            out.m14 = v.z, out.m15 = 1, out;
        }
    }, {
        key: "getTranslation",
        value: function getTranslation(out, mat) {
            return out.x = mat.m12, out.y = mat.m13, out.z = mat.m14, out;
        }
    }, {
        key: "getScaling",
        value: function getScaling(out, mat) {
            var m00 = m3_1$1.m00 = mat.m00, m01 = m3_1$1.m01 = mat.m01, m02 = m3_1$1.m02 = mat.m02, m04 = m3_1$1.m03 = mat.m04, m05 = m3_1$1.m04 = mat.m05, m06 = m3_1$1.m05 = mat.m06, m08 = m3_1$1.m06 = mat.m08, m09 = m3_1$1.m07 = mat.m09, m10 = m3_1$1.m08 = mat.m10;
            return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
            out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), Mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
            out;
        }
    }, {
        key: "getRotation",
        value: function getRotation(out, mat) {
            var trace = mat.m00 + mat.m05 + mat.m10, S = 0;
            return trace > 0 ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (mat.m06 - mat.m09) / S, 
            out.y = (mat.m08 - mat.m02) / S, out.z = (mat.m01 - mat.m04) / S) : mat.m00 > mat.m05 && mat.m00 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m00 - mat.m05 - mat.m10), 
            out.w = (mat.m06 - mat.m09) / S, out.x = .25 * S, out.y = (mat.m01 + mat.m04) / S, 
            out.z = (mat.m08 + mat.m02) / S) : mat.m05 > mat.m10 ? (S = 2 * Math.sqrt(1 + mat.m05 - mat.m00 - mat.m10), 
            out.w = (mat.m08 - mat.m02) / S, out.x = (mat.m01 + mat.m04) / S, out.y = .25 * S, 
            out.z = (mat.m06 + mat.m09) / S) : (S = 2 * Math.sqrt(1 + mat.m10 - mat.m00 - mat.m05), 
            out.w = (mat.m01 - mat.m04) / S, out.x = (mat.m08 + mat.m02) / S, out.y = (mat.m06 + mat.m09) / S, 
            out.z = .25 * S), out;
        }
    }, {
        key: "toRTS",
        value: function toRTS(m, q, v, s) {
            s.x = Vec3.set(v3_1$3, m.m00, m.m01, m.m02).length(), m3_1$1.m00 = m.m00 / s.x, 
            m3_1$1.m01 = m.m01 / s.x, m3_1$1.m02 = m.m02 / s.x, s.y = Vec3.set(v3_1$3, m.m04, m.m05, m.m06).length(), 
            m3_1$1.m03 = m.m04 / s.y, m3_1$1.m04 = m.m05 / s.y, m3_1$1.m05 = m.m06 / s.y, s.z = Vec3.set(v3_1$3, m.m08, m.m09, m.m10).length(), 
            m3_1$1.m06 = m.m08 / s.z, m3_1$1.m07 = m.m09 / s.z, m3_1$1.m08 = m.m10 / s.z, Mat3.determinant(m3_1$1) < 0 && (s.x *= -1, 
            m3_1$1.m00 *= -1, m3_1$1.m01 *= -1, m3_1$1.m02 *= -1), Quat.fromMat3(q, m3_1$1), 
            Vec3.set(v, m.m12, m.m13, m.m14);
        }
    }, {
        key: "fromRTS",
        value: function fromRTS(out, q, v, s) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
            return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
            out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
            out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
            out.m11 = 0, out.m12 = v.x, out.m13 = v.y, out.m14 = v.z, out.m15 = 1, out;
        }
    }, {
        key: "fromRTSOrigin",
        value: function fromRTSOrigin(out, q, v, s, o) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z, ox = o.x, oy = o.y, oz = o.z;
            return out.m00 = (1 - (yy + zz)) * sx, out.m01 = (xy + wz) * sx, out.m02 = (xz - wy) * sx, 
            out.m03 = 0, out.m04 = (xy - wz) * sy, out.m05 = (1 - (xx + zz)) * sy, out.m06 = (yz + wx) * sy, 
            out.m07 = 0, out.m08 = (xz + wy) * sz, out.m09 = (yz - wx) * sz, out.m10 = (1 - (xx + yy)) * sz, 
            out.m11 = 0, out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz), 
            out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz), out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz), 
            out.m15 = 1, out;
        }
    }, {
        key: "fromQuat",
        value: function fromQuat(out, q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return out.m00 = 1 - yy - zz, out.m01 = yx + wz, out.m02 = zx - wy, out.m03 = 0, 
            out.m04 = yx - wz, out.m05 = 1 - xx - zz, out.m06 = zy + wx, out.m07 = 0, out.m08 = zx + wy, 
            out.m09 = zy - wx, out.m10 = 1 - xx - yy, out.m11 = 0, out.m12 = 0, out.m13 = 0, 
            out.m14 = 0, out.m15 = 1, out;
        }
    }, {
        key: "frustum",
        value: function frustum(out, left, right, bottom, top, near, far) {
            var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
            return out.m00 = 2 * near * rl, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, 
            out.m05 = 2 * near * tb, out.m06 = 0, out.m07 = 0, out.m08 = (right + left) * rl, 
            out.m09 = (top + bottom) * tb, out.m10 = (far + near) * nf, out.m11 = -1, out.m12 = 0, 
            out.m13 = 0, out.m14 = far * near * 2 * nf, out.m15 = 0, out;
        }
    }, {
        key: "perspective",
        value: function perspective(out, fov, aspect, near, far) {
            var isFOVY = !(arguments.length > 5 && void 0 !== arguments[5]) || arguments[5], f = 1 / Math.tan(fov / 2), nf = 1 / (near - far);
            return out.m00 = isFOVY ? f / aspect : f, out.m01 = 0, out.m02 = 0, out.m03 = 0, 
            out.m04 = 0, out.m05 = isFOVY ? f : f * aspect, out.m06 = 0, out.m07 = 0, out.m08 = 0, 
            out.m09 = 0, out.m10 = (far + near) * nf, out.m11 = -1, out.m12 = 0, out.m13 = 0, 
            out.m14 = 2 * far * near * nf, out.m15 = 0, out;
        }
    }, {
        key: "ortho",
        value: function ortho(out, left, right, bottom, top, near, far) {
            var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
            return out.m00 = -2 * lr, out.m01 = 0, out.m02 = 0, out.m03 = 0, out.m04 = 0, out.m05 = -2 * bt, 
            out.m06 = 0, out.m07 = 0, out.m08 = 0, out.m09 = 0, out.m10 = 2 * nf, out.m11 = 0, 
            out.m12 = (left + right) * lr, out.m13 = (top + bottom) * bt, out.m14 = (far + near) * nf, 
            out.m15 = 1, out;
        }
    }, {
        key: "lookAt",
        value: function lookAt(out, eye, center, up) {
            var eyex = eye.x, eyey = eye.y, eyez = eye.z, upx = up.x, upy = up.y, upz = up.z, z0 = eyex - center.x, z1 = eyey - center.y, z2 = eyez - center.z, len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2), x0 = upy * (z2 *= len) - upz * (z1 *= len), x1 = upz * (z0 *= len) - upx * z2, x2 = upx * z1 - upy * z0, y0 = z1 * (x2 *= len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2)) - z2 * (x1 *= len), y1 = z2 * (x0 *= len) - z0 * x2, y2 = z0 * x1 - z1 * x0;
            return out.m00 = x0, out.m01 = y0, out.m02 = z0, out.m03 = 0, out.m04 = x1, out.m05 = y1, 
            out.m06 = z1, out.m07 = 0, out.m08 = x2, out.m09 = y2, out.m10 = z2, out.m11 = 0, 
            out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez), out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez), 
            out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez), out.m15 = 1, out;
        }
    }, {
        key: "inverseTranspose",
        value: function inverseTranspose(out, a) {
            var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            return det ? (det = 1 / det, out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, 
            out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det, out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det, 
            out.m03 = 0, out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det, out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det, 
            out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det, out.m07 = 0, out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det, 
            out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det, out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det, 
            out.m11 = 0, out.m12 = 0, out.m13 = 0, out.m14 = 0, out.m15 = 1, out) : null;
        }
    }, {
        key: "toArray",
        value: function toArray(out, m) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out[ofs + 0] = m.m00, out[ofs + 1] = m.m01, out[ofs + 2] = m.m02, out[ofs + 3] = m.m03, 
            out[ofs + 4] = m.m04, out[ofs + 5] = m.m05, out[ofs + 6] = m.m06, out[ofs + 7] = m.m07, 
            out[ofs + 8] = m.m08, out[ofs + 9] = m.m09, out[ofs + 10] = m.m10, out[ofs + 11] = m.m11, 
            out[ofs + 12] = m.m12, out[ofs + 13] = m.m13, out[ofs + 14] = m.m14, out[ofs + 15] = m.m15, 
            out;
        }
    }, {
        key: "fromArray",
        value: function fromArray(out, arr) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out.m00 = arr[ofs + 0], out.m01 = arr[ofs + 1], out.m02 = arr[ofs + 2], out.m03 = arr[ofs + 3], 
            out.m04 = arr[ofs + 4], out.m05 = arr[ofs + 5], out.m06 = arr[ofs + 6], out.m07 = arr[ofs + 7], 
            out.m08 = arr[ofs + 8], out.m09 = arr[ofs + 9], out.m10 = arr[ofs + 10], out.m11 = arr[ofs + 11], 
            out.m12 = arr[ofs + 12], out.m13 = arr[ofs + 13], out.m14 = arr[ofs + 14], out.m15 = arr[ofs + 15], 
            out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.m00 = a.m00 + b.m00, out.m01 = a.m01 + b.m01, out.m02 = a.m02 + b.m02, 
            out.m03 = a.m03 + b.m03, out.m04 = a.m04 + b.m04, out.m05 = a.m05 + b.m05, out.m06 = a.m06 + b.m06, 
            out.m07 = a.m07 + b.m07, out.m08 = a.m08 + b.m08, out.m09 = a.m09 + b.m09, out.m10 = a.m10 + b.m10, 
            out.m11 = a.m11 + b.m11, out.m12 = a.m12 + b.m12, out.m13 = a.m13 + b.m13, out.m14 = a.m14 + b.m14, 
            out.m15 = a.m15 + b.m15, out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.m00 = a.m00 - b.m00, out.m01 = a.m01 - b.m01, out.m02 = a.m02 - b.m02, 
            out.m03 = a.m03 - b.m03, out.m04 = a.m04 - b.m04, out.m05 = a.m05 - b.m05, out.m06 = a.m06 - b.m06, 
            out.m07 = a.m07 - b.m07, out.m08 = a.m08 - b.m08, out.m09 = a.m09 - b.m09, out.m10 = a.m10 - b.m10, 
            out.m11 = a.m11 - b.m11, out.m12 = a.m12 - b.m12, out.m13 = a.m13 - b.m13, out.m14 = a.m14 - b.m14, 
            out.m15 = a.m15 - b.m15, out;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(out, a, b) {
            return out.m00 = a.m00 * b, out.m01 = a.m01 * b, out.m02 = a.m02 * b, out.m03 = a.m03 * b, 
            out.m04 = a.m04 * b, out.m05 = a.m05 * b, out.m06 = a.m06 * b, out.m07 = a.m07 * b, 
            out.m08 = a.m08 * b, out.m09 = a.m09 * b, out.m10 = a.m10 * b, out.m11 = a.m11 * b, 
            out.m12 = a.m12 * b, out.m13 = a.m13 * b, out.m14 = a.m14 * b, out.m15 = a.m15 * b, 
            out;
        }
    }, {
        key: "multiplyScalarAndAdd",
        value: function multiplyScalarAndAdd(out, a, b, scale) {
            return out.m00 = a.m00 + b.m00 * scale, out.m01 = a.m01 + b.m01 * scale, out.m02 = a.m02 + b.m02 * scale, 
            out.m03 = a.m03 + b.m03 * scale, out.m04 = a.m04 + b.m04 * scale, out.m05 = a.m05 + b.m05 * scale, 
            out.m06 = a.m06 + b.m06 * scale, out.m07 = a.m07 + b.m07 * scale, out.m08 = a.m08 + b.m08 * scale, 
            out.m09 = a.m09 + b.m09 * scale, out.m10 = a.m10 + b.m10 * scale, out.m11 = a.m11 + b.m11 * scale, 
            out.m12 = a.m12 + b.m12 * scale, out.m13 = a.m13 + b.m13 * scale, out.m14 = a.m14 + b.m14 * scale, 
            out.m15 = a.m15 + b.m15 * scale, out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.m00 - b.m00) <= epsilon * Math.max(1, Math.abs(a.m00), Math.abs(b.m00)) && Math.abs(a.m01 - b.m01) <= epsilon * Math.max(1, Math.abs(a.m01), Math.abs(b.m01)) && Math.abs(a.m02 - b.m02) <= epsilon * Math.max(1, Math.abs(a.m02), Math.abs(b.m02)) && Math.abs(a.m03 - b.m03) <= epsilon * Math.max(1, Math.abs(a.m03), Math.abs(b.m03)) && Math.abs(a.m04 - b.m04) <= epsilon * Math.max(1, Math.abs(a.m04), Math.abs(b.m04)) && Math.abs(a.m05 - b.m05) <= epsilon * Math.max(1, Math.abs(a.m05), Math.abs(b.m05)) && Math.abs(a.m06 - b.m06) <= epsilon * Math.max(1, Math.abs(a.m06), Math.abs(b.m06)) && Math.abs(a.m07 - b.m07) <= epsilon * Math.max(1, Math.abs(a.m07), Math.abs(b.m07)) && Math.abs(a.m08 - b.m08) <= epsilon * Math.max(1, Math.abs(a.m08), Math.abs(b.m08)) && Math.abs(a.m09 - b.m09) <= epsilon * Math.max(1, Math.abs(a.m09), Math.abs(b.m09)) && Math.abs(a.m10 - b.m10) <= epsilon * Math.max(1, Math.abs(a.m10), Math.abs(b.m10)) && Math.abs(a.m11 - b.m11) <= epsilon * Math.max(1, Math.abs(a.m11), Math.abs(b.m11)) && Math.abs(a.m12 - b.m12) <= epsilon * Math.max(1, Math.abs(a.m12), Math.abs(b.m12)) && Math.abs(a.m13 - b.m13) <= epsilon * Math.max(1, Math.abs(a.m13), Math.abs(b.m13)) && Math.abs(a.m14 - b.m14) <= epsilon * Math.max(1, Math.abs(a.m14), Math.abs(b.m14)) && Math.abs(a.m15 - b.m15) <= epsilon * Math.max(1, Math.abs(a.m15), Math.abs(b.m15));
        }
    } ]), _createClass(Mat4, [ {
        key: "clone",
        value: function clone() {
            var t = this;
            return new Mat4(t.m00, t.m01, t.m02, t.m03, t.m04, t.m05, t.m06, t.m07, t.m08, t.m09, t.m10, t.m11, t.m12, t.m13, t.m14, t.m15);
        }
    }, {
        key: "set",
        value: function set() {
            var m00 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, m01 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, m02 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, m03 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, m04 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, m05 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, m06 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, m07 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, m08 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, m09 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, m10 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, m11 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, m12 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, m13 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, m14 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0, m15 = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1;
            return "object" === _typeof(m00) ? (this.m01 = m00.m01, this.m02 = m00.m02, this.m03 = m00.m03, 
            this.m04 = m00.m04, this.m05 = m00.m05, this.m06 = m00.m06, this.m07 = m00.m07, 
            this.m08 = m00.m08, this.m09 = m00.m09, this.m10 = m00.m10, this.m11 = m00.m11, 
            this.m12 = m00.m12, this.m13 = m00.m13, this.m14 = m00.m14, this.m15 = m00.m15, 
            this.m00 = m00.m00) : (this.m01 = m01, this.m02 = m02, this.m03 = m03, this.m04 = m04, 
            this.m05 = m05, this.m06 = m06, this.m07 = m07, this.m08 = m08, this.m09 = m09, 
            this.m10 = m10, this.m11 = m11, this.m12 = m12, this.m13 = m13, this.m14 = m14, 
            this.m15 = m15, this.m00 = m00), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            var epsilon = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : EPSILON;
            return Math.abs(this.m00 - other.m00) <= epsilon * Math.max(1, Math.abs(this.m00), Math.abs(other.m00)) && Math.abs(this.m01 - other.m01) <= epsilon * Math.max(1, Math.abs(this.m01), Math.abs(other.m01)) && Math.abs(this.m02 - other.m02) <= epsilon * Math.max(1, Math.abs(this.m02), Math.abs(other.m02)) && Math.abs(this.m03 - other.m03) <= epsilon * Math.max(1, Math.abs(this.m03), Math.abs(other.m03)) && Math.abs(this.m04 - other.m04) <= epsilon * Math.max(1, Math.abs(this.m04), Math.abs(other.m04)) && Math.abs(this.m05 - other.m05) <= epsilon * Math.max(1, Math.abs(this.m05), Math.abs(other.m05)) && Math.abs(this.m06 - other.m06) <= epsilon * Math.max(1, Math.abs(this.m06), Math.abs(other.m06)) && Math.abs(this.m07 - other.m07) <= epsilon * Math.max(1, Math.abs(this.m07), Math.abs(other.m07)) && Math.abs(this.m08 - other.m08) <= epsilon * Math.max(1, Math.abs(this.m08), Math.abs(other.m08)) && Math.abs(this.m09 - other.m09) <= epsilon * Math.max(1, Math.abs(this.m09), Math.abs(other.m09)) && Math.abs(this.m10 - other.m10) <= epsilon * Math.max(1, Math.abs(this.m10), Math.abs(other.m10)) && Math.abs(this.m11 - other.m11) <= epsilon * Math.max(1, Math.abs(this.m11), Math.abs(other.m11)) && Math.abs(this.m12 - other.m12) <= epsilon * Math.max(1, Math.abs(this.m12), Math.abs(other.m12)) && Math.abs(this.m13 - other.m13) <= epsilon * Math.max(1, Math.abs(this.m13), Math.abs(other.m13)) && Math.abs(this.m14 - other.m14) <= epsilon * Math.max(1, Math.abs(this.m14), Math.abs(other.m14)) && Math.abs(this.m15 - other.m15) <= epsilon * Math.max(1, Math.abs(this.m15), Math.abs(other.m15));
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(other) {
            return this.m00 === other.m00 && this.m01 === other.m01 && this.m02 === other.m02 && this.m03 === other.m03 && this.m04 === other.m04 && this.m05 === other.m05 && this.m06 === other.m06 && this.m07 === other.m07 && this.m08 === other.m08 && this.m09 === other.m09 && this.m10 === other.m10 && this.m11 === other.m11 && this.m12 === other.m12 && this.m13 === other.m13 && this.m14 === other.m14 && this.m15 === other.m15;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "[\n" + this.m00 + ", " + this.m01 + ", " + this.m02 + ", " + this.m03 + ",\n" + this.m04 + ", " + this.m05 + ", " + this.m06 + ", " + this.m07 + ",\n" + this.m08 + ", " + this.m09 + ", " + this.m10 + ", " + this.m11 + ",\n" + this.m12 + ", " + this.m13 + ", " + this.m14 + ", " + this.m15 + "\n]";
        }
    }, {
        key: "identity",
        value: function identity() {
            return this.m00 = 1, this.m01 = 0, this.m02 = 0, this.m03 = 0, this.m04 = 0, this.m05 = 1, 
            this.m06 = 0, this.m07 = 0, this.m08 = 0, this.m09 = 0, this.m10 = 1, this.m11 = 0, 
            this.m12 = 0, this.m13 = 0, this.m14 = 0, this.m15 = 1, this;
        }
    }, {
        key: "transpose",
        value: function transpose() {
            var a01 = this.m01, a02 = this.m02, a03 = this.m03, a12 = this.m06, a13 = this.m07, a23 = this.m11;
            return this.m01 = this.m04, this.m02 = this.m08, this.m03 = this.m12, this.m04 = a01, 
            this.m06 = this.m09, this.m07 = this.m13, this.m08 = a02, this.m09 = a12, this.m11 = this.m14, 
            this.m12 = a03, this.m13 = a13, this.m14 = a23, this;
        }
    }, {
        key: "invert",
        value: function invert() {
            var a00 = this.m00, a01 = this.m01, a02 = this.m02, a03 = this.m03, a10 = this.m04, a11 = this.m05, a12 = this.m06, a13 = this.m07, a20 = this.m08, a21 = this.m09, a22 = this.m10, a23 = this.m11, a30 = this.m12, a31 = this.m13, a32 = this.m14, a33 = this.m15, b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            return 0 === det ? (this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), this) : (det = 1 / det, 
            this.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det, this.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det, 
            this.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det, this.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det, 
            this.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det, this.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det, 
            this.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det, this.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det, 
            this.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det, this.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det, 
            this.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det, this.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det, 
            this.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det, this.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det, 
            this.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det, this.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det, 
            this);
        }
    }, {
        key: "determinant",
        value: function determinant() {
            var a00 = this.m00, a01 = this.m01, a02 = this.m02, a03 = this.m03, a10 = this.m04, a11 = this.m05, a12 = this.m06, a13 = this.m07, a20 = this.m08, a21 = this.m09, a22 = this.m10, a23 = this.m11, a30 = this.m12, a31 = this.m13, a32 = this.m14, a33 = this.m15;
            return (a00 * a11 - a01 * a10) * (a22 * a33 - a23 * a32) - (a00 * a12 - a02 * a10) * (a21 * a33 - a23 * a31) + (a00 * a13 - a03 * a10) * (a21 * a32 - a22 * a31) + (a01 * a12 - a02 * a11) * (a20 * a33 - a23 * a30) - (a01 * a13 - a03 * a11) * (a20 * a32 - a22 * a30) + (a02 * a13 - a03 * a12) * (a20 * a31 - a21 * a30);
        }
    }, {
        key: "add",
        value: function add(mat) {
            return this.m00 = this.m00 + mat.m00, this.m01 = this.m01 + mat.m01, this.m02 = this.m02 + mat.m02, 
            this.m03 = this.m03 + mat.m03, this.m04 = this.m04 + mat.m04, this.m05 = this.m05 + mat.m05, 
            this.m06 = this.m06 + mat.m06, this.m07 = this.m07 + mat.m07, this.m08 = this.m08 + mat.m08, 
            this.m09 = this.m09 + mat.m09, this.m10 = this.m10 + mat.m10, this.m11 = this.m11 + mat.m11, 
            this.m12 = this.m12 + mat.m12, this.m13 = this.m13 + mat.m13, this.m14 = this.m14 + mat.m14, 
            this.m15 = this.m15 + mat.m15, this;
        }
    }, {
        key: "subtract",
        value: function subtract(mat) {
            return this.m00 = this.m00 - mat.m00, this.m01 = this.m01 - mat.m01, this.m02 = this.m02 - mat.m02, 
            this.m03 = this.m03 - mat.m03, this.m04 = this.m04 - mat.m04, this.m05 = this.m05 - mat.m05, 
            this.m06 = this.m06 - mat.m06, this.m07 = this.m07 - mat.m07, this.m08 = this.m08 - mat.m08, 
            this.m09 = this.m09 - mat.m09, this.m10 = this.m10 - mat.m10, this.m11 = this.m11 - mat.m11, 
            this.m12 = this.m12 - mat.m12, this.m13 = this.m13 - mat.m13, this.m14 = this.m14 - mat.m14, 
            this.m15 = this.m15 - mat.m15, this;
        }
    }, {
        key: "multiply",
        value: function multiply(mat) {
            var a00 = this.m00, a01 = this.m01, a02 = this.m02, a03 = this.m03, a10 = this.m04, a11 = this.m05, a12 = this.m06, a13 = this.m07, a20 = this.m08, a21 = this.m09, a22 = this.m10, a23 = this.m11, a30 = this.m12, a31 = this.m13, a32 = this.m14, a33 = this.m15, b0 = mat.m00, b1 = mat.m01, b2 = mat.m02, b3 = mat.m03;
            return this.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, this.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, 
            this.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, this.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, 
            b0 = mat.m04, b1 = mat.m05, b2 = mat.m06, b3 = mat.m07, this.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
            this.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, this.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
            this.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = mat.m08, b1 = mat.m09, 
            b2 = mat.m10, b3 = mat.m11, this.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
            this.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, this.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
            this.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = mat.m12, b1 = mat.m13, 
            b2 = mat.m14, b3 = mat.m15, this.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, 
            this.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, this.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, 
            this.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, this;
        }
    }, {
        key: "multiplyScalar",
        value: function multiplyScalar(scalar) {
            return this.m00 = this.m00 * scalar, this.m01 = this.m01 * scalar, this.m02 = this.m02 * scalar, 
            this.m03 = this.m03 * scalar, this.m04 = this.m04 * scalar, this.m05 = this.m05 * scalar, 
            this.m06 = this.m06 * scalar, this.m07 = this.m07 * scalar, this.m08 = this.m08 * scalar, 
            this.m09 = this.m09 * scalar, this.m10 = this.m10 * scalar, this.m11 = this.m11 * scalar, 
            this.m12 = this.m12 * scalar, this.m13 = this.m13 * scalar, this.m14 = this.m14 * scalar, 
            this.m15 = this.m15 * scalar, this;
        }
    }, {
        key: "translate",
        value: function translate(vec) {
            return console.warn("function changed"), this.m12 += vec.x, this.m13 += vec.y, this.m14 += vec.z, 
            this;
        }
    }, {
        key: "scale",
        value: function scale(vec) {
            var x = vec.x, y = vec.y, z = vec.z;
            return this.m00 = this.m00 * x, this.m01 = this.m01 * x, this.m02 = this.m02 * x, 
            this.m03 = this.m03 * x, this.m04 = this.m04 * y, this.m05 = this.m05 * y, this.m06 = this.m06 * y, 
            this.m07 = this.m07 * y, this.m08 = this.m08 * z, this.m09 = this.m09 * z, this.m10 = this.m10 * z, 
            this.m11 = this.m11 * z, this.m12 = this.m12, this.m13 = this.m13, this.m14 = this.m14, 
            this.m15 = this.m15, this;
        }
    }, {
        key: "rotate",
        value: function rotate(rad, axis) {
            var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z);
            if (Math.abs(len) < EPSILON) return null;
            x *= len = 1 / len, y *= len, z *= len;
            var s = Math.sin(rad), c = Math.cos(rad), t = 1 - c, a00 = this.m00, a01 = this.m01, a02 = this.m02, a03 = this.m03, a10 = this.m04, a11 = this.m05, a12 = this.m06, a13 = this.m07, a20 = this.m08, a21 = this.m09, a22 = this.m10, a23 = this.m11, b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            return this.m00 = a00 * b00 + a10 * b01 + a20 * b02, this.m01 = a01 * b00 + a11 * b01 + a21 * b02, 
            this.m02 = a02 * b00 + a12 * b01 + a22 * b02, this.m03 = a03 * b00 + a13 * b01 + a23 * b02, 
            this.m04 = a00 * b10 + a10 * b11 + a20 * b12, this.m05 = a01 * b10 + a11 * b11 + a21 * b12, 
            this.m06 = a02 * b10 + a12 * b11 + a22 * b12, this.m07 = a03 * b10 + a13 * b11 + a23 * b12, 
            this.m08 = a00 * b20 + a10 * b21 + a20 * b22, this.m09 = a01 * b20 + a11 * b21 + a21 * b22, 
            this.m10 = a02 * b20 + a12 * b21 + a22 * b22, this.m11 = a03 * b20 + a13 * b21 + a23 * b22, 
            this;
        }
    }, {
        key: "getTranslation",
        value: function getTranslation(out) {
            return out.x = this.m12, out.y = this.m13, out.z = this.m14, out;
        }
    }, {
        key: "getScale",
        value: function getScale(out) {
            var m00 = m3_1$1.m00 = this.m00, m01 = m3_1$1.m01 = this.m01, m02 = m3_1$1.m02 = this.m02, m04 = m3_1$1.m03 = this.m04, m05 = m3_1$1.m04 = this.m05, m06 = m3_1$1.m05 = this.m06, m08 = m3_1$1.m06 = this.m08, m09 = m3_1$1.m07 = this.m09, m10 = m3_1$1.m08 = this.m10;
            return out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02), out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06), 
            out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10), Mat3.determinant(m3_1$1) < 0 && (out.x *= -1), 
            out;
        }
    }, {
        key: "getRotation",
        value: function getRotation(out) {
            var trace = this.m00 + this.m05 + this.m10, S = 0;
            return trace > 0 ? (S = 2 * Math.sqrt(trace + 1), out.w = .25 * S, out.x = (this.m06 - this.m09) / S, 
            out.y = (this.m08 - this.m02) / S, out.z = (this.m01 - this.m04) / S) : this.m00 > this.m05 && this.m00 > this.m10 ? (S = 2 * Math.sqrt(1 + this.m00 - this.m05 - this.m10), 
            out.w = (this.m06 - this.m09) / S, out.x = .25 * S, out.y = (this.m01 + this.m04) / S, 
            out.z = (this.m08 + this.m02) / S) : this.m05 > this.m10 ? (S = 2 * Math.sqrt(1 + this.m05 - this.m00 - this.m10), 
            out.w = (this.m08 - this.m02) / S, out.x = (this.m01 + this.m04) / S, out.y = .25 * S, 
            out.z = (this.m06 + this.m09) / S) : (S = 2 * Math.sqrt(1 + this.m10 - this.m00 - this.m05), 
            out.w = (this.m01 - this.m04) / S, out.x = (this.m08 + this.m02) / S, out.y = (this.m06 + this.m09) / S, 
            out.z = .25 * S), out;
        }
    }, {
        key: "fromRTS",
        value: function fromRTS(q, v, s) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, sx = s.x, sy = s.y, sz = s.z;
            return this.m00 = (1 - (yy + zz)) * sx, this.m01 = (xy + wz) * sx, this.m02 = (xz - wy) * sx, 
            this.m03 = 0, this.m04 = (xy - wz) * sy, this.m05 = (1 - (xx + zz)) * sy, this.m06 = (yz + wx) * sy, 
            this.m07 = 0, this.m08 = (xz + wy) * sz, this.m09 = (yz - wx) * sz, this.m10 = (1 - (xx + yy)) * sz, 
            this.m11 = 0, this.m12 = v.x, this.m13 = v.y, this.m14 = v.z, this.m15 = 1, this;
        }
    }, {
        key: "fromQuat",
        value: function fromQuat(q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            return this.m00 = 1 - yy - zz, this.m01 = yx + wz, this.m02 = zx - wy, this.m03 = 0, 
            this.m04 = yx - wz, this.m05 = 1 - xx - zz, this.m06 = zy + wx, this.m07 = 0, this.m08 = zx + wy, 
            this.m09 = zy - wx, this.m10 = 1 - xx - yy, this.m11 = 0, this.m12 = 0, this.m13 = 0, 
            this.m14 = 0, this.m15 = 1, this;
        }
    } ]), Mat4;
}();

Mat4.IDENTITY = Object.freeze(new Mat4);

var v3_1$3 = new Vec3, m3_1$1 = new Mat3;

function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
}

CCClass.fastDefine("cc.Mat4", Mat4, {
    m00: 1,
    m01: 0,
    m02: 0,
    m03: 0,
    m04: 0,
    m05: 1,
    m06: 0,
    m07: 0,
    m08: 0,
    m09: 0,
    m10: 1,
    m11: 0,
    m12: 0,
    m13: 0,
    m14: 0,
    m15: 1
}), cc.Mat4 = Mat4, cc.mat4 = mat4;

var AffineTransform = function() {
    function AffineTransform() {
        var a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, b = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, c = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, d = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, tx = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, ty = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
        _classCallCheck(this, AffineTransform), this.a = a, this.b = b, this.c = c, this.d = d, 
        this.tx = tx, this.ty = ty;
    }
    return _createClass(AffineTransform, null, [ {
        key: "identity",
        value: function identity() {
            return new AffineTransform;
        }
    }, {
        key: "clone",
        value: function clone(affineTransform) {
            return new AffineTransform(affineTransform.a, affineTransform.b, affineTransform.c, affineTransform.d, affineTransform.tx, affineTransform.ty);
        }
    }, {
        key: "concat",
        value: function concat(out, t1, t2) {
            var a = t1.a, b = t1.b, c = t1.c, d = t1.d, tx = t1.tx, ty = t1.ty;
            out.a = a * t2.a + b * t2.c, out.b = a * t2.b + b * t2.d, out.c = c * t2.a + d * t2.c, 
            out.d = c * t2.b + d * t2.d, out.tx = tx * t2.a + ty * t2.c + t2.tx, out.ty = tx * t2.b + ty * t2.d + t2.ty;
        }
    }, {
        key: "invert",
        value: function invert(out, t) {
            var determinant = 1 / (t.a * t.d - t.b * t.c);
            out.a = determinant * t.d, out.b = -determinant * t.b, out.c = -determinant * t.c, 
            out.d = determinant * t.a, out.tx = determinant * (t.c * t.ty - t.d * t.tx), out.ty = determinant * (t.b * t.tx - t.a * t.ty);
        }
    }, {
        key: "fromMat4",
        value: function fromMat4(out, mat) {
            out.a = mat.m00, out.b = mat.m01, out.c = mat.m04, out.d = mat.m05, out.tx = mat.m12, 
            out.ty = mat.m13;
        }
    }, {
        key: "transformVec2",
        value: function transformVec2(out, point, transOrY, t) {
            var x, y;
            void 0 === t ? (t = transOrY, x = point.x, y = point.y) : (x = point, y = transOrY), 
            out.x = t.a * x + t.c * y + t.tx, out.y = t.b * x + t.d * y + t.ty;
        }
    }, {
        key: "transformSize",
        value: function transformSize(out, size, t) {
            out.width = t.a * size.width + t.c * size.height, out.height = t.b * size.width + t.d * size.height;
        }
    }, {
        key: "transformRect",
        value: function transformRect(out, rect, t) {
            var or = rect.x + rect.width, ot = rect.y + rect.height, lbx = t.a * rect.x + t.c * rect.y + t.tx, lby = t.b * rect.x + t.d * rect.y + t.ty, rbx = t.a * or + t.c * rect.y + t.tx, rby = t.b * or + t.d * rect.y + t.ty, ltx = t.a * rect.x + t.c * ot + t.tx, lty = t.b * rect.x + t.d * ot + t.ty, rtx = t.a * or + t.c * ot + t.tx, rty = t.b * or + t.d * ot + t.ty, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
            out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY;
        }
    }, {
        key: "transformObb",
        value: function transformObb(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
            var tx = anAffineTransform.a * rect.x + anAffineTransform.c * rect.y + anAffineTransform.tx, ty = anAffineTransform.b * rect.x + anAffineTransform.d * rect.y + anAffineTransform.ty, xa = anAffineTransform.a * rect.width, xb = anAffineTransform.b * rect.width, yc = anAffineTransform.c * rect.height, yd = anAffineTransform.d * rect.height;
            out_tl.x = tx, out_tl.y = ty, out_tr.x = xa + tx, out_tr.y = xb + ty, out_bl.x = yc + tx, 
            out_bl.y = yd + ty, out_br.x = xa + yc + tx, out_br.y = xb + yd + ty;
        }
    } ]), AffineTransform;
}();

cc.AffineTransform = AffineTransform;

var Size = function(_ValueType) {
    function Size(width, height) {
        var _this;
        return _classCallCheck(this, Size), _this = _possibleConstructorReturn(this, _getPrototypeOf(Size).call(this)), 
        width && "object" === _typeof(width) ? (_this.height = width.height, _this.width = width.width) : (_this.width = width || 0, 
        _this.height = height || 0), _this;
    }
    return _inherits(Size, ValueType), _createClass(Size, [ {
        key: "x",
        set: function set(val) {
            this.width = val;
        },
        get: function get() {
            return this.width;
        }
    }, {
        key: "y",
        set: function set(val) {
            this.height = val;
        },
        get: function get() {
            return this.height;
        }
    } ], [ {
        key: "lerp",
        value: function lerp(out, from, to, ratio) {
            return out.width = from.width + (to.width - from.width) * ratio, out.height = from.height + (to.height - from.height) * ratio, 
            out;
        }
    } ]), _createClass(Size, [ {
        key: "clone",
        value: function clone() {
            return new Size(this.width, this.height);
        }
    }, {
        key: "set",
        value: function set(width, height) {
            return width && "object" === _typeof(width) ? (this.height = width.height, this.width = width.width) : (this.width = width || 0, 
            this.height = height || 0), this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            return this.width === other.width && this.height === other.height;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            return this.width = this.width + (to.width - this.width) * ratio, this.height = this.height + (to.height - this.height) * ratio, 
            this;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
        }
    } ]), Size;
}();

function size() {
    var width = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, height = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return new Size(width, height);
}

Size.ZERO = Object.freeze(new Size(0, 0)), Size.ONE = Object.freeze(new Size(1, 1)), 
CCClass.fastDefine("cc.Size", Size, {
    width: 0,
    height: 0
}), cc.size = size, cc.Size = Size;

var Rect = function(_ValueType) {
    function Rect(x, y, width, height) {
        var _this;
        return _classCallCheck(this, Rect), _this = _possibleConstructorReturn(this, _getPrototypeOf(Rect).call(this)), 
        x && "object" === _typeof(x) ? (_this.y = x.y, _this.width = x.width, _this.height = x.height, 
        _this.x = x.x) : (_this.x = x || 0, _this.y = y || 0, _this.width = width || 0, 
        _this.height = height || 0), _this;
    }
    return _inherits(Rect, ValueType), _createClass(Rect, [ {
        key: "xMin",
        get: function get() {
            return this.x;
        },
        set: function set(value) {
            this.width += this.x - value, this.x = value;
        }
    }, {
        key: "yMin",
        get: function get() {
            return this.y;
        },
        set: function set(value) {
            this.height += this.y - value, this.y = value;
        }
    }, {
        key: "xMax",
        get: function get() {
            return this.x + this.width;
        },
        set: function set(value) {
            this.width = value - this.x;
        }
    }, {
        key: "yMax",
        get: function get() {
            return this.y + this.height;
        },
        set: function set(value) {
            this.height = value - this.y;
        }
    }, {
        key: "center",
        get: function get() {
            return new Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
        },
        set: function set(value) {
            this.x = value.x - .5 * this.width, this.y = value.y - .5 * this.height;
        }
    }, {
        key: "origin",
        get: function get() {
            return new cc.Vec2(this.x, this.y);
        },
        set: function set(value) {
            this.x = value.x, this.y = value.y;
        }
    }, {
        key: "size",
        get: function get() {
            return new Size(this.width, this.height);
        },
        set: function set(value) {
            this.width = value.width, this.height = value.height;
        }
    }, {
        key: "z",
        set: function set(val) {
            this.width = val;
        },
        get: function get() {
            return this.width;
        }
    }, {
        key: "w",
        set: function set(val) {
            this.height = val;
        },
        get: function get() {
            return this.height;
        }
    } ], [ {
        key: "fromMinMax",
        value: function fromMinMax(out, v1, v2) {
            var minX = Math.min(v1.x, v2.x), minY = Math.min(v1.y, v2.y), maxX = Math.max(v1.x, v2.x), maxY = Math.max(v1.y, v2.y);
            return out.x = minX, out.y = minY, out.width = maxX - minX, out.height = maxY - minY, 
            out;
        }
    }, {
        key: "lerp",
        value: function lerp(out, from, to, ratio) {
            var x = from.x, y = from.y, w = from.width, h = from.height;
            return out.x = x + (to.x - x) * ratio, out.y = y + (to.y - y) * ratio, out.width = w + (to.width - w) * ratio, 
            out.height = h + (to.height - h) * ratio, out;
        }
    }, {
        key: "intersection",
        value: function intersection(out, one, other) {
            var axMin = one.x, ayMin = one.y, axMax = one.x + one.width, ayMax = one.y + one.height, bxMin = other.x, byMin = other.y, bxMax = other.x + other.width, byMax = other.y + other.height;
            return out.x = Math.max(axMin, bxMin), out.y = Math.max(ayMin, byMin), out.width = Math.min(axMax, bxMax) - out.x, 
            out.height = Math.min(ayMax, byMax) - out.y, out;
        }
    }, {
        key: "union",
        value: function union(out, one, other) {
            var x = one.x, y = one.y, w = one.width, h = one.height, bx = other.x, by = other.y, bw = other.width, bh = other.height;
            return out.x = Math.min(x, bx), out.y = Math.min(y, by), out.width = Math.max(x + w, bx + bw) - out.x, 
            out.height = Math.max(y + h, by + bh) - out.y, out;
        }
    } ]), _createClass(Rect, [ {
        key: "clone",
        value: function clone() {
            return new Rect(this.x, this.y, this.width, this.height);
        }
    }, {
        key: "set",
        value: function set(x, y, width, height) {
            return x && "object" === _typeof(x) ? (this.y = x.y, this.width = x.width, this.height = x.height, 
            this.x = x.x) : (this.x = x || 0, this.y = y || 0, this.width = width || 0, this.height = height || 0), 
            this;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            var x = this.x, y = this.y, w = this.width, h = this.height;
            return this.x = x + (to.x - x) * ratio, this.y = y + (to.y - y) * ratio, this.width = w + (to.width - w) * ratio, 
            this.height = h + (to.height - h) * ratio, this;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "(".concat(this.x.toFixed(2), ", ").concat(this.y.toFixed(2), ", ").concat(this.width.toFixed(2), ", ").concat(this.height.toFixed(2), ")");
        }
    }, {
        key: "intersects",
        value: function intersects(other) {
            var maxax = this.x + this.width, maxay = this.y + this.height, maxbx = other.x + other.width, maxby = other.y + other.height;
            return !(maxax < other.x || maxbx < this.x || maxay < other.y || maxby < this.y);
        }
    }, {
        key: "contains",
        value: function contains(point) {
            return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
        }
    }, {
        key: "containsRect",
        value: function containsRect(other) {
            return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
        }
    }, {
        key: "transformMat4",
        value: function transformMat4(mat) {
            var ol = this.x, ob = this.y, or = ol + this.width, ot = ob + this.height, lbx = mat.m00 * ol + mat.m04 * ob + mat.m12, lby = mat.m01 * ol + mat.m05 * ob + mat.m13, rbx = mat.m00 * or + mat.m04 * ob + mat.m12, rby = mat.m01 * or + mat.m05 * ob + mat.m13, ltx = mat.m00 * ol + mat.m04 * ot + mat.m12, lty = mat.m01 * ol + mat.m05 * ot + mat.m13, rtx = mat.m00 * or + mat.m04 * ot + mat.m12, rty = mat.m01 * or + mat.m05 * ot + mat.m13, minX = Math.min(lbx, rbx, ltx, rtx), maxX = Math.max(lbx, rbx, ltx, rtx), minY = Math.min(lby, rby, lty, rty), maxY = Math.max(lby, rby, lty, rty);
            return this.x = minX, this.y = minY, this.width = maxX - minX, this.height = maxY - minY, 
            this;
        }
    } ]), Rect;
}();

function rect() {
    var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, width = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, height = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    return new Rect(x, y, width, height);
}

CCClass.fastDefine("cc.Rect", Rect, {
    x: 0,
    y: 0,
    width: 0,
    height: 0
}), cc.Rect = Rect, cc.rect = rect;

var Color = function(_ValueType) {
    function Color(r, g, b, a) {
        var _this;
        return _classCallCheck(this, Color), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Color).call(this)))._val = 0, 
        "string" == typeof r ? _this.fromHEX(r) : void 0 !== g ? _this.set(r, g, b, a) : _this.set(r), 
        _this;
    }
    return _inherits(Color, ValueType), _createClass(Color, [ {
        key: "r",
        get: function get() {
            return 255 & this._val;
        },
        set: function set(red) {
            red = ~~clamp(red, 0, 255), this._val = (4294967040 & this._val | red) >>> 0;
        }
    }, {
        key: "g",
        get: function get() {
            return (65280 & this._val) >> 8;
        },
        set: function set(green) {
            green = ~~clamp(green, 0, 255), this._val = (4294902015 & this._val | green << 8) >>> 0;
        }
    }, {
        key: "b",
        get: function get() {
            return (16711680 & this._val) >> 16;
        },
        set: function set(blue) {
            blue = ~~clamp(blue, 0, 255), this._val = (4278255615 & this._val | blue << 16) >>> 0;
        }
    }, {
        key: "a",
        get: function get() {
            return (4278190080 & this._val) >>> 24;
        },
        set: function set(alpha) {
            alpha = ~~clamp(alpha, 0, 255), this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0;
        }
    }, {
        key: "x",
        get: function get() {
            return this.r * (1 / 255);
        },
        set: function set(value) {
            this.r = 255 * value;
        }
    }, {
        key: "y",
        get: function get() {
            return this.g * (1 / 255);
        },
        set: function set(value) {
            this.g = 255 * value;
        }
    }, {
        key: "z",
        get: function get() {
            return this.b * (1 / 255);
        },
        set: function set(value) {
            this.b = 255 * value;
        }
    }, {
        key: "w",
        get: function get() {
            return this.a * (1 / 255);
        },
        set: function set(value) {
            this.a = 255 * value;
        }
    } ], [ {
        key: "clone",
        value: function clone(a) {
            var out = new Color;
            return a._val ? out._val = a._val : out._val = (a.a << 24 >>> 0) + (a.b << 16) + (a.g << 8) + a.r, 
            out;
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return out.r = a.r, out.g = a.g, out.b = a.b, out.a = a.a, out;
        }
    }, {
        key: "set",
        value: function set(out, r, g, b, a) {
            return out.r = r, out.g = g, out.b = b, out.a = a, out;
        }
    }, {
        key: "fromHEX",
        value: function fromHEX(out, hexString) {
            return hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString, 
            out.r = parseInt(hexString.substr(0, 2), 16) || 0, out.g = parseInt(hexString.substr(2, 2), 16) || 0, 
            out.b = parseInt(hexString.substr(4, 2), 16) || 0, out.a = parseInt(hexString.substr(6, 2), 16) || 255, 
            out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r, out;
        }
    }, {
        key: "add",
        value: function add(out, a, b) {
            return out.r = a.r + b.r, out.g = a.g + b.g, out.b = a.b + b.b, out.a = a.a + b.a, 
            out;
        }
    }, {
        key: "subtract",
        value: function subtract(out, a, b) {
            return out.r = a.r - b.r, out.g = a.g - b.g, out.b = a.b - b.b, out.a = a.a - b.a, 
            out;
        }
    }, {
        key: "multiply",
        value: function multiply(out, a, b) {
            return out.r = a.r * b.r, out.g = a.g * b.g, out.b = a.b * b.b, out.a = a.a * b.a, 
            out;
        }
    }, {
        key: "divide",
        value: function divide(out, a, b) {
            return out.r = a.r / b.r, out.g = a.g / b.g, out.b = a.b / b.b, out.a = a.a / b.a, 
            out;
        }
    }, {
        key: "scale",
        value: function scale(out, a, b) {
            return out.r = a.r * b, out.g = a.g * b, out.b = a.b * b, out.a = a.a * b, out;
        }
    }, {
        key: "lerp",
        value: function lerp(out, from, to, ratio) {
            var r = from.r, g = from.g, b = from.b, a = from.a;
            return r += (to.r - r) * ratio, g += (to.g - g) * ratio, b += (to.b - b) * ratio, 
            a += (to.a - a) * ratio, out._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r), 
            out;
        }
    }, {
        key: "toArray",
        value: function toArray(out, a) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, scale = a instanceof Color || a.a > 1 ? 1 / 255 : 1;
            return out[ofs + 0] = a.r * scale, out[ofs + 1] = a.g * scale, out[ofs + 2] = a.b * scale, 
            out[ofs + 3] = a.a * scale, out;
        }
    }, {
        key: "fromArray",
        value: function fromArray(arr, out) {
            var ofs = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            return out.r = 255 * arr[ofs + 0], out.g = 255 * arr[ofs + 1], out.b = 255 * arr[ofs + 2], 
            out.a = 255 * arr[ofs + 3], out;
        }
    }, {
        key: "strictEquals",
        value: function strictEquals(a, b) {
            return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
        }
    }, {
        key: "equals",
        value: function equals(a, b) {
            var epsilon = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : EPSILON;
            return Math.abs(a.r - b.r) <= epsilon * Math.max(1, Math.abs(a.r), Math.abs(b.r)) && Math.abs(a.g - b.g) <= epsilon * Math.max(1, Math.abs(a.g), Math.abs(b.g)) && Math.abs(a.b - b.b) <= epsilon * Math.max(1, Math.abs(a.b), Math.abs(b.b)) && Math.abs(a.a - b.a) <= epsilon * Math.max(1, Math.abs(a.a), Math.abs(b.a));
        }
    }, {
        key: "hex",
        value: function hex(a) {
            return (255 * a.r << 24 | 255 * a.g << 16 | 255 * a.b << 8 | 255 * a.a) >>> 0;
        }
    } ]), _createClass(Color, [ {
        key: "clone",
        value: function clone() {
            var ret = new Color;
            return ret._val = this._val, ret;
        }
    }, {
        key: "equals",
        value: function equals(other) {
            return other && this._val === other._val;
        }
    }, {
        key: "lerp",
        value: function lerp(to, ratio) {
            var r = this.r, g = this.g, b = this.b, a = this.a;
            return r += (to.r - r) * ratio, g += (to.g - g) * ratio, b += (to.b - b) * ratio, 
            a += (to.a - a) * ratio, this._val = Math.floor((a << 24 >>> 0) + (b << 16) + (g << 8) + r), 
            this;
        }
    }, {
        key: "toString",
        value: function toString() {
            return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
        }
    }, {
        key: "toCSS",
        value: function toCSS(opt) {
            return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a * (1 / 255)).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
        }
    }, {
        key: "fromHEX",
        value: function fromHEX(hexString) {
            hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString;
            var r = parseInt(hexString.substr(0, 2), 16) || 0, g = parseInt(hexString.substr(2, 2), 16) || 0, b = parseInt(hexString.substr(4, 2), 16) || 0, a = parseInt(hexString.substr(6, 2), 16) || 255;
            return this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r, this;
        }
    }, {
        key: "toHEX",
        value: function toHEX(fmt) {
            var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ], i = -1;
            if ("#rrggbb" === fmt) for (i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]); else if ("#rrggbbaa" === fmt) for (hex.push((0 | this.a).toString(16)), 
            i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]);
            return hex.join("");
        }
    }, {
        key: "toRGBValue",
        value: function toRGBValue() {
            return 16777215 & this._val;
        }
    }, {
        key: "fromHSV",
        value: function fromHSV(h, s, v) {
            var r = 0, g = 0, b = 0;
            if (0 === s) r = g = b = v; else if (0 === v) r = g = b = 0; else {
                1 === h && (h = 0), h *= 6, s = s, v = v;
                var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - s * f), t = v * (1 - s * (1 - f));
                switch (i) {
                  case 0:
                    r = v, g = t, b = p;
                    break;

                  case 1:
                    r = q, g = v, b = p;
                    break;

                  case 2:
                    r = p, g = v, b = t;
                    break;

                  case 3:
                    r = p, g = q, b = v;
                    break;

                  case 4:
                    r = t, g = p, b = v;
                    break;

                  case 5:
                    r = v, g = p, b = q;
                }
            }
            return r *= 255, g *= 255, b *= 255, this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + r, 
            this;
        }
    }, {
        key: "toHSV",
        value: function toHSV() {
            var r = this.r * (1 / 255), g = this.g * (1 / 255), b = this.b * (1 / 255), hsv = {
                h: 0,
                s: 0,
                v: 0
            }, max = Math.max(r, g, b), min = Math.min(r, g, b), delta = 0;
            return hsv.v = max, hsv.s = max ? (max - min) / max : 0, hsv.s ? (delta = max - min, 
            hsv.h = r === max ? (g - b) / delta : g === max ? 2 + (b - r) / delta : 4 + (r - g) / delta, 
            hsv.h /= 6, hsv.h < 0 && (hsv.h += 1)) : hsv.h = 0, hsv;
        }
    }, {
        key: "set",
        value: function set(r, g, b, a) {
            return "object" === _typeof(r) ? null != r._val ? this._val = r._val : (g = r.g || 0, 
            b = r.b || 0, a = "number" == typeof r.a ? r.a : 255, r = r.r || 0, this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r) : (r = r || 0, 
            g = g || 0, b = b || 0, a = "number" == typeof a ? a : 255, this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r), 
            this;
        }
    }, {
        key: "multiply",
        value: function multiply(other) {
            var r = (255 & this._val) * other.r >> 8, g = (65280 & this._val) * other.g >> 8, b = (16711680 & this._val) * other.b >> 8, a = ((4278190080 & this._val) >>> 8) * other.a;
            return this._val = 4278190080 & a | 16711680 & b | 65280 & g | 255 & r, this;
        }
    }, {
        key: "_set_r_unsafe",
        value: function _set_r_unsafe(red) {
            return this._val = (4294967040 & this._val | red) >>> 0, this;
        }
    }, {
        key: "_set_g_unsafe",
        value: function _set_g_unsafe(green) {
            return this._val = (4294902015 & this._val | green << 8) >>> 0, this;
        }
    }, {
        key: "_set_b_unsafe",
        value: function _set_b_unsafe(blue) {
            return this._val = (4278255615 & this._val | blue << 16) >>> 0, this;
        }
    }, {
        key: "_set_a_unsafe",
        value: function _set_a_unsafe(alpha) {
            return this._val = (16777215 & this._val | alpha << 24 >>> 0) >>> 0, this;
        }
    } ]), Color;
}();

function color(r, g, b, a) {
    return new Color(r, g, b, a);
}

Color.WHITE = Object.freeze(new Color(255, 255, 255, 255)), Color.GRAY = Object.freeze(new Color(127, 127, 127, 255)), 
Color.BLACK = Object.freeze(new Color(0, 0, 0, 255)), Color.TRANSPARENT = Object.freeze(new Color(0, 0, 0, 0)), 
Color.RED = Object.freeze(new Color(255, 0, 0, 255)), Color.GREEN = Object.freeze(new Color(0, 255, 0, 255)), 
Color.BLUE = Object.freeze(new Color(0, 0, 255, 255)), Color.CYAN = Object.freeze(new Color(0, 255, 255, 255)), 
Color.MAGENTA = Object.freeze(new Color(255, 0, 255, 255)), Color.YELLOW = Object.freeze(new Color(255, 255, 0, 255)), 
CCClass.fastDefine("cc.Color", Color, {
    r: 0,
    g: 0,
    b: 0,
    a: 255
}), cc.Color = Color, cc.color = color;

var replacePropertyLog, markAsWarningLog, removePropertyLog, defaultLogTimes = 10;

var messageID = 0, messageMap = new Map;

replacePropertyLog = function replacePropertyLog(n, dp, n2, newp, f, id) {
    var item = messageMap.get(id);
    item && item.logTimes > item.count && (f("'%s' is deprecated, please use '%s' instead.", "".concat(n, ".").concat(dp), "".concat(n2, ".").concat(newp)), 
    item.count++);
}, exports.replaceProperty = function replaceProperty(owner, ownerName, properties) {
    null != owner && properties.forEach((function(item) {
        var id = messageID++;
        messageMap.set(id, {
            id: id,
            count: 0,
            logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
        });
        var target = null != item.target ? item.target : owner, newName = null != item.newName ? item.newName : item.name, targetName = null != item.targetName ? item.targetName : ownerName, sameTarget = target == owner;
        if (null != item.customFunction) owner[item.name] = function() {
            var _ref;
            return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
            (_ref = item.customFunction).call.apply(_ref, [ this ].concat(Array.prototype.slice.call(arguments)));
        }; else if (null != item.customSetter || null != item.customGetter) {
            var hasSetter = null != item.customSetter, hasGetter = null != item.customGetter;
            hasSetter && hasGetter ? Object.defineProperty(owner, item.name, {
                get: function get() {
                    return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                    item.customGetter.call(this);
                },
                set: function set(v) {
                    replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), item.customSetter.call(this, v);
                }
            }) : hasSetter ? Object.defineProperty(owner, item.name, {
                set: function set(v) {
                    replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), item.customSetter.call(this, v);
                }
            }) : hasGetter && Object.defineProperty(owner, item.name, {
                get: function get() {
                    return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                    item.customGetter.call(this);
                }
            });
        } else Object.defineProperty(owner, item.name, {
            get: function get() {
                return replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), 
                sameTarget ? this[newName] : target[newName];
            },
            set: function set(v) {
                replacePropertyLog(ownerName, item.name, targetName, newName, warn, id), sameTarget ? this[newName] = v : target[newName] = v;
            }
        });
    }));
}, removePropertyLog = function removePropertyLog(n, dp, f, id, s) {
    var item = messageMap.get(id), ss = void 0 === s ? "" : "(" + s + ")";
    item && item.logTimes > item.count && (f("'%s' has been removed. " + ss, "".concat(n, ".").concat(dp)), 
    item.count++);
}, exports.removeProperty = function removeProperty(owner, ownerName, properties) {
    null != owner && properties.forEach((function(item) {
        var id = messageID++;
        messageMap.set(id, {
            id: id,
            count: 0,
            logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
        }), Object.defineProperty(owner, item.name, {
            get: function get() {
                return removePropertyLog(ownerName, item.name, error, id, item.suggest);
            },
            set: function set() {
                removePropertyLog(ownerName, item.name, error, id, item.suggest);
            }
        });
    }));
}, markAsWarningLog = function markAsWarningLog(n, dp, f, id, s) {
    var item = messageMap.get(id), ss = void 0 === s ? "" : "(" + s + ")";
    item && item.logTimes > item.count && (f("'%s' is deprecated. " + ss, "".concat(n, ".").concat(dp)), 
    item.count++);
}, exports.markAsWarning = function markAsWarning(owner, ownerName, properties) {
    if (null != owner) {
        var _defaultGetSet = function _defaultGetSet(d, n, dp, f, id, s) {
            if (d.get) {
                var oldGet = d.get();
                d.get = function() {
                    return markAsWarningLog(n, dp, f, id, s), oldGet.call(this);
                };
            }
            if (d.set) {
                var oldSet = Object.create(d.set);
                d.set = function(v) {
                    markAsWarningLog(n, dp, f, id, s), oldSet.call(this, v);
                };
            }
        };
        properties.forEach((function(item) {
            var deprecatedProp = item.name, descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);
            if (descriptor) {
                var id = messageID++;
                if (messageMap.set(id, {
                    id: id,
                    count: 0,
                    logTimes: void 0 !== item.logTimes ? item.logTimes : defaultLogTimes
                }), null != descriptor.value) if ("function" == typeof descriptor.value) {
                    var oldValue = descriptor.value;
                    owner[deprecatedProp] = function() {
                        return markAsWarningLog(ownerName, deprecatedProp, warn, id, item.suggest), oldValue.call.apply(oldValue, [ this ].concat(Array.prototype.slice.call(arguments)));
                    };
                } else _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, item.suggest); else _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, item.suggest);
            }
        }));
    }
}, exports.replaceProperty(Vec2, "Vec2", [ {
    name: "sub",
    newName: "subtract",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "mul",
    newName: "multiply",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "div",
    newName: "divide",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "dist",
    newName: "distance",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "sqrDist",
    newName: "squaredDistance",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "mag",
    newName: "len",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "sqrMag",
    newName: "lengthSqr",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec2,
    targetName: "Vec2"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec2,
    targetName: "Vec2"
} ]), exports.replaceProperty(Vec2.prototype, "Vec2", [ {
    name: "mag",
    newName: "length",
    target: Vec2.prototype,
    targetName: "Vec2"
}, {
    name: "magSqr",
    newName: "lengthSqr",
    target: Vec2.prototype,
    targetName: "Vec2"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec2.prototype,
    targetName: "Vec2"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec2.prototype,
    targetName: "Vec2"
} ]), exports.removeProperty(Vec2.prototype, "vmath", [ {
    name: "divide"
} ]), exports.replaceProperty(Vec3, "Vec3", [ {
    name: "sub",
    newName: "subtract",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "mul",
    newName: "multiply",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "div",
    newName: "divide",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "dist",
    newName: "distance",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "sqrDist",
    newName: "squaredDistance",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "mag",
    newName: "len",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "sqrMag",
    newName: "lengthSqr",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec3,
    targetName: "Vec3"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec3,
    targetName: "Vec3"
} ]), exports.replaceProperty(Vec3.prototype, "Vec3", [ {
    name: "mag",
    newName: "length",
    target: Vec3.prototype,
    targetName: "Vec3"
}, {
    name: "magSqr",
    newName: "lengthSqr",
    target: Vec3.prototype,
    targetName: "Vec3"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec3.prototype,
    targetName: "Vec3"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec3.prototype,
    targetName: "Vec3"
} ]), exports.removeProperty(Vec3.prototype, "vmath", [ {
    name: "divide"
} ]), exports.replaceProperty(Vec4, "Vec4", [ {
    name: "sub",
    newName: "subtract",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "mul",
    newName: "multiply",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "div",
    newName: "divide",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "dist",
    newName: "distance",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "sqrDist",
    newName: "squaredDistance",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "mag",
    newName: "len",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "sqrMag",
    newName: "lengthSqr",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec4,
    targetName: "Vec4"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec4,
    targetName: "Vec4"
} ]), exports.replaceProperty(Vec4.prototype, "Vec4", [ {
    name: "mag",
    newName: "length",
    target: Vec4.prototype,
    targetName: "Vec4"
}, {
    name: "magSqr",
    newName: "lengthSqr",
    target: Vec4.prototype,
    targetName: "Vec4"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Vec4.prototype,
    targetName: "Vec4"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Vec4.prototype,
    targetName: "Vec4"
} ]), exports.removeProperty(Vec4.prototype, "vmath", [ {
    name: "divide"
} ]), exports.replaceProperty(Quat, "Quat", [ {
    name: "mag",
    newName: "len",
    target: Quat,
    targetName: "Quat"
}, {
    name: "mul",
    newName: "multiply",
    target: Quat,
    targetName: "Quat"
}, {
    name: "sqrMag",
    newName: "lengthSqr",
    target: Quat,
    targetName: "Quat"
}, {
    name: "scale",
    newName: "multiplyScalar",
    target: Quat,
    targetName: "Quat"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Quat,
    targetName: "Quat"
} ]), exports.replaceProperty(Quat.prototype, "Quat", [ {
    name: "scale",
    newName: "multiplyScalar",
    target: Quat.prototype,
    targetName: "Quat"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Quat.prototype,
    targetName: "Quat"
} ]), exports.replaceProperty(Color, "Color", [ {
    name: "sub",
    newName: "subtract",
    target: Color,
    targetName: "Color"
}, {
    name: "mul",
    newName: "multiply",
    target: Color,
    targetName: "Color"
}, {
    name: "div",
    newName: "divide",
    target: Color,
    targetName: "Color"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Color,
    targetName: "Color"
}, {
    name: "fromHex",
    newName: "fromHEX",
    customFunction: function customFunction() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        var arg1 = args[1].toString(16);
        return cc.Color.fromHEX(args[0], arg1);
    }
} ]), exports.replaceProperty(Mat3, "Mat3", [ {
    name: "sub",
    newName: "subtract",
    target: Mat3,
    targetName: "Mat3"
}, {
    name: "mul",
    newName: "multiply",
    target: Mat3,
    targetName: "Mat3"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Mat3,
    targetName: "Mat3"
} ]), exports.replaceProperty(Mat3.prototype, "Mat3", [ {
    name: "sub",
    newName: "subtract",
    target: Mat3.prototype,
    targetName: "Mat3"
}, {
    name: "mul",
    newName: "multiply",
    target: Mat3.prototype,
    targetName: "Mat3"
}, {
    name: "mulScalar",
    newName: "multiplyScalar",
    target: Mat3.prototype,
    targetName: "Mat3"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Mat3.prototype,
    targetName: "Mat3"
} ]), exports.replaceProperty(Mat4, "Mat4", [ {
    name: "sub",
    newName: "subtract",
    target: Mat4,
    targetName: "Mat4"
}, {
    name: "mul",
    newName: "multiply",
    target: Mat4,
    targetName: "Mat4"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Mat4,
    targetName: "Mat4"
} ]), exports.replaceProperty(Mat4.prototype, "Mat4", [ {
    name: "sub",
    newName: "subtract",
    target: Mat4.prototype,
    targetName: "Mat4"
}, {
    name: "mul",
    newName: "multiply",
    target: Mat4.prototype,
    targetName: "Mat4"
}, {
    name: "mulScalar",
    newName: "multiplyScalar",
    target: Mat4.prototype,
    targetName: "Mat4"
}, {
    name: "exactEquals",
    newName: "strictEquals",
    target: Mat4.prototype,
    targetName: "Mat4"
} ]);

var math = Object.freeze({
    __proto__: null,
    bits: bits,
    Vec2: Vec2,
    v2: v2,
    Vec3: Vec3,
    v3: v3,
    Vec4: Vec4,
    v4: v4,
    Quat: Quat,
    quat: quat,
    Mat3: Mat3,
    Mat4: Mat4,
    mat4: mat4,
    AffineTransform: AffineTransform,
    Size: Size,
    size: size,
    Rect: Rect,
    rect: rect,
    Color: Color,
    color: color,
    EPSILON: EPSILON,
    equals: equals,
    approx: approx,
    clamp: clamp,
    clamp01: clamp01,
    lerp: lerp,
    toRadian: toRadian,
    toDegree: toDegree,
    random: random,
    randomRange: randomRange,
    randomRangeInt: randomRangeInt,
    pseudoRandom: pseudoRandom,
    pseudoRandomRange: pseudoRandomRange,
    pseudoRandomRangeInt: pseudoRandomRangeInt,
    nextPow2: nextPow2$1,
    repeat: repeat,
    pingPong: pingPong,
    inverseLerp: inverseLerp,
    absMaxComponent: absMaxComponent,
    absMax: absMax
}), X = new Vec3, Y = new Vec3, Z = new Vec3, d = new Vec3, min$1 = new Vec3, max$1 = new Vec3, u = new Array(3), e = new Array(3);

function point_plane(point, plane_) {
    return Vec3.dot(plane_.n, point) - plane_.d;
}

function pt_point_aabb(out, point, aabb_) {
    return Vec3.copy(out, point), Vec3.subtract(min$1, aabb_.center, aabb_.halfExtents), 
    Vec3.add(max$1, aabb_.center, aabb_.halfExtents), out.x = out.x < min$1.x ? min$1.x : out.x, 
    out.y = out.y < min$1.x ? min$1.y : out.y, out.z = out.z < min$1.x ? min$1.z : out.z, 
    out.x = out.x > max$1.x ? max$1.x : out.x, out.y = out.y > max$1.x ? max$1.y : out.y, 
    out.z = out.z > max$1.x ? max$1.z : out.z, out;
}

function pt_point_obb(out, point, obb_) {
    Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02), Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05), 
    Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08), u[0] = X, 
    u[1] = Y, u[2] = Z, e[0] = obb_.halfExtents.x, e[1] = obb_.halfExtents.y, e[2] = obb_.halfExtents.z, 
    Vec3.subtract(d, point, obb_.center), Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
    for (var i = 0; i < 3; i++) {
        var dist = Vec3.dot(d, u[i]);
        dist > e[i] && (dist = e[i]), dist < -e[i] && (dist = -e[i]), out.x += dist * u[i].x, 
        out.y += dist * u[i].y, out.z += dist * u[i].z;
    }
    return out;
}

var distance = Object.freeze({
    __proto__: null,
    point_plane: point_plane,
    pt_point_plane: function pt_point_plane(out, point, plane_) {
        var t = point_plane(point, plane_);
        return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
    },
    pt_point_aabb: pt_point_aabb,
    pt_point_obb: pt_point_obb,
    pt_point_line: function pt_point_line(out, point, linePointA, linePointB) {
        Vec3.subtract(X, linePointA, linePointB);
        var dir = X, dirSquaredLength = Vec3.lengthSqr(dir);
        if (0 == dirSquaredLength) Vec3.copy(out, linePointA); else {
            Vec3.subtract(X, point, linePointA);
            var t = Vec3.dot(X, dir) / dirSquaredLength;
            t < 0 ? Vec3.copy(out, linePointA) : t > 1 ? Vec3.copy(out, linePointB) : Vec3.scaleAndAdd(out, linePointA, dir, t);
        }
    }
}), ray = function() {
    function ray() {
        var ox = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, oy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, oz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, dx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, dy = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, dz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : -1;
        _classCallCheck(this, ray), this.o = void 0, this.d = void 0, this._type = void 0, 
        this._type = enums.SHAPE_RAY, this.o = new Vec3(ox, oy, oz), this.d = new Vec3(dx, dy, dz);
    }
    return _createClass(ray, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create() {
            var ox = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, oy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, oz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, dx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, dy = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, dz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
            return new ray(ox, oy, oz, dx, dy, dz);
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return Vec3.copy(out.o, a.o), Vec3.copy(out.d, a.d), out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, origin, target) {
            return Vec3.copy(out.o, origin), Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin)), 
            out;
        }
    }, {
        key: "set",
        value: function set(out, ox, oy, oz, dx, dy, dz) {
            return out.o.x = ox, out.o.y = oy, out.o.z = oz, out.d.x = dx, out.d.y = dy, out.d.z = dz, 
            out;
        }
    } ]), _createClass(ray, [ {
        key: "computeHit",
        value: function computeHit(out, distance) {
            Vec3.normalize(out, this.d), Vec3.scaleAndAdd(out, this.o, out, distance);
        }
    } ]), ray;
}(), _v3_tmp = new Vec3;

function maxComponent(v) {
    return Math.max(Math.max(v.x, v.y), v.z);
}

var GFXObjectType, GFXStatus, sphere = function() {
    function sphere() {
        var cx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, cy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, cz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        _classCallCheck(this, sphere), this.center = void 0, this.radius = void 0, this._type = void 0, 
        this._type = enums.SHAPE_SPHERE, this.center = new Vec3(cx, cy, cz), this.radius = r;
    }
    return _createClass(sphere, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create(cx, cy, cz, r) {
            return new sphere(cx, cy, cz, r);
        }
    }, {
        key: "clone",
        value: function clone(p) {
            return new sphere(p.center.x, p.center.y, p.center.z, p.radius);
        }
    }, {
        key: "copy",
        value: function copy(out, p) {
            return Vec3.copy(out.center, p.center), out.radius = p.radius, out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, minPos, maxPos) {
            return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), .5), out.radius = .5 * Vec3.subtract(_v3_tmp, maxPos, minPos).length(), 
            out;
        }
    }, {
        key: "set",
        value: function set(out, cx, cy, cz, r) {
            return out.center.x = cx, out.center.y = cy, out.center.z = cz, out.radius = r, 
            out;
        }
    } ]), _createClass(sphere, [ {
        key: "clone",
        value: function clone() {
            return sphere.clone(this);
        }
    }, {
        key: "copy",
        value: function copy(a) {
            return sphere.copy(this, a);
        }
    }, {
        key: "getBoundary",
        value: function getBoundary(minPos, maxPos) {
            Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius), 
            Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
        }
    }, {
        key: "transform",
        value: function transform(m, pos, rot, scale, out) {
            Vec3.transformMat4(out.center, this.center, m), out.radius = this.radius * maxComponent(scale);
        }
    }, {
        key: "translateAndRotate",
        value: function translateAndRotate(m, rot, out) {
            Vec3.transformMat4(out.center, this.center, m);
        }
    }, {
        key: "setScale",
        value: function setScale(scale, out) {
            out.radius = this.radius * maxComponent(scale);
        }
    } ]), sphere;
}(), triangle = function() {
    function triangle() {
        var ax = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, ay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, az = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, bx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, by = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, bz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, cx = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, cy = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 1, cz = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0;
        _classCallCheck(this, triangle), this.a = void 0, this.b = void 0, this.c = void 0, 
        this._type = void 0, this._type = enums.SHAPE_TRIANGLE, this.a = new Vec3(ax, ay, az), 
        this.b = new Vec3(bx, by, bz), this.c = new Vec3(cx, cy, cz);
    }
    return _createClass(triangle, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create() {
            var ax = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, ay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, az = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, bx = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, by = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, bz = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, cx = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, cy = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, cz = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 1;
            return new triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
        }
    }, {
        key: "clone",
        value: function clone(t) {
            return new triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
        }
    }, {
        key: "copy",
        value: function copy(out, t) {
            return Vec3.copy(out.a, t.a), Vec3.copy(out.b, t.b), Vec3.copy(out.c, t.c), out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, a, b, c) {
            return Vec3.copy(out.a, a), Vec3.copy(out.b, b), Vec3.copy(out.c, c), out;
        }
    }, {
        key: "set",
        value: function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
            return out.a.x = ax, out.a.y = ay, out.a.z = az, out.b.x = bx, out.b.y = by, out.b.z = bz, 
            out.c.x = cx, out.c.y = cy, out.c.z = cz, out;
        }
    } ]), triangle;
}();

(GFXObjectType = exports.GFXObjectType || (exports.GFXObjectType = {}))[GFXObjectType.UNKNOWN = 0] = "UNKNOWN", 
GFXObjectType[GFXObjectType.BUFFER = 1] = "BUFFER", GFXObjectType[GFXObjectType.TEXTURE = 2] = "TEXTURE", 
GFXObjectType[GFXObjectType.TEXTURE_VIEW = 3] = "TEXTURE_VIEW", GFXObjectType[GFXObjectType.RENDER_PASS = 4] = "RENDER_PASS", 
GFXObjectType[GFXObjectType.FRAMEBUFFER = 5] = "FRAMEBUFFER", GFXObjectType[GFXObjectType.SAMPLER = 6] = "SAMPLER", 
GFXObjectType[GFXObjectType.SHADER = 7] = "SHADER", GFXObjectType[GFXObjectType.PIPELINE_LAYOUT = 8] = "PIPELINE_LAYOUT", 
GFXObjectType[GFXObjectType.PIPELINE_STATE = 9] = "PIPELINE_STATE", GFXObjectType[GFXObjectType.BINDING_LAYOUT = 10] = "BINDING_LAYOUT", 
GFXObjectType[GFXObjectType.INPUT_ASSEMBLER = 11] = "INPUT_ASSEMBLER", GFXObjectType[GFXObjectType.COMMAND_ALLOCATOR = 12] = "COMMAND_ALLOCATOR", 
GFXObjectType[GFXObjectType.COMMAND_BUFFER = 13] = "COMMAND_BUFFER", GFXObjectType[GFXObjectType.QUEUE = 14] = "QUEUE", 
GFXObjectType[GFXObjectType.WINDOW = 15] = "WINDOW", (GFXStatus = exports.GFXStatus || (exports.GFXStatus = {}))[GFXStatus.UNREADY = 0] = "UNREADY", 
GFXStatus[GFXStatus.FAILED = 1] = "FAILED", GFXStatus[GFXStatus.SUCCESS = 2] = "SUCCESS";

var GFXAttributeName, GFXType, GFXFormat, GFXBufferUsageBit, GFXMemoryUsageBit, GFXBufferFlagBit, GFXBufferAccessBit, GFXPrimitiveMode, GFXPolygonMode, GFXShadeModel, GFXCullMode, GFXComparisonFunc, GFXStencilOp, GFXBlendOp, GFXBlendFactor, GFXColorMask, GFXFilter, GFXAddress, GFXTextureType, GFXTextureUsageBit, GFXSampleCount, GFXTextureFlagBit, GFXTextureViewType, GFXShaderType, GFXBindingType, GFXCommandBufferType, GFXLoadOp, GFXStoreOp, GFXTextureLayout, GFXPipelineBindPoint, GFXDynamicState, GFXStencilFace, GFXQueueType, GFXClearFlag, GFXObject = function() {
    function GFXObject(gfxType) {
        _classCallCheck(this, GFXObject), this._gfxType = exports.GFXObjectType.UNKNOWN, 
        this._status = exports.GFXStatus.UNREADY, this._gfxType = gfxType;
    }
    return _createClass(GFXObject, [ {
        key: "gfxType",
        get: function get() {
            return this._gfxType;
        }
    }, {
        key: "status",
        get: function get() {
            return this._status;
        }
    } ]), GFXObject;
}();

(GFXAttributeName = exports.GFXAttributeName || (exports.GFXAttributeName = {})).ATTR_POSITION = "a_position", 
GFXAttributeName.ATTR_NORMAL = "a_normal", GFXAttributeName.ATTR_TANGENT = "a_tangent", 
GFXAttributeName.ATTR_BITANGENT = "a_bitangent", GFXAttributeName.ATTR_WEIGHTS = "a_weights", 
GFXAttributeName.ATTR_JOINTS = "a_joints", GFXAttributeName.ATTR_COLOR = "a_color", 
GFXAttributeName.ATTR_COLOR1 = "a_color1", GFXAttributeName.ATTR_COLOR2 = "a_color2", 
GFXAttributeName.ATTR_TEX_COORD = "a_texCoord", GFXAttributeName.ATTR_TEX_COORD1 = "a_texCoord1", 
GFXAttributeName.ATTR_TEX_COORD2 = "a_texCoord2", GFXAttributeName.ATTR_TEX_COORD3 = "a_texCoord3", 
GFXAttributeName.ATTR_TEX_COORD4 = "a_texCoord4", GFXAttributeName.ATTR_TEX_COORD5 = "a_texCoord5", 
GFXAttributeName.ATTR_TEX_COORD6 = "a_texCoord6", GFXAttributeName.ATTR_TEX_COORD7 = "a_texCoord7", 
GFXAttributeName.ATTR_TEX_COORD8 = "a_texCoord8", GFXAttributeName.ATTR_BATCH_ID = "a_batch_id", 
GFXAttributeName.ATTR_BATCH_UV = "a_batch_uv", (GFXType = exports.GFXType || (exports.GFXType = {}))[GFXType.UNKNOWN = 0] = "UNKNOWN", 
GFXType[GFXType.BOOL = 1] = "BOOL", GFXType[GFXType.BOOL2 = 2] = "BOOL2", GFXType[GFXType.BOOL3 = 3] = "BOOL3", 
GFXType[GFXType.BOOL4 = 4] = "BOOL4", GFXType[GFXType.INT = 5] = "INT", GFXType[GFXType.INT2 = 6] = "INT2", 
GFXType[GFXType.INT3 = 7] = "INT3", GFXType[GFXType.INT4 = 8] = "INT4", GFXType[GFXType.UINT = 9] = "UINT", 
GFXType[GFXType.UINT2 = 10] = "UINT2", GFXType[GFXType.UINT3 = 11] = "UINT3", GFXType[GFXType.UINT4 = 12] = "UINT4", 
GFXType[GFXType.FLOAT = 13] = "FLOAT", GFXType[GFXType.FLOAT2 = 14] = "FLOAT2", 
GFXType[GFXType.FLOAT3 = 15] = "FLOAT3", GFXType[GFXType.FLOAT4 = 16] = "FLOAT4", 
GFXType[GFXType.MAT2 = 17] = "MAT2", GFXType[GFXType.MAT2X3 = 18] = "MAT2X3", GFXType[GFXType.MAT2X4 = 19] = "MAT2X4", 
GFXType[GFXType.MAT3X2 = 20] = "MAT3X2", GFXType[GFXType.MAT3 = 21] = "MAT3", GFXType[GFXType.MAT3X4 = 22] = "MAT3X4", 
GFXType[GFXType.MAT4X2 = 23] = "MAT4X2", GFXType[GFXType.MAT4X3 = 24] = "MAT4X3", 
GFXType[GFXType.MAT4 = 25] = "MAT4", GFXType[GFXType.SAMPLER1D = 26] = "SAMPLER1D", 
GFXType[GFXType.SAMPLER1D_ARRAY = 27] = "SAMPLER1D_ARRAY", GFXType[GFXType.SAMPLER2D = 28] = "SAMPLER2D", 
GFXType[GFXType.SAMPLER2D_ARRAY = 29] = "SAMPLER2D_ARRAY", GFXType[GFXType.SAMPLER3D = 30] = "SAMPLER3D", 
GFXType[GFXType.SAMPLER_CUBE = 31] = "SAMPLER_CUBE", GFXType[GFXType.COUNT = 32] = "COUNT", 
(GFXFormat = exports.GFXFormat || (exports.GFXFormat = {}))[GFXFormat.UNKNOWN = 0] = "UNKNOWN", 
GFXFormat[GFXFormat.A8 = 1] = "A8", GFXFormat[GFXFormat.L8 = 2] = "L8", GFXFormat[GFXFormat.LA8 = 3] = "LA8", 
GFXFormat[GFXFormat.R8 = 4] = "R8", GFXFormat[GFXFormat.R8SN = 5] = "R8SN", GFXFormat[GFXFormat.R8UI = 6] = "R8UI", 
GFXFormat[GFXFormat.R8I = 7] = "R8I", GFXFormat[GFXFormat.R16F = 8] = "R16F", GFXFormat[GFXFormat.R16UI = 9] = "R16UI", 
GFXFormat[GFXFormat.R16I = 10] = "R16I", GFXFormat[GFXFormat.R32F = 11] = "R32F", 
GFXFormat[GFXFormat.R32UI = 12] = "R32UI", GFXFormat[GFXFormat.R32I = 13] = "R32I", 
GFXFormat[GFXFormat.RG8 = 14] = "RG8", GFXFormat[GFXFormat.RG8SN = 15] = "RG8SN", 
GFXFormat[GFXFormat.RG8UI = 16] = "RG8UI", GFXFormat[GFXFormat.RG8I = 17] = "RG8I", 
GFXFormat[GFXFormat.RG16F = 18] = "RG16F", GFXFormat[GFXFormat.RG16UI = 19] = "RG16UI", 
GFXFormat[GFXFormat.RG16I = 20] = "RG16I", GFXFormat[GFXFormat.RG32F = 21] = "RG32F", 
GFXFormat[GFXFormat.RG32UI = 22] = "RG32UI", GFXFormat[GFXFormat.RG32I = 23] = "RG32I", 
GFXFormat[GFXFormat.RGB8 = 24] = "RGB8", GFXFormat[GFXFormat.SRGB8 = 25] = "SRGB8", 
GFXFormat[GFXFormat.RGB8SN = 26] = "RGB8SN", GFXFormat[GFXFormat.RGB8UI = 27] = "RGB8UI", 
GFXFormat[GFXFormat.RGB8I = 28] = "RGB8I", GFXFormat[GFXFormat.RGB16F = 29] = "RGB16F", 
GFXFormat[GFXFormat.RGB16UI = 30] = "RGB16UI", GFXFormat[GFXFormat.RGB16I = 31] = "RGB16I", 
GFXFormat[GFXFormat.RGB32F = 32] = "RGB32F", GFXFormat[GFXFormat.RGB32UI = 33] = "RGB32UI", 
GFXFormat[GFXFormat.RGB32I = 34] = "RGB32I", GFXFormat[GFXFormat.RGBA8 = 35] = "RGBA8", 
GFXFormat[GFXFormat.SRGB8_A8 = 36] = "SRGB8_A8", GFXFormat[GFXFormat.RGBA8SN = 37] = "RGBA8SN", 
GFXFormat[GFXFormat.RGBA8UI = 38] = "RGBA8UI", GFXFormat[GFXFormat.RGBA8I = 39] = "RGBA8I", 
GFXFormat[GFXFormat.RGBA16F = 40] = "RGBA16F", GFXFormat[GFXFormat.RGBA16UI = 41] = "RGBA16UI", 
GFXFormat[GFXFormat.RGBA16I = 42] = "RGBA16I", GFXFormat[GFXFormat.RGBA32F = 43] = "RGBA32F", 
GFXFormat[GFXFormat.RGBA32UI = 44] = "RGBA32UI", GFXFormat[GFXFormat.RGBA32I = 45] = "RGBA32I", 
GFXFormat[GFXFormat.R5G6B5 = 46] = "R5G6B5", GFXFormat[GFXFormat.R11G11B10F = 47] = "R11G11B10F", 
GFXFormat[GFXFormat.RGB5A1 = 48] = "RGB5A1", GFXFormat[GFXFormat.RGBA4 = 49] = "RGBA4", 
GFXFormat[GFXFormat.RGB10A2 = 50] = "RGB10A2", GFXFormat[GFXFormat.RGB10A2UI = 51] = "RGB10A2UI", 
GFXFormat[GFXFormat.RGB9E5 = 52] = "RGB9E5", GFXFormat[GFXFormat.D16 = 53] = "D16", 
GFXFormat[GFXFormat.D16S8 = 54] = "D16S8", GFXFormat[GFXFormat.D24 = 55] = "D24", 
GFXFormat[GFXFormat.D24S8 = 56] = "D24S8", GFXFormat[GFXFormat.D32F = 57] = "D32F", 
GFXFormat[GFXFormat.D32F_S8 = 58] = "D32F_S8", GFXFormat[GFXFormat.BC1 = 59] = "BC1", 
GFXFormat[GFXFormat.BC1_ALPHA = 60] = "BC1_ALPHA", GFXFormat[GFXFormat.BC1_SRGB = 61] = "BC1_SRGB", 
GFXFormat[GFXFormat.BC1_SRGB_ALPHA = 62] = "BC1_SRGB_ALPHA", GFXFormat[GFXFormat.BC2 = 63] = "BC2", 
GFXFormat[GFXFormat.BC2_SRGB = 64] = "BC2_SRGB", GFXFormat[GFXFormat.BC3 = 65] = "BC3", 
GFXFormat[GFXFormat.BC3_SRGB = 66] = "BC3_SRGB", GFXFormat[GFXFormat.BC4 = 67] = "BC4", 
GFXFormat[GFXFormat.BC4_SNORM = 68] = "BC4_SNORM", GFXFormat[GFXFormat.BC5 = 69] = "BC5", 
GFXFormat[GFXFormat.BC5_SNORM = 70] = "BC5_SNORM", GFXFormat[GFXFormat.BC6H_UF16 = 71] = "BC6H_UF16", 
GFXFormat[GFXFormat.BC6H_SF16 = 72] = "BC6H_SF16", GFXFormat[GFXFormat.BC7 = 73] = "BC7", 
GFXFormat[GFXFormat.BC7_SRGB = 74] = "BC7_SRGB", GFXFormat[GFXFormat.ETC_RGB8 = 75] = "ETC_RGB8", 
GFXFormat[GFXFormat.ETC2_RGB8 = 76] = "ETC2_RGB8", GFXFormat[GFXFormat.ETC2_SRGB8 = 77] = "ETC2_SRGB8", 
GFXFormat[GFXFormat.ETC2_RGB8_A1 = 78] = "ETC2_RGB8_A1", GFXFormat[GFXFormat.ETC2_SRGB8_A1 = 79] = "ETC2_SRGB8_A1", 
GFXFormat[GFXFormat.ETC2_RGBA8 = 80] = "ETC2_RGBA8", GFXFormat[GFXFormat.ETC2_SRGB8_A8 = 81] = "ETC2_SRGB8_A8", 
GFXFormat[GFXFormat.EAC_R11 = 82] = "EAC_R11", GFXFormat[GFXFormat.EAC_R11SN = 83] = "EAC_R11SN", 
GFXFormat[GFXFormat.EAC_RG11 = 84] = "EAC_RG11", GFXFormat[GFXFormat.EAC_RG11SN = 85] = "EAC_RG11SN", 
GFXFormat[GFXFormat.PVRTC_RGB2 = 86] = "PVRTC_RGB2", GFXFormat[GFXFormat.PVRTC_RGBA2 = 87] = "PVRTC_RGBA2", 
GFXFormat[GFXFormat.PVRTC_RGB4 = 88] = "PVRTC_RGB4", GFXFormat[GFXFormat.PVRTC_RGBA4 = 89] = "PVRTC_RGBA4", 
GFXFormat[GFXFormat.PVRTC2_2BPP = 90] = "PVRTC2_2BPP", GFXFormat[GFXFormat.PVRTC2_4BPP = 91] = "PVRTC2_4BPP", 
(GFXBufferUsageBit = exports.GFXBufferUsageBit || (exports.GFXBufferUsageBit = {}))[GFXBufferUsageBit.NONE = 0] = "NONE", 
GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", GFXBufferUsageBit[GFXBufferUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", 
GFXBufferUsageBit[GFXBufferUsageBit.INDEX = 4] = "INDEX", GFXBufferUsageBit[GFXBufferUsageBit.VERTEX = 8] = "VERTEX", 
GFXBufferUsageBit[GFXBufferUsageBit.UNIFORM = 16] = "UNIFORM", GFXBufferUsageBit[GFXBufferUsageBit.STORAGE = 32] = "STORAGE", 
GFXBufferUsageBit[GFXBufferUsageBit.INDIRECT = 64] = "INDIRECT", (GFXMemoryUsageBit = exports.GFXMemoryUsageBit || (exports.GFXMemoryUsageBit = {}))[GFXMemoryUsageBit.NONE = 0] = "NONE", 
GFXMemoryUsageBit[GFXMemoryUsageBit.DEVICE = 1] = "DEVICE", GFXMemoryUsageBit[GFXMemoryUsageBit.HOST = 2] = "HOST", 
(GFXBufferFlagBit = exports.GFXBufferFlagBit || (exports.GFXBufferFlagBit = {}))[GFXBufferFlagBit.NONE = 0] = "NONE", 
GFXBufferFlagBit[GFXBufferFlagBit.BAKUP_BUFFER = 4] = "BAKUP_BUFFER", (GFXBufferAccessBit = exports.GFXBufferAccessBit || (exports.GFXBufferAccessBit = {}))[GFXBufferAccessBit.NONE = 0] = "NONE", 
GFXBufferAccessBit[GFXBufferAccessBit.READ = 1] = "READ", GFXBufferAccessBit[GFXBufferAccessBit.WRITE = 2] = "WRITE", 
(GFXPrimitiveMode = exports.GFXPrimitiveMode || (exports.GFXPrimitiveMode = {}))[GFXPrimitiveMode.POINT_LIST = 0] = "POINT_LIST", 
GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST = 1] = "LINE_LIST", GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP = 2] = "LINE_STRIP", 
GFXPrimitiveMode[GFXPrimitiveMode.LINE_LOOP = 3] = "LINE_LOOP", GFXPrimitiveMode[GFXPrimitiveMode.LINE_LIST_ADJACENCY = 4] = "LINE_LIST_ADJACENCY", 
GFXPrimitiveMode[GFXPrimitiveMode.LINE_STRIP_ADJACENCY = 5] = "LINE_STRIP_ADJACENCY", 
GFXPrimitiveMode[GFXPrimitiveMode.ISO_LINE_LIST = 6] = "ISO_LINE_LIST", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST = 7] = "TRIANGLE_LIST", 
GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP = 8] = "TRIANGLE_STRIP", GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_FAN = 9] = "TRIANGLE_FAN", 
GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_LIST_ADJACENCY = 10] = "TRIANGLE_LIST_ADJACENCY", 
GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_STRIP_ADJACENCY = 11] = "TRIANGLE_STRIP_ADJACENCY", 
GFXPrimitiveMode[GFXPrimitiveMode.TRIANGLE_PATCH_ADJACENCY = 12] = "TRIANGLE_PATCH_ADJACENCY", 
GFXPrimitiveMode[GFXPrimitiveMode.QUAD_PATCH_LIST = 13] = "QUAD_PATCH_LIST", (GFXPolygonMode = exports.GFXPolygonMode || (exports.GFXPolygonMode = {}))[GFXPolygonMode.FILL = 0] = "FILL", 
GFXPolygonMode[GFXPolygonMode.POINT = 1] = "POINT", GFXPolygonMode[GFXPolygonMode.LINE = 2] = "LINE", 
(GFXShadeModel = exports.GFXShadeModel || (exports.GFXShadeModel = {}))[GFXShadeModel.GOURAND = 0] = "GOURAND", 
GFXShadeModel[GFXShadeModel.FLAT = 1] = "FLAT", (GFXCullMode = exports.GFXCullMode || (exports.GFXCullMode = {}))[GFXCullMode.NONE = 0] = "NONE", 
GFXCullMode[GFXCullMode.FRONT = 1] = "FRONT", GFXCullMode[GFXCullMode.BACK = 2] = "BACK", 
(GFXComparisonFunc = exports.GFXComparisonFunc || (exports.GFXComparisonFunc = {}))[GFXComparisonFunc.NEVER = 0] = "NEVER", 
GFXComparisonFunc[GFXComparisonFunc.LESS = 1] = "LESS", GFXComparisonFunc[GFXComparisonFunc.EQUAL = 2] = "EQUAL", 
GFXComparisonFunc[GFXComparisonFunc.LESS_EQUAL = 3] = "LESS_EQUAL", GFXComparisonFunc[GFXComparisonFunc.GREATER = 4] = "GREATER", 
GFXComparisonFunc[GFXComparisonFunc.NOT_EQUAL = 5] = "NOT_EQUAL", GFXComparisonFunc[GFXComparisonFunc.GREATER_EQUAL = 6] = "GREATER_EQUAL", 
GFXComparisonFunc[GFXComparisonFunc.ALWAYS = 7] = "ALWAYS", (GFXStencilOp = exports.GFXStencilOp || (exports.GFXStencilOp = {}))[GFXStencilOp.ZERO = 0] = "ZERO", 
GFXStencilOp[GFXStencilOp.KEEP = 1] = "KEEP", GFXStencilOp[GFXStencilOp.REPLACE = 2] = "REPLACE", 
GFXStencilOp[GFXStencilOp.INCR = 3] = "INCR", GFXStencilOp[GFXStencilOp.DECR = 4] = "DECR", 
GFXStencilOp[GFXStencilOp.INVERT = 5] = "INVERT", GFXStencilOp[GFXStencilOp.INCR_WRAP = 6] = "INCR_WRAP", 
GFXStencilOp[GFXStencilOp.DECR_WRAP = 7] = "DECR_WRAP", (GFXBlendOp = exports.GFXBlendOp || (exports.GFXBlendOp = {}))[GFXBlendOp.ADD = 0] = "ADD", 
GFXBlendOp[GFXBlendOp.SUB = 1] = "SUB", GFXBlendOp[GFXBlendOp.REV_SUB = 2] = "REV_SUB", 
GFXBlendOp[GFXBlendOp.MIN = 3] = "MIN", GFXBlendOp[GFXBlendOp.MAX = 4] = "MAX", 
(GFXBlendFactor = exports.GFXBlendFactor || (exports.GFXBlendFactor = {}))[GFXBlendFactor.ZERO = 0] = "ZERO", 
GFXBlendFactor[GFXBlendFactor.ONE = 1] = "ONE", GFXBlendFactor[GFXBlendFactor.SRC_ALPHA = 2] = "SRC_ALPHA", 
GFXBlendFactor[GFXBlendFactor.DST_ALPHA = 3] = "DST_ALPHA", GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_ALPHA = 4] = "ONE_MINUS_SRC_ALPHA", 
GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_ALPHA = 5] = "ONE_MINUS_DST_ALPHA", 
GFXBlendFactor[GFXBlendFactor.SRC_COLOR = 6] = "SRC_COLOR", GFXBlendFactor[GFXBlendFactor.DST_COLOR = 7] = "DST_COLOR", 
GFXBlendFactor[GFXBlendFactor.ONE_MINUS_SRC_COLOR = 8] = "ONE_MINUS_SRC_COLOR", 
GFXBlendFactor[GFXBlendFactor.ONE_MINUS_DST_COLOR = 9] = "ONE_MINUS_DST_COLOR", 
GFXBlendFactor[GFXBlendFactor.SRC_ALPHA_SATURATE = 10] = "SRC_ALPHA_SATURATE", GFXBlendFactor[GFXBlendFactor.CONSTANT_COLOR = 11] = "CONSTANT_COLOR", 
GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_COLOR = 12] = "ONE_MINUS_CONSTANT_COLOR", 
GFXBlendFactor[GFXBlendFactor.CONSTANT_ALPHA = 13] = "CONSTANT_ALPHA", GFXBlendFactor[GFXBlendFactor.ONE_MINUS_CONSTANT_ALPHA = 14] = "ONE_MINUS_CONSTANT_ALPHA", 
(GFXColorMask = exports.GFXColorMask || (exports.GFXColorMask = {}))[GFXColorMask.NONE = 0] = "NONE", 
GFXColorMask[GFXColorMask.R = 1] = "R", GFXColorMask[GFXColorMask.G = 2] = "G", 
GFXColorMask[GFXColorMask.B = 4] = "B", GFXColorMask[GFXColorMask.A = 8] = "A", 
GFXColorMask[GFXColorMask.ALL = 15] = "ALL", (GFXFilter = exports.GFXFilter || (exports.GFXFilter = {}))[GFXFilter.NONE = 0] = "NONE", 
GFXFilter[GFXFilter.POINT = 1] = "POINT", GFXFilter[GFXFilter.LINEAR = 2] = "LINEAR", 
GFXFilter[GFXFilter.ANISOTROPIC = 3] = "ANISOTROPIC", (GFXAddress = exports.GFXAddress || (exports.GFXAddress = {}))[GFXAddress.WRAP = 0] = "WRAP", 
GFXAddress[GFXAddress.MIRROR = 1] = "MIRROR", GFXAddress[GFXAddress.CLAMP = 2] = "CLAMP", 
GFXAddress[GFXAddress.BORDER = 3] = "BORDER", (GFXTextureType = exports.GFXTextureType || (exports.GFXTextureType = {}))[GFXTextureType.TEX1D = 0] = "TEX1D", 
GFXTextureType[GFXTextureType.TEX2D = 1] = "TEX2D", GFXTextureType[GFXTextureType.TEX3D = 2] = "TEX3D", 
(GFXTextureUsageBit = exports.GFXTextureUsageBit || (exports.GFXTextureUsageBit = {}))[GFXTextureUsageBit.NONE = 0] = "NONE", 
GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_SRC = 1] = "TRANSFER_SRC", GFXTextureUsageBit[GFXTextureUsageBit.TRANSFER_DST = 2] = "TRANSFER_DST", 
GFXTextureUsageBit[GFXTextureUsageBit.SAMPLED = 4] = "SAMPLED", GFXTextureUsageBit[GFXTextureUsageBit.STORAGE = 8] = "STORAGE", 
GFXTextureUsageBit[GFXTextureUsageBit.COLOR_ATTACHMENT = 16] = "COLOR_ATTACHMENT", 
GFXTextureUsageBit[GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT = 32] = "DEPTH_STENCIL_ATTACHMENT", 
GFXTextureUsageBit[GFXTextureUsageBit.TRANSIENT_ATTACHMENT = 64] = "TRANSIENT_ATTACHMENT", 
GFXTextureUsageBit[GFXTextureUsageBit.INPUT_ATTACHMENT = 128] = "INPUT_ATTACHMENT", 
(GFXSampleCount = exports.GFXSampleCount || (exports.GFXSampleCount = {}))[GFXSampleCount.X1 = 0] = "X1", 
GFXSampleCount[GFXSampleCount.X2 = 1] = "X2", GFXSampleCount[GFXSampleCount.X4 = 2] = "X4", 
GFXSampleCount[GFXSampleCount.X8 = 3] = "X8", GFXSampleCount[GFXSampleCount.X16 = 4] = "X16", 
GFXSampleCount[GFXSampleCount.X32 = 5] = "X32", GFXSampleCount[GFXSampleCount.X64 = 6] = "X64", 
(GFXTextureFlagBit = exports.GFXTextureFlagBit || (exports.GFXTextureFlagBit = {}))[GFXTextureFlagBit.NONE = 0] = "NONE", 
GFXTextureFlagBit[GFXTextureFlagBit.GEN_MIPMAP = 1] = "GEN_MIPMAP", GFXTextureFlagBit[GFXTextureFlagBit.CUBEMAP = 2] = "CUBEMAP", 
GFXTextureFlagBit[GFXTextureFlagBit.BAKUP_BUFFER = 4] = "BAKUP_BUFFER", (GFXTextureViewType = exports.GFXTextureViewType || (exports.GFXTextureViewType = {}))[GFXTextureViewType.TV1D = 0] = "TV1D", 
GFXTextureViewType[GFXTextureViewType.TV2D = 1] = "TV2D", GFXTextureViewType[GFXTextureViewType.TV3D = 2] = "TV3D", 
GFXTextureViewType[GFXTextureViewType.CUBE = 3] = "CUBE", GFXTextureViewType[GFXTextureViewType.TV1D_ARRAY = 4] = "TV1D_ARRAY", 
GFXTextureViewType[GFXTextureViewType.TV2D_ARRAY = 5] = "TV2D_ARRAY", (GFXShaderType = exports.GFXShaderType || (exports.GFXShaderType = {}))[GFXShaderType.VERTEX = 0] = "VERTEX", 
GFXShaderType[GFXShaderType.HULL = 1] = "HULL", GFXShaderType[GFXShaderType.DOMAIN = 2] = "DOMAIN", 
GFXShaderType[GFXShaderType.GEOMETRY = 3] = "GEOMETRY", GFXShaderType[GFXShaderType.FRAGMENT = 4] = "FRAGMENT", 
GFXShaderType[GFXShaderType.COMPUTE = 5] = "COMPUTE", GFXShaderType[GFXShaderType.COUNT = 6] = "COUNT", 
(GFXBindingType = exports.GFXBindingType || (exports.GFXBindingType = {}))[GFXBindingType.UNKNOWN = 0] = "UNKNOWN", 
GFXBindingType[GFXBindingType.UNIFORM_BUFFER = 1] = "UNIFORM_BUFFER", GFXBindingType[GFXBindingType.SAMPLER = 2] = "SAMPLER", 
GFXBindingType[GFXBindingType.STORAGE_BUFFER = 3] = "STORAGE_BUFFER", (GFXCommandBufferType = exports.GFXCommandBufferType || (exports.GFXCommandBufferType = {}))[GFXCommandBufferType.PRIMARY = 0] = "PRIMARY", 
GFXCommandBufferType[GFXCommandBufferType.SECONDARY = 1] = "SECONDARY", (GFXLoadOp = exports.GFXLoadOp || (exports.GFXLoadOp = {}))[GFXLoadOp.LOAD = 0] = "LOAD", 
GFXLoadOp[GFXLoadOp.CLEAR = 1] = "CLEAR", GFXLoadOp[GFXLoadOp.DISCARD = 2] = "DISCARD", 
(GFXStoreOp = exports.GFXStoreOp || (exports.GFXStoreOp = {}))[GFXStoreOp.STORE = 0] = "STORE", 
GFXStoreOp[GFXStoreOp.DISCARD = 1] = "DISCARD", (GFXTextureLayout = exports.GFXTextureLayout || (exports.GFXTextureLayout = {}))[GFXTextureLayout.UNDEFINED = 0] = "UNDEFINED", 
GFXTextureLayout[GFXTextureLayout.GENERAL = 1] = "GENERAL", GFXTextureLayout[GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL = 2] = "COLOR_ATTACHMENT_OPTIMAL", 
GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3] = "DEPTH_STENCIL_ATTACHMENT_OPTIMAL", 
GFXTextureLayout[GFXTextureLayout.DEPTH_STENCIL_READONLY_OPTIMAL = 4] = "DEPTH_STENCIL_READONLY_OPTIMAL", 
GFXTextureLayout[GFXTextureLayout.SHADER_READONLY_OPTIMAL = 5] = "SHADER_READONLY_OPTIMAL", 
GFXTextureLayout[GFXTextureLayout.TRANSFER_SRC_OPTIMAL = 6] = "TRANSFER_SRC_OPTIMAL", 
GFXTextureLayout[GFXTextureLayout.TRANSFER_DST_OPTIMAL = 7] = "TRANSFER_DST_OPTIMAL", 
GFXTextureLayout[GFXTextureLayout.PREINITIALIZED = 8] = "PREINITIALIZED", GFXTextureLayout[GFXTextureLayout.PRESENT_SRC = 9] = "PRESENT_SRC", 
(GFXPipelineBindPoint = exports.GFXPipelineBindPoint || (exports.GFXPipelineBindPoint = {}))[GFXPipelineBindPoint.GRAPHICS = 0] = "GRAPHICS", 
GFXPipelineBindPoint[GFXPipelineBindPoint.COMPUTE = 1] = "COMPUTE", GFXPipelineBindPoint[GFXPipelineBindPoint.RAY_TRACING = 2] = "RAY_TRACING", 
(GFXDynamicState = exports.GFXDynamicState || (exports.GFXDynamicState = {}))[GFXDynamicState.VIEWPORT = 0] = "VIEWPORT", 
GFXDynamicState[GFXDynamicState.SCISSOR = 1] = "SCISSOR", GFXDynamicState[GFXDynamicState.LINE_WIDTH = 2] = "LINE_WIDTH", 
GFXDynamicState[GFXDynamicState.DEPTH_BIAS = 3] = "DEPTH_BIAS", GFXDynamicState[GFXDynamicState.BLEND_CONSTANTS = 4] = "BLEND_CONSTANTS", 
GFXDynamicState[GFXDynamicState.DEPTH_BOUNDS = 5] = "DEPTH_BOUNDS", GFXDynamicState[GFXDynamicState.STENCIL_WRITE_MASK = 6] = "STENCIL_WRITE_MASK", 
GFXDynamicState[GFXDynamicState.STENCIL_COMPARE_MASK = 7] = "STENCIL_COMPARE_MASK", 
(GFXStencilFace = exports.GFXStencilFace || (exports.GFXStencilFace = {}))[GFXStencilFace.FRONT = 0] = "FRONT", 
GFXStencilFace[GFXStencilFace.BACK = 1] = "BACK", GFXStencilFace[GFXStencilFace.ALL = 2] = "ALL", 
(GFXQueueType = exports.GFXQueueType || (exports.GFXQueueType = {}))[GFXQueueType.GRAPHICS = 0] = "GRAPHICS", 
GFXQueueType[GFXQueueType.COMPUTE = 1] = "COMPUTE", GFXQueueType[GFXQueueType.TRANSFER = 2] = "TRANSFER", 
(GFXClearFlag = exports.GFXClearFlag || (exports.GFXClearFlag = {}))[GFXClearFlag.NONE = 0] = "NONE", 
GFXClearFlag[GFXClearFlag.COLOR = 1] = "COLOR", GFXClearFlag[GFXClearFlag.DEPTH = 2] = "DEPTH", 
GFXClearFlag[GFXClearFlag.STENCIL = 4] = "STENCIL", GFXClearFlag[GFXClearFlag.DEPTH_STENCIL = 6] = "DEPTH_STENCIL", 
GFXClearFlag[GFXClearFlag.ALL = 7] = "ALL";

var GFXFormatType, GFXTextureSubres = function GFXTextureSubres() {
    _classCallCheck(this, GFXTextureSubres), this.baseMipLevel = 0, this.levelCount = 1, 
    this.baseArrayLayer = 0, this.layerCount = 1;
}, GFXTextureCopy = function GFXTextureCopy() {
    _classCallCheck(this, GFXTextureCopy), this.srcSubres = new GFXTextureSubres, this.srcOffset = {
        x: 0,
        y: 0,
        z: 0
    }, this.dstSubres = new GFXTextureSubres, this.dstOffset = {
        x: 0,
        y: 0,
        z: 0
    }, this.extent = {
        width: 0,
        height: 0,
        depth: 0
    };
}, GFXBufferTextureCopy = function GFXBufferTextureCopy() {
    _classCallCheck(this, GFXBufferTextureCopy), this.buffOffset = 0, this.buffStride = 0, 
    this.buffTexHeight = 0, this.texOffset = {
        x: 0,
        y: 0,
        z: 0
    }, this.texExtent = {
        width: 0,
        height: 0,
        depth: 0
    }, this.texSubres = new GFXTextureSubres;
};

(GFXFormatType = exports.GFXFormatType || (exports.GFXFormatType = {}))[GFXFormatType.NONE = 0] = "NONE", 
GFXFormatType[GFXFormatType.UNORM = 1] = "UNORM", GFXFormatType[GFXFormatType.SNORM = 2] = "SNORM", 
GFXFormatType[GFXFormatType.UINT = 3] = "UINT", GFXFormatType[GFXFormatType.INT = 4] = "INT", 
GFXFormatType[GFXFormatType.UFLOAT = 5] = "UFLOAT", GFXFormatType[GFXFormatType.FLOAT = 6] = "FLOAT";

var GFXFormatInfos = [ {
    name: "UNKNOWN",
    size: 0,
    count: 0,
    type: exports.GFXFormatType.NONE,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "A8",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "L8",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "LA8",
    size: 1,
    count: 2,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R8",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R8SN",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R8UI",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R8I",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R16F",
    size: 2,
    count: 1,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R16UI",
    size: 2,
    count: 1,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R16I",
    size: 2,
    count: 1,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R32F",
    size: 4,
    count: 1,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R32UI",
    size: 4,
    count: 1,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R32I",
    size: 4,
    count: 1,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG8",
    size: 2,
    count: 2,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG8SN",
    size: 2,
    count: 2,
    type: exports.GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG8UI",
    size: 2,
    count: 2,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG8I",
    size: 2,
    count: 2,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG16F",
    size: 4,
    count: 2,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG16UI",
    size: 4,
    count: 2,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG16I",
    size: 4,
    count: 2,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG32F",
    size: 8,
    count: 2,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG32UI",
    size: 8,
    count: 2,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RG32I",
    size: 8,
    count: 2,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB8",
    size: 3,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "SRGB8",
    size: 3,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB8SN",
    size: 3,
    count: 3,
    type: exports.GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB8UI",
    size: 3,
    count: 3,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB8I",
    size: 3,
    count: 3,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB16F",
    size: 6,
    count: 3,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB16UI",
    size: 6,
    count: 3,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB16I",
    size: 6,
    count: 3,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB32F",
    size: 12,
    count: 3,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB32UI",
    size: 12,
    count: 3,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB32I",
    size: 12,
    count: 3,
    type: exports.GFXFormatType.INT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA8",
    size: 4,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "SRGB8_A8",
    size: 4,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA8SN",
    size: 4,
    count: 4,
    type: exports.GFXFormatType.SNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA8UI",
    size: 4,
    count: 4,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA8I",
    size: 4,
    count: 4,
    type: exports.GFXFormatType.INT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA16F",
    size: 8,
    count: 4,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA16UI",
    size: 8,
    count: 4,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA16I",
    size: 8,
    count: 4,
    type: exports.GFXFormatType.INT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA32F",
    size: 16,
    count: 4,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA32UI",
    size: 16,
    count: 4,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA32I",
    size: 16,
    count: 4,
    type: exports.GFXFormatType.INT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R5G6B5",
    size: 2,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "R11G11B10F",
    size: 4,
    count: 3,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB5A1",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGBA4",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB10A2",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB10A2UI",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "RGB9E5",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "D16",
    size: 2,
    count: 1,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "D16S8",
    size: 3,
    count: 2,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !0,
    isCompressed: !1
}, {
    name: "D24",
    size: 3,
    count: 1,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "D24S8",
    size: 4,
    count: 2,
    type: exports.GFXFormatType.UINT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !0,
    isCompressed: !1
}, {
    name: "D32F",
    size: 4,
    count: 1,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !1,
    isCompressed: !1
}, {
    name: "D32FS8",
    size: 5,
    count: 2,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !0,
    hasStencil: !0,
    isCompressed: !1
}, {
    name: "BC1",
    size: 1,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC1_ALPHA",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC1_SRGB",
    size: 1,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC1_SRGB_ALPHA",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC2",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC2_SRGB",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC3",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC3_SRGB",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC4",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC4_SNORM",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC5",
    size: 1,
    count: 2,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC5_SNORM",
    size: 1,
    count: 2,
    type: exports.GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC6H_UF16",
    size: 1,
    count: 3,
    type: exports.GFXFormatType.UFLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC6H_SF16",
    size: 1,
    count: 3,
    type: exports.GFXFormatType.FLOAT,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC7",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "BC7_SRGB",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC_RGB8",
    size: 1,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_RGB8",
    size: 1,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_SRGB8",
    size: 1,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_RGB8_A1",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_SRGB8_A1",
    size: 1,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_RGBA8",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "ETC2_SRGB8_A8",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "EAC_R11",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "EAC_R11SN",
    size: 1,
    count: 1,
    type: exports.GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "EAC_RG11",
    size: 2,
    count: 2,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "EAC_RG11SN",
    size: 2,
    count: 2,
    type: exports.GFXFormatType.SNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC_RGB2",
    size: 2,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC_RGBA2",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC_RGB4",
    size: 2,
    count: 3,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !1,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC_RGBA4",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC2_2BPP",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
}, {
    name: "PVRTC2_4BPP",
    size: 2,
    count: 4,
    type: exports.GFXFormatType.UNORM,
    hasAlpha: !0,
    hasDepth: !1,
    hasStencil: !1,
    isCompressed: !0
} ];

function GFXFormatSize(format, width, height, depth) {
    if (!GFXFormatInfos[format].isCompressed) return width * height * depth * GFXFormatInfos[format].size;
    switch (format) {
      case exports.GFXFormat.BC1:
      case exports.GFXFormat.BC1_ALPHA:
      case exports.GFXFormat.BC1_SRGB:
      case exports.GFXFormat.BC1_SRGB_ALPHA:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

      case exports.GFXFormat.BC2:
      case exports.GFXFormat.BC2_SRGB:
      case exports.GFXFormat.BC3:
      case exports.GFXFormat.BC3_SRGB:
      case exports.GFXFormat.BC4:
      case exports.GFXFormat.BC4_SNORM:
      case exports.GFXFormat.BC6H_SF16:
      case exports.GFXFormat.BC6H_UF16:
      case exports.GFXFormat.BC7:
      case exports.GFXFormat.BC7_SRGB:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

      case exports.GFXFormat.BC5:
      case exports.GFXFormat.BC5_SNORM:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

      case exports.GFXFormat.ETC_RGB8:
      case exports.GFXFormat.ETC2_RGB8:
      case exports.GFXFormat.ETC2_SRGB8:
      case exports.GFXFormat.ETC2_RGB8_A1:
      case exports.GFXFormat.ETC2_SRGB8_A1:
      case exports.GFXFormat.EAC_R11:
      case exports.GFXFormat.EAC_R11SN:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

      case exports.GFXFormat.ETC2_RGBA8:
      case exports.GFXFormat.EAC_RG11:
      case exports.GFXFormat.EAC_RG11SN:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

      case exports.GFXFormat.PVRTC_RGB2:
      case exports.GFXFormat.PVRTC_RGBA2:
      case exports.GFXFormat.PVRTC2_2BPP:
        return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

      case exports.GFXFormat.PVRTC_RGB4:
      case exports.GFXFormat.PVRTC_RGBA4:
      case exports.GFXFormat.PVRTC2_4BPP:
        return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 2) * depth;

      default:
        return 0;
    }
}

function GFXFormatSurfaceSize(format, width, height, depth, mips) {
    for (var size = 0, i = 0; i < mips; ++i) size += GFXFormatSize(format, width, height, depth), 
    width = Math.max(width >> 1, 1), height = Math.max(height >> 1, 1);
    return size;
}

var _type2size = [ 0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4 ];

function GFXGetTypeSize(type) {
    return _type2size[type] || 0;
}

function getTypedArrayConstructor(info) {
    var stride = info.size / info.count;
    switch (info.type) {
      case exports.GFXFormatType.UNORM:
      case exports.GFXFormatType.UINT:
        switch (stride) {
          case 1:
            return Uint8Array;

          case 2:
            return Uint16Array;

          case 4:
            return Uint32Array;
        }
        break;

      case exports.GFXFormatType.SNORM:
      case exports.GFXFormatType.INT:
        switch (stride) {
          case 1:
            return Int8Array;

          case 2:
            return Int16Array;

          case 4:
            return Int32Array;
        }
        break;

      case exports.GFXFormatType.FLOAT:
        return Float32Array;
    }
    return Float32Array;
}

var GFXAPI, GFXFeature, GFXDefines = Object.freeze({
    __proto__: null,
    GFX_MAX_VERTEX_ATTRIBUTES: 16,
    GFX_MAX_TEXTURE_UNITS: 16,
    GFX_MAX_ATTACHMENTS: 4,
    GFX_MAX_BUFFER_BINDINGS: 24,
    get GFXObjectType() {
        return exports.GFXObjectType;
    },
    get GFXStatus() {
        return exports.GFXStatus;
    },
    GFXObject: GFXObject,
    get GFXAttributeName() {
        return exports.GFXAttributeName;
    },
    get GFXType() {
        return exports.GFXType;
    },
    get GFXFormat() {
        return exports.GFXFormat;
    },
    get GFXBufferUsageBit() {
        return exports.GFXBufferUsageBit;
    },
    get GFXMemoryUsageBit() {
        return exports.GFXMemoryUsageBit;
    },
    get GFXBufferFlagBit() {
        return exports.GFXBufferFlagBit;
    },
    get GFXBufferAccessBit() {
        return exports.GFXBufferAccessBit;
    },
    get GFXPrimitiveMode() {
        return exports.GFXPrimitiveMode;
    },
    get GFXPolygonMode() {
        return exports.GFXPolygonMode;
    },
    get GFXShadeModel() {
        return exports.GFXShadeModel;
    },
    get GFXCullMode() {
        return exports.GFXCullMode;
    },
    get GFXComparisonFunc() {
        return exports.GFXComparisonFunc;
    },
    get GFXStencilOp() {
        return exports.GFXStencilOp;
    },
    get GFXBlendOp() {
        return exports.GFXBlendOp;
    },
    get GFXBlendFactor() {
        return exports.GFXBlendFactor;
    },
    get GFXColorMask() {
        return exports.GFXColorMask;
    },
    get GFXFilter() {
        return exports.GFXFilter;
    },
    get GFXAddress() {
        return exports.GFXAddress;
    },
    get GFXTextureType() {
        return exports.GFXTextureType;
    },
    get GFXTextureUsageBit() {
        return exports.GFXTextureUsageBit;
    },
    get GFXSampleCount() {
        return exports.GFXSampleCount;
    },
    get GFXTextureFlagBit() {
        return exports.GFXTextureFlagBit;
    },
    get GFXTextureViewType() {
        return exports.GFXTextureViewType;
    },
    get GFXShaderType() {
        return exports.GFXShaderType;
    },
    get GFXBindingType() {
        return exports.GFXBindingType;
    },
    get GFXCommandBufferType() {
        return exports.GFXCommandBufferType;
    },
    get GFXLoadOp() {
        return exports.GFXLoadOp;
    },
    get GFXStoreOp() {
        return exports.GFXStoreOp;
    },
    get GFXTextureLayout() {
        return exports.GFXTextureLayout;
    },
    get GFXPipelineBindPoint() {
        return exports.GFXPipelineBindPoint;
    },
    get GFXDynamicState() {
        return exports.GFXDynamicState;
    },
    get GFXStencilFace() {
        return exports.GFXStencilFace;
    },
    get GFXQueueType() {
        return exports.GFXQueueType;
    },
    get GFXClearFlag() {
        return exports.GFXClearFlag;
    },
    GFXTextureSubres: GFXTextureSubres,
    GFXTextureCopy: GFXTextureCopy,
    GFXBufferTextureCopy: GFXBufferTextureCopy,
    get GFXFormatType() {
        return exports.GFXFormatType;
    },
    GFXFormatInfos: GFXFormatInfos,
    GFXFormatSize: GFXFormatSize,
    GFXFormatSurfaceSize: GFXFormatSurfaceSize,
    GFXGetTypeSize: GFXGetTypeSize,
    getTypedArrayConstructor: getTypedArrayConstructor
}), GFXBuffer = function(_GFXObject) {
    function GFXBuffer(device) {
        var _this;
        return _classCallCheck(this, GFXBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBuffer).call(this, exports.GFXObjectType.BUFFER)))._device = void 0, 
        _this._usage = exports.GFXBufferUsageBit.NONE, _this._memUsage = exports.GFXMemoryUsageBit.NONE, 
        _this._size = 0, _this._stride = 1, _this._count = 0, _this._flags = exports.GFXBufferFlagBit.NONE, 
        _this._bufferView = null, _this._indirectBuffer = null, _this._device = device, 
        _this;
    }
    return _inherits(GFXBuffer, GFXObject), _createClass(GFXBuffer, [ {
        key: "usage",
        get: function get() {
            return this._usage;
        }
    }, {
        key: "memUsage",
        get: function get() {
            return this._memUsage;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        }
    }, {
        key: "stride",
        get: function get() {
            return this._stride;
        }
    }, {
        key: "count",
        get: function get() {
            return this._count;
        }
    }, {
        key: "flags",
        get: function get() {
            return this._flags;
        }
    }, {
        key: "bufferView",
        get: function get() {
            return this._bufferView;
        }
    } ]), GFXBuffer;
}(), GFXCommandBuffer = function(_GFXObject) {
    function GFXCommandBuffer(device) {
        var _this;
        return _classCallCheck(this, GFXCommandBuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandBuffer).call(this, exports.GFXObjectType.COMMAND_BUFFER)))._device = void 0, 
        _this._allocator = null, _this._type = exports.GFXCommandBufferType.PRIMARY, _this._numDrawCalls = 0, 
        _this._numInstances = 0, _this._numTris = 0, _this._device = device, _this;
    }
    return _inherits(GFXCommandBuffer, GFXObject), _createClass(GFXCommandBuffer, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    }, {
        key: "numDrawCalls",
        get: function get() {
            return this._numDrawCalls;
        }
    }, {
        key: "numInstances",
        get: function get() {
            return this._numInstances;
        }
    }, {
        key: "numTris",
        get: function get() {
            return this._numTris;
        }
    } ]), GFXCommandBuffer;
}();

ccenum(exports.GFXFormat), (GFXAPI = exports.GFXAPI || (exports.GFXAPI = {}))[GFXAPI.UNKNOWN = 0] = "UNKNOWN", 
GFXAPI[GFXAPI.WEBGL = 1] = "WEBGL", GFXAPI[GFXAPI.WEBGL2 = 2] = "WEBGL2", (GFXFeature = exports.GFXFeature || (exports.GFXFeature = {}))[GFXFeature.COLOR_FLOAT = 0] = "COLOR_FLOAT", 
GFXFeature[GFXFeature.COLOR_HALF_FLOAT = 1] = "COLOR_HALF_FLOAT", GFXFeature[GFXFeature.TEXTURE_FLOAT = 2] = "TEXTURE_FLOAT", 
GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT = 3] = "TEXTURE_HALF_FLOAT", GFXFeature[GFXFeature.TEXTURE_FLOAT_LINEAR = 4] = "TEXTURE_FLOAT_LINEAR", 
GFXFeature[GFXFeature.TEXTURE_HALF_FLOAT_LINEAR = 5] = "TEXTURE_HALF_FLOAT_LINEAR", 
GFXFeature[GFXFeature.FORMAT_R11G11B10F = 6] = "FORMAT_R11G11B10F", GFXFeature[GFXFeature.FORMAT_D24S8 = 7] = "FORMAT_D24S8", 
GFXFeature[GFXFeature.FORMAT_ETC1 = 8] = "FORMAT_ETC1", GFXFeature[GFXFeature.FORMAT_ETC2 = 9] = "FORMAT_ETC2", 
GFXFeature[GFXFeature.FORMAT_DXT = 10] = "FORMAT_DXT", GFXFeature[GFXFeature.FORMAT_PVRTC = 11] = "FORMAT_PVRTC", 
GFXFeature[GFXFeature.FORMAT_ASTC = 12] = "FORMAT_ASTC", GFXFeature[GFXFeature.MSAA = 13] = "MSAA", 
GFXFeature[GFXFeature.ELEMENT_INDEX_UINT = 14] = "ELEMENT_INDEX_UINT", GFXFeature[GFXFeature.INSTANCED_ARRAYS = 15] = "INSTANCED_ARRAYS", 
GFXFeature[GFXFeature.COUNT = 16] = "COUNT";

var GFXDevice = function() {
    function GFXDevice() {
        _classCallCheck(this, GFXDevice), this._canvas = null, this._canvas2D = null, this._gfxAPI = exports.GFXAPI.UNKNOWN, 
        this._deviceName = "", this._renderer = "", this._vendor = "", this._version = "", 
        this._features = new Array(exports.GFXFeature.COUNT), this._queue = null, this._devicePixelRatio = 1, 
        this._width = 0, this._height = 0, this._nativeWidth = 0, this._nativeHeight = 0, 
        this._mainWindow = null, this._cmdAllocator = null, this._maxVertexAttributes = 0, 
        this._maxVertexUniformVectors = 0, this._maxFragmentUniformVectors = 0, this._maxTextureUnits = 0, 
        this._maxVertexTextureUnits = 0, this._maxUniformBufferBindings = 24, this._maxUniformBlockSize = 0, 
        this._maxTextureSize = 0, this._maxCubeMapTextureSize = 0, this._depthBits = 0, 
        this._stencilBits = 0, this._colorFmt = exports.GFXFormat.UNKNOWN, this._depthStencilFmt = exports.GFXFormat.UNKNOWN, 
        this._reverseCW = !1, this._shaderIdGen = 0, this._macros = new Map, this._numDrawCalls = 0, 
        this._numInstances = 0, this._numTris = 0, this._memoryStatus = {
            bufferSize: 0,
            textureSize: 0
        };
    }
    return _createClass(GFXDevice, [ {
        key: "hasFeature",
        value: function hasFeature(feature) {
            return this._features[feature];
        }
    }, {
        key: "genShaderId",
        value: function genShaderId() {
            return this._shaderIdGen++;
        }
    }, {
        key: "defineMacro",
        value: function defineMacro(macro, value) {
            var val = void 0 !== value ? value : "";
            this._macros.set(macro, val);
        }
    }, {
        key: "canvas",
        get: function get() {
            return this._canvas;
        }
    }, {
        key: "canvas2D",
        get: function get() {
            return this._canvas2D;
        }
    }, {
        key: "gfxAPI",
        get: function get() {
            return this._gfxAPI;
        }
    }, {
        key: "queue",
        get: function get() {
            return this._queue;
        }
    }, {
        key: "devicePixelRatio",
        get: function get() {
            return this._devicePixelRatio;
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "nativeWidth",
        get: function get() {
            return this._nativeWidth;
        }
    }, {
        key: "nativeHeight",
        get: function get() {
            return this._nativeHeight;
        }
    }, {
        key: "mainWindow",
        get: function get() {
            return this._mainWindow;
        }
    }, {
        key: "commandAllocator",
        get: function get() {
            return this._cmdAllocator;
        }
    }, {
        key: "renderer",
        get: function get() {
            return this._renderer;
        }
    }, {
        key: "vendor",
        get: function get() {
            return this._vendor;
        }
    }, {
        key: "maxVertexAttributes",
        get: function get() {
            return this._maxVertexAttributes;
        }
    }, {
        key: "maxVertexUniformVectors",
        get: function get() {
            return this._maxVertexUniformVectors;
        }
    }, {
        key: "maxFragmentUniformVectors",
        get: function get() {
            return this._maxFragmentUniformVectors;
        }
    }, {
        key: "maxTextureUnits",
        get: function get() {
            return this._maxTextureUnits;
        }
    }, {
        key: "maxVertexTextureUnits",
        get: function get() {
            return this._maxVertexTextureUnits;
        }
    }, {
        key: "maxUniformBufferBindings",
        get: function get() {
            return this._maxUniformBufferBindings;
        }
    }, {
        key: "maxUniformBlockSize",
        get: function get() {
            return this._maxUniformBlockSize;
        }
    }, {
        key: "maxTextureSize",
        get: function get() {
            return this._maxTextureSize;
        }
    }, {
        key: "maxCubeMapTextureSize",
        get: function get() {
            return this._maxCubeMapTextureSize;
        }
    }, {
        key: "depthBits",
        get: function get() {
            return this._depthBits;
        }
    }, {
        key: "stencilBits",
        get: function get() {
            return this._stencilBits;
        }
    }, {
        key: "colorFormat",
        get: function get() {
            return this._colorFmt;
        }
    }, {
        key: "depthStencilFormat",
        get: function get() {
            return this._depthStencilFmt;
        }
    }, {
        key: "macros",
        get: function get() {
            return this._macros;
        }
    }, {
        key: "numDrawCalls",
        get: function get() {
            return this._numDrawCalls;
        }
    }, {
        key: "numInstances",
        get: function get() {
            return this._numInstances;
        }
    }, {
        key: "numTris",
        get: function get() {
            return this._numTris;
        }
    }, {
        key: "memoryStatus",
        get: function get() {
            return this._memoryStatus;
        }
    }, {
        key: "reverseCW",
        get: function get() {
            return this._reverseCW;
        },
        set: function set(val) {
            this._reverseCW = val;
        }
    } ]), GFXDevice;
}(), GFXFramebuffer = function(_GFXObject) {
    function GFXFramebuffer(device) {
        var _this;
        return _classCallCheck(this, GFXFramebuffer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXFramebuffer).call(this, exports.GFXObjectType.FRAMEBUFFER)))._device = void 0, 
        _this._renderPass = null, _this._colorViews = [], _this._depthStencilView = null, 
        _this._isOffscreen = !0, _this._device = device, _this;
    }
    return _inherits(GFXFramebuffer, GFXObject), _createClass(GFXFramebuffer, [ {
        key: "renderPass",
        get: function get() {
            return this._renderPass;
        }
    }, {
        key: "colorViews",
        get: function get() {
            return this._colorViews;
        }
    }, {
        key: "depthStencilView",
        get: function get() {
            return this._depthStencilView;
        }
    }, {
        key: "isOffscreen",
        get: function get() {
            return this._isOffscreen;
        }
    } ]), GFXFramebuffer;
}(), GFXInputAssembler = function(_GFXObject) {
    function GFXInputAssembler(device) {
        var _this;
        return _classCallCheck(this, GFXInputAssembler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXInputAssembler).call(this, exports.GFXObjectType.INPUT_ASSEMBLER)))._device = void 0, 
        _this._attributes = [], _this._vertexBuffers = [], _this._indexBuffer = null, _this._vertexCount = 0, 
        _this._firstVertex = 0, _this._indexCount = 0, _this._firstIndex = 0, _this._vertexOffset = 0, 
        _this._instanceCount = 0, _this._firstInstance = 0, _this._isIndirect = !1, _this._indirectBuffer = null, 
        _this._device = device, _this;
    }
    return _inherits(GFXInputAssembler, GFXObject), _createClass(GFXInputAssembler, [ {
        key: "vertexBuffers",
        get: function get() {
            return this._vertexBuffers;
        }
    }, {
        key: "indexBuffer",
        get: function get() {
            return this._indexBuffer;
        }
    }, {
        key: "attributes",
        get: function get() {
            return this._attributes;
        }
    }, {
        key: "vertexCount",
        get: function get() {
            return this._vertexCount;
        },
        set: function set(count) {
            this._vertexCount = count;
        }
    }, {
        key: "firstVertex",
        get: function get() {
            return this._firstVertex;
        },
        set: function set(first) {
            this._firstVertex = first;
        }
    }, {
        key: "indexCount",
        get: function get() {
            return this._indexCount;
        },
        set: function set(count) {
            this._indexCount = count;
        }
    }, {
        key: "firstIndex",
        get: function get() {
            return this._firstIndex;
        },
        set: function set(first) {
            this._firstIndex = first;
        }
    }, {
        key: "vertexOffset",
        get: function get() {
            return this._vertexOffset;
        },
        set: function set(offset) {
            this._vertexOffset = offset;
        }
    }, {
        key: "instanceCount",
        get: function get() {
            return this._instanceCount;
        },
        set: function set(count) {
            this._instanceCount = count;
        }
    }, {
        key: "firstInstance",
        get: function get() {
            return this._firstInstance;
        },
        set: function set(first) {
            this._firstInstance = first;
        }
    }, {
        key: "isIndirect",
        get: function get() {
            return this._isIndirect;
        }
    }, {
        key: "indirectBuffer",
        get: function get() {
            return this._indirectBuffer;
        }
    } ]), _createClass(GFXInputAssembler, [ {
        key: "getVertexBuffer",
        value: function getVertexBuffer() {
            var stream = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return stream < this._vertexBuffers.length ? this._vertexBuffers[stream] : null;
        }
    } ]), GFXInputAssembler;
}(), GFXPipelineLayout = function(_GFXObject) {
    function GFXPipelineLayout(device) {
        var _this;
        return _classCallCheck(this, GFXPipelineLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineLayout).call(this, exports.GFXObjectType.PIPELINE_LAYOUT)))._device = void 0, 
        _this._pushConstantsRanges = [], _this._layouts = [], _this._device = device, _this;
    }
    return _inherits(GFXPipelineLayout, GFXObject), _createClass(GFXPipelineLayout, [ {
        key: "layouts",
        get: function get() {
            return this._layouts;
        }
    } ]), GFXPipelineLayout;
}(), GFXRasterizerState = function() {
    function GFXRasterizerState() {
        _classCallCheck(this, GFXRasterizerState), this.isDiscard = !1, this.polygonMode = exports.GFXPolygonMode.FILL, 
        this.shadeModel = exports.GFXShadeModel.GOURAND, this.cullMode = exports.GFXCullMode.BACK, 
        this.isFrontFaceCCW = !0, this.depthBias = 0, this.depthBiasClamp = 0, this.depthBiasSlop = 0, 
        this.isDepthClip = !0, this.isMultisample = !1, this.lineWidth = 1;
    }
    return _createClass(GFXRasterizerState, [ {
        key: "compare",
        value: function compare(state) {
            return this.isDiscard === state.isDiscard && this.polygonMode === state.polygonMode && this.shadeModel === state.shadeModel && this.cullMode === state.cullMode && this.isFrontFaceCCW === state.isFrontFaceCCW && this.depthBias === state.depthBias && this.depthBiasClamp === state.depthBiasClamp && this.depthBiasSlop === state.depthBiasSlop && this.isDepthClip === state.isDepthClip && this.lineWidth === state.lineWidth && this.isMultisample === state.isMultisample;
        }
    } ]), GFXRasterizerState;
}(), GFXDepthStencilState = function() {
    function GFXDepthStencilState() {
        _classCallCheck(this, GFXDepthStencilState), this.depthTest = !0, this.depthWrite = !0, 
        this.depthFunc = exports.GFXComparisonFunc.LESS, this.stencilTestFront = !1, this.stencilFuncFront = exports.GFXComparisonFunc.ALWAYS, 
        this.stencilReadMaskFront = 65535, this.stencilWriteMaskFront = 65535, this.stencilFailOpFront = exports.GFXStencilOp.KEEP, 
        this.stencilZFailOpFront = exports.GFXStencilOp.KEEP, this.stencilPassOpFront = exports.GFXStencilOp.KEEP, 
        this.stencilRefFront = 1, this.stencilTestBack = !1, this.stencilFuncBack = exports.GFXComparisonFunc.ALWAYS, 
        this.stencilReadMaskBack = 65535, this.stencilWriteMaskBack = 65535, this.stencilFailOpBack = exports.GFXStencilOp.KEEP, 
        this.stencilZFailOpBack = exports.GFXStencilOp.KEEP, this.stencilPassOpBack = exports.GFXStencilOp.KEEP, 
        this.stencilRefBack = 1;
    }
    return _createClass(GFXDepthStencilState, [ {
        key: "compare",
        value: function compare(state) {
            return this.depthTest === state.depthTest && this.depthWrite === state.depthWrite && this.depthFunc === state.depthFunc && this.stencilTestFront === state.stencilTestFront && this.stencilFuncFront === state.stencilFuncFront && this.stencilReadMaskFront === state.stencilReadMaskFront && this.stencilWriteMaskFront === state.stencilWriteMaskFront && this.stencilFailOpFront === state.stencilFailOpFront && this.stencilZFailOpFront === state.stencilZFailOpFront && this.stencilPassOpFront === state.stencilPassOpFront && this.stencilRefFront === state.stencilRefFront && this.stencilTestBack === state.stencilTestBack && this.stencilFuncBack === state.stencilFuncBack && this.stencilReadMaskBack === state.stencilReadMaskBack && this.stencilWriteMaskBack === state.stencilWriteMaskBack && this.stencilFailOpBack === state.stencilFailOpBack && this.stencilZFailOpBack === state.stencilZFailOpBack && this.stencilPassOpBack === state.stencilPassOpBack && this.stencilRefBack === state.stencilRefBack;
        }
    } ]), GFXDepthStencilState;
}(), GFXBlendTarget = function() {
    function GFXBlendTarget() {
        _classCallCheck(this, GFXBlendTarget), this.blend = !1, this.blendSrc = exports.GFXBlendFactor.ONE, 
        this.blendDst = exports.GFXBlendFactor.ZERO, this.blendEq = exports.GFXBlendOp.ADD, 
        this.blendSrcAlpha = exports.GFXBlendFactor.ONE, this.blendDstAlpha = exports.GFXBlendFactor.ZERO, 
        this.blendAlphaEq = exports.GFXBlendOp.ADD, this.blendColorMask = exports.GFXColorMask.ALL;
    }
    return _createClass(GFXBlendTarget, [ {
        key: "compare",
        value: function compare(target) {
            return this.blend === target.blend && this.blendSrc === target.blendSrc && this.blendDst === target.blendDst && this.blendEq === target.blendEq && this.blendSrcAlpha === target.blendSrcAlpha && this.blendDstAlpha === target.blendDstAlpha && this.blendAlphaEq === target.blendAlphaEq && this.blendColorMask === target.blendColorMask;
        }
    } ]), GFXBlendTarget;
}(), GFXBlendState = function GFXBlendState() {
    _classCallCheck(this, GFXBlendState), this.isA2C = !1, this.isIndepend = !1, this.blendColor = [ 0, 0, 0, 0 ], 
    this.targets = [ new GFXBlendTarget ];
}, GFXInputState = function GFXInputState() {
    _classCallCheck(this, GFXInputState), this.attributes = [];
}, GFXPipelineState = function(_GFXObject) {
    function GFXPipelineState(device) {
        var _this;
        return _classCallCheck(this, GFXPipelineState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineState).call(this, exports.GFXObjectType.PIPELINE_STATE)))._device = void 0, 
        _this._shader = null, _this._primitive = exports.GFXPrimitiveMode.TRIANGLE_LIST, 
        _this._is = null, _this._rs = null, _this._dss = null, _this._bs = null, _this._dynamicStates = [], 
        _this._layout = null, _this._renderPass = null, _this._hash = 0, _this._device = device, 
        _this;
    }
    return _inherits(GFXPipelineState, GFXObject), _createClass(GFXPipelineState, [ {
        key: "shader",
        get: function get() {
            return this._shader;
        }
    }, {
        key: "primitive",
        get: function get() {
            return this._primitive;
        }
    }, {
        key: "rasterizerState",
        get: function get() {
            return this._rs;
        }
    }, {
        key: "depthStencilState",
        get: function get() {
            return this._dss;
        }
    }, {
        key: "blendState",
        get: function get() {
            return this._bs;
        }
    }, {
        key: "inputState",
        get: function get() {
            return this._is;
        }
    }, {
        key: "dynamicStates",
        get: function get() {
            return this._dynamicStates;
        }
    }, {
        key: "pipelineLayout",
        get: function get() {
            return this._layout;
        }
    }, {
        key: "renderPass",
        get: function get() {
            return this._renderPass;
        }
    }, {
        key: "hash",
        get: function get() {
            return this._hash;
        }
    } ]), GFXPipelineState;
}(), GFXQueue = function(_GFXObject) {
    function GFXQueue(device) {
        var _this;
        return _classCallCheck(this, GFXQueue), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXQueue).call(this, exports.GFXObjectType.QUEUE)))._device = void 0, 
        _this._type = exports.GFXQueueType.GRAPHICS, _this._device = device, _this;
    }
    return _inherits(GFXQueue, GFXObject), _createClass(GFXQueue, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ]), GFXQueue;
}(), GFXRenderPass = function(_GFXObject) {
    function GFXRenderPass(device) {
        var _this;
        return _classCallCheck(this, GFXRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXRenderPass).call(this, exports.GFXObjectType.RENDER_PASS)))._device = void 0, 
        _this._colorInfos = [], _this._depthStencilInfo = null, _this._device = device, 
        _this;
    }
    return _inherits(GFXRenderPass, GFXObject), GFXRenderPass;
}(), GFXSamplerState = function() {
    function GFXSamplerState() {
        _classCallCheck(this, GFXSamplerState), this.name = "", this.minFilter = exports.GFXFilter.LINEAR, 
        this.magFilter = exports.GFXFilter.LINEAR, this.mipFilter = exports.GFXFilter.NONE, 
        this.addressU = exports.GFXAddress.WRAP, this.addressV = exports.GFXAddress.WRAP, 
        this.addressW = exports.GFXAddress.WRAP, this.maxAnisotropy = 16, this.cmpFunc = exports.GFXComparisonFunc.NEVER, 
        this.borderColor = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        }, this.minLOD = 0, this.maxLOD = 0, this.mipLODBias = 0;
    }
    return _createClass(GFXSamplerState, [ {
        key: "compare",
        value: function compare(state) {
            return this.minFilter === state.minFilter && this.magFilter === state.magFilter && this.mipFilter === state.mipFilter && this.addressU === state.addressU && this.addressV === state.addressV && this.addressW === state.addressW && this.maxAnisotropy === state.maxAnisotropy && this.cmpFunc === state.cmpFunc && this.borderColor.r === state.borderColor.r && this.borderColor.g === state.borderColor.g && this.borderColor.b === state.borderColor.b && this.borderColor.a === state.borderColor.a && this.minLOD === state.minLOD && this.maxLOD === state.maxLOD && this.mipLODBias === state.mipLODBias;
        }
    } ]), GFXSamplerState;
}(), GFXSampler = function(_GFXObject) {
    function GFXSampler(device) {
        var _this;
        return _classCallCheck(this, GFXSampler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXSampler).call(this, exports.GFXObjectType.SAMPLER)))._device = void 0, 
        _this._state = new GFXSamplerState, _this._device = device, _this._state = new GFXSamplerState, 
        _this;
    }
    return _inherits(GFXSampler, GFXObject), _createClass(GFXSampler, [ {
        key: "state",
        get: function get() {
            return this._state;
        }
    } ]), GFXSampler;
}(), GFXShader = function(_GFXObject) {
    function GFXShader(device) {
        var _this;
        return _classCallCheck(this, GFXShader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXShader).call(this, exports.GFXObjectType.SHADER)))._device = void 0, 
        _this._id = void 0, _this._name = "", _this._stages = [], _this._blocks = [], _this._samplers = [], 
        _this._device = device, _this._id = device.genShaderId(), _this;
    }
    return _inherits(GFXShader, GFXObject), _createClass(GFXShader, [ {
        key: "id",
        get: function get() {
            return this._id;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    } ]), GFXShader;
}();

function IsPowerOf2(x) {
    return x > 0 && 0 == (x & x - 1);
}

var ERaycastMode, GFXTexture = function(_GFXObject) {
    function GFXTexture(device) {
        var _this;
        return _classCallCheck(this, GFXTexture), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTexture).call(this, exports.GFXObjectType.TEXTURE)))._device = void 0, 
        _this._type = exports.GFXTextureType.TEX2D, _this._usage = exports.GFXTextureUsageBit.NONE, 
        _this._format = exports.GFXFormat.UNKNOWN, _this._width = 0, _this._height = 0, 
        _this._depth = 1, _this._arrayLayer = 1, _this._mipLevel = 1, _this._samples = exports.GFXSampleCount.X1, 
        _this._flags = exports.GFXTextureFlagBit.NONE, _this._isPowerOf2 = !1, _this._size = 0, 
        _this._buffer = null, _this._device = device, _this;
    }
    return _inherits(GFXTexture, GFXObject), _createClass(GFXTexture, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    }, {
        key: "usage",
        get: function get() {
            return this._usage;
        }
    }, {
        key: "format",
        get: function get() {
            return this._format;
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "depth",
        get: function get() {
            return this._depth;
        }
    }, {
        key: "arrayLayer",
        get: function get() {
            return this._arrayLayer;
        }
    }, {
        key: "mipLevel",
        get: function get() {
            return this._mipLevel;
        }
    }, {
        key: "samples",
        get: function get() {
            return this._samples;
        }
    }, {
        key: "flags",
        get: function get() {
            return this._flags;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        }
    }, {
        key: "buffer",
        get: function get() {
            return this._buffer;
        }
    } ]), GFXTexture;
}(), GFXTextureView = function(_GFXObject) {
    function GFXTextureView(device) {
        var _this;
        return _classCallCheck(this, GFXTextureView), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTextureView).call(this, exports.GFXObjectType.TEXTURE_VIEW)))._device = void 0, 
        _this._texture = null, _this._type = exports.GFXTextureViewType.TV2D, _this._format = exports.GFXFormat.UNKNOWN, 
        _this._baseLevel = 0, _this._levelCount = 1, _this._baseLayer = 0, _this._layerCount = 1, 
        _this._device = device, _this;
    }
    return _inherits(GFXTextureView, GFXObject), _createClass(GFXTextureView, [ {
        key: "texture",
        get: function get() {
            return this._texture;
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        }
    }, {
        key: "format",
        get: function get() {
            return this._format;
        }
    }, {
        key: "baseLevel",
        get: function get() {
            return this._baseLevel;
        }
    }, {
        key: "levelCount",
        get: function get() {
            return this._levelCount;
        }
    }, {
        key: "baseLayer",
        get: function get() {
            return this._baseLayer;
        }
    }, {
        key: "layerCount",
        get: function get() {
            return this._layerCount;
        }
    } ]), GFXTextureView;
}(), GFXBindingLayout = function(_GFXObject) {
    function GFXBindingLayout(device) {
        var _this;
        return _classCallCheck(this, GFXBindingLayout), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBindingLayout).call(this, exports.GFXObjectType.BINDING_LAYOUT)))._device = void 0, 
        _this._bindingUnits = [], _this._isDirty = !1, _this._device = device, _this;
    }
    return _inherits(GFXBindingLayout, GFXObject), _createClass(GFXBindingLayout, [ {
        key: "bindBuffer",
        value: function bindBuffer(binding, buffer) {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._bindingUnits); !(_step = _iterator()).done; ) {
                var bindingUnit = _step.value;
                if (bindingUnit.binding === binding) return void (bindingUnit.type === exports.GFXBindingType.UNIFORM_BUFFER ? bindingUnit.buffer !== buffer && (bindingUnit.buffer = buffer, 
                this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.UNIFORM_BUFFER."));
            }
        }
    }, {
        key: "bindSampler",
        value: function bindSampler(binding, sampler) {
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._bindingUnits); !(_step2 = _iterator2()).done; ) {
                var bindingUnit = _step2.value;
                if (bindingUnit.binding === binding) return void (bindingUnit.type === exports.GFXBindingType.SAMPLER ? bindingUnit.sampler !== sampler && (bindingUnit.sampler = sampler, 
                this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
            }
        }
    }, {
        key: "bindTextureView",
        value: function bindTextureView(binding, texView) {
            for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._bindingUnits); !(_step3 = _iterator3()).done; ) {
                var bindingUnit = _step3.value;
                if (bindingUnit.binding === binding) return void (bindingUnit.type === exports.GFXBindingType.SAMPLER ? bindingUnit.texView !== texView && (bindingUnit.texView = texView, 
                this._isDirty = !0) : console.error("Setting binding is not GFXBindingType.SAMPLER."));
            }
        }
    }, {
        key: "getBindingUnit",
        value: function getBindingUnit(binding) {
            for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._bindingUnits); !(_step4 = _iterator4()).done; ) {
                var unit = _step4.value;
                if (unit.binding === binding) return unit;
            }
            return null;
        }
    } ]), GFXBindingLayout;
}(), GFXCommandAllocator = function(_GFXObject) {
    function GFXCommandAllocator(device) {
        var _this;
        return _classCallCheck(this, GFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandAllocator).call(this, exports.GFXObjectType.COMMAND_ALLOCATOR)))._device = void 0, 
        _this._device = device, _this;
    }
    return _inherits(GFXCommandAllocator, GFXObject), GFXCommandAllocator;
}(), GFXWindow = function(_GFXObject) {
    function GFXWindow(device) {
        var _this;
        return _classCallCheck(this, GFXWindow), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GFXWindow).call(this, exports.GFXObjectType.WINDOW)))._device = void 0, 
        _this._title = "", _this._left = 0, _this._top = 0, _this._width = 0, _this._height = 0, 
        _this._nativeWidth = 0, _this._nativeHeight = 0, _this._colorFmt = exports.GFXFormat.UNKNOWN, 
        _this._depthStencilFmt = exports.GFXFormat.UNKNOWN, _this._isOffscreen = !1, _this._renderPass = null, 
        _this._colorTex = null, _this._colorTexView = null, _this._depthStencilTex = null, 
        _this._depthStencilTexView = null, _this._framebuffer = null, _this._device = device, 
        _this;
    }
    return _inherits(GFXWindow, GFXObject), _createClass(GFXWindow, [ {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "colorFormat",
        get: function get() {
            return this._colorFmt;
        }
    }, {
        key: "detphStencilFormat",
        get: function get() {
            return this._depthStencilFmt;
        }
    }, {
        key: "isOffscreen",
        get: function get() {
            return this._isOffscreen;
        }
    }, {
        key: "renderPass",
        get: function get() {
            return this._renderPass;
        }
    }, {
        key: "colorTexView",
        get: function get() {
            return this._colorTexView;
        }
    }, {
        key: "depthStencilTexView",
        get: function get() {
            return this._depthStencilTexView;
        }
    }, {
        key: "framebuffer",
        get: function get() {
            return this._framebuffer;
        }
    } ]), GFXWindow;
}();

cc.GFXDevice = GFXDevice, cc.GFXBuffer = GFXBuffer, cc.GFXTexture = GFXTexture, 
cc.GFXTextureView = GFXTextureView, cc.GFXSampler = GFXSampler, cc.GFXShader = GFXShader, 
cc.GFXInputAssembler = GFXInputAssembler, cc.GFXRenderPass = GFXRenderPass, cc.GFXFramebuffer = GFXFramebuffer, 
cc.GFXPipelineLayout = GFXPipelineLayout, cc.GFXPipelineState = GFXPipelineState, 
cc.GFXCommandBuffer = GFXCommandBuffer, cc.GFXQueue = GFXQueue, Object.assign(cc, GFXDefines), 
function(ERaycastMode) {
    ERaycastMode[ERaycastMode.ALL = 0] = "ALL", ERaycastMode[ERaycastMode.CLOSEST = 1] = "CLOSEST", 
    ERaycastMode[ERaycastMode.ANY = 2] = "ANY";
}(ERaycastMode || (ERaycastMode = {}));

var pt, ab, ac, pvec, tvec, qvec, ray_plane = (pt = new Vec3(0, 0, 0), function(ray, plane) {
    var denom = Vec3.dot(ray.d, plane.n);
    if (Math.abs(denom) < Number.EPSILON) return 0;
    Vec3.multiplyScalar(pt, plane.n, plane.d);
    var t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;
    return t < 0 ? 0 : t;
}), ray_triangle = (ab = new Vec3(0, 0, 0), ac = new Vec3(0, 0, 0), pvec = new Vec3(0, 0, 0), 
tvec = new Vec3(0, 0, 0), qvec = new Vec3(0, 0, 0), function(ray, triangle, doubleSided) {
    Vec3.subtract(ab, triangle.b, triangle.a), Vec3.subtract(ac, triangle.c, triangle.a), 
    Vec3.cross(pvec, ray.d, ac);
    var det = Vec3.dot(ab, pvec);
    if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) return 0;
    var inv_det = 1 / det;
    Vec3.subtract(tvec, ray.o, triangle.a);
    var u = Vec3.dot(tvec, pvec) * inv_det;
    if (u < 0 || u > 1) return 0;
    Vec3.cross(qvec, tvec, ab);
    var v = Vec3.dot(ray.d, qvec) * inv_det;
    if (v < 0 || u + v > 1) return 0;
    var t = Vec3.dot(ac, qvec) * inv_det;
    return t < 0 ? 0 : t;
}), ray_sphere = function() {
    var e = new Vec3(0, 0, 0);
    return function(ray, sphere) {
        var r = sphere.radius, c = sphere.center, o = ray.o, d = ray.d, rSq = r * r;
        Vec3.subtract(e, c, o);
        var eSq = e.lengthSqr(), aLength = Vec3.dot(e, d), fSq = rSq - (eSq - aLength * aLength);
        if (fSq < 0) return 0;
        var f = Math.sqrt(fSq), t = eSq < rSq ? aLength + f : aLength - f;
        return t < 0 ? 0 : t;
    };
}(), ray_aabb = function() {
    var min = new Vec3, max = new Vec3;
    return function(ray, aabb) {
        return Vec3.subtract(min, aabb.center, aabb.halfExtents), Vec3.add(max, aabb.center, aabb.halfExtents), 
        ray_aabb2(ray, min, max);
    };
}();

function ray_aabb2(ray, min, max) {
    var o = ray.o, d = ray.d, ix = 1 / d.x, iy = 1 / d.y, iz = 1 / d.z, t1 = (min.x - o.x) * ix, t2 = (max.x - o.x) * ix, t3 = (min.y - o.y) * iy, t4 = (max.y - o.y) * iy, t5 = (min.z - o.z) * iz, t6 = (max.z - o.z) * iz, tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6)), tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
    return tmax < 0 || tmin > tmax ? 0 : tmin > 0 ? tmin : tmax;
}

var minDis, deOpt, ray_obb = function() {
    var center = new Vec3, o = new Vec3, d = new Vec3, X = new Vec3, Y = new Vec3, Z = new Vec3, p = new Vec3, size = new Array(3), f = new Array(3), e = new Array(3), t = new Array(6);
    return function(ray, obb) {
        size[0] = obb.halfExtents.x, size[1] = obb.halfExtents.y, size[2] = obb.halfExtents.z, 
        center = obb.center, o = ray.o, d = ray.d, Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
        Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), 
        Vec3.subtract(p, center, o), f[0] = Vec3.dot(X, d), f[1] = Vec3.dot(Y, d), f[2] = Vec3.dot(Z, d), 
        e[0] = Vec3.dot(X, p), e[1] = Vec3.dot(Y, p), e[2] = Vec3.dot(Z, p);
        for (var i = 0; i < 3; ++i) {
            if (0 === f[i]) {
                if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) return 0;
                f[i] = 1e-7;
            }
            t[2 * i + 0] = (e[i] + size[i]) / f[i], t[2 * i + 1] = (e[i] - size[i]) / f[i];
        }
        var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5])), tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));
        return tmax < 0 || tmin > tmax ? 0 : tmin > 0 ? tmin : tmax;
    };
}(), ray_capsule = function() {
    var v3_0 = new Vec3, v3_1 = new Vec3, v3_2 = new Vec3, v3_3 = new Vec3, v3_4 = new Vec3, v3_5 = new Vec3, v3_6 = new Vec3, sphere_0 = new sphere;
    return function(ray, capsule) {
        var radiusSqr = capsule.radius * capsule.radius, vRayNorm = Vec3.normalize(v3_0, ray.d), A = capsule.ellipseCenter0, B = capsule.ellipseCenter1, BA = Vec3.subtract(v3_1, B, A);
        if (BA.equals(Vec3.ZERO)) return sphere_0.radius = capsule.radius, sphere_0.center.set(capsule.ellipseCenter0), 
        intersect.ray_sphere(ray, sphere_0);
        var O = ray.o, OA = Vec3.subtract(v3_2, O, A), VxBA = Vec3.cross(v3_3, vRayNorm, BA), a = VxBA.lengthSqr();
        if (0 === a) {
            sphere_0.radius = capsule.radius;
            var BO = Vec3.subtract(v3_4, B, O);
            return OA.lengthSqr() < BO.lengthSqr() ? sphere_0.center.set(capsule.ellipseCenter0) : sphere_0.center.set(capsule.ellipseCenter1), 
            intersect.ray_sphere(ray, sphere_0);
        }
        var OAxBA = Vec3.cross(v3_4, OA, BA), ab2 = BA.lengthSqr(), b = 2 * Vec3.dot(VxBA, OAxBA), d = b * b - 4 * a * (OAxBA.lengthSqr() - radiusSqr * ab2);
        if (d < 0) return 0;
        var t = (-b - Math.sqrt(d)) / (2 * a);
        if (t < 0) {
            sphere_0.radius = capsule.radius;
            var _BO = Vec3.subtract(v3_5, B, O);
            return OA.lengthSqr() < _BO.lengthSqr() ? sphere_0.center.set(capsule.ellipseCenter0) : sphere_0.center.set(capsule.ellipseCenter1), 
            intersect.ray_sphere(ray, sphere_0);
        }
        var iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t), iPosLen = Vec3.subtract(v3_6, iPos, A), tLimit = Vec3.dot(iPosLen, BA) / ab2;
        return tLimit >= 0 && tLimit <= 1 ? t : tLimit < 0 ? (sphere_0.radius = capsule.radius, 
        sphere_0.center.set(capsule.ellipseCenter0), intersect.ray_sphere(ray, sphere_0)) : tLimit > 1 ? (sphere_0.radius = capsule.radius, 
        sphere_0.center.set(capsule.ellipseCenter1), intersect.ray_sphere(ray, sphere_0)) : 0;
    };
}(), ray_subMesh = function() {
    var tri = triangle.create(), deOpt = {
        distance: 1 / 0,
        doubleSided: !1,
        mode: ERaycastMode.ANY
    }, minDis = 0, fillResult = function fillResult(m, d, i0, i1, i2, r) {
        m == ERaycastMode.CLOSEST ? (minDis > d || 0 == minDis) && (minDis = d, r && (0 == r.length ? r.push({
            distance: d,
            vertexIndex0: i0 / 3,
            vertexIndex1: i1 / 3,
            vertexIndex2: i2 / 3
        }) : (r[0].distance = d, r[0].vertexIndex0 = i0 / 3, r[0].vertexIndex1 = i1 / 3, 
        r[0].vertexIndex2 = i2 / 3))) : (minDis = d, r && r.push({
            distance: d,
            vertexIndex0: i0 / 3,
            vertexIndex1: i1 / 3,
            vertexIndex2: i2 / 3
        }));
    };
    return function(ray, submesh, options) {
        if (minDis = 0, 0 == submesh.geometricInfo.positions.length) return minDis;
        var opt = void 0 === options ? deOpt : options;
        if (ray_aabb2(ray, submesh.geometricInfo.boundingBox.min, submesh.geometricInfo.boundingBox.max)) {
            var pm = submesh.primitiveMode, _ref = submesh.geometricInfo;
            !function narrowphase(vb, ib, pm, ray, opt) {
                if (pm === exports.GFXPrimitiveMode.TRIANGLE_LIST) for (var cnt = ib.length, j = 0; j < cnt; j += 3) {
                    var i0 = 3 * ib[j], i1 = 3 * ib[j + 1], i2 = 3 * ib[j + 2];
                    Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]), Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]), 
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    var dist = intersect.ray_triangle(ray, tri, opt.doubleSided);
                    if (!(0 == dist || dist > opt.distance) && (fillResult(opt.mode, dist, i0, i1, i2, opt.result), 
                    opt.mode == ERaycastMode.ANY)) return dist;
                } else if (pm === exports.GFXPrimitiveMode.TRIANGLE_STRIP) for (var _cnt = ib.length - 2, rev = 0, _j = 0; _j < _cnt; _j += 1) {
                    var _i = 3 * ib[_j - rev], _i2 = 3 * ib[_j + rev + 1], _i3 = 3 * ib[_j + 2];
                    Vec3.set(tri.a, vb[_i], vb[_i + 1], vb[_i + 2]), Vec3.set(tri.b, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]), 
                    Vec3.set(tri.c, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]), rev = ~rev;
                    var _dist = intersect.ray_triangle(ray, tri, opt.doubleSided);
                    if (!(0 == _dist || _dist > opt.distance) && (fillResult(opt.mode, _dist, _i, _i2, _i3, opt.result), 
                    opt.mode == ERaycastMode.ANY)) return _dist;
                } else if (pm === exports.GFXPrimitiveMode.TRIANGLE_FAN) {
                    var _cnt2 = ib.length - 1, _i4 = 3 * ib[0];
                    Vec3.set(tri.a, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);
                    for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                        var _i5 = 3 * ib[_j2], _i6 = 3 * ib[_j2 + 1];
                        Vec3.set(tri.b, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]), Vec3.set(tri.c, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);
                        var _dist2 = intersect.ray_triangle(ray, tri, opt.doubleSided);
                        if (!(0 == _dist2 || _dist2 > opt.distance) && (fillResult(opt.mode, _dist2, _i4, _i5, _i6, opt.result), 
                        opt.mode == ERaycastMode.ANY)) return _dist2;
                    }
                }
            }(_ref.positions, _ref.indices, pm, ray, opt);
        }
        return minDis;
    };
}(), ray_mesh = (minDis = 0, deOpt = {
    distance: 1 / 0,
    doubleSided: !1,
    mode: ERaycastMode.ANY
}, function(ray, mesh, options) {
    minDis = 0;
    var opt = void 0 === options ? deOpt : options, length = mesh.renderingSubMeshes.length, min = mesh.struct.minPosition, max = mesh.struct.maxPosition;
    if (min && max && !ray_aabb2(ray, min, max)) return minDis;
    for (var i = 0; i < length; i++) {
        var sm = mesh.renderingSubMeshes[i], dis = ray_subMesh(ray, sm, opt);
        if (dis) if (opt.mode == ERaycastMode.CLOSEST) (0 == minDis || minDis > dis) && (minDis = dis, 
        opt.subIndices && (opt.subIndices[0] = i)); else if (minDis = dis, opt.subIndices && opt.subIndices.push(i), 
        opt.mode == ERaycastMode.ANY) return dis;
    }
    return minDis && opt.mode == ERaycastMode.CLOSEST && (opt.result && (opt.result[0].distance = minDis, 
    opt.result.length = 1), opt.subIndices && (opt.subIndices.length = 1)), minDis;
}), ray_model = function() {
    var minDis = 0, deOpt = {
        distance: 1 / 0,
        doubleSided: !1,
        mode: ERaycastMode.ANY
    }, modelRay = new ray, m4 = new Mat4;
    return function(r, model, options) {
        minDis = 0;
        var opt = void 0 === options ? deOpt : options, length = model.subModelNum, wb = model.worldBounds;
        if (wb && !ray_aabb(r, wb)) return minDis;
        ray.copy(modelRay, r), model.node && (Mat4.invert(m4, model.node.getWorldMatrix(m4)), 
        Vec3.transformMat4(modelRay.o, r.o, m4), Vec3.transformMat4Normal(modelRay.d, r.d, m4));
        for (var i = 0; i < length; i++) {
            var sm = model.getSubModel(i).subMeshData, dis = ray_subMesh(modelRay, sm, opt);
            if (dis) if (opt.mode == ERaycastMode.CLOSEST) (0 == minDis || minDis > dis) && (minDis = dis, 
            opt.subIndices && (opt.subIndices[0] = i)); else if (minDis = dis, opt.subIndices && opt.subIndices.push(i), 
            opt.mode == ERaycastMode.ANY) return dis;
        }
        return minDis && opt.mode == ERaycastMode.CLOSEST && (opt.result && (opt.result[0].distance = minDis, 
        opt.result.length = 1), opt.subIndices && (opt.subIndices.length = 1)), minDis;
    };
}(), line_plane = function() {
    var ab = new Vec3(0, 0, 0);
    return function(line, plane) {
        Vec3.subtract(ab, line.e, line.s);
        var t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);
        return t < 0 || t > 1 ? 0 : t;
    };
}(), line_triangle = function() {
    var ab = new Vec3(0, 0, 0), ac = new Vec3(0, 0, 0), qp = new Vec3(0, 0, 0), ap = new Vec3(0, 0, 0), n = new Vec3(0, 0, 0), e = new Vec3(0, 0, 0);
    return function(line, triangle, outPt) {
        Vec3.subtract(ab, triangle.b, triangle.a), Vec3.subtract(ac, triangle.c, triangle.a), 
        Vec3.subtract(qp, line.s, line.e), Vec3.cross(n, ab, ac);
        var det = Vec3.dot(qp, n);
        if (det <= 0) return 0;
        Vec3.subtract(ap, line.s, triangle.a);
        var t = Vec3.dot(ap, n);
        if (t < 0 || t > det) return 0;
        Vec3.cross(e, qp, ap);
        var v = Vec3.dot(ac, e);
        if (v < 0 || v > det) return 0;
        var w = -Vec3.dot(ab, e);
        if (w < 0 || v + w > det) return 0;
        if (outPt) {
            var invDet = 1 / det, u = 1 - (v *= invDet) - (w *= invDet);
            Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
        }
        return 1;
    };
}(), r_t = new ray;

function line_aabb(line, aabb) {
    r_t.o.set(line.s), Vec3.subtract(r_t.d, line.e, line.s), r_t.d.normalize();
    var min = ray_aabb(r_t, aabb);
    return min <= line.length() ? min : 0;
}

function line_obb(line, obb) {
    r_t.o.set(line.s), Vec3.subtract(r_t.d, line.e, line.s), r_t.d.normalize();
    var min = ray_obb(r_t, obb);
    return min <= line.length() ? min : 0;
}

function line_sphere(line, sphere) {
    r_t.o.set(line.s), Vec3.subtract(r_t.d, line.e, line.s), r_t.d.normalize();
    var min = ray_sphere(r_t, sphere);
    return min <= line.length() ? min : 0;
}

var aMin, aMax, bMin, bMax, aabb_aabb = (aMin = new Vec3, aMax = new Vec3, bMin = new Vec3, 
bMax = new Vec3, function(aabb1, aabb2) {
    return Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents), Vec3.add(aMax, aabb1.center, aabb1.halfExtents), 
    Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents), Vec3.add(bMax, aabb2.center, aabb2.halfExtents), 
    aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
});

function getOBBVertices(c, e, a1, a2, a3, out) {
    Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z), 
    Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z), 
    Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z), 
    Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z), 
    Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z), 
    Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z), 
    Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z), 
    Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
}

function getInterval(vertices, axis) {
    for (var min = Vec3.dot(axis, vertices[0]), max = min, i = 1; i < 8; ++i) {
        var projection = Vec3.dot(axis, vertices[i]);
        min = projection < min ? projection : min, max = projection > max ? projection : max;
    }
    return [ min, max ];
}

var tmp, m3, absDot, aabb_obb = function() {
    for (var test = new Array(15), i = 0; i < 15; i++) test[i] = new Vec3(0, 0, 0);
    for (var vertices = new Array(8), vertices2 = new Array(8), _i7 = 0; _i7 < 8; _i7++) vertices[_i7] = new Vec3(0, 0, 0), 
    vertices2[_i7] = new Vec3(0, 0, 0);
    var min = new Vec3, max = new Vec3;
    return function(aabb, obb) {
        Vec3.set(test[0], 1, 0, 0), Vec3.set(test[1], 0, 1, 0), Vec3.set(test[2], 0, 0, 1), 
        Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02), 
        Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05), 
        Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
        for (var _i8 = 0; _i8 < 3; ++_i8) Vec3.cross(test[6 + 3 * _i8 + 0], test[_i8], test[0]), 
        Vec3.cross(test[6 + 3 * _i8 + 1], test[_i8], test[1]), Vec3.cross(test[6 + 3 * _i8 + 1], test[_i8], test[2]);
        Vec3.subtract(min, aabb.center, aabb.halfExtents), Vec3.add(max, aabb.center, aabb.halfExtents), 
        function getAABBVertices(min, max, out) {
            Vec3.set(out[0], min.x, max.y, max.z), Vec3.set(out[1], min.x, max.y, min.z), Vec3.set(out[2], min.x, min.y, max.z), 
            Vec3.set(out[3], min.x, min.y, min.z), Vec3.set(out[4], max.x, max.y, max.z), Vec3.set(out[5], max.x, max.y, min.z), 
            Vec3.set(out[6], max.x, min.y, max.z), Vec3.set(out[7], max.x, min.y, min.z);
        }(min, max, vertices), getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
        for (var j = 0; j < 15; ++j) {
            var a = getInterval(vertices, test[j]), b = getInterval(vertices2, test[j]);
            if (b[0] > a[1] || a[0] > b[1]) return 0;
        }
        return 1;
    };
}(), aabb_plane = function aabb_plane(aabb, plane) {
    var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z), dot = Vec3.dot(plane.n, aabb.center);
    return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
}, aabb_frustum = function aabb_frustum(aabb, frustum) {
    for (var i = 0; i < frustum.planes.length; i++) if (-1 === aabb_plane(aabb, frustum.planes[i])) return 0;
    return 1;
}, aabb_frustum_accurate = function() {
    for (var tmp = new Array(8), out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = new Vec3(0, 0, 0);
    return function(aabb, frustum) {
        for (var result = 0, intersects = !1, _i9 = 0; _i9 < frustum.planes.length; _i9++) {
            if (-1 === (result = aabb_plane(aabb, frustum.planes[_i9]))) return 0;
            1 === result && (intersects = !0);
        }
        if (!intersects) return 1;
        for (var _i10 = 0; _i10 < frustum.vertices.length; _i10++) Vec3.subtract(tmp[_i10], frustum.vertices[_i10], aabb.center);
        out1 = 0, out2 = 0;
        for (var _i11 = 0; _i11 < frustum.vertices.length; _i11++) tmp[_i11].x > aabb.halfExtents.x ? out1++ : tmp[_i11].x < -aabb.halfExtents.x && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0, out2 = 0;
        for (var _i12 = 0; _i12 < frustum.vertices.length; _i12++) tmp[_i12].y > aabb.halfExtents.y ? out1++ : tmp[_i12].y < -aabb.halfExtents.y && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0, out2 = 0;
        for (var _i13 = 0; _i13 < frustum.vertices.length; _i13++) tmp[_i13].z > aabb.halfExtents.z ? out1++ : tmp[_i13].z < -aabb.halfExtents.z && out2++;
        return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
    };
}(), obb_point = (tmp = new Vec3(0, 0, 0), m3 = new Mat3, function(obb, point) {
    return Vec3.subtract(tmp, point, obb.center), Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation)), 
    function lessThan(a, b) {
        return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
    }(tmp, obb.halfExtents);
}), obb_plane = (absDot = function absDot(n, x, y, z) {
    return Math.abs(n.x * x + n.y * y + n.z * z);
}, function(obb, plane) {
    var r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08), dot = Vec3.dot(plane.n, obb.center);
    return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
}), obb_frustum = function obb_frustum(obb, frustum) {
    for (var i = 0; i < frustum.planes.length; i++) if (-1 === obb_plane(obb, frustum.planes[i])) return 0;
    return 1;
}, obb_frustum_accurate = function() {
    for (var tmp = new Array(8), dist = 0, out1 = 0, out2 = 0, i = 0; i < tmp.length; i++) tmp[i] = new Vec3(0, 0, 0);
    var dot = function dot(n, x, y, z) {
        return n.x * x + n.y * y + n.z * z;
    };
    return function(obb, frustum) {
        for (var result = 0, intersects = !1, _i14 = 0; _i14 < frustum.planes.length; _i14++) {
            if (-1 === (result = obb_plane(obb, frustum.planes[_i14]))) return 0;
            1 === result && (intersects = !0);
        }
        if (!intersects) return 1;
        for (var _i15 = 0; _i15 < frustum.vertices.length; _i15++) Vec3.subtract(tmp[_i15], frustum.vertices[_i15], obb.center);
        out1 = 0, out2 = 0;
        for (var _i16 = 0; _i16 < frustum.vertices.length; _i16++) (dist = dot(tmp[_i16], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02)) > obb.halfExtents.x ? out1++ : dist < -obb.halfExtents.x && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0, out2 = 0;
        for (var _i17 = 0; _i17 < frustum.vertices.length; _i17++) (dist = dot(tmp[_i17], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05)) > obb.halfExtents.y ? out1++ : dist < -obb.halfExtents.y && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0, out2 = 0;
        for (var _i18 = 0; _i18 < frustum.vertices.length; _i18++) (dist = dot(tmp[_i18], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08)) > obb.halfExtents.z ? out1++ : dist < -obb.halfExtents.z && out2++;
        return out1 === frustum.vertices.length || out2 === frustum.vertices.length ? 0 : 1;
    };
}(), obb_obb = function() {
    for (var test = new Array(15), i = 0; i < 15; i++) test[i] = new Vec3(0, 0, 0);
    for (var vertices = new Array(8), vertices2 = new Array(8), _i19 = 0; _i19 < 8; _i19++) vertices[_i19] = new Vec3(0, 0, 0), 
    vertices2[_i19] = new Vec3(0, 0, 0);
    return function(obb1, obb2) {
        Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02), 
        Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05), 
        Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08), 
        Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02), 
        Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05), 
        Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);
        for (var _i20 = 0; _i20 < 3; ++_i20) Vec3.cross(test[6 + 3 * _i20 + 0], test[_i20], test[0]), 
        Vec3.cross(test[6 + 3 * _i20 + 1], test[_i20], test[1]), Vec3.cross(test[6 + 3 * _i20 + 1], test[_i20], test[2]);
        getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices), 
        getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
        for (var _i21 = 0; _i21 < 15; ++_i21) {
            var a = getInterval(vertices, test[_i21]), b = getInterval(vertices2, test[_i21]);
            if (b[0] > a[1] || a[0] > b[1]) return 0;
        }
        return 1;
    };
}(), obb_capsule = function() {
    for (var sphere_0 = new sphere, v3_0 = new Vec3, v3_1 = new Vec3, v3_2 = new Vec3, v3_verts8 = new Array(8), i = 0; i < 8; i++) v3_verts8[i] = new Vec3;
    for (var v3_axis8 = new Array(8), _i22 = 0; _i22 < 8; _i22++) v3_axis8[_i22] = new Vec3;
    return function(obb, capsule) {
        if (0 === Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1)) return sphere_0.radius = capsule.radius, 
        sphere_0.center.set(capsule.ellipseCenter0), intersect.sphere_obb(sphere_0, obb);
        v3_0.x = obb.orientation.m00, v3_0.y = obb.orientation.m01, v3_0.z = obb.orientation.m02, 
        v3_1.x = obb.orientation.m03, v3_1.y = obb.orientation.m04, v3_1.z = obb.orientation.m05, 
        v3_2.x = obb.orientation.m06, v3_2.y = obb.orientation.m07, v3_2.z = obb.orientation.m08, 
        getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
        var axes = v3_axis8, a0 = Vec3.copy(axes[0], v3_0), a1 = Vec3.copy(axes[1], v3_1), a2 = Vec3.copy(axes[2], v3_2);
        Vec3.subtract(axes[3], capsule.center, obb.center).normalize();
        var B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
        B.normalize(), Vec3.cross(axes[5], a0, B), Vec3.cross(axes[6], a1, B), Vec3.cross(axes[7], a2, B);
        for (var _i23 = 0; _i23 < 8; ++_i23) {
            var a = getInterval(v3_verts8, axes[_i23]), d0 = Vec3.dot(axes[_i23], capsule.ellipseCenter0), d1 = Vec3.dot(axes[_i23], capsule.ellipseCenter1), max_d = Math.max(d0, d1), d_min = Math.min(d0, d1) - capsule.radius, d_max = max_d + capsule.radius;
            if (d_min > a[1] || a[0] > d_max) return 0;
        }
        return 1;
    };
}(), sphere_plane = function sphere_plane(sphere, plane) {
    var dot = Vec3.dot(plane.n, sphere.center), r = sphere.radius * plane.n.length();
    return dot + r < plane.d ? -1 : dot - r > plane.d ? 0 : 1;
}, sphere_frustum = function sphere_frustum(sphere, frustum) {
    for (var i = 0; i < frustum.planes.length; i++) if (-1 === sphere_plane(sphere, frustum.planes[i])) return 0;
    return 1;
}, sphere_frustum_accurate = function() {
    var pt = new Vec3(0, 0, 0), map = [ 1, -1, 1, -1, 1, -1 ];
    return function(sphere, frustum) {
        for (var i = 0; i < 6; i++) {
            var plane = frustum.planes[i], r = sphere.radius, c = sphere.center, n = plane.n, d = plane.d, dot = Vec3.dot(n, c);
            if (dot + r < d) return 0;
            if (!(dot - r > d)) {
                Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));
                for (var j = 0; j < 6; j++) if (j !== i && j !== i + map[i]) {
                    var test = frustum.planes[j];
                    if (Vec3.dot(test.n, pt) < test.d) return 0;
                }
            }
        }
        return 1;
    };
}(), sphere_sphere = function sphere_sphere(sphere0, sphere1) {
    var r = sphere0.radius + sphere1.radius;
    return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
}, sphere_aabb = function() {
    var pt = new Vec3;
    return function(sphere, aabb) {
        return pt_point_aabb(pt, sphere.center, aabb), Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
    };
}(), sphere_obb = function() {
    var pt = new Vec3;
    return function(sphere, obb) {
        return pt_point_obb(pt, sphere.center, obb), Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
    };
}(), sphere_capsule = function() {
    var v3_0 = new Vec3, v3_1 = new Vec3;
    return function(sphere, capsule) {
        var r = sphere.radius + capsule.radius, squaredR = r * r, h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);
        if (0 === h) return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
        Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0), Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
        var t = Vec3.dot(v3_0, v3_1) / h;
        return t < 0 ? Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR : t > 1 ? Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR : (Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t), 
        Vec3.squaredDistance(sphere.center, v3_0) < squaredR);
    };
}(), capsule_capsule = function() {
    var v3_0 = new Vec3, v3_1 = new Vec3, v3_2 = new Vec3, v3_3 = new Vec3, v3_4 = new Vec3, v3_5 = new Vec3;
    return function capsule_capsule(capsuleA, capsuleB) {
        var sc, sN, tc, tN, u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0), v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0), w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0), a = Vec3.dot(u, u), b = Vec3.dot(u, v), c = Vec3.dot(v, v), d = Vec3.dot(u, w), e = Vec3.dot(v, w), D = a * c - b * b, sD = D, tD = D;
        D < EPSILON ? (sN = 0, sD = 1, tN = e, tD = c) : (tN = a * e - b * d, (sN = b * e - c * d) < 0 ? (sN = 0, 
        tN = e, tD = c) : sN > sD && (sN = sD, tN = e + b, tD = c)), tN < 0 ? (tN = 0, -d < 0 ? sN = 0 : -d > a ? sN = sD : (sN = -d, 
        sD = a)) : tN > tD && (tN = tD, -d + b < 0 ? sN = 0 : -d + b > a ? sN = sD : (sN = -d + b, 
        sD = a)), sc = Math.abs(sN) < EPSILON ? 0 : sN / sD, tc = Math.abs(tN) < EPSILON ? 0 : tN / tD;
        var dP = v3_3;
        dP.set(w), dP.add(Vec3.multiplyScalar(v3_4, u, sc)), dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
        var radius = capsuleA.radius + capsuleB.radius;
        return dP.lengthSqr() < radius * radius;
    };
}(), intersect = {
    ray_sphere: ray_sphere,
    ray_aabb: ray_aabb,
    ray_obb: ray_obb,
    ray_plane: ray_plane,
    ray_triangle: ray_triangle,
    ray_capsule: ray_capsule,
    ray_subMesh: ray_subMesh,
    ray_mesh: ray_mesh,
    ray_model: ray_model,
    line_sphere: line_sphere,
    line_aabb: line_aabb,
    line_obb: line_obb,
    line_plane: line_plane,
    line_triangle: line_triangle,
    sphere_sphere: sphere_sphere,
    sphere_aabb: sphere_aabb,
    sphere_obb: sphere_obb,
    sphere_plane: sphere_plane,
    sphere_frustum: sphere_frustum,
    sphere_frustum_accurate: sphere_frustum_accurate,
    sphere_capsule: sphere_capsule,
    aabb_aabb: aabb_aabb,
    aabb_obb: aabb_obb,
    aabb_plane: aabb_plane,
    aabb_frustum: aabb_frustum,
    aabb_frustum_accurate: aabb_frustum_accurate,
    obb_obb: obb_obb,
    obb_plane: obb_plane,
    obb_frustum: obb_frustum,
    obb_frustum_accurate: obb_frustum_accurate,
    obb_point: obb_point,
    obb_capsule: obb_capsule,
    capsule_capsule: capsule_capsule,
    resolve: function resolve(g1, g2) {
        var outPt = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, type1 = g1._type, type2 = g2._type, resolver = this[type1 | type2];
        return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
    }
};

intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = ray_sphere, intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = ray_aabb, 
intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = ray_obb, intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = ray_plane, 
intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = ray_triangle, intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = ray_capsule, 
intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = line_sphere, intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = line_aabb, 
intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = line_obb, intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = line_plane, 
intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = line_triangle, intersect[enums.SHAPE_SPHERE] = sphere_sphere, 
intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphere_aabb, intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphere_obb, 
intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = sphere_plane, intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphere_frustum, 
intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphere_frustum_accurate, 
intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphere_capsule, intersect[enums.SHAPE_AABB] = aabb_aabb, 
intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabb_obb, intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabb_plane, 
intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabb_frustum, intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabb_frustum_accurate, 
intersect[enums.SHAPE_OBB] = obb_obb, intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obb_plane, 
intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obb_frustum, intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obb_frustum_accurate, 
intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obb_capsule, intersect[enums.SHAPE_CAPSULE] = capsule_capsule;

var line = function() {
    function line() {
        var sx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, sy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, sz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, ex = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, ey = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, ez = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : -1;
        _classCallCheck(this, line), this.s = void 0, this.e = void 0, this._type = void 0, 
        this._type = enums.SHAPE_LINE, this.s = new Vec3(sx, sy, sz), this.e = new Vec3(ex, ey, ez);
    }
    return _createClass(line, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create(sx, sy, sz, ex, ey, ez) {
            return new line(sx, sy, sz, ex, ey, ez);
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return Vec3.copy(out.s, a.s), Vec3.copy(out.e, a.e), out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, start, end) {
            return Vec3.copy(out.s, start), Vec3.copy(out.e, end), out;
        }
    }, {
        key: "set",
        value: function set(out, sx, sy, sz, ex, ey, ez) {
            return out.s.x = sx, out.s.y = sy, out.s.z = sz, out.e.x = ex, out.e.y = ey, out.e.z = ez, 
            out;
        }
    }, {
        key: "len",
        value: function len(a) {
            return Vec3.distance(a.s, a.e);
        }
    } ]), _createClass(line, [ {
        key: "length",
        value: function length() {
            return Vec3.distance(this.s, this.e);
        }
    } ]), line;
}(), v1 = new Vec3(0, 0, 0), v2$1 = new Vec3(0, 0, 0), temp_mat = cc.mat4(), temp_vec4 = cc.v4(), plane = function() {
    function plane() {
        var nx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, ny = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, nz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, d = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        _classCallCheck(this, plane), this.n = void 0, this.d = void 0, this._type = void 0, 
        this._type = enums.SHAPE_PLANE, this.n = new Vec3(nx, ny, nz), this.d = d;
    }
    return _createClass(plane, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create(nx, ny, nz, d) {
            return new plane(nx, ny, nz, d);
        }
    }, {
        key: "clone",
        value: function clone(p) {
            return new plane(p.n.x, p.n.y, p.n.z, p.d);
        }
    }, {
        key: "copy",
        value: function copy(out, p) {
            return Vec3.copy(out.n, p.n), out.d = p.d, out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, a, b, c) {
            return Vec3.subtract(v1, b, a), Vec3.subtract(v2$1, c, a), Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2$1)), 
            out.d = Vec3.dot(out.n, a), out;
        }
    }, {
        key: "set",
        value: function set(out, nx, ny, nz, d) {
            return out.n.x = nx, out.n.y = ny, out.n.z = nz, out.d = d, out;
        }
    }, {
        key: "fromNormalAndPoint",
        value: function fromNormalAndPoint(out, normal, point) {
            return Vec3.copy(out.n, normal), out.d = Vec3.dot(normal, point), out;
        }
    }, {
        key: "normalize",
        value: function normalize(out, a) {
            var len = a.n.length();
            return Vec3.normalize(out.n, a.n), len > 0 && (out.d = a.d / len), out;
        }
    } ]), _createClass(plane, [ {
        key: "transform",
        value: function transform(mat) {
            Mat4.invert(temp_mat, mat), Mat4.transpose(temp_mat, temp_mat), Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d), 
            Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat), Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z), 
            this.d = temp_vec4.w;
        }
    } ]), plane;
}(), _v3_tmp$1 = new Vec3, _v3_tmp2 = new Vec3, _v3_tmp3 = new Vec3, _v3_tmp4 = new Vec3, _m3_tmp = new Mat3, transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
    _m3_tmp.m00 = Math.abs(m4.m00), _m3_tmp.m01 = Math.abs(m4.m01), _m3_tmp.m02 = Math.abs(m4.m02), 
    _m3_tmp.m03 = Math.abs(m4.m04), _m3_tmp.m04 = Math.abs(m4.m05), _m3_tmp.m05 = Math.abs(m4.m06), 
    _m3_tmp.m06 = Math.abs(m4.m08), _m3_tmp.m07 = Math.abs(m4.m09), _m3_tmp.m08 = Math.abs(m4.m10), 
    Vec3.transformMat3(out, extent, _m3_tmp);
}, aabb = function() {
    function aabb() {
        var px = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, py = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, pz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, hw = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, hh = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, hl = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
        _classCallCheck(this, aabb), this.center = void 0, this.halfExtents = void 0, this._type = void 0, 
        this._type = enums.SHAPE_AABB, this.center = new Vec3(px, py, pz), this.halfExtents = new Vec3(hw, hh, hl);
    }
    return _createClass(aabb, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create(px, py, pz, hw, hh, hl) {
            return new aabb(px, py, pz, hw, hh, hl);
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new aabb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return Vec3.copy(out.center, a.center), Vec3.copy(out.halfExtents, a.halfExtents), 
            out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, minPos, maxPos) {
            return Vec3.add(_v3_tmp$1, maxPos, minPos), Vec3.subtract(_v3_tmp2, maxPos, minPos), 
            Vec3.multiplyScalar(out.center, _v3_tmp$1, .5), Vec3.multiplyScalar(out.halfExtents, _v3_tmp2, .5), 
            out;
        }
    }, {
        key: "set",
        value: function set(out, px, py, pz, hw, hh, hl) {
            return Vec3.set(out.center, px, py, pz), Vec3.set(out.halfExtents, hw, hh, hl), 
            out;
        }
    }, {
        key: "merge",
        value: function merge(out, a, b) {
            return Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents), Vec3.subtract(_v3_tmp2, b.center, b.halfExtents), 
            Vec3.add(_v3_tmp3, a.center, a.halfExtents), Vec3.add(_v3_tmp4, b.center, b.halfExtents), 
            Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4), Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2), 
            aabb.fromPoints(out, _v3_tmp3, _v3_tmp4);
        }
    }, {
        key: "transform",
        value: function transform(out, a, matrix) {
            return Vec3.transformMat4(out.center, a.center, matrix), transform_extent_m4(out.halfExtents, a.halfExtents, matrix), 
            out;
        }
    } ]), _createClass(aabb, [ {
        key: "getBoundary",
        value: function getBoundary(minPos, maxPos) {
            Vec3.subtract(minPos, this.center, this.halfExtents), Vec3.add(maxPos, this.center, this.halfExtents);
        }
    }, {
        key: "transform",
        value: function transform(m, pos, rot, scale, out) {
            Vec3.transformMat4(out.center, this.center, m), transform_extent_m4(out.halfExtents, this.halfExtents, m);
        }
    }, {
        key: "clone",
        value: function clone() {
            return aabb.clone(this);
        }
    }, {
        key: "copy",
        value: function copy(a) {
            return aabb.copy(this, a);
        }
    } ]), aabb;
}(), _v3_tmp$2 = new Vec3, _v3_tmp2$1 = new Vec3, _m3_tmp$1 = new Mat3, obb = function() {
    function obb() {
        var cx = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, cy = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, cz = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, hw = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, hh = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1, hl = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, ox_1 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, ox_2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, ox_3 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, oy_1 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, oy_2 = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, oy_3 = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, oz_1 = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, oz_2 = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, oz_3 = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 1;
        _classCallCheck(this, obb), this.center = void 0, this.halfExtents = void 0, this.orientation = void 0, 
        this._type = void 0, this._type = enums.SHAPE_OBB, this.center = new Vec3(cx, cy, cz), 
        this.halfExtents = new Vec3(hw, hh, hl), this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
    }
    return _createClass(obb, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
            return new obb(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        }
    }, {
        key: "clone",
        value: function clone(a) {
            return new obb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
        }
    }, {
        key: "copy",
        value: function copy(out, a) {
            return Vec3.copy(out.center, a.center), Vec3.copy(out.halfExtents, a.halfExtents), 
            Mat3.copy(out.orientation, a.orientation), out;
        }
    }, {
        key: "fromPoints",
        value: function fromPoints(out, minPos, maxPos) {
            return Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), .5), 
            Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), .5), 
            Mat3.identity(out.orientation), out;
        }
    }, {
        key: "set",
        value: function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
            return Vec3.set(out.center, cx, cy, cz), Vec3.set(out.halfExtents, hw, hh, hl), 
            Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3), 
            out;
        }
    } ]), _createClass(obb, [ {
        key: "getBoundary",
        value: function getBoundary(minPos, maxPos) {
            !function transform_extent_m3(out, extent, m3) {
                _m3_tmp$1.m00 = Math.abs(m3.m00), _m3_tmp$1.m01 = Math.abs(m3.m01), _m3_tmp$1.m02 = Math.abs(m3.m02), 
                _m3_tmp$1.m03 = Math.abs(m3.m03), _m3_tmp$1.m04 = Math.abs(m3.m04), _m3_tmp$1.m05 = Math.abs(m3.m05), 
                _m3_tmp$1.m06 = Math.abs(m3.m06), _m3_tmp$1.m07 = Math.abs(m3.m07), _m3_tmp$1.m08 = Math.abs(m3.m08), 
                Vec3.transformMat3(out, extent, _m3_tmp$1);
            }(_v3_tmp$2, this.halfExtents, this.orientation), Vec3.subtract(minPos, this.center, _v3_tmp$2), 
            Vec3.add(maxPos, this.center, _v3_tmp$2);
        }
    }, {
        key: "transform",
        value: function transform(m, pos, rot, scale, out) {
            Vec3.transformMat4(out.center, this.center, m), Mat3.fromQuat(out.orientation, rot), 
            Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        }
    }, {
        key: "translateAndRotate",
        value: function translateAndRotate(m, rot, out) {
            Vec3.transformMat4(out.center, this.center, m), Mat3.fromQuat(out.orientation, rot);
        }
    }, {
        key: "setScale",
        value: function setScale(scale, out) {
            Vec3.multiply(out.halfExtents, this.halfExtents, scale);
        }
    } ]), obb;
}(), capsule = function() {
    function capsule() {
        var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, halfHeight = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5, axis = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
        _classCallCheck(this, capsule), this._type = void 0, this.radius = void 0, this.halfHeight = void 0, 
        this.axis = void 0, this.center = void 0, this.rotation = void 0, this.ellipseCenter0 = void 0, 
        this.ellipseCenter1 = void 0, this._type = enums.SHAPE_CAPSULE, this.radius = radius, 
        this.halfHeight = halfHeight, this.axis = axis, this.center = new Vec3, this.rotation = new Quat, 
        this.ellipseCenter0 = new Vec3(0, halfHeight, 0), this.ellipseCenter1 = new Vec3(0, -halfHeight, 0), 
        this.updateCache();
    }
    return _createClass(capsule, [ {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ]), _createClass(capsule, [ {
        key: "transform",
        value: function transform(m, pos, rot, scale, out) {
            var ws = scale, s = absMaxComponent(ws);
            out.radius = this.radius * Math.abs(s);
            var halfWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y) - out.radius;
            halfWorldHeight < 0 && (halfWorldHeight = 0), out.halfHeight = halfWorldHeight, 
            Vec3.transformMat4(out.center, this.center, m), Quat.multiply(out.rotation, this.rotation, rot), 
            out.updateCache();
        }
    }, {
        key: "updateCache",
        value: function updateCache() {
            this.updateLocalCenter(), Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation), 
            Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation), this.ellipseCenter0.add(this.center), 
            this.ellipseCenter1.add(this.center);
        }
    }, {
        key: "updateLocalCenter",
        value: function updateLocalCenter() {
            var halfHeight = this.halfHeight;
            switch (this.axis) {
              case 0:
                this.ellipseCenter0.set(halfHeight, 0, 0), this.ellipseCenter1.set(-halfHeight, 0, 0);
                break;

              case 1:
                this.ellipseCenter0.set(0, halfHeight, 0), this.ellipseCenter1.set(0, -halfHeight, 0);
                break;

              case 2:
                this.ellipseCenter0.set(0, 0, halfHeight), this.ellipseCenter1.set(0, 0, -halfHeight);
            }
        }
    } ]), capsule;
}(), _v = new Array(8);

_v[0] = new Vec3(1, 1, 1), _v[1] = new Vec3(-1, 1, 1), _v[2] = new Vec3(-1, -1, 1), 
_v[3] = new Vec3(1, -1, 1), _v[4] = new Vec3(1, 1, -1), _v[5] = new Vec3(-1, 1, -1), 
_v[6] = new Vec3(-1, -1, -1), _v[7] = new Vec3(1, -1, -1);

var frustum = function() {
    function frustum() {
        _classCallCheck(this, frustum), this._type = void 0, this.planes = void 0, this.vertices = void 0, 
        this._type = enums.SHAPE_FRUSTUM, this.planes = new Array(6);
        for (var i = 0; i < 6; ++i) this.planes[i] = plane.create(0, 0, 0, 0);
        this.vertices = new Array(8);
        for (var _i2 = 0; _i2 < 8; ++_i2) this.vertices[_i2] = new Vec3;
    }
    return _createClass(frustum, [ {
        key: "accurate",
        set: function set(b) {
            this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ], [ {
        key: "create",
        value: function create() {
            return new frustum;
        }
    }, {
        key: "clone",
        value: function clone(f) {
            return frustum.copy(new frustum, f);
        }
    }, {
        key: "copy",
        value: function copy(out, f) {
            out._type = f._type;
            for (var i = 0; i < 6; ++i) plane.copy(out.planes[i], f.planes[i]);
            for (var _i = 0; _i < 8; ++_i) Vec3.copy(out.vertices[_i], f.vertices[_i]);
            return out;
        }
    } ]), _createClass(frustum, [ {
        key: "update",
        value: function update(m, inv) {
            if (Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08), this.planes[0].d = -(m.m15 + m.m12), 
            Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08), this.planes[1].d = -(m.m15 - m.m12), 
            Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09), this.planes[2].d = -(m.m15 + m.m13), 
            Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09), this.planes[3].d = -(m.m15 - m.m13), 
            Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10), this.planes[4].d = -(m.m15 + m.m14), 
            Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10), this.planes[5].d = -(m.m15 - m.m14), 
            this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                for (var i = 0; i < 6; i++) {
                    var pl = this.planes[i], invDist = 1 / pl.n.length();
                    Vec3.multiplyScalar(pl.n, pl.n, invDist), pl.d *= invDist;
                }
                for (var _i3 = 0; _i3 < 8; _i3++) Vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
            }
        }
    }, {
        key: "transform",
        value: function transform(mat) {
            if (this._type === enums.SHAPE_FRUSTUM_ACCURATE) {
                for (var i = 0; i < 8; i++) Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
                plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]), 
                plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]), 
                plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]), 
                plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]), 
                plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]), 
                plane.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
            }
        }
    } ]), frustum;
}();

frustum.createOrtho = function() {
    var _temp_v3 = new Vec3;
    return function(out, width, height, near, far, transform) {
        var halfWidth = width / 2, halfHeight = height / 2;
        Vec3.set(_temp_v3, halfWidth, halfHeight, near), Vec3.transformMat4(out.vertices[0], _temp_v3, transform), 
        Vec3.set(_temp_v3, -halfWidth, halfHeight, near), Vec3.transformMat4(out.vertices[1], _temp_v3, transform), 
        Vec3.set(_temp_v3, -halfWidth, -halfHeight, near), Vec3.transformMat4(out.vertices[2], _temp_v3, transform), 
        Vec3.set(_temp_v3, halfWidth, -halfHeight, near), Vec3.transformMat4(out.vertices[3], _temp_v3, transform), 
        Vec3.set(_temp_v3, halfWidth, halfHeight, far), Vec3.transformMat4(out.vertices[4], _temp_v3, transform), 
        Vec3.set(_temp_v3, -halfWidth, halfHeight, far), Vec3.transformMat4(out.vertices[5], _temp_v3, transform), 
        Vec3.set(_temp_v3, -halfWidth, -halfHeight, far), Vec3.transformMat4(out.vertices[6], _temp_v3, transform), 
        Vec3.set(_temp_v3, halfWidth, -halfHeight, far), Vec3.transformMat4(out.vertices[7], _temp_v3, transform), 
        plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]), 
        plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]), 
        plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]), 
        plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]), 
        plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]), 
        plane.fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
    };
}();

var WrapMode = Enum({
    Default: 0,
    Once: 1,
    Loop: 2,
    PingPong: 3,
    ClampForever: 4
}), Keyframe = function Keyframe() {
    _classCallCheck(this, Keyframe), this.time = 0, this.value = 0, this.inTangent = 0, 
    this.outTangent = 0;
};

CCClass.fastDefine("cc.Keyframe", Keyframe, {
    time: 0,
    value: 0,
    inTangent: 0,
    outTangent: 0
});

var OptimizedKey = function() {
    function OptimizedKey() {
        _classCallCheck(this, OptimizedKey), this.index = void 0, this.time = void 0, this.endTime = void 0, 
        this.coefficient = void 0, this.index = -1, this.time = 0, this.endTime = 0, this.coefficient = new Float32Array(4);
    }
    return _createClass(OptimizedKey, [ {
        key: "evaluate",
        value: function evaluate(T) {
            return function evalOptCurve(t, coefs) {
                return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
            }(T - this.time, this.coefficient);
        }
    } ]), OptimizedKey;
}();

var AnimationCurve = function() {
    function AnimationCurve() {
        var keyFrames = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
        _classCallCheck(this, AnimationCurve), this.keyFrames = void 0, this.preWrapMode = WrapMode.Loop, 
        this.postWrapMode = WrapMode.Loop, this.cachedKey = void 0, this.keyFrames = keyFrames || [].concat(AnimationCurve.defaultKF), 
        this.cachedKey = new OptimizedKey;
    }
    return _createClass(AnimationCurve, [ {
        key: "addKey",
        value: function addKey(keyFrame) {
            null == this.keyFrames && (this.keyFrames = []), this.keyFrames.push(keyFrame);
        }
    }, {
        key: "evaluate_slow",
        value: function evaluate_slow(time) {
            var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
            switch (wrapMode) {
              case WrapMode.Loop:
                wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                break;

              case WrapMode.PingPong:
                wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                break;

              case WrapMode.ClampForever:
                wrappedTime = clamp(time, startTime, endTime);
            }
            var preKFIndex = 0;
            if (wrappedTime > this.keyFrames[0].time) if (wrappedTime >= this.keyFrames[this.keyFrames.length - 1].time) preKFIndex = this.keyFrames.length - 2; else for (var i = 0; i < this.keyFrames.length - 1; i++) if (wrappedTime >= this.keyFrames[0].time && wrappedTime <= this.keyFrames[i + 1].time) {
                preKFIndex = i;
                break;
            }
            var keyframe0 = this.keyFrames[preKFIndex], keyframe1 = this.keyFrames[preKFIndex + 1], t = inverseLerp(keyframe0.time, keyframe1.time, wrappedTime), dt = keyframe1.time - keyframe0.time, m0 = keyframe0.outTangent * dt, m1 = keyframe1.inTangent * dt, t2 = t * t, t3 = t2 * t, b = t3 - 2 * t2 + t, c = t3 - t2, d = -2 * t3 + 3 * t2;
            return (2 * t3 - 3 * t2 + 1) * keyframe0.value + b * m0 + c * m1 + d * keyframe1.value;
        }
    }, {
        key: "evaluate",
        value: function evaluate(time) {
            var wrappedTime = time, wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode, startTime = this.keyFrames[0].time, endTime = this.keyFrames[this.keyFrames.length - 1].time;
            switch (wrapMode) {
              case WrapMode.Loop:
                wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                break;

              case WrapMode.PingPong:
                wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                break;

              case WrapMode.ClampForever:
                wrappedTime = clamp(time, startTime, endTime);
            }
            if (wrappedTime >= this.cachedKey.time && wrappedTime < this.cachedKey.endTime) return this.cachedKey.evaluate(wrappedTime);
            var leftIndex = this.findIndex(this.cachedKey, wrappedTime), rightIndex = leftIndex + 1;
            return rightIndex === this.keyFrames.length && (rightIndex -= 1), this.calcOptimizedKey(this.cachedKey, leftIndex, rightIndex), 
            this.cachedKey.evaluate(wrappedTime);
        }
    }, {
        key: "calcOptimizedKey",
        value: function calcOptimizedKey(optKey, leftIndex, rightIndex) {
            var lhs = this.keyFrames[leftIndex], rhs = this.keyFrames[rightIndex];
            optKey.index = leftIndex, optKey.time = lhs.time, optKey.endTime = rhs.time;
            var dx = rhs.time - lhs.time, dy = rhs.value - lhs.value, length = 1 / (dx * dx), d1 = lhs.outTangent * dx, d2 = rhs.inTangent * dx;
            optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx, optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length, 
            optKey.coefficient[2] = lhs.outTangent, optKey.coefficient[3] = lhs.value;
        }
    }, {
        key: "findIndex",
        value: function findIndex(optKey, t) {
            var cachedIndex = optKey.index;
            if (-1 !== cachedIndex) if (t > this.keyFrames[cachedIndex].time) for (var i = 0; i < 3; i++) {
                var currIndex = cachedIndex + i;
                if (currIndex + 1 < this.keyFrames.length && this.keyFrames[currIndex + 1].time > t) return currIndex;
            } else for (var _i = 0; _i < 3; _i++) {
                var _currIndex = cachedIndex - _i;
                if (_currIndex >= 0 && this.keyFrames[_currIndex - 1].time <= t) return _currIndex - 1;
            }
            for (var left = 0, right = this.keyFrames.length, mid = Math.floor((left + right) / 2); right - left > 1; ) this.keyFrames[mid].time >= t ? right = mid : left = mid + 1, 
            mid = Math.floor((left + right) / 2);
            return left;
        }
    } ]), AnimationCurve;
}();

AnimationCurve.defaultKF = [ {
    time: 0,
    value: 1,
    inTangent: 0,
    outTangent: 0
}, {
    time: 1,
    value: 1,
    inTangent: 0,
    outTangent: 0
} ], CCClass.fastDefine("cc.AnimationCurve", AnimationCurve, {
    preWrapMode: WrapMode.Default,
    postWrapMode: WrapMode.Default,
    keyFrames: []
}), exports.replaceProperty(line.prototype, "line", [ {
    name: "mag",
    newName: "len"
}, {
    name: "magnitude",
    newName: "len"
} ]), exports.removeProperty(intersect, "intersect", [ {
    name: "line_quad"
} ]);

var geometry = Object.freeze({
    __proto__: null,
    distance: distance,
    enums: enums,
    intersect: intersect,
    line: line,
    plane: plane,
    ray: ray,
    triangle: triangle,
    sphere: sphere,
    aabb: aabb,
    obb: obb,
    capsule: capsule,
    frustum: frustum,
    Keyframe: Keyframe,
    AnimationCurve: AnimationCurve,
    get ERaycastMode() {
        return ERaycastMode;
    }
}), Pool$1 = function() {
    function Pool(fn, size) {
        _classCallCheck(this, Pool), this._fn = void 0, this._idx = void 0, this._frees = void 0, 
        this._fn = fn, this._idx = size - 1, this._frees = new Array(size);
        for (var i = 0; i < size; ++i) this._frees[i] = fn();
    }
    return _createClass(Pool, [ {
        key: "alloc",
        value: function alloc() {
            this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
            var ret = this._frees[this._idx];
            return this._frees.splice(this._idx), --this._idx, ret;
        }
    }, {
        key: "free",
        value: function free(obj) {
            ++this._idx, this._frees[this._idx] = obj;
        }
    }, {
        key: "clear",
        value: function clear(fn) {
            for (var i = 0; i <= this._idx; i++) fn && fn(this._frees[i]);
            this._frees.splice(0), this._idx = -1;
        }
    }, {
        key: "_expand",
        value: function _expand(size) {
            var old = this._frees;
            this._frees = new Array(size);
            for (var len = size - old.length, i = 0; i < len; ++i) this._frees[i] = this._fn();
            for (var _i = len, j = 0; _i < size; ++_i, ++j) this._frees[_i] = old[j];
            this._idx += len;
        }
    } ]), Pool;
}(), RecyclePool = function() {
    function RecyclePool(fn, size) {
        _classCallCheck(this, RecyclePool), this._fn = void 0, this._count = 0, this._data = void 0, 
        this._fn = fn, this._data = new Array(size);
        for (var i = 0; i < size; ++i) this._data[i] = fn();
    }
    return _createClass(RecyclePool, [ {
        key: "reset",
        value: function reset() {
            this._count = 0;
        }
    }, {
        key: "resize",
        value: function resize(size) {
            if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = this._fn();
        }
    }, {
        key: "add",
        value: function add() {
            return this._count >= this._data.length && this.resize(2 * this._data.length), this._data[this._count++];
        }
    }, {
        key: "removeAt",
        value: function removeAt(idx) {
            if (!(idx >= this._count)) {
                var last = this._count - 1, tmp = this._data[idx];
                this._data[idx] = this._data[last], this._data[last] = tmp, this._count -= 1;
            }
        }
    }, {
        key: "length",
        get: function get() {
            return this._count;
        }
    }, {
        key: "data",
        get: function get() {
            return this._data;
        }
    } ]), RecyclePool;
}(), CachedArray = function() {
    function CachedArray(length, compareFn) {
        _classCallCheck(this, CachedArray), this.array = void 0, this.length = 0, this._compareFn = void 0, 
        this.array = new Array(length), this.length = 0, this._compareFn = void 0 !== compareFn ? compareFn : function(a, b) {
            return a - b;
        };
    }
    return _createClass(CachedArray, [ {
        key: "push",
        value: function push(item) {
            this.array[this.length++] = item;
        }
    }, {
        key: "pop",
        value: function pop() {
            return this.array[--this.length];
        }
    }, {
        key: "get",
        value: function get(idx) {
            return this.array[idx];
        }
    }, {
        key: "clear",
        value: function clear() {
            this.length = 0;
        }
    }, {
        key: "sort",
        value: function sort() {
            this.array.length = this.length, this.array.sort(this._compareFn);
        }
    }, {
        key: "concat",
        value: function concat(array) {
            for (var i = 0; i < array.length; ++i) this.array[this.length++] = array[i];
        }
    }, {
        key: "fastRemove",
        value: function fastRemove(idx) {
            if (!(idx >= this.length || idx < 0)) {
                var last = --this.length;
                this.array[idx] = this.array[last];
            }
        }
    }, {
        key: "indexOf",
        value: function indexOf(val) {
            return this.array.indexOf(val);
        }
    } ]), CachedArray;
}(), index = Object.freeze({
    __proto__: null,
    Pool: Pool$1,
    RecyclePool: RecyclePool,
    CachedArray: CachedArray
}), WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/, SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/, LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+|\S)$/, LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+$/, FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]/;

function isUnicodeCJK(ch) {
    return /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/.test(ch) || /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g.test(ch) || /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/.test(ch);
}

function isUnicodeSpace(ch) {
    var chCode = ch.charCodeAt(0);
    return chCode >= 9 && chCode <= 13 || 32 === chCode || 133 === chCode || 160 === chCode || 5760 === chCode || chCode >= 8192 && chCode <= 8202 || 8232 === chCode || 8233 === chCode || 8239 === chCode || 8287 === chCode || 12288 === chCode;
}

function safeMeasureText(ctx, string) {
    var metric = ctx.measureText(string);
    return metric && metric.width || 0;
}

function fragmentText(stringToken, allWidth, maxWidth, measureText) {
    var wrappedWords = [];
    if (0 === stringToken.length || maxWidth < 0) return wrappedWords.push(""), wrappedWords;
    for (var text = stringToken; allWidth > maxWidth && text.length > 1; ) {
        for (var fuzzyLen = text.length * (maxWidth / allWidth) | 0, tmpText = text.substr(fuzzyLen), width = allWidth - measureText(tmpText), sLine = tmpText, pushNum = 0, checkWhile = 0; width > maxWidth && checkWhile++ < 10; ) fuzzyLen *= maxWidth / width, 
        fuzzyLen |= 0, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
        for (checkWhile = 0; width <= maxWidth && checkWhile++ < 10; ) {
            if (tmpText) {
                var exec = WORD_REG.exec(tmpText);
                pushNum = exec ? exec[0].length : 1, sLine = tmpText;
            }
            fuzzyLen += pushNum, width = allWidth - measureText(tmpText = text.substr(fuzzyLen));
        }
        0 === (fuzzyLen -= pushNum) && (fuzzyLen = 1, sLine = sLine.substr(1));
        var sText = text.substr(0, fuzzyLen), result = void 0;
        SYMBOL_REG.test(sLine || tmpText) && (0 === (fuzzyLen -= (result = LAST_WORD_REG.exec(sText)) ? result[0].length : 0) && (fuzzyLen = 1), 
        sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), FIRST_ENGLISH_REG.test(sLine) && (result = LAST_ENGLISH_REG.exec(sText)) && sText !== result[0] && (fuzzyLen -= result[0].length, 
        sLine = text.substr(fuzzyLen), sText = text.substr(0, fuzzyLen)), (0 === wrappedWords.length || (sText = sText.trim()).length > 0) && wrappedWords.push(sText), 
        allWidth = measureText(text = sLine || tmpText);
    }
    return (0 === wrappedWords.length || (text = text.trim()).length > 0) && wrappedWords.push(text), 
    wrappedWords;
}

var eventRegx = /^(click)(\s)*=|(param)(\s)*=/, imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/, HtmlTextParser = function() {
    function HtmlTextParser() {
        _classCallCheck(this, HtmlTextParser), this._specialSymbolArray = [], this._stack = [], 
        this._resultObjectArray = [], this._specialSymbolArray.push([ /&lt;/g, "<" ]), this._specialSymbolArray.push([ /&gt;/g, ">" ]), 
        this._specialSymbolArray.push([ /&amp;/g, "&" ]), this._specialSymbolArray.push([ /&quot;/g, '"' ]), 
        this._specialSymbolArray.push([ /&apos;/g, "'" ]);
    }
    return _createClass(HtmlTextParser, [ {
        key: "parse",
        value: function parse(htmlString) {
            this._resultObjectArray.length = 0, this._stack.length = 0;
            for (var startIndex = 0, length = htmlString.length; startIndex < length; ) {
                var tagBeginIndex = htmlString.indexOf("<", startIndex);
                if (tagBeginIndex < 0) this._stack.pop(), this._processResult(htmlString.substring(startIndex)), 
                startIndex = length; else {
                    this._processResult(htmlString.substring(startIndex, tagBeginIndex));
                    var tagEndIndex = htmlString.indexOf(">", startIndex);
                    -1 === tagEndIndex ? tagEndIndex = tagBeginIndex : "/" === htmlString.charAt(tagBeginIndex + 1) ? this._stack.pop() : this._addToStack(htmlString.substring(tagBeginIndex + 1, tagEndIndex)), 
                    startIndex = tagEndIndex + 1;
                }
            }
            return this._resultObjectArray;
        }
    }, {
        key: "_attributeToObject",
        value: function _attributeToObject(attribute) {
            var obj = {}, header = (attribute = attribute.trim()).match(/^(color|size)(\s)*=/), tagName = "", nextSpace = 0, eventHanlderString = "";
            if (header) {
                if (tagName = header[0], "" === (attribute = attribute.substring(tagName.length).trim())) return obj;
                switch (nextSpace = attribute.indexOf(" "), tagName[0]) {
                  case "c":
                    obj.color = nextSpace > -1 ? attribute.substring(0, nextSpace).trim() : attribute;
                    break;

                  case "s":
                    obj.size = parseInt(attribute);
                }
                return nextSpace > -1 && (eventHanlderString = attribute.substring(nextSpace + 1).trim(), 
                obj.event = this._processEventHandler(eventHanlderString)), obj;
            }
            if ((header = attribute.match(/^(br(\s)*\/)/)) && header[0].length > 0 && (tagName = header[0].trim()).startsWith("br") && "/" === tagName[tagName.length - 1]) return obj.isNewLine = !0, 
            this._resultObjectArray.push({
                text: "",
                style: {
                    newline: !0
                }
            }), obj;
            var remainingArgument = "";
            if ((header = attribute.match(/^(img(\s)*src(\s)*=[^>]+\/)/)) && header[0].length > 0 && (tagName = header[0].trim()).startsWith("img") && "/" === tagName[tagName.length - 1]) {
                var tagValue;
                header = attribute.match(imageAttrReg);
                for (var isValidImageTag = !1; header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                tagValue = (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                attribute = remainingArgument.substring(nextSpace).trim(), "src" === tagName ? (obj.isImage = !0, 
                tagValue.endsWith("/") && (tagValue = tagValue.substring(0, tagValue.length - 1)), 
                (0 === tagValue.indexOf("'") || 0 === tagValue.indexOf('"')) && (isValidImageTag = !0, 
                tagValue = tagValue.substring(1, tagValue.length - 1)), obj.src = tagValue) : "height" === tagName ? obj.imageHeight = parseInt(tagValue) : "width" === tagName ? obj.imageWidth = parseInt(tagValue) : "click" === tagName && (obj.event = this._processEventHandler(tagName + "=" + tagValue)), 
                obj.event && "param" === tagName && (obj.event[tagName] = tagValue.replace(/^\"|\"$/g, "")), 
                header = attribute.match(imageAttrReg);
                return isValidImageTag && obj.isImage && this._resultObjectArray.push({
                    text: "",
                    style: obj
                }), {};
            }
            if (header = attribute.match(/^(outline(\s)*[^>]*)/)) {
                var defaultOutlineObject = {
                    color: "#ffffff",
                    width: 1
                };
                if (attribute = header[0].substring("outline".length).trim()) {
                    var _tagValue, outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                    for (header = attribute.match(outlineAttrReg); header; ) tagName = (attribute = attribute.substring(attribute.indexOf(header[0]))).substr(0, header[0].length), 
                    _tagValue = (nextSpace = (remainingArgument = attribute.substring(tagName.length).trim()).indexOf(" ")) > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument, 
                    tagName = (tagName = tagName.replace(/[^a-zA-Z]/g, "").trim()).toLocaleLowerCase(), 
                    attribute = remainingArgument.substring(nextSpace).trim(), "click" === tagName ? obj.event = this._processEventHandler(tagName + "=" + _tagValue) : "color" === tagName ? defaultOutlineObject.color = _tagValue : "width" === tagName && (defaultOutlineObject.width = parseInt(_tagValue)), 
                    obj.event && "param" === tagName && (obj.event[tagName] = _tagValue.replace(/^\"|\"$/g, "")), 
                    header = attribute.match(outlineAttrReg);
                }
                obj.outline = defaultOutlineObject;
            }
            if ((header = attribute.match(/^(on|u|b|i)(\s)*/)) && header[0].length > 0) {
                switch (tagName = header[0], attribute = attribute.substring(tagName.length).trim(), 
                tagName[0]) {
                  case "u":
                    obj.underline = !0;
                    break;

                  case "i":
                    obj.italic = !0;
                    break;

                  case "b":
                    obj.bold = !0;
                }
                if ("" === attribute) return obj;
                obj.event = this._processEventHandler(attribute);
            }
            return obj;
        }
    }, {
        key: "_processEventHandler",
        value: function _processEventHandler(eventString) {
            for (var index = 0, obj = new Map, eventNames = eventString.match(eventRegx), isValidTag = !1; eventNames; ) {
                var eventName = eventNames[0], eventValue = "";
                if (isValidTag = !1, '"' === (eventString = eventString.substring(eventName.length).trim()).charAt(0)) (index = eventString.indexOf('"', 1)) > -1 && (eventValue = eventString.substring(1, index).trim(), 
                isValidTag = !0), index++; else if ("'" === eventString.charAt(0)) (index = eventString.indexOf("'", 1)) > -1 && (eventValue = eventString.substring(1, index).trim(), 
                isValidTag = !0), index++; else {
                    var match = eventString.match(/(\S)+/);
                    index = (eventValue = match ? match[0] : "").length;
                }
                isValidTag && (obj[eventName = eventName.substring(0, eventName.length - 1).trim()] = eventValue), 
                eventNames = (eventString = eventString.substring(index).trim()).match(eventRegx);
            }
            return obj;
        }
    }, {
        key: "_addToStack",
        value: function _addToStack(attribute) {
            var obj = this._attributeToObject(attribute);
            if (0 === this._stack.length) this._stack.push(obj); else {
                if (obj.isNewLine || obj.isImage) return;
                var previousTagObj = this._stack[this._stack.length - 1];
                for (var key in previousTagObj) obj[key] || (obj[key] = previousTagObj[key]);
                this._stack.push(obj);
            }
        }
    }, {
        key: "_processResult",
        value: function _processResult(value) {
            0 !== value.length && (value = this._escapeSpecialSymbol(value), this._stack.length > 0 ? this._resultObjectArray.push({
                text: value,
                style: this._stack[this._stack.length - 1]
            }) : this._resultObjectArray.push({
                text: value
            }));
        }
    }, {
        key: "_escapeSpecialSymbol",
        value: function _escapeSpecialSymbol(str) {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._specialSymbolArray); !(_step = _iterator()).done; ) {
                var symbolArr = _step.value, key = symbolArr[0], value = symbolArr[1];
                str = str.replace(key, value);
            }
            return str;
        }
    } ]), HtmlTextParser;
}();

function fNOP(ctor) {
    return ctor;
}

function getSubDict(obj, key) {
    return obj[key] || (obj[key] = {});
}

function checkCtorArgument(decorate) {
    return function(target) {
        return "function" == typeof target ? decorate(target) : function(ctor) {
            return decorate(ctor, target);
        };
    };
}

function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
    return function(target) {
        return function(ctor) {
            return decorate(ctor, target);
        };
    };
}

var checkCompArgument = _checkNormalArgument.bind(null, !1);

function _argumentChecker(type) {
    return _checkNormalArgument.bind(null, !1);
}

var checkStringArgument = _argumentChecker(), checkNumberArgument = _argumentChecker();

function getClassCache(ctor, decoratorName) {
    return getSubDict(ctor, "__ccclassCache__");
}

function genProperty(ctor, properties, propName, options, desc, cache) {
    var fullOptions;
    options && (fullOptions = (fullOptions = getFullFormOfProperty(options)) || options);
    var prop = mixin(properties[propName] || {}, fullOptions || {});
    if (desc && (desc.get || desc.set)) desc.get && (prop.get = desc.get), desc.set && (prop.set = desc.set); else {
        var defaultValue;
        if (desc) desc.initializer && (defaultValue = function getDefaultFromInitializer(initializer) {
            var value;
            try {
                value = initializer();
            } catch (e) {
                return initializer;
            }
            return "object" !== _typeof(value) || null === value ? value : initializer;
        }(desc.initializer)); else {
            var actualDefaultValues = cache.default || (cache.default = function extractActualDefaultValues(ctor) {
                var dummyObj;
                try {
                    dummyObj = new ctor;
                } catch (e) {
                    return {};
                }
                return dummyObj;
            }(ctor));
            actualDefaultValues.hasOwnProperty(propName) && (defaultValue = actualDefaultValues[propName]);
        }
        prop.default = defaultValue;
    }
    properties[propName] = prop;
}

var ccclass = checkCtorArgument((function(ctor, name) {
    var base = getSuper(ctor);
    base === Object && (base = null);
    var proto = {
        name: name,
        extends: base,
        ctor: ctor,
        __ES6__: !0
    }, cache = ctor.__ccclassCache__;
    if (cache) {
        var decoratedProto = cache.proto;
        decoratedProto && mixin(proto, decoratedProto), ctor.__ccclassCache__ = void 0;
    }
    return cc.Class(proto);
}));

function property(ctorProtoOrOptions, propName, desc) {
    var options = null;
    function normalized(ctorProto, propName, desc) {
        var cache = getClassCache(ctorProto.constructor);
        if (cache) {
            var ccclassProto = getSubDict(cache, "proto"), properties = getSubDict(ccclassProto, "properties");
            genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
        }
    }
    return void 0 === ctorProtoOrOptions ? property({
        type: void 0
    }) : void 0 === propName ? (options = ctorProtoOrOptions, normalized) : void normalized(ctorProtoOrOptions, propName, desc);
}

function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
    return argCheckFunc((function(ctor, decoratedValue) {
        var cache = getClassCache(ctor);
        if (cache) {
            var value = void 0 !== staticValue ? staticValue : decoratedValue, proto = getSubDict(cache, "proto");
            getSubDict(proto, "editor")[editorPropName] = value;
        }
    }), editorPropName);
}

function createDummyDecorator(argCheckFunc) {
    return argCheckFunc(fNOP);
}

var executeInEditMode = createDummyDecorator(checkCtorArgument), requireComponent = createEditorDecorator(checkCompArgument, "requireComponent"), menu = createDummyDecorator(checkStringArgument), executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder"), disallowMultiple = createDummyDecorator(checkCtorArgument), playOnFocus = createDummyDecorator(checkCtorArgument), inspector = createDummyDecorator(checkStringArgument), icon = createDummyDecorator(checkStringArgument), help = createDummyDecorator(checkStringArgument), integer = type(CCInteger), _float = type(CCFloat), _boolean = type(CCBoolean), string = type(CCString);

function type(type) {
    return property({
        type: type
    });
}

var _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _decorator = Object.freeze({
    __proto__: null,
    ccclass: ccclass,
    property: property,
    executeInEditMode: executeInEditMode,
    requireComponent: requireComponent,
    menu: menu,
    executionOrder: executionOrder,
    disallowMultiple: disallowMultiple,
    playOnFocus: playOnFocus,
    inspector: inspector,
    icon: icon,
    help: help,
    integer: integer,
    float: _float,
    boolean: _boolean,
    string: string,
    type: type
}), PrefabInfo = ccclass("cc.PrefabInfo")((_descriptor = _applyDecoratedDescriptor((_class2 = function PrefabInfo() {
    _classCallCheck(this, PrefabInfo), _initializerDefineProperty(this, "root", _descriptor, this), 
    _initializerDefineProperty(this, "asset", _descriptor2, this), _initializerDefineProperty(this, "fileId", _descriptor3, this), 
    _initializerDefineProperty(this, "sync", _descriptor4, this), _initializerDefineProperty(this, "_synced", _descriptor5, this);
}).prototype, "root", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "asset", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "fileId", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "sync", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_synced", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return {
            default: !1,
            serializable: !1
        };
    }
}), _class = _class2)) || _class;

cc._PrefabInfo = PrefabInfo;

var NetworkType, _global$1 = "undefined" == typeof window ? global : window;

!function(NetworkType) {
    NetworkType[NetworkType.NONE = 0] = "NONE", NetworkType[NetworkType.LAN = 1] = "LAN", 
    NetworkType[NetworkType.WWAN = 2] = "WWAN";
}(NetworkType || (NetworkType = {}));

var buffer, audio, _typeMap2, sys = {
    NetworkType: NetworkType,
    LANGUAGE_ENGLISH: "en",
    LANGUAGE_CHINESE: "zh",
    LANGUAGE_FRENCH: "fr",
    LANGUAGE_ITALIAN: "it",
    LANGUAGE_GERMAN: "de",
    LANGUAGE_SPANISH: "es",
    LANGUAGE_DUTCH: "du",
    LANGUAGE_RUSSIAN: "ru",
    LANGUAGE_KOREAN: "ko",
    LANGUAGE_JAPANESE: "ja",
    LANGUAGE_HUNGARIAN: "hu",
    LANGUAGE_PORTUGUESE: "pt",
    LANGUAGE_ARABIC: "ar",
    LANGUAGE_NORWEGIAN: "no",
    LANGUAGE_POLISH: "pl",
    LANGUAGE_TURKISH: "tr",
    LANGUAGE_UKRAINIAN: "uk",
    LANGUAGE_ROMANIAN: "ro",
    LANGUAGE_BULGARIAN: "bg",
    LANGUAGE_UNKNOWN: "unknown",
    OS_IOS: "iOS",
    OS_ANDROID: "Android",
    OS_WINDOWS: "Windows",
    OS_LINUX: "Linux",
    OS_OSX: "OS X",
    OS_UNKNOWN: "Unknown",
    UNKNOWN: -1,
    WIN32: 0,
    LINUX: 1,
    MACOS: 2,
    ANDROID: 3,
    IPHONE: 4,
    IPAD: 5,
    BLACKBERRY: 6,
    NACL: 7,
    EMSCRIPTEN: 8,
    TIZEN: 9,
    WINRT: 10,
    WP8: 11,
    MOBILE_BROWSER: 100,
    DESKTOP_BROWSER: 101,
    EDITOR_PAGE: 102,
    EDITOR_CORE: 103,
    WECHAT_GAME: 104,
    QQ_PLAY: 105,
    BROWSER_TYPE_WECHAT: "wechat",
    BROWSER_TYPE_COCOSPLAY: "cocosplay",
    BROWSER_TYPE_ANDROID: "androidbrowser",
    BROWSER_TYPE_IE: "ie",
    BROWSER_TYPE_QQ: "qqbrowser",
    BROWSER_TYPE_MOBILE_QQ: "mqqbrowser",
    BROWSER_TYPE_UC: "ucbrowser",
    BROWSER_TYPE_UCBS: "ucbs",
    BROWSER_TYPE_360: "360browser",
    BROWSER_TYPE_BAIDU_APP: "baiduboxapp",
    BROWSER_TYPE_BAIDU: "baidubrowser",
    BROWSER_TYPE_MAXTHON: "maxthon",
    BROWSER_TYPE_OPERA: "opera",
    BROWSER_TYPE_OUPENG: "oupeng",
    BROWSER_TYPE_MIUI: "miuibrowser",
    BROWSER_TYPE_FIREFOX: "firefox",
    BROWSER_TYPE_SAFARI: "safari",
    BROWSER_TYPE_CHROME: "chrome",
    BROWSER_TYPE_LIEBAO: "liebao",
    BROWSER_TYPE_QZONE: "qzone",
    BROWSER_TYPE_SOUGOU: "sogou",
    BROWSER_TYPE_UNKNOWN: "unknown",
    isNative: !1,
    isBrowser: "object" === ("undefined" == typeof window ? "undefined" : _typeof(window)) && "object" === ("undefined" == typeof document ? "undefined" : _typeof(document)) && !1,
    isMobile: !1,
    isLittleEndian: (buffer = new ArrayBuffer(2), new DataView(buffer).setInt16(0, 256, !0), 
    256 === new Int16Array(buffer)[0]),
    platform: -1,
    language: "unknown",
    os: "Unknown",
    osVersion: "",
    osMainVersion: 0,
    browserType: "unknown",
    browserVersion: "",
    windowPixelResolution: null,
    capabilities: null,
    localStorage: null,
    __audioSupport: null,
    getNetworkType: function getNetworkType() {
        return NetworkType.LAN;
    },
    getBatteryLevel: function getBatteryLevel() {
        return 1;
    },
    garbageCollect: function garbageCollect() {},
    isObjectValid: function isObjectValid(obj) {
        return null != obj;
    },
    dump: function dump() {
        var str = "";
        str += "isMobile : " + this.isMobile + "\r\n", str += "language : " + this.language + "\r\n", 
        str += "browserType : " + this.browserType + "\r\n", str += "browserVersion : " + this.browserVersion + "\r\n", 
        str += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n", str += "os : " + this.os + "\r\n", 
        str += "osVersion : " + this.osVersion + "\r\n", str += "platform : " + this.platform + "\r\n", 
        str += "Using " + (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n", 
        cc.log(str);
    },
    openURL: function openURL(url) {
        window.open(url);
    },
    now: function now() {
        return Date.now ? Date.now() : +new Date;
    },
    dumpRoot: function dumpRoot() {},
    restartVM: function restartVM() {},
    cleanScript: function cleanScript(jsfile) {}
};

if (_global$1.__globalAdapter && _global$1.__globalAdapter.adaptSys) _global$1.__globalAdapter.adaptSys(sys); else {
    var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement, ua = nav.userAgent.toLowerCase();
    sys.isMobile = /mobile|android|iphone|ipad/.test(ua), sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
    var currLanguage = nav.language;
    currLanguage = (currLanguage = currLanguage || nav.browserLanguage) ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH, 
    sys.language = currLanguage;
    var isAndroid = !1, iOS = !1, osVersion = "", osMajorVersion = 0, uaResult = /android\s*(\d+(?:\.\d+)*)/i.exec(ua) || /android\s*(\d+(?:\.\d+)*)/i.exec(nav.platform);
    uaResult && (isAndroid = !0, osVersion = uaResult[1] || "", osMajorVersion = parseInt(osVersion) || 0), 
    (uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua)) ? (iOS = !0, osVersion = uaResult[2] || "", 
    osMajorVersion = parseInt(osVersion) || 0) : (/(iPhone|iPad|iPod)/.exec(nav.platform) || "MacIntel" === nav.platform && nav.maxTouchPoints && nav.maxTouchPoints > 1) && (iOS = !0, 
    osVersion = "", osMajorVersion = 0);
    var osName = sys.OS_UNKNOWN;
    -1 !== nav.appVersion.indexOf("Win") ? osName = sys.OS_WINDOWS : iOS ? osName = sys.OS_IOS : -1 !== nav.appVersion.indexOf("Mac") ? osName = sys.OS_OSX : -1 !== nav.appVersion.indexOf("X11") && -1 === nav.appVersion.indexOf("Linux") ? osName = sys.OS_UNIX : isAndroid ? osName = sys.OS_ANDROID : -1 === nav.appVersion.indexOf("Linux") && -1 === ua.indexOf("ubuntu") || (osName = sys.OS_LINUX), 
    sys.os = osName, sys.osVersion = osVersion, sys.osMainVersion = osMajorVersion, 
    sys.browserType = sys.BROWSER_TYPE_UNKNOWN, function() {
        var browserTypes = /mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i.exec(ua);
        browserTypes || (browserTypes = /qqbrowser|ucbrowser/i.exec(ua)), browserTypes || (browserTypes = /chrome|safari|firefox|trident|opera|opr\/|oupeng/i.exec(ua));
        var browserType = browserTypes ? browserTypes[0].toLowerCase() : sys.BROWSER_TYPE_UNKNOWN;
        "micromessenger" === browserType ? browserType = sys.BROWSER_TYPE_WECHAT : "safari" === browserType && isAndroid || "qq" === browserType && ua.match(/android.*applewebkit/i) ? browserType = sys.BROWSER_TYPE_ANDROID : "trident" === browserType ? browserType = sys.BROWSER_TYPE_IE : "360 aphone" === browserType ? browserType = sys.BROWSER_TYPE_360 : "mxbrowser" === browserType ? browserType = sys.BROWSER_TYPE_MAXTHON : "opr/" === browserType && (browserType = sys.BROWSER_TYPE_OPERA), 
        sys.browserType = browserType;
    }(), sys.browserVersion = "", function() {
        var tmp = ua.match(/(mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui)(mobile)?(browser)?\/?([\d.]+)/i);
        tmp || (tmp = ua.match(/(qqbrowser|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i)), 
        sys.browserVersion = tmp ? tmp[4] : "";
    }();
    var _w = window.innerWidth || document.documentElement.clientWidth, _h = window.innerHeight || document.documentElement.clientHeight, _ratio = window.devicePixelRatio || 1;
    sys.windowPixelResolution = {
        width: _ratio * _w,
        height: _ratio * _h
    };
    var _tmpCanvas1 = document.createElement("canvas");
    try {
        var localStorage = sys.localStorage = win.localStorage;
        localStorage.setItem("storage", ""), localStorage.removeItem("storage"), localStorage = null;
    } catch (e) {
        var warn$1 = function warn() {
            cc.warnID(5200);
        };
        sys.localStorage = {
            getItem: warn$1,
            setItem: warn$1,
            removeItem: warn$1,
            clear: warn$1
        };
    }
    var _supportWebp = _tmpCanvas1.toDataURL("image/webp").startsWith("data:image/webp"), _supportCanvas = !!_tmpCanvas1.getContext("2d");
    !0;
    var __audioSupport, _capabilities = sys.capabilities = {
        canvas: _supportCanvas,
        opengl: !0,
        webp: _supportWebp
    };
    (void 0 !== docEle.ontouchstart || void 0 !== doc.ontouchstart || nav.msPointerEnabled) && (_capabilities.touches = !0), 
    void 0 !== docEle.onmouseup && (_capabilities.mouse = !0), void 0 !== docEle.onkeyup && (_capabilities.keyboard = !0), 
    (win.DeviceMotionEvent || win.DeviceOrientationEvent) && (_capabilities.accelerometer = !0), 
    __audioSupport = {
        ONLY_ONE: !1,
        WEB_AUDIO: !1,
        DELAY_CREATE_CTX: !1
    }, sys.os === sys.OS_IOS && (__audioSupport.USE_LOADER_EVENT = "loadedmetadata"), 
    sys.browserType === sys.BROWSER_TYPE_FIREFOX && (__audioSupport.DELAY_CREATE_CTX = !0, 
    __audioSupport.USE_LOADER_EVENT = "canplay"), sys.os === sys.OS_ANDROID && sys.browserType === sys.BROWSER_TYPE_UC && (__audioSupport.ONE_SOURCE = !0);
    try {
        __audioSupport.WEB_AUDIO && (__audioSupport._context = null, Object.defineProperty(__audioSupport, "context", {
            get: function get() {
                return this._context ? this._context : this._context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
            }
        }));
    } catch (error) {
        __audioSupport.WEB_AUDIO = !1, cc.logID(5201);
    }
    var formatSupport = [];
    (audio = document.createElement("audio")).canPlayType && (audio.canPlayType('audio/ogg; codecs="vorbis"') && formatSupport.push(".ogg"), 
    audio.canPlayType("audio/mpeg") && formatSupport.push(".mp3"), audio.canPlayType('audio/wav; codecs="1"') && formatSupport.push(".wav"), 
    audio.canPlayType("audio/mp4") && formatSupport.push(".mp4"), audio.canPlayType("audio/x-m4a") && formatSupport.push(".m4a")), 
    __audioSupport.format = formatSupport, sys.__audioSupport = __audioSupport;
}

cc.sys = sys;

var _typeMap = (_defineProperty(_typeMap2 = {}, exports.GFXFormatType.UNORM, "Uint"), 
_defineProperty(_typeMap2, exports.GFXFormatType.SNORM, "Int"), _defineProperty(_typeMap2, exports.GFXFormatType.UINT, "Uint"), 
_defineProperty(_typeMap2, exports.GFXFormatType.INT, "Int"), _defineProperty(_typeMap2, exports.GFXFormatType.UFLOAT, "Float"), 
_defineProperty(_typeMap2, exports.GFXFormatType.FLOAT, "Float"), _defineProperty(_typeMap2, "default", "Uint"), 
_typeMap2);

function _getDataViewType(info) {
    return (_typeMap[info.type] || _typeMap.default) + info.size / info.count * 8;
}

function writeBuffer(target, data) {
    var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : exports.GFXFormat.R32F, offset = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, stride = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, info = GFXFormatInfos[format];
    stride || (stride = info.size);
    for (var writer = "set" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(data.length / info.count), isLittleEndian = sys.isLittleEndian, iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
        var y = x + componentBytesLength * iComponent;
        target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian);
    }
}

function readBuffer(target) {
    var format = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : exports.GFXFormat.R32F, offset = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, length = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : target.byteLength - offset, stride = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, out = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : [], info = GFXFormatInfos[format];
    stride || (stride = info.size);
    for (var reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), isLittleEndian = sys.isLittleEndian, iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
        var y = x + componentBytesLength * iComponent;
        out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian);
    }
    return out;
}

function mapBuffer(target, callback) {
    var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : exports.GFXFormat.R32F, offset = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, length = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : target.byteLength - offset, stride = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, out = arguments.length > 6 ? arguments[6] : void 0;
    out || (out = new DataView(target.buffer.slice(target.byteOffset, target.byteOffset + target.byteLength)));
    var info = GFXFormatInfos[format];
    stride || (stride = info.size);
    for (var writer = "set" + _getDataViewType(info), reader = "get" + _getDataViewType(info), componentBytesLength = info.size / info.count, nSeg = Math.floor(length / stride), isLittleEndian = sys.isLittleEndian, iSeg = 0; iSeg < nSeg; ++iSeg) for (var x = offset + stride * iSeg, iComponent = 0; iComponent < info.count; ++iComponent) {
        var y = x + componentBytesLength * iComponent, _cur = target[reader](y, isLittleEndian);
        out[writer](y, callback(_cur, iComponent, target), isLittleEndian);
    }
    return out;
}

var BufferBlob = function() {
    function BufferBlob() {
        _classCallCheck(this, BufferBlob), this._arrayBufferOrPaddings = [], this._length = 0;
    }
    return _createClass(BufferBlob, [ {
        key: "setNextAlignment",
        value: function setNextAlignment(align) {
            if (0 !== align) {
                var remainder = this._length % align;
                if (0 !== remainder) {
                    var padding = align - remainder;
                    this._arrayBufferOrPaddings.push(padding), this._length += padding;
                }
            }
        }
    }, {
        key: "addBuffer",
        value: function addBuffer(arrayBuffer) {
            var result = this._length;
            return this._arrayBufferOrPaddings.push(arrayBuffer), this._length += arrayBuffer.byteLength, 
            result;
        }
    }, {
        key: "getLength",
        value: function getLength() {
            return this._length;
        }
    }, {
        key: "getCombined",
        value: function getCombined() {
            var result = new Uint8Array(this._length), counter = 0;
            return this._arrayBufferOrPaddings.forEach((function(arrayBufferOrPadding) {
                "number" == typeof arrayBufferOrPadding ? counter += arrayBufferOrPadding : (result.set(new Uint8Array(arrayBufferOrPadding), counter), 
                counter += arrayBufferOrPadding.byteLength);
            })), result.buffer;
        }
    } ]), BufferBlob;
}(), getUint8ForString = String.prototype.charCodeAt;

function getUint8ForArray(idx) {
    return this[idx];
}

function murmurhash2_32_gc(input, seed) {
    for (var l = input.length, h = seed ^ l, i = 0, getUint8 = "string" == typeof input ? getUint8ForString : getUint8ForArray; l >= 4; ) {
        var k = 255 & getUint8.call(input, i) | (255 & getUint8.call(input, ++i)) << 8 | (255 & getUint8.call(input, ++i)) << 16 | (255 & getUint8.call(input, ++i)) << 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ (k = 1540483477 * (65535 & (k ^= k >>> 24)) + ((1540483477 * (k >>> 16) & 65535) << 16)), 
        l -= 4, ++i;
    }
    switch (l) {
      case 3:
        h ^= (255 & getUint8.call(input, i + 2)) << 16;

      case 2:
        h ^= (255 & getUint8.call(input, i + 1)) << 8;

      case 1:
        h = 1540483477 * (65535 & (h ^= 255 & getUint8.call(input, i))) + ((1540483477 * (h >>> 16) & 65535) << 16);
    }
    return h = 1540483477 * (65535 & (h ^= h >>> 13)) + ((1540483477 * (h >>> 16) & 65535) << 16), 
    (h ^= h >>> 15) >>> 0;
}

var Event = function() {
    function Event(type, bubbles) {
        _classCallCheck(this, Event), this.type = void 0, this.bubbles = void 0, this.target = null, 
        this.currentTarget = null, this.eventPhase = 0, this.propagationStopped = !1, this.propagationImmediateStopped = !1, 
        this.type = type, this.bubbles = !!bubbles;
    }
    return _createClass(Event, [ {
        key: "unuse",
        value: function unuse() {
            this.type = Event.NO_TYPE, this.target = null, this.currentTarget = null, this.eventPhase = Event.NONE, 
            this.propagationStopped = !1, this.propagationImmediateStopped = !1;
        }
    }, {
        key: "reuse",
        value: function reuse(type, bubbles) {
            this.type = type, this.bubbles = bubbles || !1;
        }
    }, {
        key: "isStopped",
        value: function isStopped() {
            return this.propagationStopped || this.propagationImmediateStopped;
        }
    }, {
        key: "getCurrentTarget",
        value: function getCurrentTarget() {
            return this.currentTarget;
        }
    }, {
        key: "getType",
        value: function getType() {
            return this.type;
        }
    } ]), Event;
}();

Event.NO_TYPE = "no_type", Event.TOUCH = "touch", Event.MOUSE = "mouse", Event.KEYBOARD = "keyboard", 
Event.ACCELERATION = "acceleration", Event.NONE = 0, Event.CAPTURING_PHASE = 1, 
Event.AT_TARGET = 2, Event.BUBBLING_PHASE = 3, cc.Event = Event;

var objectsToDestroy = [];

var CCObject = function() {
    function CCObject() {
        var name = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
        _classCallCheck(this, CCObject), this._objFlags = void 0, this._name = void 0, this._name = name, 
        this._objFlags = 0;
    }
    return _createClass(CCObject, null, [ {
        key: "_deferredDestroy",
        value: function _deferredDestroy() {
            for (var deleteCount = objectsToDestroy.length, i = 0; i < deleteCount; ++i) {
                var obj = objectsToDestroy[i];
                1 & obj._objFlags || obj._destroyImmediate();
            }
            deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
        }
    } ]), _createClass(CCObject, [ {
        key: "destroy",
        value: function destroy() {
            return 1 & this._objFlags ? (warnID(5e3), !1) : !(4 & this._objFlags) && (this._objFlags |= 4, 
            objectsToDestroy.push(this), !0);
        }
    }, {
        key: "_destruct",
        value: function _destruct() {
            var ctor = this.constructor, destruct = ctor.__destruct__;
            destruct || (destruct = function compileDestruct(obj, ctor) {
                var key, shouldSkipId = obj instanceof cc._BaseNode || obj instanceof cc.Component, idToSkip = shouldSkipId ? "_id" : null, propsToReset = {};
                for (key in obj) if (obj.hasOwnProperty(key)) {
                    if (key === idToSkip) continue;
                    switch (_typeof(obj[key])) {
                      case "string":
                        propsToReset[key] = "";
                        break;

                      case "object":
                      case "function":
                        propsToReset[key] = null;
                    }
                }
                if (CCClass._isCCClass(ctor)) for (var attrs = cc.Class.Attr.getClassAttrs(ctor), propList = ctor.__props__, i = 0; i < propList.length; i++) {
                    var attrKey = (key = propList[i]) + cc.Class.Attr.DELIMETER + "default";
                    if (attrKey in attrs) {
                        if (shouldSkipId && "_id" === key) continue;
                        switch (_typeof(attrs[attrKey])) {
                          case "string":
                            propsToReset[key] = "";
                            break;

                          case "object":
                          case "function":
                            propsToReset[key] = null;
                            break;

                          case "undefined":
                            propsToReset[key] = void 0;
                        }
                    }
                }
                return function(o) {
                    for (var _key in propsToReset) o[_key] = propsToReset[_key];
                };
            }(this, ctor), value(ctor, "__destruct__", destruct, !0)), destruct(this);
        }
    }, {
        key: "_destroyImmediate",
        value: function _destroyImmediate() {
            1 & this._objFlags ? errorID(5e3) : (this._onPreDestroy && this._onPreDestroy(), 
            this._destruct(), this._objFlags |= 1);
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        },
        set: function set(value) {
            this._name = value;
        }
    }, {
        key: "isValid",
        get: function get() {
            return !(1 & this._objFlags);
        }
    } ]), CCObject;
}(), prototype = CCObject.prototype;

function isValid(value, strictMode) {
    return "object" === _typeof(value) ? !(!value || value._objFlags & (strictMode ? 5 : 1)) : void 0 !== value;
}

prototype._deserialize = null, prototype._onPreDestroy = null, CCClass.fastDefine("cc.Object", CCObject, {
    _name: "",
    _objFlags: 0
}), value(CCObject, "Flags", {
    Destroyed: 1,
    DontSave: 8,
    EditorOnly: 16,
    Dirty: 32,
    DontDestroy: 64,
    PersistentMask: -4192741,
    Destroying: 128,
    Deactivating: 256,
    LockedInEditor: 512,
    HideInHierarchy: 1024,
    IsPreloadStarted: 8192,
    IsOnLoadStarted: 32768,
    IsOnLoadCalled: 16384,
    IsOnEnableCalled: 2048,
    IsStartCalled: 65536,
    IsEditorOnEnableCalled: 4096,
    IsPositionLocked: 1 << 21,
    IsRotationLocked: 1 << 17,
    IsScaleLocked: 1 << 18,
    IsAnchorLocked: 1 << 19,
    IsSizeLocked: 1 << 20
}), cc.isValid = isValid, cc.Object = CCObject;

var fastRemoveAt$1 = array.fastRemoveAt;

function empty() {}

var CallbackInfo = function() {
    function CallbackInfo() {
        _classCallCheck(this, CallbackInfo), this.callback = empty, this.target = void 0, 
        this.once = !1;
    }
    return _createClass(CallbackInfo, [ {
        key: "set",
        value: function set(callback, target, once) {
            this.callback = callback || empty, this.target = target, this.once = !!once;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.target = void 0, this.callback = empty, this.once = !1;
        }
    }, {
        key: "check",
        value: function check() {
            return !(this.target instanceof CCObject && !isValid(this.target, !0));
        }
    } ]), CallbackInfo;
}(), callbackInfoPool = new Pool$1((function() {
    return new CallbackInfo;
}), 32), CallbackList = function() {
    function CallbackList() {
        _classCallCheck(this, CallbackList), this.callbackInfos = [], this.isInvoking = !1, 
        this.containCanceled = !1;
    }
    return _createClass(CallbackList, [ {
        key: "removeByCallback",
        value: function removeByCallback(cb) {
            for (var i = 0; i < this.callbackInfos.length; ++i) {
                var info = this.callbackInfos[i];
                info && info.callback === cb && (info.reset(), callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                --i);
            }
        }
    }, {
        key: "removeByTarget",
        value: function removeByTarget(target) {
            for (var i = 0; i < this.callbackInfos.length; ++i) {
                var info = this.callbackInfos[i];
                info && info.target === target && (info.reset(), callbackInfoPool.free(info), fastRemoveAt$1(this.callbackInfos, i), 
                --i);
            }
        }
    }, {
        key: "cancel",
        value: function cancel(index) {
            var info = this.callbackInfos[index];
            info && (info.reset(), this.isInvoking ? this.callbackInfos[index] = null : fastRemoveAt$1(this.callbackInfos, index), 
            callbackInfoPool.free(info)), this.containCanceled = !0;
        }
    }, {
        key: "cancelAll",
        value: function cancelAll() {
            for (var i = 0; i < this.callbackInfos.length; i++) {
                var info = this.callbackInfos[i];
                info && (info.reset(), callbackInfoPool.free(info), this.callbackInfos[i] = null);
            }
            this.containCanceled = !0;
        }
    }, {
        key: "purgeCanceled",
        value: function purgeCanceled() {
            for (var i = this.callbackInfos.length - 1; i >= 0; --i) {
                this.callbackInfos[i] || fastRemoveAt$1(this.callbackInfos, i);
            }
            this.containCanceled = !1;
        }
    }, {
        key: "clear",
        value: function clear() {
            this.cancelAll(), this.callbackInfos.length = 0, this.isInvoking = !1, this.containCanceled = !1;
        }
    } ]), CallbackList;
}(), callbackListPool = new Pool$1((function() {
    return new CallbackList;
}), 16), CallbacksInvoker = function() {
    function CallbacksInvoker() {
        _classCallCheck(this, CallbacksInvoker), this._callbackTable = createMap(!0);
    }
    return _createClass(CallbacksInvoker, [ {
        key: "on",
        value: function on(key, callback, target, once) {
            if (!this.hasEventListener(key, callback, target)) {
                var list = this._callbackTable[key];
                list || (list = this._callbackTable[key] = callbackListPool.alloc());
                var info = callbackInfoPool.alloc();
                info.set(callback, target, once), list.callbackInfos.push(info);
            }
            return callback;
        }
    }, {
        key: "hasEventListener",
        value: function hasEventListener(key, callback, target) {
            var list = this._callbackTable[key];
            if (!list) return !1;
            var infos = list.callbackInfos;
            if (!callback) {
                if (list.isInvoking) {
                    for (var i = 0; i < infos.length; ++i) if (infos[i]) return !0;
                    return !1;
                }
                return infos.length > 0;
            }
            for (var _i = 0; _i < infos.length; ++_i) {
                var info = infos[_i];
                if (info && info.check() && info.callback === callback && info.target === target) return !0;
            }
            return !1;
        }
    }, {
        key: "removeAll",
        value: function removeAll(keyOrTarget) {
            if ("string" == typeof keyOrTarget) {
                var list = this._callbackTable[keyOrTarget];
                list && (list.isInvoking ? list.cancelAll() : (list.clear(), callbackListPool.free(list), 
                delete this._callbackTable[keyOrTarget]));
            } else if (keyOrTarget) for (var key in this._callbackTable) {
                var _list = this._callbackTable[key];
                if (_list.isInvoking) for (var infos = _list.callbackInfos, i = 0; i < infos.length; ++i) {
                    var info = infos[i];
                    info && info.target === keyOrTarget && _list.cancel(i);
                } else _list.removeByTarget(keyOrTarget);
            }
        }
    }, {
        key: "off",
        value: function off(key, callback, target) {
            var list = this._callbackTable[key];
            if (list) {
                var infos = list.callbackInfos;
                if (callback) for (var i = 0; i < infos.length; ++i) {
                    var info = infos[i];
                    if (info && info.callback === callback && info.target === target) {
                        list.cancel(i);
                        break;
                    }
                } else this.removeAll(key);
            }
        }
    }, {
        key: "emit",
        value: function emit(key, arg0, arg1, arg2, arg3, arg4) {
            var list = this._callbackTable[key];
            if (list) {
                var rootInvoker = !list.isInvoking;
                list.isInvoking = !0;
                for (var infos = list.callbackInfos, i = 0, len = infos.length; i < len; ++i) {
                    var info = infos[i];
                    if (info) {
                        var callback = info.callback, target = info.target;
                        info.once && this.off(key, callback, target), info.check() ? target ? callback.call(target, arg0, arg1, arg2, arg3, arg4) : callback(arg0, arg1, arg2, arg3, arg4) : this.off(key, callback, target);
                    }
                }
                rootInvoker && (list.isInvoking = !1, list.containCanceled && list.purgeCanceled());
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var key in this._callbackTable) {
                var list = this._callbackTable[key];
                list && (list.clear(), callbackListPool.free(list), delete this._callbackTable[key]);
            }
        }
    } ]), CallbacksInvoker;
}();

function Eventify(base) {
    for (var Eventified = function(_ref) {
        function Eventified() {
            var _getPrototypeOf2, _this;
            _classCallCheck(this, Eventified);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Eventified)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._callbackTable = createMap(!0), 
            _this;
        }
        return _inherits(Eventified, _ref), _createClass(Eventified, [ {
            key: "once",
            value: function once(type, callback, target) {
                return this.on(type, callback, target, !0);
            }
        }, {
            key: "targetOff",
            value: function targetOff(typeOrTarget) {
                this.removeAll(typeOrTarget);
            }
        } ]), Eventified;
    }(base), callbacksInvokerPrototype = CallbacksInvoker.prototype, propertyKeys = Object.getOwnPropertyNames(callbacksInvokerPrototype).concat(Object.getOwnPropertySymbols(callbacksInvokerPrototype)), iPropertyKey = 0; iPropertyKey < propertyKeys.length; ++iPropertyKey) {
        var propertyKey = propertyKeys[iPropertyKey];
        if (!(propertyKey in Eventified.prototype)) {
            var propertyDescriptor = Object.getOwnPropertyDescriptor(callbacksInvokerPrototype, propertyKey);
            propertyDescriptor && Object.defineProperty(Eventified.prototype, propertyKey, propertyDescriptor);
        }
    }
    return Eventified;
}

var _class$1, EventTarget = Eventify((function Empty() {
    _classCallCheck(this, Empty);
}));

cc.EventTarget = EventTarget;

var _dec$2, _dec2, _class$2, _class2$1, _descriptor$1, _class3, _temp$2, RawAsset = ccclass("cc.RawAsset")(_class$1 = function(_CCObject) {
    function RawAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, RawAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RawAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uuid = void 0, 
        Object.defineProperty(_assertThisInitialized(_this), "_uuid", {
            value: "",
            writable: !0
        }), _this;
    }
    return _inherits(RawAsset, CCObject), _createClass(RawAsset, null, [ {
        key: "isRawAssetType",
        value: function isRawAssetType(ctor) {
            return isChildClassOf(ctor, cc.RawAsset) && !isChildClassOf(ctor, cc.Asset);
        }
    } ]), RawAsset;
}()) || _class$1;

cc.RawAsset = RawAsset;

var PixelFormat, WrapMode$1, Filter, DepthStencilFormat, _dec$3, _dec2$1, _class$3, _class2$2, _class3$1, _temp$3, Asset = (_dec$2 = ccclass("cc.Asset"), 
_dec2 = property({
    visible: !1
}), _dec$2((_temp$2 = _class3 = function(_Eventify) {
    function Asset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Asset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Asset)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).loaded = !0, 
        _initializerDefineProperty(_this, "_native", _descriptor$1, _assertThisInitialized(_this)), 
        _this._file = null, _this;
    }
    return _inherits(Asset, Eventify(RawAsset)), _createClass(Asset, [ {
        key: "toString",
        value: function toString() {
            return this.nativeUrl;
        }
    }, {
        key: "serialize",
        value: function serialize() {}
    }, {
        key: "_setRawAsset",
        value: function _setRawAsset(filename) {
            var inLibrary = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            this._native = !1 !== inLibrary ? filename || "" : "/" + filename;
        }
    }, {
        key: "nativeUrl",
        get: function get() {
            if (this._native) {
                var name = this._native;
                if (47 === name.charCodeAt(0)) return name.slice(1);
                if (cc.AssetLibrary) {
                    var base = cc.AssetLibrary.getLibUrlNoExt(this._uuid, !0);
                    return 46 === name.charCodeAt(0) ? base + name : base + "/" + name;
                }
                cc.errorID(6400);
            }
            return "";
        }
    }, {
        key: "_nativeAsset",
        get: function get() {
            return this._file;
        },
        set: function set(obj) {
            this._file = obj;
        }
    } ], [ {
        key: "deserialize",
        value: function deserialize(data) {
            return cc.deserialize(data);
        }
    } ]), Asset;
}(), _class3.preventDeferredLoadDependents = !1, _class3.preventPreloadNativeObject = !1, 
_descriptor$1 = _applyDecoratedDescriptor((_class2$1 = _temp$2).prototype, "_native", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _applyDecoratedDescriptor(_class2$1.prototype, "nativeUrl", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2$1.prototype, "nativeUrl"), _class2$1.prototype), 
_applyDecoratedDescriptor(_class2$1.prototype, "_nativeAsset", [ property ], Object.getOwnPropertyDescriptor(_class2$1.prototype, "_nativeAsset"), _class2$1.prototype), 
_class$2 = _class2$1)) || _class$2);

Asset.prototype.createNode = null, cc.Asset = Asset, function(PixelFormat) {
    PixelFormat[PixelFormat.RGB565 = exports.GFXFormat.R5G6B5] = "RGB565", PixelFormat[PixelFormat.RGB5A1 = exports.GFXFormat.RGB5A1] = "RGB5A1", 
    PixelFormat[PixelFormat.RGBA4444 = exports.GFXFormat.RGBA4] = "RGBA4444", PixelFormat[PixelFormat.RGB888 = exports.GFXFormat.RGB8] = "RGB888", 
    PixelFormat[PixelFormat.RGB32F = exports.GFXFormat.RGB32F] = "RGB32F", PixelFormat[PixelFormat.RGBA8888 = exports.GFXFormat.RGBA8] = "RGBA8888", 
    PixelFormat[PixelFormat.RGBA32F = exports.GFXFormat.RGBA32F] = "RGBA32F", PixelFormat[PixelFormat.A8 = exports.GFXFormat.A8] = "A8", 
    PixelFormat[PixelFormat.I8 = exports.GFXFormat.L8] = "I8", PixelFormat[PixelFormat.AI8 = exports.GFXFormat.LA8] = "AI8", 
    PixelFormat[PixelFormat.RGB_PVRTC_2BPPV1 = exports.GFXFormat.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1", 
    PixelFormat[PixelFormat.RGBA_PVRTC_2BPPV1 = exports.GFXFormat.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1", 
    PixelFormat[PixelFormat.RGB_PVRTC_4BPPV1 = exports.GFXFormat.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1", 
    PixelFormat[PixelFormat.RGBA_PVRTC_4BPPV1 = exports.GFXFormat.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1", 
    PixelFormat[PixelFormat.RGB_ETC1 = exports.GFXFormat.ETC_RGB8] = "RGB_ETC1", PixelFormat[PixelFormat.RGB_ETC2 = exports.GFXFormat.ETC2_RGB8] = "RGB_ETC2", 
    PixelFormat[PixelFormat.RGBA_ETC2 = exports.GFXFormat.ETC2_RGBA8] = "RGBA_ETC2";
}(PixelFormat || (PixelFormat = {})), function(WrapMode) {
    WrapMode[WrapMode.REPEAT = exports.GFXAddress.WRAP] = "REPEAT", WrapMode[WrapMode.CLAMP_TO_EDGE = exports.GFXAddress.CLAMP] = "CLAMP_TO_EDGE", 
    WrapMode[WrapMode.MIRRORED_REPEAT = exports.GFXAddress.MIRROR] = "MIRRORED_REPEAT", 
    WrapMode[WrapMode.CLAMP_TO_BORDER = exports.GFXAddress.BORDER] = "CLAMP_TO_BORDER";
}(WrapMode$1 || (WrapMode$1 = {})), function(Filter) {
    Filter[Filter.NONE = exports.GFXFilter.NONE] = "NONE", Filter[Filter.LINEAR = exports.GFXFilter.LINEAR] = "LINEAR", 
    Filter[Filter.NEAREST = exports.GFXFilter.POINT] = "NEAREST";
}(Filter || (Filter = {})), function(DepthStencilFormat) {
    DepthStencilFormat[DepthStencilFormat.NONE = exports.GFXFormat.UNKNOWN] = "NONE", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_16 = exports.GFXFormat.D16] = "DEPTH_16", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_24 = exports.GFXFormat.D24] = "DEPTH_24", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_32 = exports.GFXFormat.D32F] = "DEPTH_32", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_16_STENCIL_8 = exports.GFXFormat.D16S8] = "DEPTH_16_STENCIL_8", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_24_STENCIL_8 = exports.GFXFormat.D24S8] = "DEPTH_24_STENCIL_8", 
    DepthStencilFormat[DepthStencilFormat.DEPTH_32_STENCIL_8 = exports.GFXFormat.D32F_S8] = "DEPTH_32_STENCIL_8";
}(DepthStencilFormat || (DepthStencilFormat = {}));

var SamplerInfoIndex, ImageAsset = (_dec$3 = ccclass("cc.ImageAsset"), _dec2$1 = property({
    override: !0
}), _dec$3((_temp$3 = _class3$1 = function(_Asset) {
    function ImageAsset(nativeAsset) {
        var _this;
        return _classCallCheck(this, ImageAsset), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ImageAsset).call(this)))._nativeData = void 0, 
        _this._tex = void 0, _this._url = void 0, _this._exportedExts = void 0, _this._format = PixelFormat.RGBA8888, 
        _this._width = 0, _this._height = 0, _this._url = "", _this.loaded = !1, _this._nativeData = {
            _data: null,
            width: 0,
            height: 0,
            format: 0,
            _compressed: !1
        }, void 0 !== nativeAsset && _this.reset(nativeAsset), _this;
    }
    return _inherits(ImageAsset, Asset), _createClass(ImageAsset, [ {
        key: "_nativeAsset",
        get: function get() {
            return this._nativeData;
        },
        set: function set(value) {
            value instanceof HTMLElement || (value.format = this._format), this.reset(value);
        }
    }, {
        key: "data",
        get: function get() {
            var data = this._nativeData && this._nativeData._data;
            return ArrayBuffer.isView(data) ? data : this._nativeData;
        }
    }, {
        key: "width",
        get: function get() {
            return this._nativeData.width || this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._nativeData.height || this._height;
        }
    }, {
        key: "format",
        get: function get() {
            return this._format;
        }
    }, {
        key: "isCompressed",
        get: function get() {
            return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
        }
    }, {
        key: "url",
        get: function get() {
            return this._url;
        }
    }, {
        key: "_texture",
        set: function set(tex) {
            this._tex = tex;
        },
        get: function get() {
            if (!this._tex) {
                var tex = new cc.Texture2D;
                tex.name = this._url, tex.image = this, this._tex = tex;
            }
            return this._tex;
        }
    } ]), _createClass(ImageAsset, [ {
        key: "reset",
        value: function reset(data) {
            data instanceof HTMLElement ? (this._nativeData = data, this._onDataComplete()) : (this._nativeData = data, 
            this._format = data.format, this._onDataComplete());
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this.data && this.data instanceof HTMLImageElement && (this.data.src = "", 
            this._setRawAsset(""), cc.loader.removeItem(this.data.id)), _get(_getPrototypeOf(ImageAsset.prototype), "destroy", this).call(this);
        }
    }, {
        key: "_serialize",
        value: function _serialize() {
            var targetExtensions = this._exportedExts;
            if (!targetExtensions && this._native && (targetExtensions = [ this._native ]), 
            !targetExtensions) return "";
            for (var _step, extensionIndices = [], _iterator = _createForOfIteratorHelperLoose(targetExtensions); !(_step = _iterator()).done; ) {
                var targetExtension = _step.value, extensionFormat = targetExtension.split("@"), i = ImageAsset.extnames.indexOf(extensionFormat[0]), exportedExtensionID = i < 0 ? targetExtension : "".concat(i);
                extensionFormat[1] && (exportedExtensionID += "@" + extensionFormat[1]), extensionIndices.push(exportedExtensionID);
            }
            return {
                fmt: extensionIndices.join("_"),
                w: this.width,
                h: this.height
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(data, handle) {
            var fmtStr = "";
            "string" == typeof data ? fmtStr = data : (this._width = data.w, this._height = data.h, 
            fmtStr = data.fmt);
            for (var _step2, device = function _getGlobalDevice() {
                return cc.director.root ? cc.director.root.device : null;
            }(), extensionIDs = fmtStr.split("_"), preferedExtensionIndex = Number.MAX_VALUE, format = this._format, ext = "", SupportTextureFormats = cc.macro.SUPPORT_TEXTURE_FORMATS, _iterator2 = _createForOfIteratorHelperLoose(extensionIDs); !(_step2 = _iterator2()).done; ) {
                var extFormat = _step2.value.split("@"), i = parseInt(extFormat[0], void 0), tmpExt = ImageAsset.extnames[i] || extFormat.join(), index = SupportTextureFormats.indexOf(tmpExt);
                if (-1 !== index && index < preferedExtensionIndex) {
                    var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;
                    if (!(".pvr" !== tmpExt || device && device.hasFeature(exports.GFXFeature.FORMAT_PVRTC))) continue;
                    if (!(fmt !== PixelFormat.RGB_ETC1 || device && device.hasFeature(exports.GFXFeature.FORMAT_ETC1))) continue;
                    if (!(fmt !== PixelFormat.RGB_ETC2 && fmt !== PixelFormat.RGBA_ETC2 || device && device.hasFeature(exports.GFXFeature.FORMAT_ETC2))) continue;
                    if (".webp" === tmpExt && !cc.sys.capabilities.webp) continue;
                    preferedExtensionIndex = index, ext = tmpExt, format = fmt;
                }
            }
            ext && (this._setRawAsset(ext), this._format = format);
            var loadingItem = handle.customEnv, uuid = loadingItem && loadingItem.uuid;
            uuid && (this._uuid = uuid, this._url = this.nativeUrl);
        }
    }, {
        key: "_onDataComplete",
        value: function _onDataComplete() {
            this.loaded = !0, this.emit("load");
        }
    } ]), ImageAsset;
}(), _class3$1.extnames = [ ".png", ".jpg", ".jpeg", ".bmp", ".webp", ".pvr", ".pkm" ], 
_applyDecoratedDescriptor((_class2$2 = _temp$3).prototype, "_nativeAsset", [ _dec2$1 ], Object.getOwnPropertyDescriptor(_class2$2.prototype, "_nativeAsset"), _class2$2.prototype), 
_class$3 = _class2$2)) || _class$3);

cc.ImageAsset = ImageAsset, function(SamplerInfoIndex) {
    SamplerInfoIndex[SamplerInfoIndex.minFilter = 0] = "minFilter", SamplerInfoIndex[SamplerInfoIndex.magFilter = 1] = "magFilter", 
    SamplerInfoIndex[SamplerInfoIndex.mipFilter = 2] = "mipFilter", SamplerInfoIndex[SamplerInfoIndex.addressU = 3] = "addressU", 
    SamplerInfoIndex[SamplerInfoIndex.addressV = 4] = "addressV", SamplerInfoIndex[SamplerInfoIndex.addressW = 5] = "addressW", 
    SamplerInfoIndex[SamplerInfoIndex.maxAnisotropy = 6] = "maxAnisotropy", SamplerInfoIndex[SamplerInfoIndex.cmpFunc = 7] = "cmpFunc", 
    SamplerInfoIndex[SamplerInfoIndex.minLOD = 8] = "minLOD", SamplerInfoIndex[SamplerInfoIndex.maxLOD = 9] = "maxLOD", 
    SamplerInfoIndex[SamplerInfoIndex.mipLODBias = 10] = "mipLODBias", SamplerInfoIndex[SamplerInfoIndex.total = 11] = "total";
}(SamplerInfoIndex || (SamplerInfoIndex = {}));

var defaultInfo = [ exports.GFXFilter.LINEAR, exports.GFXFilter.LINEAR, exports.GFXFilter.NONE, exports.GFXAddress.WRAP, exports.GFXAddress.WRAP, exports.GFXAddress.WRAP, 8, exports.GFXComparisonFunc.NEVER, 0, 0, 0 ], defaultHash = genSamplerHash(defaultInfo), borderColor = {
    r: 0,
    g: 0,
    b: 0,
    a: 0
}, gfxInfo = {};

function genSamplerHash(info) {
    for (var value = 0, hash = 0, i = 0; i < defaultInfo.length; i++) switch (value = info[i] || defaultInfo[i], 
    i) {
      case SamplerInfoIndex.minFilter:
        hash |= value;
        break;

      case SamplerInfoIndex.magFilter:
        hash |= value << 2;
        break;

      case SamplerInfoIndex.mipFilter:
        hash |= value << 4;
        break;

      case SamplerInfoIndex.addressU:
        hash |= value << 6;
        break;

      case SamplerInfoIndex.addressV:
        hash |= value << 8;
        break;

      case SamplerInfoIndex.addressW:
        hash |= value << 10;
        break;

      case SamplerInfoIndex.maxAnisotropy:
        hash |= value << 12;
        break;

      case SamplerInfoIndex.cmpFunc:
        hash |= value << 16;
        break;

      case SamplerInfoIndex.minLOD:
        hash |= value << 20;
        break;

      case SamplerInfoIndex.maxLOD:
        hash |= value << 24;
        break;

      case SamplerInfoIndex.mipLODBias:
        hash |= value << 28;
    }
    return hash;
}

var _class$4, _class2$3, _descriptor$2, _descriptor2$1, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _class3$2, _temp$4, samplerLib = new (function() {
    function SamplerLib() {
        _classCallCheck(this, SamplerLib), this._cache = {};
    }
    return _createClass(SamplerLib, [ {
        key: "getSampler",
        value: function getSampler(device, hash) {
            0 === hash && (hash = defaultHash);
            var cache = this._cache[hash];
            return cache || (gfxInfo.minFilter = 3 & hash, gfxInfo.magFilter = hash >> 2 & 3, 
            gfxInfo.mipFilter = hash >> 4 & 3, gfxInfo.addressU = hash >> 6 & 3, gfxInfo.addressV = hash >> 8 & 3, 
            gfxInfo.addressW = hash >> 10 & 3, gfxInfo.maxAnisotropy = hash >> 12 & 15, gfxInfo.cmpFunc = hash >> 16 & 15, 
            gfxInfo.minLOD = hash >> 20 & 15, gfxInfo.maxLOD = hash >> 24 & 15, gfxInfo.mipLODBias = hash >> 28 & 15, 
            gfxInfo.borderColor = borderColor, this._cache[hash] = device.createSampler(gfxInfo));
        }
    } ]), SamplerLib;
}());

cc.samplerLib = samplerLib;

var idGenerator = new IDGenerator("Tex"), TextureBase = ccclass("cc.TextureBase")((_temp$4 = _class3$2 = function(_Asset) {
    function TextureBase() {
        var _this, flipY = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        return _classCallCheck(this, TextureBase), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureBase).call(this)), "_format", _descriptor$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_premultiplyAlpha", _descriptor2$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_flipY", _descriptor3$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_minFilter", _descriptor4$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_magFilter", _descriptor5$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_mipFilter", _descriptor6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_wrapS", _descriptor7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_wrapT", _descriptor8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_wrapR", _descriptor9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_anisotropy", _descriptor10, _assertThisInitialized(_this)), 
        _this._width = 0, _this._height = 0, _this._id = void 0, _this._samplerInfo = [], 
        _this._samplerHash = 0, _this._gfxSampler = null, _this._gfxDevice = null, _this._flipY = flipY, 
        _this._id = idGenerator.getNewId(), _this.loaded = !1, _this._gfxDevice = _this._getGFXDevice(), 
        _this;
    }
    return _inherits(TextureBase, Asset), _createClass(TextureBase, [ {
        key: "isCompressed",
        get: function get() {
            return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    } ]), _createClass(TextureBase, [ {
        key: "getId",
        value: function getId() {
            return this._id;
        }
    }, {
        key: "getPixelFormat",
        value: function getPixelFormat() {
            return this._format;
        }
    }, {
        key: "hasPremultipliedAlpha",
        value: function hasPremultipliedAlpha() {
            return this._premultiplyAlpha || !1;
        }
    }, {
        key: "getAnisotropy",
        value: function getAnisotropy() {
            return this._anisotropy;
        }
    }, {
        key: "setWrapMode",
        value: function setWrapMode(wrapS, wrapT, wrapR) {
            this._wrapS = wrapS, this._samplerInfo[SamplerInfoIndex.addressU] = wrapS, this._wrapT = wrapT, 
            this._samplerInfo[SamplerInfoIndex.addressV] = wrapT, void 0 !== wrapR && (this._wrapR = wrapR, 
            this._samplerInfo[SamplerInfoIndex.addressW] = wrapR), this._samplerHash = genSamplerHash(this._samplerInfo), 
            this._gfxDevice && (this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash));
        }
    }, {
        key: "setFilters",
        value: function setFilters(minFilter, magFilter) {
            this._minFilter = minFilter, this._samplerInfo[SamplerInfoIndex.minFilter] = minFilter, 
            this._magFilter = magFilter, this._samplerInfo[SamplerInfoIndex.magFilter] = magFilter, 
            this._samplerHash = genSamplerHash(this._samplerInfo), this._gfxDevice && (this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash));
        }
    }, {
        key: "setMipFilter",
        value: function setMipFilter(mipFilter) {
            this._mipFilter = mipFilter, this._samplerInfo[SamplerInfoIndex.mipFilter] = mipFilter, 
            this._samplerInfo[SamplerInfoIndex.maxLOD] = mipFilter === Filter.NONE ? 0 : 15, 
            this._samplerHash = genSamplerHash(this._samplerInfo), this._gfxDevice && (this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash));
        }
    }, {
        key: "setFlipY",
        value: function setFlipY(flipY) {
            this._flipY = flipY;
        }
    }, {
        key: "setPremultiplyAlpha",
        value: function setPremultiplyAlpha(premultiply) {
            this._premultiplyAlpha = premultiply;
        }
    }, {
        key: "setAnisotropy",
        value: function setAnisotropy(anisotropy) {
            this._anisotropy = anisotropy, this._samplerInfo[SamplerInfoIndex.maxAnisotropy] = anisotropy, 
            this._samplerHash = genSamplerHash(this._samplerInfo), this._gfxDevice && (this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash));
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return _get(_getPrototypeOf(TextureBase.prototype), "destroy", this).call(this);
        }
    }, {
        key: "getGFXTextureView",
        value: function getGFXTextureView() {
            return null;
        }
    }, {
        key: "getSamplerHash",
        value: function getSamplerHash() {
            return this._samplerHash;
        }
    }, {
        key: "getGFXSampler",
        value: function getGFXSampler() {
            return this._gfxSampler || (this._gfxDevice ? this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash) : cc.errorID(9302)), 
            this._gfxSampler;
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            return this._minFilter + "," + this._magFilter + "," + this._wrapS + "," + this._wrapT + "," + (this._premultiplyAlpha ? 1 : 0) + "," + this._mipFilter + "," + this._anisotropy + "," + (this._flipY ? 1 : 0);
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializedData, handle) {
            var fields = serializedData.split(",");
            fields.unshift(""), fields.length >= 6 && (this.setFilters(parseInt(fields[1]), parseInt(fields[2])), 
            this.setWrapMode(parseInt(fields[3]), parseInt(fields[4])), this._premultiplyAlpha = 49 === fields[5].charCodeAt(0)), 
            fields.length >= 8 && (this.setMipFilter(parseInt(fields[6])), this.setAnisotropy(parseInt(fields[7]))), 
            fields.length >= 9 && (this._flipY = 49 === fields[8].charCodeAt(0));
        }
    }, {
        key: "_getGFXDevice",
        value: function _getGFXDevice() {
            return cc.director.root && cc.director.root.device;
        }
    }, {
        key: "_getGFXFormat",
        value: function _getGFXFormat() {
            return this._format;
        }
    }, {
        key: "_setGFXFormat",
        value: function _setGFXFormat(format) {
            this._format = void 0 === format ? PixelFormat.RGBA8888 : format;
        }
    } ]), TextureBase;
}(), _class3$2.PixelFormat = PixelFormat, _class3$2.WrapMode = WrapMode$1, _class3$2.Filter = Filter, 
_descriptor$2 = _applyDecoratedDescriptor((_class2$3 = _temp$4).prototype, "_format", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return PixelFormat.RGBA8888;
    }
}), _descriptor2$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_premultiplyAlpha", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_flipY", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor4$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_minFilter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Filter.LINEAR;
    }
}), _descriptor5$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_magFilter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Filter.LINEAR;
    }
}), _descriptor6 = _applyDecoratedDescriptor(_class2$3.prototype, "_mipFilter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Filter.NONE;
    }
}), _descriptor7 = _applyDecoratedDescriptor(_class2$3.prototype, "_wrapS", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return WrapMode$1.REPEAT;
    }
}), _descriptor8 = _applyDecoratedDescriptor(_class2$3.prototype, "_wrapT", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return WrapMode$1.REPEAT;
    }
}), _descriptor9 = _applyDecoratedDescriptor(_class2$3.prototype, "_wrapR", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return WrapMode$1.REPEAT;
    }
}), _descriptor10 = _applyDecoratedDescriptor(_class2$3.prototype, "_anisotropy", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 8;
    }
}), _class$4 = _class2$3)) || _class$4;

TextureBase || (TextureBase = {}), cc.TextureBase = TextureBase;

var _class$5, macro = {
    SUPPORT_TEXTURE_FORMATS: [ ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png" ],
    KEY: {
        none: 0,
        back: 6,
        menu: 18,
        backspace: 8,
        tab: 9,
        enter: 13,
        shift: 16,
        ctrl: 17,
        alt: 18,
        pause: 19,
        capslock: 20,
        escape: 27,
        space: 32,
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        select: 41,
        insert: 45,
        Delete: 46,
        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        num0: 96,
        num1: 97,
        num2: 98,
        num3: 99,
        num4: 100,
        num5: 101,
        num6: 102,
        num7: 103,
        num8: 104,
        num9: 105,
        "*": 106,
        "+": 107,
        "-": 109,
        numdel: 110,
        "/": 111,
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123,
        numlock: 144,
        scrolllock: 145,
        ";": 186,
        semicolon: 186,
        equal: 187,
        "=": 187,
        ",": 188,
        comma: 188,
        dash: 189,
        ".": 190,
        period: 190,
        forwardslash: 191,
        grave: 192,
        "[": 219,
        openbracket: 219,
        backslash: 220,
        "]": 221,
        closebracket: 221,
        quote: 222,
        dpadLeft: 1e3,
        dpadRight: 1001,
        dpadUp: 1003,
        dpadDown: 1004,
        dpadCenter: 1005
    },
    RAD: Math.PI / 180,
    DEG: 180 / Math.PI,
    REPEAT_FOREVER: Number.MAX_VALUE - 1,
    FLT_EPSILON: 1.192092896e-7,
    ORIENTATION_PORTRAIT: 1,
    ORIENTATION_LANDSCAPE: 2,
    ORIENTATION_AUTO: 3,
    FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: !0,
    ENABLE_TILEDMAP_CULLING: !0,
    DIRECTOR_STATS_POSITION: new Vec2(0, 0),
    TOUCH_TIMEOUT: 5e3,
    DOWNLOAD_MAX_CONCURRENT: 64,
    ENABLE_TRANSPARENT_CANVAS: !1,
    ENABLE_WEBGL_ANTIALIAS: !1,
    CLEANUP_IMAGE_CACHE: !1,
    ENABLE_MULTI_TOUCH: !0
};

cc.macro = macro;

var _regions = [ {
    buffOffset: 0,
    buffStride: 0,
    buffTexHeight: 0,
    texOffset: {
        x: 0,
        y: 0,
        z: 0
    },
    texExtent: {
        width: 1,
        height: 1,
        depth: 1
    },
    texSubres: {
        baseMipLevel: 1,
        levelCount: 1,
        baseArrayLayer: 0,
        layerCount: 1
    }
} ];

function isPOT(n) {
    return n && 0 == (n & n - 1);
}

var _dec$6, _dec2$2, _class$6, _class2$4, _descriptor$3, SimpleTexture = ccclass("cc.SimpleTexture")(_class$5 = function(_TextureBase) {
    function SimpleTexture() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SimpleTexture);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SimpleTexture)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gfxTexture = null, 
        _this._gfxTextureView = null, _this._mipmapLevel = 1, _this;
    }
    return _inherits(SimpleTexture, TextureBase), _createClass(SimpleTexture, [ {
        key: "getGFXTexture",
        value: function getGFXTexture() {
            return this._gfxTexture;
        }
    }, {
        key: "getGFXTextureView",
        value: function getGFXTextureView() {
            return this._gfxTextureView;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._tryDestroyTexture(), _get(_getPrototypeOf(SimpleTexture.prototype), "destroy", this).call(this);
        }
    }, {
        key: "updateImage",
        value: function updateImage() {
            this.updateMipmaps(0);
        }
    }, {
        key: "updateMipmaps",
        value: function updateMipmaps() {}
    }, {
        key: "uploadData",
        value: function uploadData(source) {
            var level = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, arrayIndex = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            if (this._gfxTexture && !(this._gfxTexture.mipLevel <= level)) {
                var gfxDevice = this._getGFXDevice();
                if (gfxDevice) {
                    var region = _regions[0];
                    region.texExtent.width = this._gfxTexture.width >> level, region.texExtent.height = this._gfxTexture.height >> level, 
                    region.texSubres.baseMipLevel = level, region.texSubres.baseArrayLayer = arrayIndex, 
                    ArrayBuffer.isView(source) ? gfxDevice.copyBuffersToTexture([ source ], this._gfxTexture, _regions) : gfxDevice.copyTexImagesToTexture([ source ], this._gfxTexture, _regions);
                }
            }
        }
    }, {
        key: "_assignImage",
        value: function _assignImage(image, level, arrayIndex) {
            var _this2 = this, upload = function upload() {
                var data = image.data;
                data && (_this2.uploadData(data, level, arrayIndex), _this2._checkTextureLoaded(), 
                macro.CLEANUP_IMAGE_CACHE && cc.loader.release(image));
            };
            if (image.loaded) upload(); else {
                if (image.once("load", (function() {
                    upload();
                })), !this.isCompressed) {
                    var defaultImg = cc.builtinResMgr.get("black-texture").image;
                    this.uploadData(defaultImg.data, level, arrayIndex);
                }
                cc.textureUtil.postLoadImage(image);
            }
        }
    }, {
        key: "_checkTextureLoaded",
        value: function _checkTextureLoaded() {
            this._textureReady();
        }
    }, {
        key: "_textureReady",
        value: function _textureReady() {
            this.loaded = !0, this.emit("load");
        }
    }, {
        key: "_setMipmapLevel",
        value: function _setMipmapLevel(value) {
            this._mipmapLevel = value < 1 ? 1 : value;
        }
    }, {
        key: "_getGfxTextureCreateInfo",
        value: function _getGfxTextureCreateInfo(presumed) {
            return null;
        }
    }, {
        key: "_getGfxTextureViewCreateInfo",
        value: function _getGfxTextureViewCreateInfo(texture) {
            return null;
        }
    }, {
        key: "_tryReset",
        value: function _tryReset() {
            this._tryDestroyTexture();
            var device = this._getGFXDevice();
            device && this._createTexture(device);
        }
    }, {
        key: "_createTexture",
        value: function _createTexture(device) {
            var flags = exports.GFXTextureFlagBit.NONE;
            this._mipFilter !== Filter.NONE && function canGenerateMipmap(device, w, h) {
                return !(device.gfxAPI === exports.GFXAPI.WEBGL) || isPOT(w) && isPOT(h);
            }(device, this._width, this._height) && (this._mipmapLevel = function getMipLevel(width, height) {
                for (var size = Math.max(width, height), level = 0; size; ) size >>= 1, level++;
                return level;
            }(this._width, this._height), flags = exports.GFXTextureFlagBit.GEN_MIPMAP);
            var textureCreateInfo = this._getGfxTextureCreateInfo({
                usage: exports.GFXTextureUsageBit.SAMPLED | exports.GFXTextureUsageBit.TRANSFER_DST,
                format: this._getGFXFormat(),
                mipLevel: this._mipmapLevel,
                flags: flags
            });
            if (textureCreateInfo) {
                var texture = device.createTexture(textureCreateInfo), textureViewCreateInfo = this._getGfxTextureViewCreateInfo({
                    texture: texture,
                    format: this._getGFXFormat()
                });
                if (textureViewCreateInfo) {
                    var view = device.createTextureView(textureViewCreateInfo);
                    view ? (this._gfxTexture = texture, this._gfxTextureView = view) : texture.destroy();
                } else texture.destroy();
            }
        }
    }, {
        key: "_tryDestroyTexture",
        value: function _tryDestroyTexture() {
            this._gfxTexture && (this._gfxTexture.destroy(), this._gfxTexture = null), this._gfxTextureView && (this._gfxTextureView.destroy(), 
            this._gfxTextureView = null);
        }
    }, {
        key: "mipmapLevel",
        get: function get() {
            return this._mipmapLevel;
        }
    } ]), SimpleTexture;
}()) || _class$5;

cc.SimpleTexture = SimpleTexture;

var Texture2D = (_dec$6 = ccclass("cc.Texture2D"), _dec2$2 = property([ ImageAsset ]), 
_dec$6((_descriptor$3 = _applyDecoratedDescriptor((_class2$4 = function(_SimpleTexture) {
    function Texture2D() {
        var _this;
        return _classCallCheck(this, Texture2D), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Texture2D).call(this, !0)), "_mipmaps", _descriptor$3, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(Texture2D, SimpleTexture), _createClass(Texture2D, [ {
        key: "mipmaps",
        get: function get() {
            return this._mipmaps;
        },
        set: function set(value) {
            var _this2 = this;
            if (this._mipmaps = value, this._setMipmapLevel(this._mipmaps.length), this._mipmaps.length > 0) {
                var imageAsset = this._mipmaps[0];
                this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._mipmaps.length
                }), this._mipmaps.forEach((function(mipmap, level) {
                    _this2._assignImage(mipmap, level);
                }));
            } else this.reset({
                width: 0,
                height: 0,
                mipmapLevel: this._mipmaps.length
            });
        }
    }, {
        key: "image",
        get: function get() {
            return 0 === this._mipmaps.length ? null : this._mipmaps[0];
        },
        set: function set(value) {
            this.mipmaps = value ? [ value ] : [];
        }
    } ]), _createClass(Texture2D, [ {
        key: "initialize",
        value: function initialize() {
            this.mipmaps = this._mipmaps;
        }
    }, {
        key: "onLoaded",
        value: function onLoaded() {
            this.initialize();
        }
    }, {
        key: "reset",
        value: function reset(info) {
            this._width = info.width, this._height = info.height, this._setGFXFormat(info.format), 
            this._setMipmapLevel(info.mipmapLevel || 1), this._tryReset();
        }
    }, {
        key: "create",
        value: function create(width, height) {
            var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : PixelFormat.RGBA8888, mipmapLevel = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            this.reset({
                width: width,
                height: height,
                format: format,
                mipmapLevel: mipmapLevel
            });
        }
    }, {
        key: "toString",
        value: function toString() {
            return 0 !== this._mipmaps.length ? this._mipmaps[0].url : "";
        }
    }, {
        key: "updateMipmaps",
        value: function updateMipmaps() {
            var firstLevel = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, count = arguments.length > 1 ? arguments[1] : void 0;
            if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), i = 0; i < nUpdate; ++i) {
                var level = firstLevel + i;
                this._assignImage(this._mipmaps[level], level);
            }
        }
    }, {
        key: "getHtmlElementObj",
        value: function getHtmlElementObj() {
            return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._mipmaps = [], _get(_getPrototypeOf(Texture2D.prototype), "destroy", this).call(this);
        }
    }, {
        key: "description",
        value: function description() {
            var url = this._mipmaps[0] ? this._mipmaps[0].url : "";
            return "<cc.Texture2D | Name = ".concat(url, " | Dimension = ").concat(this.width, " x ").concat(this.height, ">");
        }
    }, {
        key: "releaseTexture",
        value: function releaseTexture() {
            this.destroy();
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            return {
                base: _get(_getPrototypeOf(Texture2D.prototype), "_serialize", this).call(this, exporting),
                mipmaps: this._mipmaps.map((function(mipmap) {
                    return mipmap && mipmap._uuid ? exporting ? EditorExtends.UuidUtils.compressUuid(mipmap._uuid, !0) : mipmap._uuid : null;
                }))
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializedData, handle) {
            var data = serializedData;
            _get(_getPrototypeOf(Texture2D.prototype), "_deserialize", this).call(this, data.base, handle), 
            this._mipmaps = new Array(data.mipmaps.length);
            for (var i = 0; i < data.mipmaps.length; ++i) if (this._mipmaps[i] = new ImageAsset, 
            data.mipmaps[i]) {
                var mipmapUUID = data.mipmaps[i];
                handle.result.push(this._mipmaps, "".concat(i), mipmapUUID), this._mipmaps[i]._texture = this;
            }
        }
    }, {
        key: "_getGfxTextureCreateInfo",
        value: function _getGfxTextureCreateInfo(presumed) {
            return Object.assign({
                type: exports.GFXTextureType.TEX2D,
                width: this._width,
                height: this._height
            }, presumed);
        }
    }, {
        key: "_getGfxTextureViewCreateInfo",
        value: function _getGfxTextureViewCreateInfo(presumed) {
            return Object.assign({
                type: exports.GFXTextureViewType.TV2D
            }, presumed);
        }
    }, {
        key: "_checkTextureLoaded",
        value: function _checkTextureLoaded() {
            for (var ready = !0, i = 0; i < this._mipmaps.length; ++i) {
                if (!this._mipmaps[i].loaded) {
                    ready = !1;
                    break;
                }
            }
            ready && _get(_getPrototypeOf(Texture2D.prototype), "_textureReady", this).call(this);
        }
    } ]), Texture2D;
}()).prototype, "_mipmaps", [ _dec2$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$6 = _class2$4)) || _class$6);

cc.Texture2D = Texture2D;

var layerList = {
    NONE: 0,
    IGNORE_RAYCAST: 1 << 20,
    GIZMOS: 1 << 21,
    EDITOR: 1 << 22,
    UI_3D: 1 << 23,
    SCENE_GIZMO: 1 << 24,
    UI_2D: 1 << 25,
    PROFILER: 1 << 28,
    DEFAULT: 1 << 30,
    ALL: 4294967295
}, Layers = function() {
    function Layers() {
        _classCallCheck(this, Layers);
    }
    return _createClass(Layers, null, [ {
        key: "makeMaskInclude",
        value: function makeMaskInclude(includes) {
            for (var _step, mask = 0, _iterator = _createForOfIteratorHelperLoose(includes); !(_step = _iterator()).done; ) {
                mask |= _step.value;
            }
            return mask;
        }
    }, {
        key: "makeMaskExclude",
        value: function makeMaskExclude(excludes) {
            return ~Layers.makeMaskInclude(excludes);
        }
    }, {
        key: "addLayer",
        value: function addLayer(name, bitNum) {
            void 0 !== bitNum ? bitNum > 19 || bitNum < 0 ? console.warn("maximum layers reached.") : (Layers.Enum[name] = 1 << bitNum, 
            Layers.Enum[bitNum] = name, Layers.BitMask[name] = 1 << bitNum, Layers.BitMask[bitNum] = name) : console.warn("bitNum can't be undefined");
        }
    }, {
        key: "deleteLayer",
        value: function deleteLayer(bitNum) {
            bitNum > 19 || bitNum < 0 ? console.warn("do not change buildin layers.") : (delete Layers.Enum[Layers.Enum[bitNum]], 
            delete Layers.Enum[bitNum], delete Layers.BitMask[Layers.BitMask[bitNum]], delete Layers.BitMask[bitNum]);
        }
    } ]), Layers;
}();

Layers.Enum = Enum(layerList), Layers.BitMask = BitMask(Object.assign({}, layerList)), 
cc.Layers = Layers;

var RenderPassStage, RenderPriority;

!function(RenderPassStage) {
    RenderPassStage[RenderPassStage.DEFAULT = 100] = "DEFAULT";
}(RenderPassStage || (RenderPassStage = {})), cc.RenderPassStage = RenderPassStage, 
function(RenderPriority) {
    RenderPriority[RenderPriority.MIN = 0] = "MIN", RenderPriority[RenderPriority.MAX = 255] = "MAX", 
    RenderPriority[RenderPriority.DEFAULT = 128] = "DEFAULT";
}(RenderPriority || (RenderPriority = {}));

var UniformBinding;

!function(UniformBinding) {
    UniformBinding[UniformBinding.UBO_GLOBAL = 23] = "UBO_GLOBAL", UniformBinding[UniformBinding.UBO_SHADOW = 22] = "UBO_SHADOW", 
    UniformBinding[UniformBinding.UBO_LOCAL = 21] = "UBO_LOCAL", UniformBinding[UniformBinding.UBO_FORWARD_LIGHTS = 20] = "UBO_FORWARD_LIGHTS", 
    UniformBinding[UniformBinding.UBO_SKINNING_ANIMATION = 19] = "UBO_SKINNING_ANIMATION", 
    UniformBinding[UniformBinding.UBO_SKINNING_TEXTURE = 18] = "UBO_SKINNING_TEXTURE", 
    UniformBinding[UniformBinding.UBO_UI = 17] = "UBO_UI", UniformBinding[UniformBinding.UBO_MORPH = 16] = "UBO_MORPH", 
    UniformBinding[UniformBinding.UBO_BUILTIN_BINDING_END = 15] = "UBO_BUILTIN_BINDING_END", 
    UniformBinding[UniformBinding.SAMPLER_JOINTS = 25] = "SAMPLER_JOINTS", UniformBinding[UniformBinding.SAMPLER_ENVIRONMENT = 26] = "SAMPLER_ENVIRONMENT", 
    UniformBinding[UniformBinding.SAMPLER_MORPH_POSITION = 27] = "SAMPLER_MORPH_POSITION", 
    UniformBinding[UniformBinding.SAMPLER_MORPH_NORMAL = 28] = "SAMPLER_MORPH_NORMAL", 
    UniformBinding[UniformBinding.SAMPLER_MORPH_TANGENT = 29] = "SAMPLER_MORPH_TANGENT", 
    UniformBinding[UniformBinding.SAMPLER_LIGHTING_MAP = 30] = "SAMPLER_LIGHTING_MAP", 
    UniformBinding[UniformBinding.CUSTUM_UBO_BINDING_END_POINT = UniformBinding.UBO_BUILTIN_BINDING_END] = "CUSTUM_UBO_BINDING_END_POINT", 
    UniformBinding[UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT = 31] = "CUSTOM_SAMPLER_BINDING_START_POINT";
}(UniformBinding || (UniformBinding = {}));

var isBuiltinBinding = function isBuiltinBinding(binding) {
    return binding >= UniformBinding.CUSTUM_UBO_BINDING_END_POINT && binding < UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT;
}, UBOGlobal = function UBOGlobal() {
    _classCallCheck(this, UBOGlobal), this.view = new Float32Array(UBOGlobal.COUNT);
};

UBOGlobal.SIZE = 4 * (UBOGlobal.COUNT = (UBOGlobal.AMBIENT_GROUND_OFFSET = (UBOGlobal.AMBIENT_SKY_OFFSET = (UBOGlobal.MAIN_LIT_COLOR_OFFSET = (UBOGlobal.MAIN_LIT_DIR_OFFSET = (UBOGlobal.EXPOSURE_OFFSET = (UBOGlobal.CAMERA_POS_OFFSET = (UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET = (UBOGlobal.MAT_VIEW_PROJ_OFFSET = (UBOGlobal.MAT_PROJ_INV_OFFSET = (UBOGlobal.MAT_PROJ_OFFSET = (UBOGlobal.MAT_VIEW_INV_OFFSET = (UBOGlobal.MAT_VIEW_OFFSET = (UBOGlobal.NATIVE_SIZE_OFFSET = (UBOGlobal.SCREEN_SCALE_OFFSET = (UBOGlobal.SCREEN_SIZE_OFFSET = (UBOGlobal.TIME_OFFSET = 0) + 4) + 4) + 4) + 4) + 16) + 16) + 16) + 16) + 16) + 16) + 4) + 4) + 4) + 4) + 4) + 4), 
UBOGlobal.BLOCK = {
    binding: UniformBinding.UBO_GLOBAL,
    name: "CCGlobal",
    members: [ {
        name: "cc_time",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_screenSize",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_screenScale",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_nativeSize",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_matView",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matViewInv",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matProj",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matProjInv",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matViewProj",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matViewProjInv",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_cameraPos",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_exposure",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_mainLitDir",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_mainLitColor",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_ambientSky",
        type: exports.GFXType.FLOAT4,
        count: 1
    }, {
        name: "cc_ambientGround",
        type: exports.GFXType.FLOAT4,
        count: 1
    } ]
};

var UBOShadow = function UBOShadow() {
    _classCallCheck(this, UBOShadow), this.view = new Float32Array(UBOShadow.COUNT);
};

UBOShadow.SIZE = 4 * (UBOShadow.COUNT = (UBOShadow.SHADOW_COLOR_OFFSET = (UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0) + 16) + 4), 
UBOShadow.BLOCK = {
    binding: UniformBinding.UBO_SHADOW,
    name: "CCShadow",
    members: [ {
        name: "cc_matLightPlaneProj",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_shadowColor",
        type: exports.GFXType.FLOAT4,
        count: 1
    } ]
};

var UNIFORM_ENVIRONMENT = {
    binding: UniformBinding.SAMPLER_ENVIRONMENT,
    name: "cc_environment",
    type: exports.GFXType.SAMPLER_CUBE,
    count: 1
}, localBindingsDesc = new Map, UBOLocal = function UBOLocal() {
    _classCallCheck(this, UBOLocal), this.view = new Float32Array(UBOLocal.COUNT);
};

UBOLocal.SIZE = 4 * (UBOLocal.COUNT = (UBOLocal.LIGHTINGMAP_UVPARAM = (UBOLocal.MAT_WORLD_IT_OFFSET = (UBOLocal.MAT_WORLD_OFFSET = 0) + 16) + 16) + 4), 
UBOLocal.BLOCK = {
    binding: UniformBinding.UBO_LOCAL,
    name: "CCLocal",
    members: [ {
        name: "cc_matWorld",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_matWorldIT",
        type: exports.GFXType.MAT4,
        count: 1
    }, {
        name: "cc_lightingMapUVParam",
        type: exports.GFXType.FLOAT4,
        count: 1
    } ]
}, localBindingsDesc.set(UBOLocal.BLOCK.name, {
    type: exports.GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOLocal.BLOCK
});

var UBOLocalBatched = function UBOLocalBatched() {
    _classCallCheck(this, UBOLocalBatched), this.view = new Float32Array(UBOLocalBatched.COUNT);
};

UBOLocalBatched.BATCHING_COUNT = 10, UBOLocalBatched.MAT_WORLDS_OFFSET = 0, UBOLocalBatched.SIZE = 4 * (UBOLocalBatched.COUNT = 16 * UBOLocalBatched.BATCHING_COUNT), 
UBOLocalBatched.BLOCK = {
    binding: UniformBinding.UBO_LOCAL,
    name: "CCLocalBatched",
    members: [ {
        name: "cc_matWorlds",
        type: exports.GFXType.MAT4,
        count: UBOLocalBatched.BATCHING_COUNT
    } ]
}, localBindingsDesc.set(UBOLocalBatched.BLOCK.name, {
    type: exports.GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOLocalBatched.BLOCK
});

var UBOForwardLight = function UBOForwardLight() {
    _classCallCheck(this, UBOForwardLight), this.view = new Float32Array(UBOForwardLight.COUNT);
};

UBOForwardLight.MAX_SPHERE_LIGHTS = 2, UBOForwardLight.MAX_SPOT_LIGHTS = 2, UBOForwardLight.SIZE = 4 * (UBOForwardLight.COUNT = (UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET = (UBOForwardLight.SPOT_LIGHT_DIR_OFFSET = (UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET = (UBOForwardLight.SPOT_LIGHT_POS_OFFSET = (UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET = (UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET = (UBOForwardLight.SPHERE_LIGHT_POS_OFFSET = 0) + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS) + 4 * UBOForwardLight.MAX_SPHERE_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS) + 4 * UBOForwardLight.MAX_SPOT_LIGHTS), 
UBOForwardLight.BLOCK = {
    binding: UniformBinding.UBO_FORWARD_LIGHTS,
    name: "CCForwardLight",
    members: [ {
        name: "cc_sphereLitPos",
        type: exports.GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPHERE_LIGHTS
    }, {
        name: "cc_sphereLitSizeRange",
        type: exports.GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPHERE_LIGHTS
    }, {
        name: "cc_sphereLitColor",
        type: exports.GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPHERE_LIGHTS
    }, {
        name: "cc_spotLitPos",
        type: exports.GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPOT_LIGHTS
    }, {
        name: "cc_spotLitSizeRangeAngle",
        type: exports.GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPOT_LIGHTS
    }, {
        name: "cc_spotLitDir",
        type: exports.GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPOT_LIGHTS
    }, {
        name: "cc_spotLitColor",
        type: exports.GFXType.FLOAT4,
        count: UBOForwardLight.MAX_SPOT_LIGHTS
    } ]
}, localBindingsDesc.set(UBOForwardLight.BLOCK.name, {
    type: exports.GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOForwardLight.BLOCK
});

var UBOSkinningTexture = function UBOSkinningTexture() {
    _classCallCheck(this, UBOSkinningTexture);
};

UBOSkinningTexture.SIZE = 4 * (UBOSkinningTexture.COUNT = (UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0) + 4), 
UBOSkinningTexture.BLOCK = {
    binding: UniformBinding.UBO_SKINNING_TEXTURE,
    name: "CCSkinningTexture",
    members: [ {
        name: "cc_jointTextureInfo",
        type: exports.GFXType.FLOAT4,
        count: 1
    } ]
}, localBindingsDesc.set(UBOSkinningTexture.BLOCK.name, {
    type: exports.GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOSkinningTexture.BLOCK
});

var UBOSkinningAnimation = function UBOSkinningAnimation() {
    _classCallCheck(this, UBOSkinningAnimation);
};

UBOSkinningAnimation.SIZE = 4 * (UBOSkinningAnimation.COUNT = (UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0) + 4), 
UBOSkinningAnimation.BLOCK = {
    binding: UniformBinding.UBO_SKINNING_ANIMATION,
    name: "CCSkinningAnimation",
    members: [ {
        name: "cc_jointAnimInfo",
        type: exports.GFXType.FLOAT4,
        count: 1
    } ]
}, localBindingsDesc.set(UBOSkinningAnimation.BLOCK.name, {
    type: exports.GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOSkinningAnimation.BLOCK
});

var UBOSkinning = function UBOSkinning() {
    _classCallCheck(this, UBOSkinning);
};

UBOSkinning.SIZE = 4 * (UBOSkinning.COUNT = (UBOSkinning.JOINTS_OFFSET = 0) + 360), 
UBOSkinning.BLOCK = {
    binding: UniformBinding.UBO_SKINNING_TEXTURE,
    name: "CCSkinning",
    members: [ {
        name: "cc_joints",
        type: exports.GFXType.FLOAT4,
        count: 90
    } ]
}, localBindingsDesc.set(UBOSkinning.BLOCK.name, {
    type: exports.GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOSkinning.BLOCK
});

var UniformJointTexture = {
    binding: UniformBinding.SAMPLER_JOINTS,
    name: "cc_jointTexture",
    type: exports.GFXType.SAMPLER2D,
    count: 1
};

localBindingsDesc.set(UniformJointTexture.name, {
    type: exports.GFXBindingType.SAMPLER,
    samplerInfo: UniformJointTexture
});

var UBOMorph = function UBOMorph() {
    _classCallCheck(this, UBOMorph);
};

UBOMorph.MAX_MORPH_TARGET_COUNT = 60, UBOMorph.OFFSET_OF_WEIGHTS = 0, UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = (UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * UBOMorph.MAX_MORPH_TARGET_COUNT) + 4, 
UBOMorph.COUNT_BASE_4_BYTES = 4 * Math.ceil(UBOMorph.MAX_MORPH_TARGET_COUNT / 4) + 4, 
UBOMorph.SIZE = 4 * UBOMorph.COUNT_BASE_4_BYTES, UBOMorph.BLOCK = {
    binding: UniformBinding.UBO_MORPH,
    name: "CCMorph",
    members: [ {
        name: "cc_displacementWeights",
        type: exports.GFXType.FLOAT4,
        count: UBOMorph.MAX_MORPH_TARGET_COUNT / 4
    }, {
        name: "cc_displacementTextureInfo",
        type: exports.GFXType.FLOAT4,
        count: 1
    } ]
}, localBindingsDesc.set(UBOMorph.BLOCK.name, {
    type: exports.GFXBindingType.UNIFORM_BUFFER,
    blockInfo: UBOMorph.BLOCK
});

var UniformPositionMorphTexture = {
    binding: UniformBinding.SAMPLER_MORPH_POSITION,
    name: "cc_PositionDisplacements",
    type: exports.GFXType.SAMPLER2D,
    count: 1
};

localBindingsDesc.set(UniformPositionMorphTexture.name, {
    type: exports.GFXBindingType.SAMPLER,
    samplerInfo: UniformPositionMorphTexture
});

var UniformNormalMorphTexture = {
    binding: UniformBinding.SAMPLER_MORPH_NORMAL,
    name: "cc_NormalDisplacements",
    type: exports.GFXType.SAMPLER2D,
    count: 1
};

localBindingsDesc.set(UniformNormalMorphTexture.name, {
    type: exports.GFXBindingType.SAMPLER,
    samplerInfo: UniformNormalMorphTexture
});

var UniformLightingMapSampler = {
    binding: UniformBinding.SAMPLER_LIGHTING_MAP,
    name: "cc_lightingMap",
    type: exports.GFXType.SAMPLER2D,
    count: 1
};

localBindingsDesc.set(UniformLightingMapSampler.name, {
    type: exports.GFXBindingType.SAMPLER,
    samplerInfo: UniformLightingMapSampler
});

var UniformTangentMorphTexture = {
    binding: UniformBinding.SAMPLER_MORPH_TANGENT,
    name: "cc_TangentDisplacements",
    type: exports.GFXType.SAMPLER2D,
    count: 1
};

localBindingsDesc.set(UniformTangentMorphTexture.name, {
    type: exports.GFXBindingType.SAMPLER,
    samplerInfo: UniformTangentMorphTexture
});

var CAMERA_DEFAULT_MASK = Layers.makeMaskExclude([ Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER ]), CAMERA_EDITOR_MASK = Layers.makeMaskExclude([ Layers.BitMask.UI_2D, Layers.BitMask.PROFILER ]), MODEL_ALWAYS_MASK = Layers.Enum.ALL, pipelineDefine = Object.freeze({
    __proto__: null,
    PIPELINE_FLOW_FORWARD: "ForwardFlow",
    PIPELINE_FLOW_SMAA: "SMAAFlow",
    PIPELINE_FLOW_TONEMAP: "ToneMapFlow",
    get RenderPassStage() {
        return RenderPassStage;
    },
    get RenderPriority() {
        return RenderPriority;
    },
    get UniformBinding() {
        return UniformBinding;
    },
    isBuiltinBinding: isBuiltinBinding,
    UBOGlobal: UBOGlobal,
    UBOShadow: UBOShadow,
    UNIFORM_ENVIRONMENT: UNIFORM_ENVIRONMENT,
    localBindingsDesc: localBindingsDesc,
    UBOLocal: UBOLocal,
    INST_MAT_WORLD: "a_matWorld0",
    UBOLocalBatched: UBOLocalBatched,
    UBOForwardLight: UBOForwardLight,
    JOINT_UNIFORM_CAPACITY: 30,
    UBOSkinningTexture: UBOSkinningTexture,
    UBOSkinningAnimation: UBOSkinningAnimation,
    INST_JOINT_ANIM_INFO: "a_jointAnimInfo",
    UBOSkinning: UBOSkinning,
    UniformJointTexture: UniformJointTexture,
    UBOMorph: UBOMorph,
    UniformPositionMorphTexture: UniformPositionMorphTexture,
    UniformNormalMorphTexture: UniformNormalMorphTexture,
    UniformLightingMapSampler: UniformLightingMapSampler,
    UniformTangentMorphTexture: UniformTangentMorphTexture,
    CAMERA_DEFAULT_MASK: CAMERA_DEFAULT_MASK,
    CAMERA_EDITOR_MASK: CAMERA_EDITOR_MASK,
    MODEL_ALWAYS_MASK: MODEL_ALWAYS_MASK
});

function assertIsNonNullable(expr, message) {
    assertIsTrue(!(null == expr), message);
}

function assertIsTrue(expr, message) {
    if (!expr) throw new Error("Assertion failed: ".concat(null != message ? message : "<no-message>"));
}

var _class$7, _class2$5, _descriptor$4, _descriptor2$2, _descriptor3$2, StdMorphRendering = function() {
    function StdMorphRendering(mesh, gfxDevice) {
        if (_classCallCheck(this, StdMorphRendering), this._mesh = void 0, this._subMeshRenderings = [], 
        this._mesh = mesh, this._mesh.struct.morph) {
            var nSubMeshes = this._mesh.struct.primitives.length;
            this._subMeshRenderings = new Array(nSubMeshes).fill(null);
            for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                var subMeshMorph = this._mesh.struct.morph.subMeshMorphs[iSubMesh];
                subMeshMorph && (subMeshMorph.targets.length > UBOMorph.MAX_MORPH_TARGET_COUNT ? warnID(10002, UBOMorph.MAX_MORPH_TARGET_COUNT, subMeshMorph.targets.length) : this._subMeshRenderings[iSubMesh] = new GpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice));
            }
        }
    }
    return _createClass(StdMorphRendering, [ {
        key: "createInstance",
        value: function createInstance() {
            for (var _this = this, nSubMeshes = this._mesh.struct.primitives.length, subMeshInstances = new Array(nSubMeshes), iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                var _this$_subMeshRenderi, _this$_subMeshRenderi2;
                subMeshInstances[iSubMesh] = null !== (_this$_subMeshRenderi = null === (_this$_subMeshRenderi2 = this._subMeshRenderings[iSubMesh]) || void 0 === _this$_subMeshRenderi2 ? void 0 : _this$_subMeshRenderi2.createInstance()) && void 0 !== _this$_subMeshRenderi ? _this$_subMeshRenderi : null;
            }
            return {
                setWeights: function setWeights(subMeshIndex, weights) {
                    var _subMeshInstances$sub;
                    null === (_subMeshInstances$sub = subMeshInstances[subMeshIndex]) || void 0 === _subMeshInstances$sub || _subMeshInstances$sub.setWeights(weights);
                },
                requiredPatches: function requiredPatches(subMeshIndex) {
                    var subMeshMorph = _this._mesh.struct.morph.subMeshMorphs[subMeshIndex], subMeshRenderingInstance = subMeshInstances[subMeshIndex];
                    if (null !== subMeshRenderingInstance) {
                        assertIsNonNullable(subMeshMorph);
                        var patches = [ {
                            name: "CC_USE_MORPH",
                            value: !0
                        }, {
                            name: "CC_MORPH_TARGET_COUNT",
                            value: subMeshMorph.targets.length
                        } ];
                        return subMeshMorph.attributes.includes(exports.GFXAttributeName.ATTR_POSITION) && patches.push({
                            name: "CC_MORPH_TARGET_HAS_POSITION",
                            value: !0
                        }), subMeshMorph.attributes.includes(exports.GFXAttributeName.ATTR_NORMAL) && patches.push({
                            name: "CC_MORPH_TARGET_HAS_NORMAL",
                            value: !0
                        }), subMeshMorph.attributes.includes(exports.GFXAttributeName.ATTR_TANGENT) && patches.push({
                            name: "CC_MORPH_TARGET_HAS_TANGENT",
                            value: !0
                        }), patches.push.apply(patches, _toConsumableArray(subMeshRenderingInstance.requiredPatches())), 
                        patches;
                    }
                },
                adaptPipelineState: function adaptPipelineState(subMeshIndex, pipelineState) {
                    var _subMeshInstances$sub2;
                    null === (_subMeshInstances$sub2 = subMeshInstances[subMeshIndex]) || void 0 === _subMeshInstances$sub2 || _subMeshInstances$sub2.adaptPipelineState(pipelineState);
                },
                destroy: function destroy() {
                    for (var _step, _iterator = _createForOfIteratorHelperLoose(subMeshInstances); !(_step = _iterator()).done; ) {
                        var subMeshInstance = _step.value;
                        null == subMeshInstance || subMeshInstance.destroy();
                    }
                }
            };
        }
    } ]), StdMorphRendering;
}(), GpuComputing = function() {
    function GpuComputing(mesh, subMeshIndex, morph, gfxDevice) {
        _classCallCheck(this, GpuComputing), this._gfxDevice = void 0, this._subMeshMorph = void 0, 
        this._textureInfo = void 0, this._attributes = void 0, this._gfxDevice = gfxDevice;
        var meshData = mesh.data.buffer, subMeshMorph = morph.subMeshMorphs[subMeshIndex];
        assertIsNonNullable(subMeshMorph), this._subMeshMorph = subMeshMorph, function enableVertexId(mesh, subMeshIndex, gfxDevice) {
            mesh.renderingSubMeshes[subMeshIndex].enableVertexIdChannel(gfxDevice);
        }(mesh, subMeshIndex, gfxDevice);
        var nVertices = mesh.struct.vertexBundles[mesh.struct.primitives[subMeshIndex].vertexBundelIndices[0]].view.count, nTargets = subMeshMorph.targets.length, pixelsRequired = nTargets + nVertices * nTargets, textureExtents = function nearestSqrtPowerOf2LargeThan(value) {
            return nextPow2(Math.ceil(Math.sqrt(value)));
        }(pixelsRequired), width = textureExtents, height = textureExtents;
        assertIsTrue(width * height > pixelsRequired), this._textureInfo = {
            width: width,
            height: height
        }, this._attributes = subMeshMorph.attributes.map((function(attributeName, attributeIndex) {
            var nTargets = subMeshMorph.targets.length, textureInfo = {
                displacements: new Array,
                targetOffsets: new Array(nTargets).fill(0)
            };
            subMeshMorph.targets.forEach((function(morphTarget, morphTargetIndex) {
                var _textureInfo$displace, displacements = morphTarget.displacements[attributeIndex];
                textureInfo.targetOffsets[morphTargetIndex] = textureInfo.displacements.length, 
                (_textureInfo$displace = textureInfo.displacements).push.apply(_textureInfo$displace, _toConsumableArray(new Float32Array(meshData, displacements.offset, displacements.count)));
            }));
            for (var pixelFormat = Texture2D.PixelFormat.RGB32F, textureSource = new Float32Array(3 * width * height), headPixels = nTargets, headElements = 3 * headPixels, iTarget = 0; iTarget < nTargets; ++iTarget) textureSource[3 * iTarget] = headPixels + textureInfo.targetOffsets[iTarget] / 3;
            for (var iData = 0; iData < textureInfo.displacements.length; ++iData) textureSource[headElements + iData] = textureInfo.displacements[iData];
            var image = new ImageAsset({
                width: width,
                height: height,
                _data: textureSource,
                _compressed: !1,
                format: pixelFormat
            }), textureAsset = new Texture2D;
            textureAsset.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST), textureAsset.setMipFilter(Texture2D.Filter.NONE), 
            textureAsset.setWrapMode(Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE), 
            textureAsset.image = image;
            var sampler = samplerLib.getSampler(gfxDevice, textureAsset.getSamplerHash());
            return {
                name: attributeName,
                texture: textureAsset,
                sampler: sampler
            };
        }));
    }
    return _createClass(GpuComputing, [ {
        key: "destroy",
        value: function destroy() {
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._attributes); !(_step2 = _iterator2()).done; ) {
                var attribute = _step2.value;
                attribute.texture.destroy(), attribute.sampler.destroy();
            }
        }
    }, {
        key: "createInstance",
        value: function createInstance() {
            var _this2 = this, morphUniforms = new MorphUniforms(this._gfxDevice, this._subMeshMorph.targets.length);
            return morphUniforms.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height), 
            morphUniforms.commit(), {
                setWeights: function setWeights(weights) {
                    morphUniforms.setWeights(weights), morphUniforms.commit();
                },
                requiredPatches: function requiredPatches() {
                    return [ {
                        name: "CC_MORPH_TARGET_USE_TEXTURE",
                        value: !0
                    } ];
                },
                adaptPipelineState: function adaptPipelineState(pipelineState) {
                    for (var _step3, bindingLayout = pipelineState.pipelineLayout.layouts[0], _iterator3 = _createForOfIteratorHelperLoose(_this2._attributes); !(_step3 = _iterator3()).done; ) {
                        var attribute = _step3.value, binding = void 0;
                        switch (attribute.name) {
                          case exports.GFXAttributeName.ATTR_POSITION:
                            binding = UniformPositionMorphTexture.binding;
                            break;

                          case exports.GFXAttributeName.ATTR_NORMAL:
                            binding = UniformNormalMorphTexture.binding;
                            break;

                          case exports.GFXAttributeName.ATTR_TANGENT:
                            binding = UniformTangentMorphTexture.binding;
                            break;

                          default:
                            warn("Unexpected attribute!");
                        }
                        void 0 !== binding && (bindingLayout.bindSampler(binding, attribute.sampler), bindingLayout.bindTextureView(binding, attribute.texture.getGFXTextureView()));
                    }
                    bindingLayout.bindBuffer(UBOMorph.BLOCK.binding, morphUniforms.buffer), bindingLayout.update();
                },
                destroy: function destroy() {}
            };
        }
    } ]), GpuComputing;
}(), MorphUniforms = function() {
    function MorphUniforms(gfxDevice, targetCount) {
        _classCallCheck(this, MorphUniforms), this._targetCount = void 0, this._localBuffer = void 0, 
        this._remoteBuffer = void 0, this._targetCount = targetCount, this._localBuffer = new DataView(new ArrayBuffer(UBOMorph.SIZE)), 
        this._remoteBuffer = gfxDevice.createBuffer({
            usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
            memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
            size: UBOMorph.SIZE,
            stride: UBOMorph.SIZE
        });
    }
    return _createClass(MorphUniforms, [ {
        key: "destroy",
        value: function destroy() {
            this._remoteBuffer.destroy();
        }
    }, {
        key: "setWeights",
        value: function setWeights(weights) {
            assertIsTrue(weights.length === this._targetCount);
            for (var iWeight = 0; iWeight < weights.length; ++iWeight) this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_WEIGHTS + 4 * iWeight, weights[iWeight], cc.sys.isLittleEndian);
        }
    }, {
        key: "setMorphTextureInfo",
        value: function setMorphTextureInfo(width, height) {
            this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH, width, cc.sys.isLittleEndian), 
            this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT, height, cc.sys.isLittleEndian);
        }
    }, {
        key: "commit",
        value: function commit() {
            this._remoteBuffer.update(this._localBuffer.buffer, this._localBuffer.byteOffset, this._localBuffer.byteLength);
        }
    }, {
        key: "buffer",
        get: function get() {
            return this._remoteBuffer;
        }
    } ]), MorphUniforms;
}();

function getIndexStrideCtor(stride) {
    switch (stride) {
      case 1:
        return Uint8Array;

      case 2:
        return Uint16Array;

      case 4:
        return Uint32Array;
    }
    return Uint8Array;
}

var RenderingSubMesh = function() {
    function RenderingSubMesh(vertexBuffers, attributes, primitiveMode) {
        _classCallCheck(this, RenderingSubMesh), this.vertexBuffers = void 0, this.attributes = void 0, 
        this.primitiveMode = void 0, this.indexBuffer = void 0, this.indirectBuffer = void 0, 
        this.mesh = void 0, this.subMeshIdx = void 0, this._flatBuffers = void 0, this._jointMappedBuffers = void 0, 
        this._jointMappedBufferIndices = void 0, this._vertexIdChannel = void 0, this._geometricInfo = void 0, 
        this.vertexBuffers = vertexBuffers, this.attributes = attributes, this.primitiveMode = primitiveMode;
    }
    return _createClass(RenderingSubMesh, [ {
        key: "geometricInfo",
        get: function get() {
            if (this._geometricInfo) return this._geometricInfo;
            if (void 0 === this.mesh) return {
                positions: new Float32Array,
                indices: new Uint8Array,
                boundingBox: {
                    min: Vec3.ZERO,
                    max: Vec3.ZERO
                }
            };
            if (void 0 === this.subMeshIdx) return {
                positions: new Float32Array,
                indices: new Uint8Array,
                boundingBox: {
                    min: Vec3.ZERO,
                    max: Vec3.ZERO
                }
            };
            var mesh = this.mesh, index = this.subMeshIdx, positions = mesh.readAttribute(index, exports.GFXAttributeName.ATTR_POSITION), indices = mesh.readIndices(index), max = new Vec3, min = new Vec3, pAttri = this.attributes.find((function(element) {
                return element.name === cc.GFXAttributeName.ATTR_POSITION;
            }));
            if (pAttri) {
                var conut = GFXFormatInfos[pAttri.format].count;
                2 === conut ? (max.set(positions[0], positions[1], 0), min.set(positions[0], positions[1], 0)) : (max.set(positions[0], positions[1], positions[2]), 
                min.set(positions[0], positions[1], positions[2]));
                for (var i = 0; i < positions.length; i += conut) 2 === conut ? (max.x = positions[i] > max.x ? positions[i] : max.x, 
                max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y, min.x = positions[i] < min.x ? positions[i] : min.x, 
                min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y) : (max.x = positions[i] > max.x ? positions[i] : max.x, 
                max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y, max.z = positions[i + 2] > max.z ? positions[i + 2] : max.z, 
                min.x = positions[i] < min.x ? positions[i] : min.x, min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y, 
                min.z = positions[i + 2] < min.z ? positions[i + 2] : min.z);
            }
            return this._geometricInfo = {
                positions: positions,
                indices: indices,
                boundingBox: {
                    max: max,
                    min: min
                }
            }, this._geometricInfo;
        }
    }, {
        key: "flatBuffers",
        get: function get() {
            if (this._flatBuffers) return this._flatBuffers;
            var buffers = this._flatBuffers = [];
            if (!this.mesh || void 0 === this.subMeshIdx) return buffers;
            var mesh = this.mesh, idxCount = 0, prim = mesh.struct.primitives[this.subMeshIdx];
            prim.indexView && (idxCount = prim.indexView.count);
            for (var _step, _iterator = _createForOfIteratorHelperLoose(prim.vertexBundelIndices); !(_step = _iterator()).done; ) {
                var bundleIdx = _step.value, _vertexBundle = mesh.struct.vertexBundles[bundleIdx], vbCount = prim.indexView ? prim.indexView.count : _vertexBundle.view.count, vbStride = _vertexBundle.view.stride, vbSize = vbStride * vbCount, view = new Uint8Array(mesh.data.buffer, _vertexBundle.view.offset, _vertexBundle.view.length);
                if (prim.indexView) {
                    for (var vbView = new Uint8Array(vbSize), ibView = mesh.readIndices(this.subMeshIdx), n = 0; n < idxCount; ++n) for (var offset = n * vbStride, srcOffset = ibView[n] * vbStride, m = 0; m < vbStride; ++m) vbView[offset + m] = view[srcOffset + m];
                    this._flatBuffers.push({
                        stride: vbStride,
                        count: vbCount,
                        buffer: vbView
                    });
                } else this._flatBuffers.push({
                    stride: vbStride,
                    count: vbCount,
                    buffer: view
                });
            }
            return this._flatBuffers;
        }
    }, {
        key: "jointMappedBuffers",
        get: function get() {
            var _this = this;
            if (this._jointMappedBuffers) return this._jointMappedBuffers;
            var buffers = this._jointMappedBuffers = [], indices = this._jointMappedBufferIndices = [];
            if (!this.mesh || void 0 === this.subMeshIdx) return this._jointMappedBuffers = this.vertexBuffers;
            var jointFormat, jointOffset, struct = this.mesh.struct, prim = struct.primitives[this.subMeshIdx];
            if (!struct.jointMaps || void 0 === prim.jointMapIndex || !struct.jointMaps[prim.jointMapIndex]) return this._jointMappedBuffers = this.vertexBuffers;
            for (var device = cc.director.root.device, i = 0; i < prim.vertexBundelIndices.length; i++) {
                var bundle = struct.vertexBundles[prim.vertexBundelIndices[i]];
                jointOffset = 0, jointFormat = exports.GFXFormat.UNKNOWN;
                for (var j = 0; j < bundle.attributes.length; j++) {
                    var attr = bundle.attributes[j];
                    if (attr.name === exports.GFXAttributeName.ATTR_JOINTS) {
                        jointFormat = attr.format;
                        break;
                    }
                    jointOffset += GFXFormatInfos[attr.format].size;
                }
                jointFormat ? function() {
                    var data = new Uint8Array(_this.mesh.data.buffer, bundle.view.offset, bundle.view.length), dataView = new DataView(data.slice().buffer), idxMap = struct.jointMaps[prim.jointMapIndex];
                    mapBuffer(dataView, (function(cur) {
                        return idxMap.indexOf(cur);
                    }), jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    var buffer = device.createBuffer({
                        usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: bundle.view.length,
                        stride: bundle.view.stride
                    });
                    buffer.update(dataView.buffer), buffers.push(buffer), indices.push(i);
                }() : buffers.push(this.vertexBuffers[prim.vertexBundelIndices[i]]);
            }
            return this._vertexIdChannel && buffers.push(this._allocVertexIdBuffer(device)), 
            buffers;
        }
    } ]), _createClass(RenderingSubMesh, [ {
        key: "destroy",
        value: function destroy() {
            for (var i = 0; i < this.vertexBuffers.length; i++) this.vertexBuffers[i].destroy();
            if (this.vertexBuffers.length = 0, this.indexBuffer && (this.indexBuffer.destroy(), 
            this.indexBuffer = void 0), this._jointMappedBuffers && this._jointMappedBufferIndices) {
                for (var _i = 0; _i < this._jointMappedBufferIndices.length; _i++) this._jointMappedBuffers[this._jointMappedBufferIndices[_i]].destroy();
                this._jointMappedBuffers = void 0, this._jointMappedBufferIndices = void 0;
            }
            this.indirectBuffer && (this.indirectBuffer.destroy(), this.indirectBuffer = void 0);
        }
    }, {
        key: "enableVertexIdChannel",
        value: function enableVertexIdChannel(device) {
            if (!this._vertexIdChannel) {
                var streamIndex = this.vertexBuffers.length, attributeIndex = this.attributes.length, vertexIdBuffer = this._allocVertexIdBuffer(device);
                this.vertexBuffers.push(vertexIdBuffer), this.attributes.push({
                    name: "a_vertexId",
                    format: exports.GFXFormat.R32F,
                    stream: streamIndex,
                    isNormalized: !1
                }), this._vertexIdChannel = {
                    stream: streamIndex,
                    index: attributeIndex
                };
            }
        }
    }, {
        key: "_allocVertexIdBuffer",
        value: function _allocVertexIdBuffer(device) {
            for (var vertexCount = 0 === this.vertexBuffers.length || 0 === this.vertexBuffers[0].stride ? 0 : this.vertexBuffers[0].size / this.vertexBuffers[0].stride, vertexIds = new Float32Array(vertexCount), iVertex = 0; iVertex < vertexCount; ++iVertex) vertexIds[iVertex] = iVertex;
            var vertexIdBuffer = device.createBuffer({
                usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: vertexIds.byteLength,
                stride: vertexIds.BYTES_PER_ELEMENT
            });
            return vertexIdBuffer.update(vertexIds), vertexIdBuffer;
        }
    } ]), RenderingSubMesh;
}(), v3_1$4 = new Vec3, v3_2$2 = new Vec3, Mesh = ccclass("cc.Mesh")((_descriptor$4 = _applyDecoratedDescriptor((_class2$5 = function(_Asset) {
    function Mesh() {
        var _this2;
        return _classCallCheck(this, Mesh), _initializerDefineProperty(_this2 = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this)), "_struct", _descriptor$4, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_dataLength", _descriptor2$2, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_hash", _descriptor3$2, _assertThisInitialized(_this2)), 
        _this2._data = null, _this2._initialized = !1, _this2._renderingSubMeshes = null, 
        _this2._boneSpaceBounds = new Map, _this2._jointBufferIndices = null, _this2.morphRendering = null, 
        _this2.loaded = !1, _this2;
    }
    return _inherits(Mesh, Asset), _createClass(Mesh, [ {
        key: "_nativeAsset",
        get: function get() {
            return this._data.buffer;
        },
        set: function set(value) {
            this._data && this._data.byteLength === value.byteLength ? (this._data.set(new Uint8Array(value)), 
            cc.loader._cache[this.nativeUrl] && (cc.loader._cache[this.nativeUrl].content = this._data.buffer)) : this._data = new Uint8Array(value), 
            this.loaded = !0, this.emit("load");
        }
    }, {
        key: "subMeshCount",
        get: function get() {
            var renderingMesh = this.renderingSubMeshes;
            return renderingMesh ? renderingMesh.length : 0;
        }
    }, {
        key: "minPosition",
        get: function get() {
            return this.struct.minPosition;
        }
    }, {
        key: "maxPosition",
        get: function get() {
            return this.struct.maxPosition;
        }
    }, {
        key: "struct",
        get: function get() {
            return this._struct;
        }
    }, {
        key: "data",
        get: function get() {
            return this._data;
        }
    }, {
        key: "hash",
        get: function get() {
            return !this._hash && this._data && (this._hash = murmurhash2_32_gc(this._data, 666)), 
            this._hash;
        }
    }, {
        key: "jointBufferIndices",
        get: function get() {
            return this._jointBufferIndices ? this._jointBufferIndices : this._jointBufferIndices = this._struct.primitives.map((function(p) {
                return p.jointMapIndex || 0;
            }));
        }
    } ]), _createClass(Mesh, [ {
        key: "initialize",
        value: function initialize() {
            var _this3 = this;
            if (!this._initialized) {
                this._initialized = !0, this._data || (this._data = new Uint8Array(this._dataLength), 
                function postLoadMesh(mesh, callback) {
                    mesh.loaded ? callback && callback() : mesh.nativeUrl ? cc.loader.load({
                        url: mesh.nativeUrl
                    }, (function(err, arrayBuffer) {
                        arrayBuffer && (mesh.loaded || (mesh._nativeAsset = arrayBuffer)), callback && callback(err);
                    })) : callback && callback();
                }(this));
                for (var buffer = this._data.buffer, gfxDevice = cc.director.root.device, vertexBuffers = this._createVertexBuffers(gfxDevice, buffer), subMeshes = [], _loop = function _loop(i) {
                    var prim = _this3._struct.primitives[i];
                    if (0 === prim.vertexBundelIndices.length) return "continue";
                    var indexBuffer = void 0, ib = null;
                    if (prim.indexView) {
                        var idxView = prim.indexView, dstStride = idxView.stride, dstSize = idxView.length;
                        if (4 === dstStride && !gfxDevice.hasFeature(exports.GFXFeature.ELEMENT_INDEX_UINT)) {
                            var vertexCount = _this3._struct.vertexBundles[prim.vertexBundelIndices[0]].view.count;
                            if (vertexCount >= 65536) return warnID(10001, vertexCount, 65536), "continue";
                            dstStride >>= 1, dstSize >>= 1;
                        }
                        indexBuffer = gfxDevice.createBuffer({
                            usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                            memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                            size: dstSize,
                            stride: dstStride
                        }), ib = new (getIndexStrideCtor(idxView.stride))(buffer, idxView.offset, idxView.count), 
                        idxView.stride !== dstStride && (ib = getIndexStrideCtor(dstStride).from(ib)), _this3.loaded ? indexBuffer.update(ib) : _this3.once("load", (function() {
                            indexBuffer.update(ib);
                        }));
                    }
                    var vbReference = prim.vertexBundelIndices.map((function(idx) {
                        return vertexBuffers[idx];
                    })), gfxAttributes = [];
                    if (prim.vertexBundelIndices.length > 0) {
                        var idx = prim.vertexBundelIndices[0];
                        gfxAttributes = _this3._struct.vertexBundles[idx].attributes;
                    }
                    var subMesh = new RenderingSubMesh(vbReference, gfxAttributes, prim.primitiveMode);
                    subMesh.mesh = _this3, subMesh.subMeshIdx = i, subMesh.indexBuffer = indexBuffer, 
                    subMeshes.push(subMesh);
                }, i = 0; i < this._struct.primitives.length; i++) _loop(i);
                this._renderingSubMeshes = subMeshes, this._struct.morph && (this.morphRendering = function createMorphRendering(mesh, gfxDevice) {
                    return new StdMorphRendering(mesh, gfxDevice);
                }(this, gfxDevice));
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this.destroyRenderingMesh(), _get(_getPrototypeOf(Mesh.prototype), "destroy", this).call(this);
        }
    }, {
        key: "destroyRenderingMesh",
        value: function destroyRenderingMesh() {
            if (this._renderingSubMeshes) {
                for (var i = 0; i < this._renderingSubMeshes.length; i++) this._renderingSubMeshes[i].destroy();
                this._renderingSubMeshes = null, this._data = null, this._initialized = !1;
            }
        }
    }, {
        key: "assign",
        value: function assign(struct, data) {
            this.reset({
                struct: struct,
                data: data
            });
        }
    }, {
        key: "reset",
        value: function reset(info) {
            this.destroyRenderingMesh(), this._struct = info.struct, this._data = info.data, 
            this._hash = 0, this.loaded = !0, this.emit("load");
        }
    }, {
        key: "getBoneSpaceBounds",
        value: function getBoneSpaceBounds(skeleton) {
            if (this._boneSpaceBounds.has(skeleton.hash)) return this._boneSpaceBounds.get(skeleton.hash);
            var bounds = [];
            this._boneSpaceBounds.set(skeleton.hash, bounds);
            for (var valid = [], bindposes = skeleton.bindposes, i = 0; i < bindposes.length; i++) bounds.push(new aabb(1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0)), 
            valid.push(!1);
            for (var primitives = this._struct.primitives, p = 0; p < primitives.length; p++) {
                var joints = this.readAttribute(p, exports.GFXAttributeName.ATTR_JOINTS), weights = this.readAttribute(p, exports.GFXAttributeName.ATTR_WEIGHTS), positions = this.readAttribute(p, exports.GFXAttributeName.ATTR_POSITION);
                if (joints && weights && positions) for (var vertCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3), _i2 = 0; _i2 < vertCount; _i2++) {
                    Vec3.set(v3_1$4, positions[3 * _i2 + 0], positions[3 * _i2 + 1], positions[3 * _i2 + 2]);
                    for (var j = 0; j < 4; ++j) {
                        var idx = 4 * _i2 + j, joint = joints[idx];
                        if (!(0 === weights[idx] || joint >= bindposes.length)) {
                            Vec3.transformMat4(v3_2$2, v3_1$4, bindposes[joint]), valid[joint] = !0;
                            var b = bounds[joint];
                            Vec3.min(b.center, b.center, v3_2$2), Vec3.max(b.halfExtents, b.halfExtents, v3_2$2);
                        }
                    }
                }
            }
            for (var _i3 = 0; _i3 < bindposes.length; _i3++) {
                var _b = bounds[_i3];
                valid[_i3] ? aabb.fromPoints(_b, _b.center, _b.halfExtents) : bounds[_i3] = null;
            }
            return bounds;
        }
    }, {
        key: "merge",
        value: function merge(mesh, worldMatrix, validate) {
            if (validate && (!this.loaded || !mesh.loaded || !this.validateMergingMesh(mesh))) return !1;
            var vec3_temp = new Vec3, rotate = worldMatrix && new Quat, boundingBox = worldMatrix && new aabb;
            if (rotate && worldMatrix.getRotation(rotate), !this._initialized && mesh._data) {
                var struct = JSON.parse(JSON.stringify(mesh._struct)), data = mesh._data.slice();
                if (worldMatrix) {
                    struct.maxPosition && struct.minPosition && (Vec3.add(boundingBox.center, struct.maxPosition, struct.minPosition), 
                    Vec3.multiplyScalar(boundingBox.center, boundingBox.center, .5), Vec3.subtract(boundingBox.halfExtents, struct.maxPosition, struct.minPosition), 
                    Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, .5), aabb.transform(boundingBox, boundingBox, worldMatrix), 
                    Vec3.add(struct.maxPosition, boundingBox.center, boundingBox.halfExtents), Vec3.subtract(struct.minPosition, boundingBox.center, boundingBox.halfExtents));
                    for (var i = 0; i < struct.vertexBundles.length; i++) for (var vtxBdl = struct.vertexBundles[i], j = 0; j < vtxBdl.attributes.length; j++) if (vtxBdl.attributes[j].name === exports.GFXAttributeName.ATTR_POSITION || vtxBdl.attributes[j].name === exports.GFXAttributeName.ATTR_NORMAL) {
                        var format = vtxBdl.attributes[j].format, inputView = new DataView(data.buffer, vtxBdl.view.offset + getOffset(vtxBdl.attributes, j)), reader = getReader(inputView, format), writer = getWriter(inputView, format);
                        if (!reader || !writer) continue;
                        for (var vertexCount = vtxBdl.view.count, vertexStride = vtxBdl.view.stride, attrComponentByteLength = getComponentByteLength(format), vtxIdx = 0; vtxIdx < vertexCount; vtxIdx++) {
                            var xOffset = vtxIdx * vertexStride, yOffset = xOffset + attrComponentByteLength, zOffset = yOffset + attrComponentByteLength;
                            switch (vec3_temp.set(reader(xOffset), reader(yOffset), reader(zOffset)), vtxBdl.attributes[j].name) {
                              case exports.GFXAttributeName.ATTR_POSITION:
                                vec3_temp.transformMat4(worldMatrix);
                                break;

                              case exports.GFXAttributeName.ATTR_NORMAL:
                                Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                            }
                            writer(xOffset, vec3_temp.x), writer(yOffset, vec3_temp.y), writer(zOffset, vec3_temp.z);
                        }
                    }
                }
                return this.reset({
                    struct: struct,
                    data: data
                }), this.initialize(), !0;
            }
            for (var vb, vbView, srcVBView, dstVBView, dstAttrView, bufferBlob = new BufferBlob, vertCount = 0, vertStride = 0, srcOffset = 0, dstOffset = 0, srcAttrOffset = 0, srcVBOffset = 0, dstVBOffset = 0, attrSize = 0, hasAttr = !1, vertexBundles = new Array(this._struct.vertexBundles.length), _i4 = 0; _i4 < this._struct.vertexBundles.length; ++_i4) {
                var bundle = this._struct.vertexBundles[_i4], dstBundle = mesh._struct.vertexBundles[_i4];
                srcOffset = bundle.view.offset, dstOffset = dstBundle.view.offset, vertStride = bundle.view.stride, 
                vertCount = bundle.view.count + dstBundle.view.count, vb = new ArrayBuffer(vertCount * vertStride), 
                vbView = new Uint8Array(vb), srcOffset += (srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length)).length, 
                dstOffset += (dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length)).length, 
                vbView.set(srcVBView), srcAttrOffset = 0;
                for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(bundle.attributes); !(_step2 = _iterator2()).done; ) {
                    var attr = _step2.value;
                    dstVBOffset = 0, hasAttr = !1;
                    for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(dstBundle.attributes); !(_step3 = _iterator3()).done; ) {
                        var dstAttr = _step3.value;
                        if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                            hasAttr = !0;
                            break;
                        }
                        dstVBOffset += GFXFormatInfos[dstAttr.format].size;
                    }
                    if (hasAttr) {
                        attrSize = GFXFormatInfos[attr.format].size, srcVBOffset = bundle.view.length + srcAttrOffset;
                        for (var v = 0; v < dstBundle.view.count; ++v) {
                            if (dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize), vbView.set(dstAttrView, srcVBOffset), 
                            (attr.name === exports.GFXAttributeName.ATTR_POSITION || attr.name === exports.GFXAttributeName.ATTR_NORMAL) && worldMatrix) {
                                var f32_temp = new Float32Array(vbView.buffer, srcVBOffset, 3);
                                switch (vec3_temp.set(f32_temp[0], f32_temp[1], f32_temp[2]), attr.name) {
                                  case exports.GFXAttributeName.ATTR_POSITION:
                                    vec3_temp.transformMat4(worldMatrix);
                                    break;

                                  case exports.GFXAttributeName.ATTR_NORMAL:
                                    Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                                }
                                f32_temp[0] = vec3_temp.x, f32_temp[1] = vec3_temp.y, f32_temp[2] = vec3_temp.z;
                            }
                            srcVBOffset += bundle.view.stride, dstVBOffset += dstBundle.view.stride;
                        }
                    }
                    srcAttrOffset += GFXFormatInfos[attr.format].size;
                }
                vertexBundles[_i4] = {
                    attributes: bundle.attributes,
                    view: {
                        offset: bufferBlob.getLength(),
                        length: vb.byteLength,
                        count: vertCount,
                        stride: vertStride
                    }
                }, bufferBlob.addBuffer(vb);
            }
            for (var ibView, srcIBView, dstIBView, idxCount = 0, idxStride = 2, vertBatchCount = 0, primitives = new Array(this._struct.primitives.length), _i5 = 0; _i5 < this._struct.primitives.length; ++_i5) {
                var prim = this._struct.primitives[_i5], dstPrim = mesh._struct.primitives[_i5];
                primitives[_i5] = {
                    primitiveMode: prim.primitiveMode,
                    vertexBundelIndices: prim.vertexBundelIndices
                };
                for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(prim.vertexBundelIndices); !(_step4 = _iterator4()).done; ) {
                    var bundleIdx = _step4.value;
                    vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                }
                if (prim.indexView && dstPrim.indexView) {
                    idxCount = prim.indexView.count, idxCount += dstPrim.indexView.count, srcOffset = prim.indexView.offset, 
                    dstOffset = dstPrim.indexView.offset, idxStride = idxCount < 256 ? 1 : idxCount < 65536 ? 2 : 4;
                    var ib = new ArrayBuffer(idxCount * idxStride);
                    if (ibView = 2 === idxStride ? new Uint16Array(ib) : 1 === idxStride ? new Uint8Array(ib) : new Uint32Array(ib), 
                    srcIBView = 2 === prim.indexView.stride ? new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count) : 1 === prim.indexView.stride ? new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count) : new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count), 
                    idxStride === prim.indexView.stride) ibView.set(srcIBView); else for (var n = 0; n < prim.indexView.count; ++n) ibView[n] = srcIBView[n];
                    srcOffset += prim.indexView.length, dstIBView = 2 === dstPrim.indexView.stride ? new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : 1 === dstPrim.indexView.stride ? new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count) : new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    for (var _n = 0; _n < dstPrim.indexView.count; ++_n) ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
                    dstOffset += dstPrim.indexView.length, primitives[_i5].indexView = {
                        offset: bufferBlob.getLength(),
                        length: ib.byteLength,
                        count: idxCount,
                        stride: idxStride
                    }, bufferBlob.setNextAlignment(idxStride), bufferBlob.addBuffer(ib);
                }
            }
            var meshStruct = {
                vertexBundles: vertexBundles,
                primitives: primitives,
                minPosition: this._struct.minPosition,
                maxPosition: this._struct.maxPosition
            };
            return meshStruct.minPosition && mesh._struct.minPosition && meshStruct.maxPosition && mesh._struct.maxPosition && (worldMatrix ? (Vec3.add(boundingBox.center, mesh._struct.maxPosition, mesh._struct.minPosition), 
            Vec3.multiplyScalar(boundingBox.center, boundingBox.center, .5), Vec3.subtract(boundingBox.halfExtents, mesh._struct.maxPosition, mesh._struct.minPosition), 
            Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, .5), aabb.transform(boundingBox, boundingBox, worldMatrix), 
            Vec3.add(vec3_temp, boundingBox.center, boundingBox.halfExtents), Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, vec3_temp), 
            Vec3.subtract(vec3_temp, boundingBox.center, boundingBox.halfExtents), Vec3.min(meshStruct.minPosition, meshStruct.minPosition, vec3_temp)) : (Vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition), 
            Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition))), 
            this.reset({
                struct: meshStruct,
                data: new Uint8Array(bufferBlob.getCombined())
            }), this.initialize(), !0;
        }
    }, {
        key: "validateMergingMesh",
        value: function validateMergingMesh(mesh) {
            if (!this._data && mesh._data) return !0;
            if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) return !1;
            for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
                var bundle = this._struct.vertexBundles[i], dstBundle = mesh._struct.vertexBundles[i];
                if (bundle.attributes.length !== dstBundle.attributes.length) return !1;
                for (var j = 0; j < bundle.attributes.length; ++j) if (bundle.attributes[j].format !== dstBundle.attributes[j].format) return !1;
            }
            if (this._struct.primitives.length !== mesh._struct.primitives.length) return !1;
            for (var _i6 = 0; _i6 < this._struct.primitives.length; ++_i6) {
                var prim = this._struct.primitives[_i6], dstPrim = mesh._struct.primitives[_i6];
                if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) return !1;
                for (var _j = 0; _j < prim.vertexBundelIndices.length; ++_j) if (prim.vertexBundelIndices[_j] !== dstPrim.vertexBundelIndices[_j]) return !1;
                if (prim.primitiveMode !== dstPrim.primitiveMode) return !1;
                if (prim.indexView) {
                    if (void 0 === dstPrim.indexView) return !1;
                } else if (dstPrim.indexView) return !1;
            }
            return !0;
        }
    }, {
        key: "readAttribute",
        value: function readAttribute(primitiveIndex, attributeName) {
            var _this4 = this, result = null;
            return this._accessAttribute(primitiveIndex, attributeName, (function(vertexBundle, iAttribute) {
                var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this4._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), formatInfo = GFXFormatInfos[format], storageConstructor = getTypedArrayConstructor(GFXFormatInfos[format]), reader = getReader(inputView, format);
                if (storageConstructor && reader) {
                    for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, storage = new storageConstructor(vertexCount * componentCount), inputStride = vertexBundle.view.stride, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                    result = storage;
                }
            })), result;
        }
    }, {
        key: "copyAttribute",
        value: function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
            var _this5 = this, written = !1;
            return this._accessAttribute(primitiveIndex, attributeName, (function(vertexBundle, iAttribute) {
                var format = vertexBundle.attributes[iAttribute].format, inputView = new DataView(_this5._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute)), outputView = new DataView(buffer, offset), formatInfo = GFXFormatInfos[format], reader = getReader(inputView, format), writer = getWriter(outputView, format);
                if (reader && writer) {
                    for (var vertexCount = vertexBundle.view.count, componentCount = formatInfo.count, inputStride = vertexBundle.view.stride, inputComponentByteLength = getComponentByteLength(format), outputStride = stride, outputComponentByteLength = inputComponentByteLength, iVertex = 0; iVertex < vertexCount; ++iVertex) for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                        writer(outputStride * iVertex + outputComponentByteLength * iComponent, reader(inputStride * iVertex + inputComponentByteLength * iComponent));
                    }
                    written = !0;
                }
            })), written;
        }
    }, {
        key: "readIndices",
        value: function readIndices(primitiveIndex) {
            if (!this._data || primitiveIndex >= this._struct.primitives.length) return null;
            var primitive = this._struct.primitives[primitiveIndex];
            if (!primitive.indexView) return null;
            var stride = primitive.indexView.stride;
            return new (1 === stride ? Uint8Array : 2 === stride ? Uint16Array : Uint32Array)(this._data.buffer, primitive.indexView.offset, primitive.indexView.count);
        }
    }, {
        key: "copyIndices",
        value: function copyIndices(primitiveIndex, outputArray) {
            if (!this._data || primitiveIndex >= this._struct.primitives.length) return !1;
            var primitive = this._struct.primitives[primitiveIndex];
            if (!primitive.indexView) return !1;
            for (var indexCount = primitive.indexView.count, indexFormat = 1 === primitive.indexView.stride ? exports.GFXFormat.R8UI : 2 === primitive.indexView.stride ? exports.GFXFormat.R16UI : exports.GFXFormat.R32UI, reader = getReader(new DataView(this._data.buffer), indexFormat), i = 0; i < indexCount; ++i) outputArray[i] = reader(primitive.indexView.offset + GFXFormatInfos[indexFormat].size * i);
            return !0;
        }
    }, {
        key: "_accessAttribute",
        value: function _accessAttribute(primitiveIndex, attributeName, accessor) {
            if (this._data && !(primitiveIndex >= this._struct.primitives.length)) for (var _step5, _iterator5 = _createForOfIteratorHelperLoose(this._struct.primitives[primitiveIndex].vertexBundelIndices); !(_step5 = _iterator5()).done; ) {
                var vertexBundleIndex = _step5.value, _vertexBundle3 = this._struct.vertexBundles[vertexBundleIndex], _iAttribute = _vertexBundle3.attributes.findIndex((function(a) {
                    return a.name === attributeName;
                }));
                if (!(_iAttribute < 0)) {
                    accessor(_vertexBundle3, _iAttribute);
                    break;
                }
            }
        }
    }, {
        key: "_createVertexBuffers",
        value: function _createVertexBuffers(gfxDevice, data) {
            var _this6 = this;
            return this._struct.vertexBundles.map((function(vertexBundle) {
                var vertexBuffer = gfxDevice.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: vertexBundle.view.length,
                    stride: vertexBundle.view.stride
                }), view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);
                return _this6.loaded ? vertexBuffer.update(view) : _this6.once("load", (function() {
                    vertexBuffer.update(view);
                })), vertexBuffer;
            }));
        }
    }, {
        key: "renderingSubMeshes",
        get: function get() {
            return this.initialize(), this._renderingSubMeshes;
        }
    } ]), Mesh;
}()).prototype, "_struct", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return {
            vertexBundles: [],
            primitives: []
        };
    }
}), _descriptor2$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_dataLength", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor3$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_hash", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$7 = _class2$5)) || _class$7;

function getOffset(attributes, attributeIndex) {
    for (var result = 0, i = 0; i < attributeIndex; ++i) {
        var attribute = attributes[i];
        result += GFXFormatInfos[attribute.format].size;
    }
    return result;
}

cc.Mesh = Mesh;

var _dec$8, _dec2$3, _class$8, _class2$6, _descriptor$5, _class3$3, _temp$8, isLittleEndian = sys.isLittleEndian;

function getComponentByteLength(format) {
    var info = GFXFormatInfos[format];
    return info.size / info.count;
}

function getReader(dataView, format) {
    var info = GFXFormatInfos[format], stride = info.size / info.count;
    switch (info.type) {
      case exports.GFXFormatType.UNORM:
        switch (stride) {
          case 1:
            return function(offset) {
                return dataView.getUint8(offset);
            };

          case 2:
            return function(offset) {
                return dataView.getUint16(offset, isLittleEndian);
            };

          case 4:
            return function(offset) {
                return dataView.getUint32(offset, isLittleEndian);
            };
        }
        break;

      case exports.GFXFormatType.SNORM:
      case exports.GFXFormatType.INT:
        switch (stride) {
          case 1:
            return function(offset) {
                return dataView.getInt8(offset);
            };

          case 2:
            return function(offset) {
                return dataView.getInt16(offset, isLittleEndian);
            };

          case 4:
            return function(offset) {
                return dataView.getInt32(offset, isLittleEndian);
            };
        }
        break;

      case exports.GFXFormatType.UINT:
        switch (stride) {
          case 1:
            return function(offset) {
                return dataView.getUint8(offset);
            };

          case 2:
            return function(offset) {
                return dataView.getUint16(offset, isLittleEndian);
            };

          case 4:
            return function(offset) {
                return dataView.getUint32(offset, isLittleEndian);
            };
        }
        break;

      case exports.GFXFormatType.FLOAT:
        return function(offset) {
            return dataView.getFloat32(offset, isLittleEndian);
        };
    }
    return null;
}

function getWriter(dataView, format) {
    var info = GFXFormatInfos[format], stride = info.size / info.count;
    switch (info.type) {
      case exports.GFXFormatType.UNORM:
        switch (stride) {
          case 1:
            return function(offset, value) {
                return dataView.setUint8(offset, value);
            };

          case 2:
            return function(offset, value) {
                return dataView.setUint16(offset, value, isLittleEndian);
            };

          case 4:
            return function(offset, value) {
                return dataView.setUint32(offset, value, isLittleEndian);
            };
        }
        break;

      case exports.GFXFormatType.SNORM:
      case exports.GFXFormatType.INT:
        switch (stride) {
          case 1:
            return function(offset, value) {
                return dataView.setInt8(offset, value);
            };

          case 2:
            return function(offset, value) {
                return dataView.setInt16(offset, value, isLittleEndian);
            };

          case 4:
            return function(offset, value) {
                return dataView.setInt32(offset, value, isLittleEndian);
            };
        }
        break;

      case exports.GFXFormatType.UINT:
        switch (stride) {
          case 1:
            return function(offset, value) {
                return dataView.setUint8(offset, value);
            };

          case 2:
            return function(offset, value) {
                return dataView.setUint16(offset, value, isLittleEndian);
            };

          case 4:
            return function(offset, value) {
                return dataView.setUint32(offset, value, isLittleEndian);
            };
        }
        break;

      case exports.GFXFormatType.FLOAT:
        return function(offset, value) {
            return dataView.setFloat32(offset, value, isLittleEndian);
        };
    }
    return null;
}

ccenum(DepthStencilFormat);

var _class$9, RenderTexture = (_dec$8 = ccclass("cc.RenderTexture"), _dec2$3 = property({
    type: DepthStencilFormat
}), _dec$8((_temp$8 = _class3$3 = function(_TextureBase) {
    function RenderTexture() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, RenderTexture);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderTexture)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._window = null, 
        _initializerDefineProperty(_this, "_depthStencilFormat", _descriptor$5, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(RenderTexture, TextureBase), _createClass(RenderTexture, [ {
        key: "getGFXWindow",
        value: function getGFXWindow() {
            return this._window;
        }
    }, {
        key: "getGFXTextureView",
        value: function getGFXTextureView() {
            return this._window ? this._window.colorTexView : null;
        }
    }, {
        key: "getGFXStencilTexture",
        value: function getGFXStencilTexture() {
            return this._window ? this._window.depthStencilTexView : null;
        }
    }, {
        key: "reset",
        value: function reset(info) {
            info && (this._width = info.width, this._height = info.height, info.colorFormat && (this._format = info.colorFormat), 
            info.depthStencilFormat && (this._depthStencilFormat = info.depthStencilFormat), 
            this._tryResetWindow(), this.emit("resize", this));
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._window && (cc.director.root.destroyWindow(this._window), this._window = null), 
            _get(_getPrototypeOf(RenderTexture.prototype), "destroy", this).call(this);
        }
    }, {
        key: "onLoaded",
        value: function onLoaded() {
            this._tryResetWindow();
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            return {
                base: _get(_getPrototypeOf(RenderTexture.prototype), "_serialize", this).call(this),
                name: this._name,
                width: this._width,
                height: this._height,
                colorFormat: this._format,
                depthStencilFormat: this._depthStencilFormat
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializeData, handle) {
            _get(_getPrototypeOf(RenderTexture.prototype), "_deserialize", this).call(this, serializeData.base, handle);
            var data = serializeData;
            this.name = data.name || "", this._width = data.width, this._height = data.height, 
            this._format = data.colorFormat, this._depthStencilFormat = data.depthStencilFormat;
        }
    }, {
        key: "_tryResetWindow",
        value: function _tryResetWindow() {
            var device = this._getGFXDevice();
            device && (this._window && this._window.destroy(), this._createWindow(device));
        }
    }, {
        key: "_createWindow",
        value: function _createWindow(device) {
            var config = {
                title: this.name,
                isOffscreen: !0,
                width: this._width,
                height: this._height,
                colorFmt: this._format,
                depthStencilFmt: this._depthStencilFormat
            };
            if (this._window) return this._window.initialize(config), this._window;
            this._window = cc.director.root.createWindow(config), this.loaded = !0, this.emit("load");
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(value) {
            this._width = value, this.reset();
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        },
        set: function set(value) {
            this._height = value, this.reset();
        }
    }, {
        key: "depthStencilFormat",
        get: function get() {
            return this._depthStencilFormat;
        },
        set: function set(value) {
            this._depthStencilFormat = value, this.reset();
        }
    } ]), RenderTexture;
}(), _class3$3.DepthStencilFormat = DepthStencilFormat, _descriptor$5 = _applyDecoratedDescriptor((_class2$6 = _temp$8).prototype, "_depthStencilFormat", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return DepthStencilFormat.NONE;
    }
}), _applyDecoratedDescriptor(_class2$6.prototype, "width", [ property ], Object.getOwnPropertyDescriptor(_class2$6.prototype, "width"), _class2$6.prototype), 
_applyDecoratedDescriptor(_class2$6.prototype, "height", [ property ], Object.getOwnPropertyDescriptor(_class2$6.prototype, "height"), _class2$6.prototype), 
_applyDecoratedDescriptor(_class2$6.prototype, "depthStencilFormat", [ _dec2$3 ], Object.getOwnPropertyDescriptor(_class2$6.prototype, "depthStencilFormat"), _class2$6.prototype), 
_class$8 = _class2$6)) || _class$8);

cc.RenderTexture = RenderTexture;

var _class$a, _class2$7, _descriptor$6, _class3$4, _temp$a, FaceIndex, temp_uvs = [ {
    u: 0,
    v: 0
}, {
    u: 0,
    v: 0
}, {
    u: 0,
    v: 0
}, {
    u: 0,
    v: 0
} ], SpriteFrame = ccclass("cc.SpriteFrame")(_class$9 = function(_Asset) {
    function SpriteFrame() {
        var _this;
        return _classCallCheck(this, SpriteFrame), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpriteFrame).call(this))).vertices = null, 
        _this.uv = [], _this.uvHash = 0, _this.uvSliced = [], _this._rect = new Rect, _this._offset = new Vec2, 
        _this._originalSize = new Size, _this._rotated = !1, _this._capInsets = [ 0, 0, 0, 0 ], 
        _this._atlasUuid = "", _this._texture = void 0, _this._flipUv = !1, _this;
    }
    return _inherits(SpriteFrame, Asset), _createClass(SpriteFrame, [ {
        key: "insetTop",
        get: function get() {
            return this._capInsets[1];
        },
        set: function set(value) {
            this._capInsets[1] !== value && (this._capInsets[1] = value, this._texture && this._calculateSlicedUV());
        }
    }, {
        key: "insetBottom",
        get: function get() {
            return this._capInsets[3];
        },
        set: function set(value) {
            this._capInsets[3] !== value && (this._capInsets[3] = value, this._texture && this._calculateSlicedUV());
        }
    }, {
        key: "insetLeft",
        get: function get() {
            return this._capInsets[0];
        },
        set: function set(value) {
            this._capInsets[0] !== value && (this._capInsets[0] = value, this._texture && this._calculateSlicedUV());
        }
    }, {
        key: "insetRight",
        get: function get() {
            return this._capInsets[2];
        },
        set: function set(value) {
            this._capInsets[2] !== value && (this._capInsets[2] = value, this._texture && this._calculateSlicedUV());
        }
    }, {
        key: "rect",
        get: function get() {
            return this._rect;
        },
        set: function set(value) {
            this._rect.equals(value) || (this._rect.set(value), this._texture && this._calculateUV());
        }
    }, {
        key: "originalSize",
        get: function get() {
            return this._originalSize;
        },
        set: function set(value) {
            this._originalSize.equals(value) || (this._originalSize.set(value), this._texture && this._calculateUV());
        }
    }, {
        key: "offset",
        get: function get() {
            return this._offset;
        },
        set: function set(value) {
            this._offset.set(value);
        }
    }, {
        key: "rotated",
        get: function get() {
            return this._rotated;
        },
        set: function set(rotated) {
            this._rotated !== rotated && (this._rotated = rotated, this._texture && this._calculateUV());
        }
    }, {
        key: "texture",
        get: function get() {
            return this._texture;
        },
        set: function set(value) {
            value ? this.reset({
                texture: value
            }, !0) : console.warn("Error Texture in ".concat(this.name));
        }
    }, {
        key: "atlasUuid",
        get: function get() {
            return this._atlasUuid;
        },
        set: function set(value) {
            this._atlasUuid = value;
        }
    }, {
        key: "width",
        get: function get() {
            return this._texture.width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._texture.height;
        }
    }, {
        key: "_textureSource",
        set: function set(value) {
            value && (this._refreshTexture(value), this._calculateUV());
        }
    } ], [ {
        key: "createWithImage",
        value: function createWithImage(imageSourceOrImageAsset) {
            var img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset), tex = new Texture2D;
            tex.image = img;
            var spf = new SpriteFrame;
            return spf.texture = tex, spf;
        }
    } ]), _createClass(SpriteFrame, [ {
        key: "textureLoaded",
        value: function textureLoaded() {
            return this.texture && this.texture.loaded;
        }
    }, {
        key: "isRotated",
        value: function isRotated() {
            return this._rotated;
        }
    }, {
        key: "setRotated",
        value: function setRotated(rotated) {
            this.rotated = rotated;
        }
    }, {
        key: "getRect",
        value: function getRect(out) {
            return out ? (out.set(this._rect), out) : this._rect.clone();
        }
    }, {
        key: "setRect",
        value: function setRect(rect) {
            this.rect = rect;
        }
    }, {
        key: "getOriginalSize",
        value: function getOriginalSize(out) {
            return out ? (out.set(this._originalSize), out) : this._originalSize.clone();
        }
    }, {
        key: "setOriginalSize",
        value: function setOriginalSize(size) {
            this.originalSize = size;
        }
    }, {
        key: "getOffset",
        value: function getOffset(out) {
            return out ? (out.set(this._offset), out) : this._offset.clone();
        }
    }, {
        key: "setOffset",
        value: function setOffset(offset) {
            this.offset = offset;
        }
    }, {
        key: "getGFXTextureView",
        value: function getGFXTextureView() {
            return this._texture.getGFXTextureView();
        }
    }, {
        key: "getGFXSampler",
        value: function getGFXSampler() {
            return this._texture.getGFXSampler();
        }
    }, {
        key: "reset",
        value: function reset(info) {
            var clearData = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], calUV = !1;
            clearData && (this._originalSize.set(0, 0), this._rect.set(0, 0, 0, 0), this._offset.set(0, 0), 
            this._capInsets = [ 0, 0, 0, 0 ], this._rotated = !1, calUV = !0), info && (info.texture && (this.loaded = !1, 
            this._rect.x = this._rect.y = 0, this._rect.width = info.texture.width, this._rect.height = info.texture.height, 
            this._refreshTexture(info.texture), this.checkRect(this._texture)), info.originalSize && this._originalSize.set(info.originalSize), 
            info.rect && this._rect.set(info.rect), info.offset && this._offset.set(info.offset), 
            void 0 !== info.borderTop && (this._capInsets[1] = info.borderTop), void 0 !== info.borderBottom && (this._capInsets[3] = info.borderBottom), 
            void 0 !== info.borderLeft && (this._capInsets[0] = info.borderLeft), void 0 !== info.borderRight && (this._capInsets[2] = info.borderRight), 
            void 0 !== info.isRotate && (this._rotated = !!info.isRotate), void 0 !== info.isFlipUv && (this._flipUv = !!info.isFlipUv), 
            this._texture instanceof RenderTexture && (this._flipUv = !0), calUV = !0), calUV && this.texture && this._calculateUV();
        }
    }, {
        key: "checkRect",
        value: function checkRect(texture) {
            var rect = this._rect, maxX = rect.x, maxY = rect.y;
            return this._rotated ? (maxX += rect.height, maxY += rect.width) : (maxX += rect.width, 
            maxY += rect.height), maxX > texture.width ? (cc.errorID(3300, this.name + "/" + texture.name, maxX, texture.width), 
            !1) : !(maxY > texture.height) || (cc.errorID(3301, this.name + "/" + texture.name, maxY, texture.height), 
            !1);
        }
    }, {
        key: "onLoaded",
        value: function onLoaded() {
            this.loaded = !0, this.emit("load");
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return _get(_getPrototypeOf(SpriteFrame.prototype), "destroy", this).call(this);
        }
    }, {
        key: "_calculateSlicedUV",
        value: function _calculateSlicedUV() {
            var rect = this._rect, tex = this.texture, atlasWidth = tex.width, atlasHeight = tex.height, leftWidth = this._capInsets[0], rightWidth = this._capInsets[2], centerWidth = rect.width - leftWidth - rightWidth, topHeight = this._capInsets[1], bottomHeight = this._capInsets[3], centerHeight = rect.height - topHeight - bottomHeight, uvSliced = this.uvSliced;
            if (uvSliced.length = 0, this._rotated) {
                temp_uvs[0].u = (rect.x + .5) / atlasWidth, temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth, 
                temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth, temp_uvs[3].u = (rect.x + rect.height - .5) / atlasWidth, 
                temp_uvs[3].v = (rect.y + .5) / atlasHeight, temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight, 
                temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight, temp_uvs[0].v = (rect.y + rect.width - .5) / atlasHeight;
                for (var row = 0; row < 4; ++row) for (var rowD = temp_uvs[row], col = 0; col < 4; ++col) {
                    var colD = temp_uvs[3 - col];
                    uvSliced.push({
                        u: rowD.u,
                        v: colD.v
                    });
                }
            } else {
                temp_uvs[0].u = (rect.x + .5) / atlasWidth, temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth, 
                temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth, temp_uvs[3].u = (rect.x + rect.width - .5) / atlasWidth, 
                temp_uvs[3].v = (rect.y + .5) / atlasHeight, temp_uvs[2].v = (rect.y + topHeight) / atlasHeight, 
                temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight, temp_uvs[0].v = (rect.y + rect.height - .5) / atlasHeight;
                for (var _row = 0; _row < 4; ++_row) for (var _rowD = temp_uvs[_row], _col = 0; _col < 4; ++_col) {
                    var _colD = temp_uvs[_col];
                    uvSliced.push({
                        u: _colD.u,
                        v: _rowD.v
                    });
                }
            }
        }
    }, {
        key: "_calculateUV",
        value: function _calculateUV() {
            var rect = this._rect, uv = this.uv, tex = this.texture, texw = tex.width, texh = tex.height;
            if (this._rotated) {
                var l = 0 === texw ? 0 : (rect.x + .5) / texw, r = 0 === texw ? 0 : (rect.x + rect.height - .5) / texw, t = 0 === texh ? 0 : (rect.y + .5) / texh, b = 0 === texh ? 0 : (rect.y + rect.width - .5) / texh;
                this._flipUv, uv[0] = l, uv[1] = t, uv[2] = l, uv[3] = b, uv[4] = r, uv[5] = t, 
                uv[6] = r, uv[7] = b;
            } else {
                var _l = 0 === texw ? 0 : (rect.x + .5) / texw, _r = 0 === texw ? 0 : (rect.x + rect.width - .5) / texw, _b = 0 === texh ? 0 : (rect.y + rect.height - .5) / texh, _t = 0 === texh ? 0 : (rect.y + .5) / texh;
                this._flipUv ? (uv[0] = _l, uv[1] = _t, uv[2] = _r, uv[3] = _t, uv[4] = _l, uv[5] = _b, 
                uv[6] = _r, uv[7] = _b) : (uv[0] = _l, uv[1] = _b, uv[2] = _r, uv[3] = _b, uv[4] = _l, 
                uv[5] = _t, uv[6] = _r, uv[7] = _t);
            }
            for (var uvHashStr = "", i = 0; i < uv.length; i++) uvHashStr += uv[i];
            this.uvHash = murmurhash2_32_gc(uvHashStr, 666);
            var vertices = this.vertices;
            if (vertices) {
                vertices.nu.length = 0, vertices.nv.length = 0;
                for (var _i = 0; _i < vertices.u.length; _i++) vertices.nu[_i] = vertices.u[_i] / texw, 
                vertices.nv[_i] = vertices.v[_i] / texh;
            }
            this._calculateSlicedUV();
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            var texture, vertices, rect = this._rect, offset = this._offset, originalSize = this._originalSize, uuid = this._uuid;
            return this._texture && (texture = this._texture._uuid), uuid && exporting && (uuid = EditorExtends.UuidUtils.compressUuid(uuid, !0)), 
            texture && exporting && (texture = EditorExtends.UuidUtils.compressUuid(texture, !0)), 
            this.vertices && (vertices = {
                triangles: this.vertices.triangles,
                x: this.vertices.x,
                y: this.vertices.y,
                u: this.vertices.u,
                v: this.vertices.v
            }), {
                name: this._name,
                atlas: exporting ? void 0 : this._atlasUuid,
                rect: rect,
                offset: offset,
                originalSize: originalSize,
                rotated: this._rotated,
                capInsets: this._capInsets,
                vertices: vertices,
                texture: texture
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializeData, handle) {
            var data = serializeData, rect = data.rect;
            rect && (this._rect = new Rect(rect.x, rect.y, rect.width, rect.height));
            var offset = data.offset;
            data.offset && (this._offset = new Vec2(offset.x, offset.y));
            var originalSize = data.originalSize;
            data.originalSize && (this._originalSize = new Size(originalSize.width, originalSize.height)), 
            this._rotated = !!data.rotated, this._name = data.name;
            var capInsets = data.capInsets;
            capInsets && (this._capInsets[0] = capInsets[0], this._capInsets[1] = capInsets[1], 
            this._capInsets[2] = capInsets[2], this._capInsets[3] = capInsets[3]), data.texture && handle.result.push(this, "_textureSource", data.texture), 
            this.vertices = data.vertices, this.vertices && (this.vertices.nu = [], this.vertices.nv = []);
        }
    }, {
        key: "_textureLoaded",
        value: function _textureLoaded() {
            var tex = this._texture, config = {}, isReset = !1;
            0 !== this._rect.width && 0 !== this._rect.height && this.checkRect(tex) || (config.rect = new Rect(0, 0, tex.width, tex.height), 
            isReset = !0), (0 === this._originalSize.width || 0 === this._originalSize.height || isReset) && (config.originalSize = new Size(tex.width, tex.height), 
            isReset = !0), isReset && (this.reset(config), this.onLoaded());
        }
    }, {
        key: "_refreshTexture",
        value: function _refreshTexture(texture) {
            this._texture = texture, texture.loaded ? this._textureLoaded() : texture.once("load", this._textureLoaded, this);
        }
    } ]), SpriteFrame;
}()) || _class$9;

cc.SpriteFrame = SpriteFrame, function(FaceIndex) {
    FaceIndex[FaceIndex.right = 0] = "right", FaceIndex[FaceIndex.left = 1] = "left", 
    FaceIndex[FaceIndex.top = 2] = "top", FaceIndex[FaceIndex.bottom = 3] = "bottom", 
    FaceIndex[FaceIndex.front = 4] = "front", FaceIndex[FaceIndex.back = 5] = "back";
}(FaceIndex || (FaceIndex = {}));

var TextureCube = ccclass("cc.TextureCube")((_temp$a = _class3$4 = function(_SimpleTexture) {
    function TextureCube() {
        var _this;
        return _classCallCheck(this, TextureCube), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this)), "_mipmaps", _descriptor$6, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(TextureCube, SimpleTexture), _createClass(TextureCube, [ {
        key: "mipmaps",
        get: function get() {
            return this._mipmaps;
        },
        set: function set(value) {
            var _this2 = this;
            if (this._mipmaps = value, this._setMipmapLevel(this._mipmaps.length), this._mipmaps.length > 0) {
                var imageAsset = this._mipmaps[0].front;
                this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._mipmaps.length
                }), this._mipmaps.forEach((function(mipmap, level) {
                    _forEachFace(mipmap, (function(face, faceIndex) {
                        _this2._assignImage(face, level, faceIndex);
                    }));
                }));
            } else this.reset({
                width: 0,
                height: 0,
                mipmapLevel: this._mipmaps.length
            });
        }
    }, {
        key: "image",
        get: function get() {
            return 0 === this._mipmaps.length ? null : this._mipmaps[0];
        },
        set: function set(value) {
            this.mipmaps = value ? [ value ] : [];
        }
    } ], [ {
        key: "fromTexture2DArray",
        value: function fromTexture2DArray(textures, out) {
            for (var mipmaps = [], nMipmaps = textures.length / 6, i = 0; i < nMipmaps; i++) {
                var x = 6 * i;
                mipmaps.push({
                    front: textures[x + FaceIndex.front].image,
                    back: textures[x + FaceIndex.back].image,
                    left: textures[x + FaceIndex.left].image,
                    right: textures[x + FaceIndex.right].image,
                    top: textures[x + FaceIndex.top].image,
                    bottom: textures[x + FaceIndex.bottom].image
                });
            }
            return (out = out || new TextureCube).mipmaps = mipmaps, out;
        }
    } ]), _createClass(TextureCube, [ {
        key: "onLoaded",
        value: function onLoaded() {
            this.mipmaps = this._mipmaps, this.loaded = !0, this.emit("load");
        }
    }, {
        key: "reset",
        value: function reset(info) {
            this._width = info.width, this._height = info.height, this._setGFXFormat(info.format), 
            this._setMipmapLevel(info.mipmapLevel || 1), this._tryReset();
        }
    }, {
        key: "updateMipmaps",
        value: function updateMipmaps() {
            var _this3 = this, firstLevel = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, count = arguments.length > 1 ? arguments[1] : void 0;
            if (!(firstLevel >= this._mipmaps.length)) for (var nUpdate = Math.min(void 0 === count ? this._mipmaps.length : count, this._mipmaps.length - firstLevel), _loop = function _loop(i) {
                var level = firstLevel + i;
                _forEachFace(_this3._mipmaps[level], (function(face, faceIndex) {
                    _this3._assignImage(face, level, faceIndex);
                }));
            }, i = 0; i < nUpdate; ++i) _loop(i);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._mipmaps = [], _get(_getPrototypeOf(TextureCube.prototype), "destroy", this).call(this);
        }
    }, {
        key: "releaseTexture",
        value: function releaseTexture() {
            this.mipmaps = [];
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            return {
                base: _get(_getPrototypeOf(TextureCube.prototype), "_serialize", this).call(this),
                mipmaps: this._mipmaps.map((function(mipmap) {
                    return exporting ? {
                        front: EditorExtends.UuidUtils.compressUuid(mipmap.front._uuid, !0),
                        back: EditorExtends.UuidUtils.compressUuid(mipmap.back._uuid, !0),
                        left: EditorExtends.UuidUtils.compressUuid(mipmap.left._uuid, !0),
                        right: EditorExtends.UuidUtils.compressUuid(mipmap.right._uuid, !0),
                        top: EditorExtends.UuidUtils.compressUuid(mipmap.top._uuid, !0),
                        bottom: EditorExtends.UuidUtils.compressUuid(mipmap.bottom._uuid, !0)
                    } : {
                        front: mipmap.front._uuid,
                        back: mipmap.back._uuid,
                        left: mipmap.left._uuid,
                        right: mipmap.right._uuid,
                        top: mipmap.top._uuid,
                        bottom: mipmap.bottom._uuid
                    };
                }))
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializedData, handle) {
            var data = serializedData;
            _get(_getPrototypeOf(TextureCube.prototype), "_deserialize", this).call(this, data.base, handle), 
            this._mipmaps = new Array(data.mipmaps.length);
            for (var i = 0; i < data.mipmaps.length; ++i) {
                this._mipmaps[i] = {
                    front: new ImageAsset,
                    back: new ImageAsset,
                    left: new ImageAsset,
                    right: new ImageAsset,
                    top: new ImageAsset,
                    bottom: new ImageAsset
                };
                var mipmap = data.mipmaps[i];
                handle.result.push(this._mipmaps[i], "front", mipmap.front), handle.result.push(this._mipmaps[i], "back", mipmap.back), 
                handle.result.push(this._mipmaps[i], "left", mipmap.left), handle.result.push(this._mipmaps[i], "right", mipmap.right), 
                handle.result.push(this._mipmaps[i], "top", mipmap.top), handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom);
            }
        }
    }, {
        key: "_getGfxTextureCreateInfo",
        value: function _getGfxTextureCreateInfo(presumed) {
            var result = Object.assign({
                type: exports.GFXTextureType.TEX2D,
                width: this._width,
                height: this._height,
                arrayLayer: 6
            }, presumed);
            return result.flags = (result.flags || 0) | exports.GFXTextureFlagBit.CUBEMAP, result;
        }
    }, {
        key: "_getGfxTextureViewCreateInfo",
        value: function _getGfxTextureViewCreateInfo(presumed) {
            return Object.assign({
                type: exports.GFXTextureViewType.CUBE,
                layerCount: 6
            }, presumed);
        }
    } ]), TextureCube;
}(), _class3$4.FaceIndex = FaceIndex, _descriptor$6 = _applyDecoratedDescriptor((_class2$7 = _temp$a).prototype, "_mipmaps", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$a = _class2$7)) || _class$a;

function _forEachFace(mipmap, callback) {
    callback(mipmap.front, FaceIndex.front), callback(mipmap.back, FaceIndex.back), 
    callback(mipmap.left, FaceIndex.left), callback(mipmap.right, FaceIndex.right), 
    callback(mipmap.top, FaceIndex.top), callback(mipmap.bottom, FaceIndex.bottom);
}

cc.TextureCube = TextureCube;

var _type2reader, _type2writer, effects = [ {
    name: "builtin-billboard",
    _uuid: "711ebe11-f673-4cd9-9a83-63c60ba54c5b",
    techniques: [ {
        name: "add",
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 1,
                    blendSrcAlpha: 2,
                    blendDstAlpha: 1
                } ]
            },
            program: "builtin-billboard|vert:vs_main|tinted-fs:add",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                mainTiling_Offset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                tintColor: {
                    value: [ .5, .5, .5, .5 ],
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-billboard|vert:vs_main|tinted-fs:add",
        hash: 3052980566,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nuniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_HDR",
            type: "boolean"
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "mainTiling_Offset",
                type: 16,
                count: 1
            }, {
                name: "frameTile_velLenScale",
                type: 16,
                count: 1
            }, {
                name: "scale",
                type: 16,
                count: 1
            } ]
        }, {
            name: "builtin",
            defines: [],
            binding: 1,
            members: [ {
                name: "cc_size_rotation",
                type: 16,
                count: 1
            } ]
        }, {
            name: "FragConstants",
            defines: [],
            binding: 2,
            members: [ {
                name: "tintColor",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 31
        } ],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_texCoord",
            type: 14,
            count: 1,
            defines: [],
            format: 21,
            location: 1
        }, {
            name: "a_color",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 2
        } ]
    } ]
}, {
    name: "builtin-particle-gpu",
    _uuid: "971bdb23-3ff6-43eb-b422-1c30165a3663",
    techniques: [ {
        name: "add",
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 1,
                    blendSrcAlpha: 2,
                    blendDstAlpha: 1
                } ]
            },
            program: "builtin-particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                mainTiling_Offset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                tintColor: {
                    value: [ .5, .5, .5, .5 ],
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
        hash: 4003605751,
        glsl3: {
            vert: "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform SampleConstants {\n  vec4 u_sampleInfo;\n};\nuniform TickConstants {\n  vec4 u_worldRot;\n  vec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord;\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D color_over_time_tex0;\n  uniform ColorConstant {\n    int u_color_mode;\n  };\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D rotation_over_time_tex0;\n  uniform RotationConstant {\n    int u_rotation_mode;\n  };\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D size_over_time_tex0;\n  uniform SizeConstant {\n    int u_size_mode;\n  };\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D force_over_time_tex0;\n  uniform ForceConstant {\n    int u_force_mode;\n    int u_force_space;\n  };\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D velocity_over_time_tex0;\n  uniform VelocityConstant {\n    int u_velocity_mode;\n    int u_velocity_space;\n  };\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  uniform sampler2D texture_animation_tex0;\n  uniform AnimationConstant {\n    vec4 u_anim_info;\n  };\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord;\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture2D(tex, coord);\n    vec4 b = texture2D(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture2D(tex, coord);\n    vec4 b = texture2D(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D color_over_time_tex0;\n  uniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D rotation_over_time_tex0;\n  uniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D size_over_time_tex0;\n  uniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D force_over_time_tex0;\n  uniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D velocity_over_time_tex0;\n  uniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  uniform sampler2D texture_animation_tex0;\n  uniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture2D(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_RENDER_MODE",
            type: "number",
            range: [ 0, 4 ]
        }, {
            name: "COLOR_OVER_TIME_MODULE_ENABLE",
            type: "boolean"
        }, {
            name: "ROTATION_OVER_TIME_MODULE_ENABLE",
            type: "boolean"
        }, {
            name: "SIZE_OVER_TIME_MODULE_ENABLE",
            type: "boolean"
        }, {
            name: "FORCE_OVER_TIME_MODULE_ENABLE",
            type: "boolean"
        }, {
            name: "VELOCITY_OVER_TIME_MODULE_ENABLE",
            type: "boolean"
        }, {
            name: "TEXTURE_ANIMATION_MODULE_ENABLE",
            type: "boolean"
        }, {
            name: "CC_USE_WORLD_SPACE",
            type: "boolean"
        }, {
            name: "CC_USE_HDR",
            type: "boolean"
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "mainTiling_Offset",
                type: 16,
                count: 1
            }, {
                name: "frameTile_velLenScale",
                type: 16,
                count: 1
            }, {
                name: "scale",
                type: 16,
                count: 1
            } ]
        }, {
            name: "SampleConstants",
            defines: [],
            binding: 1,
            members: [ {
                name: "u_sampleInfo",
                type: 16,
                count: 1
            } ]
        }, {
            name: "TickConstants",
            defines: [],
            binding: 2,
            members: [ {
                name: "u_worldRot",
                type: 16,
                count: 1
            }, {
                name: "u_timeDelta",
                type: 16,
                count: 1
            } ]
        }, {
            name: "ColorConstant",
            defines: [ "COLOR_OVER_TIME_MODULE_ENABLE" ],
            binding: 3,
            members: [ {
                name: "u_color_mode",
                type: 5,
                count: 1
            } ]
        }, {
            name: "RotationConstant",
            defines: [ "ROTATION_OVER_TIME_MODULE_ENABLE" ],
            binding: 4,
            members: [ {
                name: "u_rotation_mode",
                type: 5,
                count: 1
            } ]
        }, {
            name: "SizeConstant",
            defines: [ "SIZE_OVER_TIME_MODULE_ENABLE" ],
            binding: 5,
            members: [ {
                name: "u_size_mode",
                type: 5,
                count: 1
            } ]
        }, {
            name: "ForceConstant",
            defines: [ "FORCE_OVER_TIME_MODULE_ENABLE" ],
            binding: 6,
            members: [ {
                name: "u_force_mode",
                type: 5,
                count: 1
            }, {
                name: "u_force_space",
                type: 5,
                count: 1
            } ]
        }, {
            name: "VelocityConstant",
            defines: [ "VELOCITY_OVER_TIME_MODULE_ENABLE" ],
            binding: 7,
            members: [ {
                name: "u_velocity_mode",
                type: 5,
                count: 1
            }, {
                name: "u_velocity_space",
                type: 5,
                count: 1
            } ]
        }, {
            name: "AnimationConstant",
            defines: [ "TEXTURE_ANIMATION_MODULE_ENABLE" ],
            binding: 8,
            members: [ {
                name: "u_anim_info",
                type: 16,
                count: 1
            } ]
        }, {
            name: "FragConstants",
            defines: [],
            binding: 9,
            members: [ {
                name: "tintColor",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "color_over_time_tex0",
            type: 28,
            count: 1,
            defines: [ "COLOR_OVER_TIME_MODULE_ENABLE" ],
            binding: 31
        }, {
            name: "rotation_over_time_tex0",
            type: 28,
            count: 1,
            defines: [ "ROTATION_OVER_TIME_MODULE_ENABLE" ],
            binding: 32
        }, {
            name: "size_over_time_tex0",
            type: 28,
            count: 1,
            defines: [ "SIZE_OVER_TIME_MODULE_ENABLE" ],
            binding: 33
        }, {
            name: "force_over_time_tex0",
            type: 28,
            count: 1,
            defines: [ "FORCE_OVER_TIME_MODULE_ENABLE" ],
            binding: 34
        }, {
            name: "velocity_over_time_tex0",
            type: 28,
            count: 1,
            defines: [ "VELOCITY_OVER_TIME_MODULE_ENABLE" ],
            binding: 35
        }, {
            name: "texture_animation_tex0",
            type: 28,
            count: 1,
            defines: [ "TEXTURE_ANIMATION_MODULE_ENABLE" ],
            binding: 36
        }, {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 37
        } ],
        attributes: [ {
            name: "a_position_starttime",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 0
        }, {
            name: "a_size_uv",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 1
        }, {
            name: "a_rotation_uv",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 2
        }, {
            name: "a_color",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 3
        }, {
            name: "a_dir_life",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 4
        }, {
            name: "a_rndSeed",
            type: 13,
            count: 1,
            defines: [],
            format: 11,
            location: 5
        }, {
            name: "a_texCoord",
            type: 15,
            count: 1,
            defines: [ "CC_RENDER_MODE" ],
            format: 32,
            location: 6
        }, {
            name: "a_texCoord3",
            type: 15,
            count: 1,
            defines: [ "CC_RENDER_MODE" ],
            format: 32,
            location: 7
        }, {
            name: "a_normal",
            type: 15,
            count: 1,
            defines: [ "CC_RENDER_MODE" ],
            format: 32,
            location: 8
        }, {
            name: "a_color1",
            type: 16,
            count: 1,
            defines: [ "CC_RENDER_MODE" ],
            format: 43,
            location: 9
        } ]
    } ]
}, {
    name: "builtin-particle-trail",
    _uuid: "17debcc3-0a6b-4b8a-b00b-dc58b885581e",
    techniques: [ {
        name: "add",
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 1,
                    blendSrcAlpha: 2,
                    blendDstAlpha: 1
                } ]
            },
            program: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                mainTiling_Offset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                frameTile_velLenScale: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                tintColor: {
                    value: [ .5, .5, .5, .5 ],
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
        hash: 535523547,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout vec2 uv;\nout vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
            frag: "\n  precision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  in vec2 uv;\n  in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    in vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
            frag: "\n  precision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  varying vec2 uv;\n  varying vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform vec4 tintColor;\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nvoid main() { gl_FragColor = add(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_RENDER_MODE",
            type: "number",
            range: [ 0, 4 ]
        }, {
            name: "CC_DRAW_WIRE_FRAME",
            type: "boolean"
        }, {
            name: "CC_USE_WORLD_SPACE",
            type: "boolean"
        }, {
            name: "CC_USE_HDR",
            type: "boolean"
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "mainTiling_Offset",
                type: 16,
                count: 1
            }, {
                name: "frameTile_velLenScale",
                type: 16,
                count: 1
            }, {
                name: "scale",
                type: 16,
                count: 1
            } ]
        }, {
            name: "FragConstants",
            defines: [],
            binding: 1,
            members: [ {
                name: "tintColor",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 31
        } ],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_texCoord",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 1
        }, {
            name: "a_texCoord1",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 2
        }, {
            name: "a_texCoord2",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 3
        }, {
            name: "a_color",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 4
        } ]
    } ]
}, {
    name: "builtin-particle",
    _uuid: "d1346436-ac96-4271-b863-1f4fdead95b0",
    techniques: [ {
        name: "add",
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 1,
                    blendSrcAlpha: 2,
                    blendDstAlpha: 1
                } ]
            },
            program: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                mainTiling_Offset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                tintColor: {
                    value: [ .5, .5, .5, .5 ],
                    type: 16
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
        hash: 2171161221,
        glsl3: {
            vert: "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
        },
        glsl1: {
            vert: "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_RENDER_MODE",
            type: "number",
            range: [ 0, 4 ]
        }, {
            name: "CC_USE_WORLD_SPACE",
            type: "boolean"
        }, {
            name: "CC_USE_HDR",
            type: "boolean"
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "mainTiling_Offset",
                type: 16,
                count: 1
            }, {
                name: "frameTile_velLenScale",
                type: 16,
                count: 1
            }, {
                name: "scale",
                type: 16,
                count: 1
            } ]
        }, {
            name: "FragConstants",
            defines: [],
            binding: 1,
            members: [ {
                name: "tintColor",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 31
        } ],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_texCoord",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 1
        }, {
            name: "a_texCoord1",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 2
        }, {
            name: "a_texCoord2",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 3
        }, {
            name: "a_color",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 4
        }, {
            name: "a_color1",
            type: 15,
            count: 1,
            defines: [ "CC_RENDER_MODE" ],
            format: 32,
            location: 5
        }, {
            name: "a_texCoord3",
            type: 15,
            count: 1,
            defines: [ "CC_RENDER_MODE" ],
            format: 32,
            location: 6
        }, {
            name: "a_normal",
            type: 15,
            count: 1,
            defines: [ "CC_RENDER_MODE" ],
            format: 32,
            location: 7
        } ]
    } ]
}, {
    name: "builtin-sprite",
    _uuid: "60f7195c-ec2a-45eb-ba94-8955f60e81d0",
    techniques: [ {
        passes: [ {
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 4,
                    blendDstAlpha: 4
                } ]
            },
            rasterizerState: {
                cullMode: 0
            },
            program: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
            priority: 244,
            depthStencilState: {
                depthTest: !1,
                depthWrite: !1
            },
            properties: {
                mainTexture: {
                    value: "white",
                    type: 28
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
        hash: 447598955,
        glsl3: {
            vert: "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_LOCAL\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nin vec3 a_position;\nin vec4 a_color;\nout vec4 color;\nin vec2 a_texCoord;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision highp float;\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
        },
        glsl1: {
            vert: "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 color;\nattribute vec2 a_texCoord;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision highp float;\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: [ "USE_LOCAL" ]
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "USE_LOCAL",
            type: "boolean"
        }, {
            name: "USE_TEXTURE",
            type: "boolean"
        }, {
            name: "IS_GRAY",
            type: "boolean"
        } ],
        blocks: [],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [ "USE_TEXTURE" ],
            binding: 31
        } ],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_color",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 1
        }, {
            name: "a_texCoord",
            type: 14,
            count: 1,
            defines: [],
            format: 21,
            location: 2
        } ]
    } ]
}, {
    name: "builtin-standard",
    _uuid: "1baf0fc9-befa-459c-8bdd-af1a450a0319",
    techniques: [ {
        name: "opaque",
        passes: [ {
            program: "builtin-standard|standard-vs:vert|standard-fs:frag",
            properties: {
                tilingOffset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                mainColor: {
                    value: [ 1, 1, 1, 1 ],
                    type: 16,
                    handleInfo: [ "albedo", 0, 16 ]
                },
                albedoScale: {
                    value: [ 1, 1, 1 ],
                    type: 15,
                    handleInfo: [ "albedoScaleAndCutoff", 0, 15 ]
                },
                alphaThreshold: {
                    value: [ .5 ],
                    type: 13,
                    handleInfo: [ "albedoScaleAndCutoff", 3, 13 ]
                },
                occlusion: {
                    value: [ 1 ],
                    type: 13,
                    handleInfo: [ "pbrParams", 0, 13 ]
                },
                roughness: {
                    value: [ .8 ],
                    type: 13,
                    handleInfo: [ "pbrParams", 1, 13 ]
                },
                metallic: {
                    value: [ .6 ],
                    type: 13,
                    handleInfo: [ "pbrParams", 2, 13 ]
                },
                normalStrenth: {
                    value: [ 1 ],
                    type: 13,
                    handleInfo: [ "pbrParams", 3, 13 ]
                },
                emissive: {
                    value: [ 0, 0, 0, 1 ],
                    type: 16
                },
                emissiveScale: {
                    value: [ 1, 1, 1 ],
                    type: 15,
                    handleInfo: [ "emissiveScaleParam", 0, 15 ]
                },
                mainTexture: {
                    value: "grey",
                    type: 28,
                    handleInfo: [ "albedoMap", 0, 28 ]
                },
                normalMap: {
                    value: "normal",
                    type: 28
                },
                pbrMap: {
                    value: "grey",
                    type: 28
                },
                metallicRoughnessMap: {
                    value: "grey",
                    type: 28
                },
                occlusionMap: {
                    value: "white",
                    type: 28
                },
                emissiveMap: {
                    value: "grey",
                    type: 28
                },
                albedo: {
                    type: 16,
                    value: [ 1, 1, 1, 1 ]
                },
                albedoScaleAndCutoff: {
                    type: 16,
                    value: [ 1, 1, 1, .5 ]
                },
                pbrParams: {
                    type: 16,
                    value: [ 1, .8, .6, 1 ]
                },
                emissiveScaleParam: {
                    type: 16,
                    value: [ 1, 1, 1, 0 ]
                },
                albedoMap: {
                    type: 28,
                    value: "grey"
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-standard|standard-vs:vert|standard-fs:frag",
        hash: 120153765,
        glsl3: {
            vert: "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform sampler2D cc_jointTexture;\n  #else\n  uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\n#if USE_VERTEX_COLOR\n  in vec3 a_color;\n  out vec3 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nin vec2 a_texCoord;\nout vec2 v_uv;\nin vec2 a_texCoord1;\nout vec2 v_uv1;\n#if USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING\n  out vec2 v_luv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  #if USE_LIGHTMAP && HAS_SECOND_UV && !USE_BATCHING && !USE_INSTANCING\n    v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform CCForwardLight {\n  highp vec4 cc_sphereLitPos[2];\n  vec4 cc_sphereLitSizeRange[2];\n  vec4 cc_sphereLitColor[2];\n  highp vec4 cc_spotLitPos[2];\n  vec4 cc_spotLitSizeRangeAngle[2];\n  vec4 cc_spotLitDir[2];\n  vec4 cc_spotLitColor[2];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting (vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_LIGHTMAP\n  in vec2 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.OCCLUSION_CHANNEL;\n    pbr.y *= res.ROUGHNESS_CHANNEL;\n    pbr.z *= res.METALLIC_CHANNEL;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n    pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n    pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  #if USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING\n    vec4 lighting = texture(cc_lightingMap, v_luv);\n    float fAmb = 0.5 - s.normal.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);\n    finalColor += lighting.rgb *  s.albedo.rgb;\n    finalColor = finalColor * s.occlusion;\n    finalColor += s.emissive;\n    color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;\n  #endif\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
        },
        glsl1: {
            vert: "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture2D(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\n#endif\nuniform vec4 tilingOffset;\n#if USE_VERTEX_COLOR\n  attribute vec3 a_color;\n  varying vec3 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nattribute vec2 a_texCoord1;\nvarying vec2 v_uv1;\n#if USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING\n  varying vec2 v_luv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  #if USE_LIGHTMAP && HAS_SECOND_UV && !USE_BATCHING && !USE_INSTANCING\n    v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\n  #ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n  #endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform highp vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting (vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_LIGHTMAP\n  varying vec2 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.OCCLUSION_CHANNEL;\n    pbr.y *= res.ROUGHNESS_CHANNEL;\n    pbr.z *= res.METALLIC_CHANNEL;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n    pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n    pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  #if USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING\n    vec4 lighting = texture2D(cc_lightingMap, v_luv);\n    float fAmb = 0.5 - s.normal.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);\n    finalColor += lighting.rgb *  s.albedo.rgb;\n    finalColor = finalColor * s.occlusion;\n    finalColor += s.emissive;\n    color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;\n  #endif\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: [ {
                    name: "cc_environment",
                    defines: [ "CC_USE_IBL" ]
                } ]
            },
            locals: {
                blocks: [ {
                    name: "CCMorph",
                    defines: [ "CC_USE_MORPH" ]
                }, {
                    name: "CCSkinningTexture",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCSkinningAnimation",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCSkinning",
                    defines: [ "CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCLocalBatched",
                    defines: [ "!USE_INSTANCING", "USE_BATCHING" ]
                }, {
                    name: "CCLocal",
                    defines: [ "!USE_INSTANCING", "!USE_BATCHING" ]
                }, {
                    name: "CCForwardLight",
                    defines: []
                } ],
                samplers: [ {
                    name: "cc_PositionDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION" ]
                }, {
                    name: "cc_NormalDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL" ]
                }, {
                    name: "cc_TangentDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT" ]
                }, {
                    name: "cc_jointTexture",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "cc_lightingMap",
                    defines: [ "USE_LIGHTMAP" ]
                } ]
            }
        },
        defines: [ {
            name: "CC_USE_MORPH",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_COUNT",
            type: "number",
            range: [ 2, 8 ]
        }, {
            name: "CC_MORPH_PRECOMPUTED",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_POSITION",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_NORMAL",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_TANGENT",
            type: "boolean"
        }, {
            name: "CC_USE_SKINNING",
            type: "boolean"
        }, {
            name: "CC_USE_BAKED_ANIMATION",
            type: "boolean"
        }, {
            name: "USE_INSTANCING",
            type: "boolean"
        }, {
            name: "CC_SUPPORT_FLOAT_TEXTURE",
            type: "boolean"
        }, {
            name: "USE_BATCHING",
            type: "boolean"
        }, {
            name: "USE_VERTEX_COLOR",
            type: "boolean"
        }, {
            name: "USE_NORMAL_MAP",
            type: "boolean"
        }, {
            name: "USE_LIGHTMAP",
            type: "boolean"
        }, {
            name: "HAS_SECOND_UV",
            type: "boolean"
        }, {
            name: "CC_USE_IBL",
            type: "number",
            range: [ 0, 2 ]
        }, {
            name: "CC_USE_HDR",
            type: "boolean"
        }, {
            name: "USE_ALBEDO_MAP",
            type: "boolean"
        }, {
            name: "ALBEDO_UV",
            type: "string",
            options: [ "v_uv", "v_uv1" ]
        }, {
            name: "NORMAL_UV",
            type: "string",
            options: [ "v_uv", "v_uv1" ]
        }, {
            name: "USE_PBR_MAP",
            type: "boolean"
        }, {
            name: "PBR_UV",
            type: "string",
            options: [ "v_uv", "v_uv1" ]
        }, {
            name: "USE_METALLIC_ROUGHNESS_MAP",
            type: "boolean"
        }, {
            name: "METALLIC_ROUGHNESS_UV",
            type: "string",
            options: [ "v_uv", "v_uv1" ]
        }, {
            name: "USE_OCCLUSION_MAP",
            type: "boolean"
        }, {
            name: "OCCLUSION_UV",
            type: "string",
            options: [ "v_uv", "v_uv1" ]
        }, {
            name: "USE_EMISSIVE_MAP",
            type: "boolean"
        }, {
            name: "EMISSIVE_UV",
            type: "string",
            options: [ "v_uv", "v_uv1" ]
        }, {
            name: "OCCLUSION_CHANNEL",
            type: "string",
            options: [ "r", "g", "b" ]
        }, {
            name: "ROUGHNESS_CHANNEL",
            type: "string",
            options: [ "g", "b", "r" ]
        }, {
            name: "METALLIC_CHANNEL",
            type: "string",
            options: [ "b", "r", "g" ]
        }, {
            name: "USE_ALPHA_TEST",
            type: "boolean"
        }, {
            name: "ALPHA_TEST_CHANNEL",
            type: "string",
            options: [ "a", "r" ]
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "tilingOffset",
                type: 16,
                count: 1
            }, {
                name: "albedo",
                type: 16,
                count: 1
            }, {
                name: "albedoScaleAndCutoff",
                type: 16,
                count: 1
            }, {
                name: "pbrParams",
                type: 16,
                count: 1
            }, {
                name: "emissive",
                type: 16,
                count: 1
            }, {
                name: "emissiveScaleParam",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "albedoMap",
            type: 28,
            count: 1,
            defines: [ "USE_ALBEDO_MAP" ],
            binding: 31
        }, {
            name: "normalMap",
            type: 28,
            count: 1,
            defines: [ "USE_NORMAL_MAP" ],
            binding: 32
        }, {
            name: "pbrMap",
            type: 28,
            count: 1,
            defines: [ "USE_PBR_MAP" ],
            binding: 33
        }, {
            name: "metallicRoughnessMap",
            type: 28,
            count: 1,
            defines: [ "USE_METALLIC_ROUGHNESS_MAP" ],
            binding: 34
        }, {
            name: "occlusionMap",
            type: 28,
            count: 1,
            defines: [ "USE_OCCLUSION_MAP" ],
            binding: 35
        }, {
            name: "emissiveMap",
            type: 28,
            count: 1,
            defines: [ "USE_EMISSIVE_MAP" ],
            binding: 36
        } ],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_normal",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 1
        }, {
            name: "a_tangent",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 2
        }, {
            name: "a_vertexId",
            type: 13,
            count: 1,
            defines: [ "CC_USE_MORPH" ],
            format: 11,
            location: 3
        }, {
            name: "a_weights",
            type: 16,
            count: 1,
            defines: [ "CC_USE_SKINNING" ],
            format: 43,
            location: 4
        }, {
            name: "a_joints",
            type: 16,
            count: 1,
            defines: [ "CC_USE_SKINNING" ],
            format: 43,
            location: 5
        }, {
            name: "a_jointAnimInfo",
            type: 16,
            count: 1,
            precision: "highp ",
            defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 6
        }, {
            name: "a_matWorld0",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 7
        }, {
            name: "a_matWorld1",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 8
        }, {
            name: "a_matWorld2",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 9
        }, {
            name: "a_dyn_batch_id",
            type: 13,
            count: 1,
            defines: [ "!USE_INSTANCING", "USE_BATCHING" ],
            format: 11,
            location: 10
        }, {
            name: "a_color",
            type: 15,
            count: 1,
            defines: [ "USE_VERTEX_COLOR" ],
            format: 32,
            location: 11
        }, {
            name: "a_texCoord",
            type: 14,
            count: 1,
            defines: [],
            format: 21,
            location: 12
        }, {
            name: "a_texCoord1",
            type: 14,
            count: 1,
            defines: [],
            format: 21,
            location: 13
        } ]
    } ]
}, {
    name: "builtin-terrain",
    _uuid: "1d08ef62-a503-4ce2-8b9a-46c90873f7d3",
    techniques: [ {
        name: "opaque",
        passes: [ {
            program: "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
            properties: {
                UVScale: {
                    value: [ 1, 1, 1, 1 ],
                    type: 16
                },
                lightMapUVParam: {
                    value: [ 0, 0, 0, 0 ],
                    type: 16
                },
                weightMap: {
                    value: "black",
                    type: 28
                },
                detailMap0: {
                    value: "grey",
                    type: 28
                },
                detailMap1: {
                    value: "grey",
                    type: 28
                },
                detailMap2: {
                    value: "grey",
                    type: 28
                },
                detailMap3: {
                    value: "grey",
                    type: 28
                },
                lightMap: {
                    value: "grey",
                    type: 28
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
        hash: 29493851,
        glsl3: {
            vert: "\n  precision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n  in vec3 a_position;\n  in vec3 a_normal;\n  in vec2 a_texCoord;\n  out vec2 uvw;\n  out vec2 uv0;\n  out vec2 uv1;\n  out vec2 uv2;\n  out vec2 uv3;\n  out vec2 luv;\n  out vec3 diffuse;\n  uniform TexCoords {\n    vec4 UVScale;\n    vec4 lightMapUVParam;\n  };\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  in vec2 uvw;\n  in vec2 uv0;\n  in vec2 uv1;\n  in vec2 uv2;\n  in vec2 uv3;\n  in vec3 diffuse;\n  in vec2 luv;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\n  uniform sampler2D lightMap;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
        },
        glsl1: {
            vert: "\n  precision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform highp mat4 cc_matWorld;\n  attribute vec3 a_position;\n  attribute vec3 a_normal;\n  attribute vec2 a_texCoord;\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec2 luv;\n  varying vec3 diffuse;\n  uniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec3 diffuse;\n  varying vec2 luv;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\n  uniform sampler2D lightMap;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture2D(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n    color += texture2D(detailMap3, uv3) * w.a;\n  #else\n    color = texture2D(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture2D(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCLocal",
                    defines: []
                } ],
                samplers: []
            }
        },
        defines: [ {
            name: "LIGHT_MAP",
            type: "number",
            range: [ 0, 3 ]
        }, {
            name: "CC_USE_HDR",
            type: "boolean"
        }, {
            name: "LAYERS",
            type: "number",
            range: [ 0, 4 ]
        } ],
        blocks: [ {
            name: "TexCoords",
            defines: [],
            binding: 0,
            members: [ {
                name: "UVScale",
                type: 16,
                count: 1
            }, {
                name: "lightMapUVParam",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "weightMap",
            type: 28,
            count: 1,
            defines: [],
            binding: 31
        }, {
            name: "detailMap0",
            type: 28,
            count: 1,
            defines: [],
            binding: 32
        }, {
            name: "detailMap1",
            type: 28,
            count: 1,
            defines: [],
            binding: 33
        }, {
            name: "detailMap2",
            type: 28,
            count: 1,
            defines: [],
            binding: 34
        }, {
            name: "detailMap3",
            type: 28,
            count: 1,
            defines: [],
            binding: 35
        }, {
            name: "lightMap",
            type: 28,
            count: 1,
            defines: [],
            binding: 36
        } ],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_normal",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 1
        }, {
            name: "a_texCoord",
            type: 14,
            count: 1,
            defines: [],
            format: 21,
            location: 2
        } ]
    } ]
}, {
    name: "builtin-unlit",
    _uuid: "a3cd009f-0ab0-420d-9278-b9fdab939bbc",
    techniques: [ {
        name: "opaque",
        passes: [ {
            program: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
            properties: {
                mainTexture: {
                    value: "grey",
                    type: 28
                },
                tilingOffset: {
                    value: [ 1, 1, 0, 0 ],
                    type: 16
                },
                mainColor: {
                    value: [ 1, 1, 1, 1 ],
                    type: 16
                },
                colorScale: {
                    value: [ 1, 1, 1 ],
                    type: 15,
                    handleInfo: [ "colorScaleAndCutoff", 0, 15 ]
                },
                alphaThreshold: {
                    value: [ .5 ],
                    type: 13,
                    handleInfo: [ "colorScaleAndCutoff", 3, 13 ]
                },
                color: {
                    type: 16,
                    handleInfo: [ "mainColor", 0, 16 ]
                },
                colorScaleAndCutoff: {
                    type: 16,
                    value: [ 1, 1, 1, .5 ]
                }
            }
        } ]
    } ],
    shaders: [ {
        name: "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
        hash: 2493645459,
        glsl3: {
            vert: "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform sampler2D cc_jointTexture;\n  #else\n  uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\n#if USE_TEXTURE\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n  uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n    #if FLIP_UV\n      v_uv.y = 1.0 - v_uv.y;\n    #endif\n    v_uv = v_uv * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nuniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return CCFragOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
        },
        glsl1: {
            vert: "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture2D(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\n#if USE_TEXTURE\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n  uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n    #if FLIP_UV\n      v_uv.y = 1.0 - v_uv.y;\n    #endif\n    v_uv = v_uv * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCMorph",
                    defines: [ "CC_USE_MORPH" ]
                }, {
                    name: "CCSkinningTexture",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCSkinningAnimation",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCSkinning",
                    defines: [ "CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCLocalBatched",
                    defines: [ "!USE_INSTANCING", "USE_BATCHING" ]
                }, {
                    name: "CCLocal",
                    defines: [ "!USE_INSTANCING", "!USE_BATCHING" ]
                } ],
                samplers: [ {
                    name: "cc_PositionDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION" ]
                }, {
                    name: "cc_NormalDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL" ]
                }, {
                    name: "cc_TangentDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT" ]
                }, {
                    name: "cc_jointTexture",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                } ]
            }
        },
        defines: [ {
            name: "CC_USE_MORPH",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_COUNT",
            type: "number",
            range: [ 2, 8 ]
        }, {
            name: "CC_MORPH_PRECOMPUTED",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_POSITION",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_NORMAL",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_TANGENT",
            type: "boolean"
        }, {
            name: "CC_USE_SKINNING",
            type: "boolean"
        }, {
            name: "CC_USE_BAKED_ANIMATION",
            type: "boolean"
        }, {
            name: "USE_INSTANCING",
            type: "boolean"
        }, {
            name: "CC_SUPPORT_FLOAT_TEXTURE",
            type: "boolean"
        }, {
            name: "USE_BATCHING",
            type: "boolean"
        }, {
            name: "USE_VERTEX_COLOR",
            type: "boolean"
        }, {
            name: "USE_TEXTURE",
            type: "boolean"
        }, {
            name: "FLIP_UV",
            type: "boolean"
        }, {
            name: "CC_USE_HDR",
            type: "boolean"
        }, {
            name: "USE_ALPHA_TEST",
            type: "boolean"
        }, {
            name: "ALPHA_TEST_CHANNEL",
            type: "string",
            options: [ "a", "r", "g", "b" ]
        } ],
        blocks: [ {
            name: "TexCoords",
            defines: [ "USE_TEXTURE" ],
            binding: 0,
            members: [ {
                name: "tilingOffset",
                type: 16,
                count: 1
            } ]
        }, {
            name: "Constant",
            defines: [],
            binding: 1,
            members: [ {
                name: "mainColor",
                type: 16,
                count: 1
            }, {
                name: "colorScaleAndCutoff",
                type: 16,
                count: 1
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [ "USE_TEXTURE" ],
            binding: 31
        } ],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_vertexId",
            type: 13,
            count: 1,
            defines: [ "CC_USE_MORPH" ],
            format: 11,
            location: 1
        }, {
            name: "a_weights",
            type: 16,
            count: 1,
            defines: [ "CC_USE_SKINNING" ],
            format: 43,
            location: 2
        }, {
            name: "a_joints",
            type: 16,
            count: 1,
            defines: [ "CC_USE_SKINNING" ],
            format: 43,
            location: 3
        }, {
            name: "a_jointAnimInfo",
            type: 16,
            count: 1,
            precision: "highp ",
            defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 4
        }, {
            name: "a_matWorld0",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 5
        }, {
            name: "a_matWorld1",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 6
        }, {
            name: "a_matWorld2",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 7
        }, {
            name: "a_dyn_batch_id",
            type: 13,
            count: 1,
            defines: [ "!USE_INSTANCING", "USE_BATCHING" ],
            format: 11,
            location: 8
        }, {
            name: "a_color",
            type: 16,
            count: 1,
            defines: [ "USE_VERTEX_COLOR" ],
            format: 43,
            location: 9
        }, {
            name: "a_texCoord",
            type: 14,
            count: 1,
            defines: [ "USE_TEXTURE" ],
            format: 21,
            location: 10
        } ]
    } ]
}, {
    name: "pipeline/planar-shadow",
    _uuid: "9361fd90-ba52-4f84-aa93-6e878fd576ca",
    techniques: [ {
        passes: [ {
            phase: "planarShadow",
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 4,
                    blendDstAlpha: 4
                } ]
            },
            program: "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1,
                stencilTestFront: !0,
                stencilFuncFront: 5,
                stencilPassOpFront: 2,
                stencilRefBack: 128,
                stencilRefFront: 128,
                stencilReadMaskBack: 128,
                stencilReadMaskFront: 128,
                stencilWriteMaskBack: 128,
                stencilWriteMaskFront: 128
            }
        } ]
    } ],
    shaders: [ {
        name: "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
        hash: 3225402078,
        glsl3: {
            vert: "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform sampler2D cc_jointTexture;\n  #else\n  uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nuniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  lowp vec4 cc_shadowColor;\n};\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  lowp vec4 cc_shadowColor;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
        },
        glsl1: {
            vert: "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture2D(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - step(127.99, rgba[3]) * 2.0;\n  highp float Exponent = 2.0 * mod(rgba[3], 127.99) + step(128.0, rgba[2]) - 127.0;\n  highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nuniform highp mat4 cc_matLightPlaneProj;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                }, {
                    name: "CCShadow",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [ {
                    name: "CCMorph",
                    defines: [ "CC_USE_MORPH" ]
                }, {
                    name: "CCSkinningTexture",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCSkinningAnimation",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCSkinning",
                    defines: [ "CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION" ]
                }, {
                    name: "CCLocalBatched",
                    defines: [ "!USE_INSTANCING", "USE_BATCHING" ]
                }, {
                    name: "CCLocal",
                    defines: [ "!USE_INSTANCING", "!USE_BATCHING" ]
                } ],
                samplers: [ {
                    name: "cc_PositionDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION" ]
                }, {
                    name: "cc_NormalDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL" ]
                }, {
                    name: "cc_TangentDisplacements",
                    defines: [ "CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT" ]
                }, {
                    name: "cc_jointTexture",
                    defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION" ]
                } ]
            }
        },
        defines: [ {
            name: "CC_USE_MORPH",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_COUNT",
            type: "number",
            range: [ 2, 8 ]
        }, {
            name: "CC_MORPH_PRECOMPUTED",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_POSITION",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_NORMAL",
            type: "boolean"
        }, {
            name: "CC_MORPH_TARGET_HAS_TANGENT",
            type: "boolean"
        }, {
            name: "CC_USE_SKINNING",
            type: "boolean"
        }, {
            name: "CC_USE_BAKED_ANIMATION",
            type: "boolean"
        }, {
            name: "USE_INSTANCING",
            type: "boolean"
        }, {
            name: "CC_SUPPORT_FLOAT_TEXTURE",
            type: "boolean"
        }, {
            name: "USE_BATCHING",
            type: "boolean"
        }, {
            name: "CC_USE_HDR",
            type: "boolean"
        } ],
        blocks: [],
        samplers: [],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_vertexId",
            type: 13,
            count: 1,
            defines: [ "CC_USE_MORPH" ],
            format: 11,
            location: 1
        }, {
            name: "a_weights",
            type: 16,
            count: 1,
            defines: [ "CC_USE_SKINNING" ],
            format: 43,
            location: 2
        }, {
            name: "a_joints",
            type: 16,
            count: 1,
            defines: [ "CC_USE_SKINNING" ],
            format: 43,
            location: 3
        }, {
            name: "a_jointAnimInfo",
            type: 16,
            count: 1,
            precision: "highp ",
            defines: [ "CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 4
        }, {
            name: "a_matWorld0",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 5
        }, {
            name: "a_matWorld1",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 6
        }, {
            name: "a_matWorld2",
            type: 16,
            count: 1,
            defines: [ "USE_INSTANCING" ],
            format: 43,
            isInstanced: !0,
            location: 7
        }, {
            name: "a_dyn_batch_id",
            type: 13,
            count: 1,
            defines: [ "!USE_INSTANCING", "USE_BATCHING" ],
            format: 11,
            location: 8
        } ]
    } ]
}, {
    name: "pipeline/skybox",
    _uuid: "511d2633-09a7-4bdd-ac42-f778032124b3",
    techniques: [ {
        passes: [ {
            rasterizerState: {
                cullMode: 0
            },
            program: "pipeline/skybox|sky-vs:vert|sky-fs:frag",
            priority: 245,
            depthStencilState: {
                depthTest: !0,
                depthWrite: !1
            }
        } ]
    } ],
    shaders: [ {
        name: "pipeline/skybox|sky-vs:vert|sky-fs:frag",
        hash: 1449700672,
        glsl3: {
            vert: "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nout vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_screenSize.y * cc_screenSize.z, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
        },
        glsl1: {
            vert: "\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nvarying vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_screenSize.y * cc_screenSize.z, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: [ {
                    name: "cc_environment",
                    defines: []
                } ]
            },
            locals: {
                blocks: [],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_IBL",
            type: "number",
            range: [ 0, 2 ]
        }, {
            name: "CC_USE_HDR",
            type: "boolean"
        }, {
            name: "USE_RGBE_CUBEMAP",
            type: "boolean"
        } ],
        blocks: [],
        samplers: [],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        } ]
    } ]
}, {
    name: "util/profiler",
    _uuid: "871c3b6c-7379-419d-bda3-794b239ab90d",
    techniques: [ {
        passes: [ {
            blendState: {
                targets: [ {
                    blend: !0,
                    blendSrc: 2,
                    blendDst: 4,
                    blendDstAlpha: 4
                } ]
            },
            rasterizerState: {
                cullMode: 0
            },
            program: "util/profiler|profiler-vs:vert|profiler-fs:frag",
            depthStencilState: {
                depthTest: !1,
                depthWrite: !1
            }
        } ]
    } ],
    shaders: [ {
        name: "util/profiler|profiler-vs:vert|profiler-fs:frag",
        hash: 3438710735,
        glsl3: {
            vert: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nuniform Constants {\n  vec4 offset;\n};\nuniform PerFrameInfo {\n  vec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
        },
        glsl1: {
            vert: "\nprecision mediump float;\nuniform mediump vec4 cc_screenSize;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
            frag: "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
        },
        builtins: {
            globals: {
                blocks: [ {
                    name: "CCGlobal",
                    defines: []
                } ],
                samplers: []
            },
            locals: {
                blocks: [],
                samplers: []
            }
        },
        defines: [ {
            name: "CC_USE_HDR",
            type: "boolean"
        } ],
        blocks: [ {
            name: "Constants",
            defines: [],
            binding: 0,
            members: [ {
                name: "offset",
                type: 16,
                count: 1
            } ]
        }, {
            name: "PerFrameInfo",
            defines: [],
            binding: 1,
            members: [ {
                name: "digits",
                type: 16,
                count: 20
            } ]
        } ],
        samplers: [ {
            name: "mainTexture",
            type: 28,
            count: 1,
            defines: [],
            binding: 31
        } ],
        attributes: [ {
            name: "a_position",
            type: 15,
            count: 1,
            defines: [],
            format: 32,
            location: 0
        }, {
            name: "a_color",
            type: 16,
            count: 1,
            defines: [],
            format: 43,
            location: 1
        } ]
    } ]
} ], BuiltinResMgr = function() {
    function BuiltinResMgr() {
        _classCallCheck(this, BuiltinResMgr), this._device = null, this._resources = {};
    }
    return _createClass(BuiltinResMgr, [ {
        key: "initBuiltinRes",
        value: function initBuiltinRes(device) {
            this._device = device;
            var resources = this._resources, canvas = document.createElement("canvas"), context = canvas.getContext("2d"), imgAsset = new ImageAsset(canvas), l = canvas.width = canvas.height = 2;
            context.fillStyle = "#000", context.fillRect(0, 0, l, l);
            var blackTexture = new Texture2D;
            blackTexture._uuid = "black-texture", blackTexture.image = imgAsset, resources[blackTexture._uuid] = blackTexture, 
            context.fillStyle = "rgba(0,0,0,0)", context.fillRect(0, 0, l, l);
            for (var emptyBuffer = new Uint8Array(16), i = 0; i < emptyBuffer.length; ++i) emptyBuffer[i] = 0;
            var emptyTexture = new Texture2D;
            emptyTexture._uuid = "empty-texture", emptyTexture.image = imgAsset, emptyTexture.uploadData(emptyBuffer), 
            resources[emptyTexture._uuid] = emptyTexture;
            var blackCubeTexture = new TextureCube;
            blackCubeTexture._uuid = "black-cube-texture", blackCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
            blackCubeTexture.image = {
                front: new ImageAsset(canvas),
                back: new ImageAsset(canvas),
                left: new ImageAsset(canvas),
                right: new ImageAsset(canvas),
                top: new ImageAsset(canvas),
                bottom: new ImageAsset(canvas)
            }, resources[blackCubeTexture._uuid] = blackCubeTexture, context.fillStyle = "#777", 
            context.fillRect(0, 0, l, l);
            var greyTexture = new Texture2D;
            greyTexture._uuid = "grey-texture", greyTexture.image = imgAsset, resources[greyTexture._uuid] = greyTexture, 
            context.fillStyle = "#fff", context.fillRect(0, 0, l, l);
            var whiteTexture = new Texture2D;
            whiteTexture._uuid = "white-texture", whiteTexture.image = imgAsset, resources[whiteTexture._uuid] = whiteTexture;
            var whiteCubeTexture = new TextureCube;
            whiteCubeTexture._uuid = "white-cube-texture", whiteCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), 
            whiteCubeTexture.image = {
                front: new ImageAsset(canvas),
                back: new ImageAsset(canvas),
                left: new ImageAsset(canvas),
                right: new ImageAsset(canvas),
                top: new ImageAsset(canvas),
                bottom: new ImageAsset(canvas)
            }, resources[whiteCubeTexture._uuid] = whiteCubeTexture, context.fillStyle = "#7f7fff", 
            context.fillRect(0, 0, l, l);
            var normalTexture = new Texture2D;
            normalTexture._uuid = "normal-texture", normalTexture.image = imgAsset, resources[normalTexture._uuid] = normalTexture, 
            canvas.width = canvas.height = 16, context.fillStyle = "#ddd", context.fillRect(0, 0, 16, 16), 
            context.fillStyle = "#555", context.fillRect(0, 0, 8, 8), context.fillStyle = "#555", 
            context.fillRect(8, 8, 8, 8);
            var defaultTexture = new Texture2D;
            defaultTexture._uuid = "default-texture", defaultTexture.image = imgAsset, resources[defaultTexture._uuid] = defaultTexture;
            var defaultCubeTexture = new TextureCube;
            defaultCubeTexture.setMipFilter(TextureCube.Filter.LINEAR), defaultCubeTexture._uuid = "default-cube-texture", 
            defaultCubeTexture.image = {
                front: new ImageAsset(canvas),
                back: new ImageAsset(canvas),
                left: new ImageAsset(canvas),
                right: new ImageAsset(canvas),
                top: new ImageAsset(canvas),
                bottom: new ImageAsset(canvas)
            }, resources[defaultCubeTexture._uuid] = defaultCubeTexture;
            var spriteFrame = new SpriteFrame, texture = imgAsset._texture;
            spriteFrame.texture = texture, spriteFrame._uuid = "default-spriteframe", resources[spriteFrame._uuid] = spriteFrame, 
            effects.forEach((function(e) {
                Object.assign(new cc.EffectAsset, e).onLoaded();
            }));
            var standardMtl = new cc.Material;
            standardMtl._uuid = "standard-material", standardMtl.initialize({
                effectName: "builtin-standard"
            }), resources[standardMtl._uuid] = standardMtl;
            var missingEfxMtl = new cc.Material;
            missingEfxMtl._uuid = "missing-effect-material", missingEfxMtl.initialize({
                effectName: "builtin-unlit",
                defines: {
                    USE_COLOR: !0
                }
            }), missingEfxMtl.setProperty("mainColor", cc.color("#ffff00")), resources[missingEfxMtl._uuid] = missingEfxMtl;
            var missingMtl = new cc.Material;
            missingMtl._uuid = "missing-material", missingMtl.initialize({
                effectName: "builtin-unlit",
                defines: {
                    USE_COLOR: !0
                }
            }), missingMtl.setProperty("mainColor", cc.color("#ff00ff")), resources[missingMtl._uuid] = missingMtl;
            var spriteMtl = new cc.Material;
            spriteMtl._uuid = "ui-base-material", spriteMtl.initialize({
                defines: {
                    USE_TEXTURE: !1
                },
                effectName: "builtin-sprite"
            }), resources[spriteMtl._uuid] = spriteMtl;
            var spriteColorMtl = new cc.Material;
            spriteColorMtl._uuid = "ui-sprite-material", spriteColorMtl.initialize({
                defines: {
                    USE_TEXTURE: !0,
                    IS_GRAY: !1
                },
                effectName: "builtin-sprite"
            }), resources[spriteColorMtl._uuid] = spriteColorMtl;
            var spriteGrayMtl = new cc.Material;
            spriteGrayMtl._uuid = "ui-sprite-gray-material", spriteGrayMtl.initialize({
                defines: {
                    USE_TEXTURE: !0,
                    IS_GRAY: !0
                },
                effectName: "builtin-sprite"
            }), resources[spriteGrayMtl._uuid] = spriteGrayMtl;
            var defaultParticleMtl = new cc.Material;
            defaultParticleMtl._uuid = "default-particle-material", defaultParticleMtl.initialize({
                effectName: "builtin-particle"
            }), resources[defaultParticleMtl._uuid] = defaultParticleMtl;
            var defaultParticleGPUMtl = new cc.Material;
            defaultParticleGPUMtl._uuid = "default-particle-gpu-material", defaultParticleGPUMtl.initialize({
                effectName: "builtin-particle-gpu"
            }), resources[defaultParticleGPUMtl._uuid] = defaultParticleGPUMtl;
            var defaultTrailMtl = new cc.Material;
            defaultTrailMtl._uuid = "default-trail-material", defaultTrailMtl.initialize({
                effectName: "builtin-particle-trail"
            }), resources[defaultTrailMtl._uuid] = defaultTrailMtl;
            var defaultBillboardMtl = new cc.Material;
            defaultBillboardMtl._uuid = "default-billboard-material", defaultBillboardMtl.initialize({
                effectName: "builtin-billboard"
            }), resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
        }
    }, {
        key: "get",
        value: function get(uuid) {
            return this._resources[uuid];
        }
    } ]), BuiltinResMgr;
}(), builtinResMgr = cc.builtinResMgr = new BuiltinResMgr, SubModel = function() {
    function SubModel() {
        _classCallCheck(this, SubModel), this.priority = RenderPriority.DEFAULT, this._psos = null, 
        this._subMeshObject = null, this._material = null, this._inputAssembler = null, 
        this._cmdBuffers = [];
    }
    return _createClass(SubModel, [ {
        key: "initialize",
        value: function initialize(subMesh, mat, psos) {
            this.psos = psos, this.subMeshData = subMesh, this.material = mat;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._inputAssembler && (this._inputAssembler.destroy(), this._inputAssembler = null);
            for (var i = 0; i < this.passes.length; i++) this.passes[i].destroyPipelineState(this._psos[i]);
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._cmdBuffers); !(_step = _iterator()).done; ) {
                _step.value.destroy();
            }
            this._cmdBuffers.length = 0, this._material = null;
        }
    }, {
        key: "updateCommandBuffer",
        value: function updateCommandBuffer() {
            if (this._material) {
                for (var i = 0; i < this._material.passes.length; i++) this.recordCommandBuffer(i);
                for (var _i = this._cmdBuffers.length - 1; _i >= this._material.passes.length; _i--) {
                    var cmdBuff = this._cmdBuffers.pop();
                    cmdBuff && cmdBuff.destroy();
                }
            }
        }
    }, {
        key: "recordCommandBuffer",
        value: function recordCommandBuffer(index) {
            var device = cc.director.root.device, pso = this._psos[index];
            if (null == this._cmdBuffers[index]) {
                var cmdBufferInfo = {
                    allocator: device.commandAllocator,
                    type: exports.GFXCommandBufferType.SECONDARY
                };
                this._cmdBuffers[index] = device.createCommandBuffer(cmdBufferInfo);
            } else this._cmdBuffers[index].status === exports.GFXStatus.UNREADY && this._cmdBuffers[index].initialize({
                allocator: device.commandAllocator,
                type: exports.GFXCommandBufferType.SECONDARY
            });
            var inputAssembler = this._inputAssembler, cmdBuff = this._cmdBuffers[index];
            cmdBuff.begin(), cmdBuff.bindPipelineState(pso), cmdBuff.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
            cmdBuff.bindInputAssembler(inputAssembler), cmdBuff.draw(inputAssembler), cmdBuff.end();
        }
    }, {
        key: "psos",
        set: function set(val) {
            this._psos = val;
        },
        get: function get() {
            return this._psos;
        }
    }, {
        key: "subMeshData",
        set: function set(sm) {
            this._inputAssembler && this._inputAssembler.destroy(), this._subMeshObject = sm, 
            this._inputAssembler ? this._inputAssembler.initialize(sm) : this._inputAssembler = cc.director.root.device.createInputAssembler(sm);
        },
        get: function get() {
            return this._subMeshObject;
        }
    }, {
        key: "material",
        set: function set(material) {
            this._material = material, null != material && this.updateCommandBuffer();
        },
        get: function get() {
            return this._material;
        }
    }, {
        key: "passes",
        get: function get() {
            return this._material.passes;
        }
    }, {
        key: "inputAssembler",
        get: function get() {
            return this._inputAssembler;
        }
    }, {
        key: "commandBuffers",
        get: function get() {
            return this._cmdBuffers;
        }
    } ]), SubModel;
}(), genHandle = function genHandle(bt, binding, type) {
    var offset = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    return bt << 28 & 4026531840 | type << 22 & 264241152 | binding << 14 & 4177920 | 16383 & offset;
}, getBindingTypeFromHandle = function getBindingTypeFromHandle(handle) {
    return (4026531840 & handle) >>> 28;
}, getTypeFromHandle = function getTypeFromHandle(handle) {
    return (264241152 & handle) >>> 22;
}, getBindingFromHandle = function getBindingFromHandle(handle) {
    return (4177920 & handle) >>> 14;
}, getOffsetFromHandle = function getOffsetFromHandle(handle) {
    return 16383 & handle;
}, customizeType = function customizeType(handle, type) {
    return -264241153 & handle | type << 22 & 264241152;
}, type2reader = (_defineProperty(_type2reader = {}, exports.GFXType.UNKNOWN, (function(a, v) {
    return console.warn("illegal uniform handle");
})), _defineProperty(_type2reader, exports.GFXType.INT, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return a[idx];
})), _defineProperty(_type2reader, exports.GFXType.INT2, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec2.fromArray(v, a, idx);
})), _defineProperty(_type2reader, exports.GFXType.INT3, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec3.fromArray(v, a, idx);
})), _defineProperty(_type2reader, exports.GFXType.INT4, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec4.fromArray(v, a, idx);
})), _defineProperty(_type2reader, exports.GFXType.FLOAT, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return a[idx];
})), _defineProperty(_type2reader, exports.GFXType.FLOAT2, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec2.fromArray(v, a, idx);
})), _defineProperty(_type2reader, exports.GFXType.FLOAT3, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec3.fromArray(v, a, idx);
})), _defineProperty(_type2reader, exports.GFXType.FLOAT4, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec4.fromArray(v, a, idx);
})), _defineProperty(_type2reader, exports.GFXType.MAT3, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Mat3.fromArray(v, a, idx);
})), _defineProperty(_type2reader, exports.GFXType.MAT4, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Mat4.fromArray(v, a, idx);
})), _type2reader), type2writer = (_defineProperty(_type2writer = {}, exports.GFXType.UNKNOWN, (function(a, v) {
    return console.warn("illegal uniform handle");
})), _defineProperty(_type2writer, exports.GFXType.INT, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return a[idx] = v;
})), _defineProperty(_type2writer, exports.GFXType.INT2, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec2.toArray(a, v, idx);
})), _defineProperty(_type2writer, exports.GFXType.INT3, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec3.toArray(a, v, idx);
})), _defineProperty(_type2writer, exports.GFXType.INT4, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec4.toArray(a, v, idx);
})), _defineProperty(_type2writer, exports.GFXType.FLOAT, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return a[idx] = v;
})), _defineProperty(_type2writer, exports.GFXType.FLOAT2, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec2.toArray(a, v, idx);
})), _defineProperty(_type2writer, exports.GFXType.FLOAT3, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec3.toArray(a, v, idx);
})), _defineProperty(_type2writer, exports.GFXType.FLOAT4, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Vec4.toArray(a, v, idx);
})), _defineProperty(_type2writer, exports.GFXType.MAT3, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Mat3.toArray(a, v, idx);
})), _defineProperty(_type2writer, exports.GFXType.MAT4, (function(a, v) {
    var idx = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    return Mat4.toArray(a, v, idx);
})), _type2writer), defaultValues = [ Object.freeze([ 0 ]), Object.freeze([ 0, 0 ]), Object.freeze([ 0, 0, 0, 0 ]), Object.freeze([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]) ];

function getDefaultFromType(type) {
    switch (type) {
      case exports.GFXType.BOOL:
      case exports.GFXType.INT:
      case exports.GFXType.UINT:
      case exports.GFXType.FLOAT:
        return defaultValues[0];

      case exports.GFXType.BOOL2:
      case exports.GFXType.INT2:
      case exports.GFXType.UINT2:
      case exports.GFXType.FLOAT2:
        return defaultValues[1];

      case exports.GFXType.BOOL4:
      case exports.GFXType.INT4:
      case exports.GFXType.UINT4:
      case exports.GFXType.FLOAT4:
        return defaultValues[2];

      case exports.GFXType.MAT4:
        return defaultValues[3];

      case exports.GFXType.SAMPLER2D:
        return "default-texture";

      case exports.GFXType.SAMPLER_CUBE:
        return "default-cube-texture";
    }
    return defaultValues[0];
}

function assignDefines(target, source) {
    for (var entries = Object.entries(source), isDifferent = !1, i = 0; i < entries.length; i++) target[entries[i][0]] !== entries[i][1] && (target[entries[i][0]] = entries[i][1], 
    isDifferent = !0);
    return isDifferent;
}

function getBitCount(cnt) {
    return Math.ceil(Math.log2(Math.max(cnt, 2)));
}

function mapDefine(info, def) {
    switch (info.type) {
      case "boolean":
        return ("number" == typeof def ? def : def ? 1 : 0) + "";

      case "string":
        return void 0 !== def ? def : info.options[0];

      case "number":
        return (void 0 !== def ? def : info.range[0]) + "";
    }
    return console.warn("unknown define type '".concat(info.type, "'")), "-1";
}

function getShaderInstanceName(name, macros) {
    return name + macros.reduce((function(acc, cur) {
        return cur.isDefault ? acc : "".concat(acc, "|").concat(cur.name).concat(cur.value);
    }), "");
}

function insertBuiltinBindings(tmpl, source, type) {
    for (var _step2, target = tmpl.builtins[type], blocks = tmpl.blocks, _iterator2 = _createForOfIteratorHelperLoose(target.blocks); !(_step2 = _iterator2()).done; ) {
        var b = _step2.value, info = source.get(b.name);
        if (info && info.type === exports.GFXBindingType.UNIFORM_BUFFER) {
            var builtin = Object.assign({
                defines: b.defines,
                size: getSize(info.blockInfo),
                bindingType: exports.GFXBindingType.UNIFORM_BUFFER,
                defaultValue: info.defaultValue
            }, info.blockInfo);
            blocks.push(builtin);
        } else console.warn("builtin UBO '".concat(b.name, "' not available!"));
    }
    for (var _step3, samplers = tmpl.samplers, _iterator3 = _createForOfIteratorHelperLoose(target.samplers); !(_step3 = _iterator3()).done; ) {
        var s = _step3.value, _info = source.get(s.name);
        if (_info && _info.type === exports.GFXBindingType.SAMPLER) {
            var _builtin = Object.assign({
                defines: s.defines,
                bindingType: exports.GFXBindingType.SAMPLER,
                defaultValue: _info.defaultValue
            }, _info.samplerInfo);
            samplers.push(_builtin);
        } else console.warn("builtin sampler '".concat(s.name, "' not available!"));
    }
}

function getSize(block) {
    return block.members.reduce((function(s, m) {
        return s + GFXGetTypeSize(m.type) * m.count;
    }), 0);
}

function dependencyCheck(dependencies, defines) {
    for (var i = 0; i < dependencies.length; i++) {
        var d = dependencies[i];
        if ("!" === d[0]) {
            if (defines[d.slice(1)]) return !1;
        } else if (!defines[d]) return !1;
    }
    return !0;
}

var programLib = new (function() {
    function ProgramLib() {
        _classCallCheck(this, ProgramLib), this._templates = void 0, this._cache = void 0, 
        this._templates = {}, this._cache = {};
    }
    return _createClass(ProgramLib, [ {
        key: "define",
        value: function define(prog) {
            var curTmpl = this._templates[prog.name];
            if (!curTmpl || curTmpl.hash !== prog.hash) {
                for (var _step4, tmpl = prog, offset = 0, _loop = function _loop() {
                    var def = _step4.value, cnt = 1;
                    if ("number" === def.type) {
                        var range = def.range;
                        cnt = getBitCount(range[1] - range[0] + 1), def._map = function(value) {
                            return value - range[0];
                        };
                    } else "string" === def.type ? (cnt = getBitCount(def.options.length), def._map = function(value) {
                        return Math.max(0, def.options.findIndex((function(s) {
                            return s === value;
                        })));
                    }) : "boolean" === def.type && (def._map = function(value) {
                        return value ? 1 : 0;
                    });
                    def._offset = offset, offset += cnt;
                }, _iterator4 = _createForOfIteratorHelperLoose(tmpl.defines); !(_step4 = _iterator4()).done; ) _loop();
                offset > 31 && (tmpl.uber = !0), tmpl.blocks.forEach((function(b) {
                    b.bindingType = exports.GFXBindingType.UNIFORM_BUFFER, b.size = getSize(b);
                })), tmpl.samplers.forEach((function(s) {
                    return s.bindingType = exports.GFXBindingType.SAMPLER;
                })), tmpl.handleMap = function genHandles(tmpl) {
                    for (var handleMap = {}, i = 0; i < tmpl.blocks.length; i++) for (var block = tmpl.blocks[i], members = block.members, offset = 0, j = 0; j < members.length; j++) {
                        var uniform = members[j];
                        handleMap[uniform.name] = genHandle(exports.GFXBindingType.UNIFORM_BUFFER, block.binding, uniform.type, offset), 
                        offset += (GFXGetTypeSize(uniform.type) >> 2) * uniform.count;
                    }
                    for (var _i = 0; _i < tmpl.samplers.length; _i++) {
                        var sampler = tmpl.samplers[_i];
                        handleMap[sampler.name] = genHandle(exports.GFXBindingType.SAMPLER, sampler.binding, sampler.type);
                    }
                    return handleMap;
                }(tmpl), tmpl.localsInited || (insertBuiltinBindings(tmpl, localBindingsDesc, "locals"), 
                tmpl.localsInited = !0), this._templates[prog.name] = tmpl;
            }
        }
    }, {
        key: "getTemplate",
        value: function getTemplate(name) {
            return this._templates[name];
        }
    }, {
        key: "hasProgram",
        value: function hasProgram(name) {
            return void 0 !== this._templates[name];
        }
    }, {
        key: "getKey",
        value: function getKey(name, defines) {
            var tmpl = this._templates[name], tmplDefs = tmpl.defines;
            if (tmpl.uber) {
                for (var key = "", i = 0; i < tmplDefs.length; i++) {
                    var tmplDef = tmplDefs[i], _value2 = defines[tmplDef.name];
                    if (_value2 && tmplDef._map) {
                        var mapped = tmplDef._map(_value2);
                        key += tmplDef._offset + (mapped + "|");
                    }
                }
                return key + tmpl.hash;
            }
            for (var _key = 0, _i4 = 0; _i4 < tmplDefs.length; _i4++) {
                var _tmplDef = tmplDefs[_i4], _value3 = defines[_tmplDef.name];
                if (_value3 && _tmplDef._map) _key |= _tmplDef._map(_value3) << _tmplDef._offset;
            }
            return "".concat(_key.toString(16), "|").concat(tmpl.hash);
        }
    }, {
        key: "destroyShaderByDefines",
        value: function destroyShaderByDefines(defines) {
            var _this = this, names = Object.keys(defines);
            if (names.length) for (var _step5, regexes = names.map((function(cur) {
                var val = defines[cur];
                return "boolean" == typeof val && (val = val ? "1" : "0"), new RegExp(cur + val);
            })), _iterator5 = _createForOfIteratorHelperLoose(Object.keys(this._cache).filter((function(k) {
                return regexes.every((function(re) {
                    return re.test(_this._cache[k].shader.name);
                }));
            }))); !(_step5 = _iterator5()).done; ) {
                var k = _step5.value, prog = this._cache[k].shader;
                console.log("destroyed shader ".concat(prog.name)), prog.destroy(), delete this._cache[k];
            }
        }
    }, {
        key: "getGFXShader",
        value: function getGFXShader(device, name, defines, pipeline, key) {
            key || (key = this.getKey(name, defines));
            var res = this._cache[key];
            if (res) return res;
            var tmpl = this._templates[name];
            tmpl.globalsInited || (insertBuiltinBindings(tmpl, pipeline.globalBindings, "globals"), 
            tmpl.globalsInited = !0);
            var macroArray = function prepareDefines(defs, tDefs) {
                for (var _step, macros = [], _iterator = _createForOfIteratorHelperLoose(tDefs); !(_step = _iterator()).done; ) {
                    var tmpl = _step.value, name = tmpl.name, v = defs[name], _value = mapDefine(tmpl, v), isDefault = !v || "0" === v;
                    macros.push({
                        name: name,
                        value: _value,
                        isDefault: isDefault
                    });
                }
                return macros;
            }(defines, tmpl.defines), prefix = macroArray.reduce((function(acc, cur) {
                return "".concat(acc, "#define ").concat(cur.name, " ").concat(cur.value, "\n");
            }), "") + "\n", src = tmpl.glsl3;
            switch (device.gfxAPI) {
              case exports.GFXAPI.WEBGL2:
                src = tmpl.glsl3;
                break;

              default:
                src = tmpl.glsl1;
            }
            var blocks = [], samplers = [], bindings = [], inputState = new GFXInputState;
            !function getShaderBindings(tmpl, defines, outBlocks, outSamplers, bindings, outAttributes) {
                for (var blocks = tmpl.blocks, samplers = tmpl.samplers, attributes = tmpl.attributes, i = 0; i < blocks.length; i++) {
                    var block = blocks[i];
                    dependencyCheck(block.defines, defines) && (outBlocks.push(block), bindings.push(block));
                }
                for (var _i2 = 0; _i2 < samplers.length; _i2++) {
                    var sampler = samplers[_i2];
                    dependencyCheck(sampler.defines, defines) && (outSamplers.push(sampler), bindings.push(sampler));
                }
                for (var _i3 = 0; _i3 < attributes.length; _i3++) {
                    var attribute = attributes[_i3];
                    dependencyCheck(attribute.defines, defines) && outAttributes.push(attribute);
                }
            }(tmpl, defines, blocks, samplers, bindings, inputState.attributes);
            var shader = device.createShader({
                name: getShaderInstanceName(name, macroArray),
                blocks: blocks,
                samplers: samplers,
                stages: [ {
                    type: exports.GFXShaderType.VERTEX,
                    source: prefix + src.vert
                }, {
                    type: exports.GFXShaderType.FRAGMENT,
                    source: prefix + src.frag
                } ]
            });
            return this._cache[key] = {
                shader: shader,
                bindings: bindings,
                inputState: inputState
            };
        }
    } ]), ProgramLib;
}());

cc.programLib = programLib;

var ModelType, m4_1 = new Mat4, _subMeshPool = new Pool$1((function() {
    return new SubModel;
}), 32);

!function(ModelType) {
    ModelType[ModelType.DEFAULT = 0] = "DEFAULT", ModelType[ModelType.SKINNING = 1] = "SKINNING", 
    ModelType[ModelType.BAKED_SKINNING = 2] = "BAKED_SKINNING", ModelType[ModelType.UI_BATCH = 3] = "UI_BATCH", 
    ModelType[ModelType.PARTICLE_BATCH = 4] = "PARTICLE_BATCH", ModelType[ModelType.LINE = 5] = "LINE";
}(ModelType || (ModelType = {}));

var NodeSpace, TransformBit, Model = function() {
    function Model() {
        _classCallCheck(this, Model), this.type = ModelType.DEFAULT, this.scene = null, 
        this.node = null, this.transform = null, this.enabled = !0, this.visFlags = Layers.Enum.NONE, 
        this.castShadow = !1, this.isDynamicBatching = !1, this.instancedAttributes = {
            buffer: null,
            list: []
        }, this._device = void 0, this._worldBounds = null, this._modelBounds = null, this._subModels = [], 
        this._implantPSOs = [], this._matPSORecord = new Map, this._matRefCount = new Map, 
        this._localData = new Float32Array(UBOLocal.COUNT), this._localBuffer = null, this._lightBuffer = null, 
        this._inited = !1, this._updateStamp = -1, this._transformUpdated = !0, this._instMatWorldIdx = -1, 
        this._device = cc.director.root.device;
    }
    return _createClass(Model, [ {
        key: "subModels",
        get: function get() {
            return this._subModels;
        }
    }, {
        key: "subModelNum",
        get: function get() {
            return this._subModels.length;
        }
    }, {
        key: "inited",
        get: function get() {
            return this._inited;
        }
    }, {
        key: "worldBounds",
        get: function get() {
            return this._worldBounds;
        }
    }, {
        key: "modelBounds",
        get: function get() {
            return this._modelBounds;
        }
    }, {
        key: "lightBuffer",
        get: function get() {
            return this._lightBuffer;
        }
    }, {
        key: "localBuffer",
        get: function get() {
            return this._localBuffer;
        }
    }, {
        key: "updateStamp",
        get: function get() {
            return this._updateStamp;
        }
    }, {
        key: "isInstancingEnabled",
        get: function get() {
            return this._instMatWorldIdx >= 0;
        }
    } ]), _createClass(Model, [ {
        key: "initialize",
        value: function initialize(node) {
            this.transform = this.node = node;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._subModels); !(_step = _iterator()).done; ) {
                var subModel = _step.value;
                subModel.destroy(), _subMeshPool.free(subModel);
            }
            this._localBuffer && (this._localBuffer.destroy(), this._localBuffer = null), this._lightBuffer && (this._lightBuffer.destroy(), 
            this._lightBuffer = null), this._worldBounds = null, this._modelBounds = null, this._subModels.length = 0, 
            this._matPSORecord.clear(), this._matRefCount.clear(), this._inited = !1, this._transformUpdated = !0, 
            this.isDynamicBatching = !1;
        }
    }, {
        key: "attachToScene",
        value: function attachToScene(scene) {
            this.scene = scene;
        }
    }, {
        key: "detachFromScene",
        value: function detachFromScene() {
            this.scene = null;
        }
    }, {
        key: "getSubModel",
        value: function getSubModel(idx) {
            return this._subModels[idx];
        }
    }, {
        key: "updateTransform",
        value: function updateTransform(stamp) {
            var node = this.transform;
            (node.hasChangedFlags || node._dirtyFlags) && (node.updateWorldTransform(), this._transformUpdated = !0, 
            this._modelBounds && this._worldBounds && this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, this._worldBounds));
        }
    }, {
        key: "updateLightingmap",
        value: function updateLightingmap(tex, uvParam) {
            Vec4.toArray(this._localData, uvParam, UBOLocal.LIGHTINGMAP_UVPARAM), null === tex && (tex = builtinResMgr.get("empty-texture"));
            var textureView = tex.getGFXTextureView();
            if (null !== textureView) {
                var sampler;
                if (tex.mipmaps.length > 1) {
                    var samplerHash = genSamplerHash([ exports.GFXFilter.LINEAR, exports.GFXFilter.LINEAR, exports.GFXFilter.LINEAR, exports.GFXAddress.CLAMP, exports.GFXAddress.CLAMP, exports.GFXAddress.CLAMP ]);
                    sampler = samplerLib.getSampler(this._device, samplerHash);
                } else {
                    var _samplerHash = genSamplerHash([ exports.GFXFilter.NONE, exports.GFXFilter.NONE, exports.GFXFilter.NONE, exports.GFXAddress.CLAMP, exports.GFXAddress.CLAMP, exports.GFXAddress.CLAMP ]);
                    sampler = samplerLib.getSampler(this._device, _samplerHash);
                }
                for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._subModels); !(_step2 = _iterator2()).done; ) {
                    var sub = _step2.value;
                    if (null !== sub.psos) for (var i = 0; i < sub.psos.length; i++) sub.psos[i].pipelineLayout.layouts[0].bindTextureView(UniformLightingMapSampler.binding, textureView), 
                    sub.psos[i].pipelineLayout.layouts[0].bindSampler(UniformLightingMapSampler.binding, sampler), 
                    sub.psos[i].pipelineLayout.layouts[0].update();
                }
            }
        }
    }, {
        key: "updateUBOs",
        value: function updateUBOs(stamp) {
            if (this._matPSORecord.forEach(this._updatePass, this), this._updateStamp = stamp, 
            this._transformUpdated) {
                this._transformUpdated = !1;
                var worldMatrix = this.transform._mat, idx = this._instMatWorldIdx;
                if (idx >= 0) {
                    var attrs = this.instancedAttributes.list;
                    !function uploadMat4AsVec4x3(mat, v1, v2, v3) {
                        v1[0] = mat.m00, v1[1] = mat.m01, v1[2] = mat.m02, v1[3] = mat.m12, v2[0] = mat.m04, 
                        v2[1] = mat.m05, v2[2] = mat.m06, v2[3] = mat.m13, v3[0] = mat.m08, v3[1] = mat.m09, 
                        v3[2] = mat.m10, v3[3] = mat.m14;
                    }(worldMatrix, attrs[idx].view, attrs[idx + 1].view, attrs[idx + 2].view);
                } else Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET), Mat4.inverseTranspose(m4_1, worldMatrix), 
                Mat4.toArray(this._localData, m4_1, UBOLocal.MAT_WORLD_IT_OFFSET), this._localBuffer.update(this._localData);
            }
        }
    }, {
        key: "createBoundingShape",
        value: function createBoundingShape(minPos, maxPos) {
            minPos && maxPos && (this._modelBounds = aabb.fromPoints(aabb.create(), minPos, maxPos), 
            this._worldBounds = aabb.clone(this._modelBounds));
        }
    }, {
        key: "initSubModel",
        value: function initSubModel(idx, subMeshData, mat) {
            if (this.initLocalBindings(mat), null == this._subModels[idx]) this._subModels[idx] = _subMeshPool.alloc(); else {
                var oldMat = this._subModels[idx].material;
                this._subModels[idx].destroy(), this.releasePSO(oldMat);
            }
            this.allocatePSO(mat, idx), this._subModels[idx].initialize(subMeshData, mat, this._matPSORecord.get(mat)), 
            this._inited = !0;
        }
    }, {
        key: "setSubModelMesh",
        value: function setSubModelMesh(idx, subMeshData) {
            null == this._subModels[idx] && (this._subModels[idx] = _subMeshPool.alloc()), this._subModels[idx].subMeshData = subMeshData;
        }
    }, {
        key: "setSubModelMaterial",
        value: function setSubModelMaterial(idx, mat) {
            this.initLocalBindings(mat), this._subModels[idx] && (this._subModels[idx].material === mat ? mat && (this.destroyPipelineStates(mat, this._matPSORecord.get(mat)), 
            this._matPSORecord.set(mat, this.createPipelineStates(mat, idx))) : (this._subModels[idx].material && this.releasePSO(this._subModels[idx].material), 
            mat && this.allocatePSO(mat, idx)), this._subModels[idx].psos = mat && this._matPSORecord.get(mat) || null, 
            this._subModels[idx].material = mat);
        }
    }, {
        key: "onGlobalPipelineStateChanged",
        value: function onGlobalPipelineStateChanged() {
            var _this = this, subModels = this._subModels;
            this._matPSORecord.forEach((function(psos, mat) {
                for (var i = 0; i < subModels.length && subModels[i].material !== mat; i++) ;
                if (!(i >= subModels.length)) {
                    for (var j = 0; j < mat.passes.length; j++) {
                        var pass = mat.passes[j];
                        pass.destroyPipelineState(psos[j]), pass.beginChangeStatesSilently(), pass.tryCompile(), 
                        pass.endChangeStatesSilently();
                    }
                    var newPSOs = _this.createPipelineStates(mat, i);
                    psos.length = newPSOs.length;
                    for (var _j = 0; _j < newPSOs.length; _j++) psos[_j] = newPSOs[_j];
                }
            }));
            for (var i = 0; i < subModels.length; i++) subModels[i].updateCommandBuffer();
        }
    }, {
        key: "insertImplantPSO",
        value: function insertImplantPSO(pso) {
            this._implantPSOs.push(pso);
        }
    }, {
        key: "removeImplantPSO",
        value: function removeImplantPSO(pso) {
            var idx = this._implantPSOs.indexOf(pso);
            idx >= 0 && this._implantPSOs.splice(idx, 1);
        }
    }, {
        key: "createPipelineStates",
        value: function createPipelineStates(mat, subModelIdx) {
            for (var ret = [], i = 0; i < mat.passes.length; i++) {
                var pass = mat.passes[i];
                ret[i] = this.createPipelineState(pass, subModelIdx);
            }
            return ret[0] && this.updateInstancedAttributeList(ret[0], mat.passes[0]), ret;
        }
    }, {
        key: "destroyPipelineStates",
        value: function destroyPipelineStates(mat, pso) {
            for (var i = 0; i < mat.passes.length; i++) {
                mat.passes[i].destroyPipelineState(pso[i]);
            }
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState(pass, subModelIdx, patches) {
            var pso = pass.createPipelineState(patches), bindingLayout = pso.pipelineLayout.layouts[0];
            return this._localBuffer && bindingLayout.bindBuffer(UBOLocal.BLOCK.binding, this._localBuffer), 
            this._lightBuffer && bindingLayout.bindBuffer(UBOForwardLight.BLOCK.binding, this._lightBuffer), 
            pso;
        }
    }, {
        key: "updateInstancedAttributeList",
        value: function updateInstancedAttributeList(pso, pass) {
            if (pass.device.hasFeature(exports.GFXFeature.INSTANCED_ARRAYS)) {
                for (var attributes = pso.inputState.attributes, size = 0, j = 0; j < attributes.length; j++) {
                    var attribute = attributes[j];
                    attribute.isInstanced && (size += GFXFormatInfos[attribute.format].size);
                }
                var attrs = this.instancedAttributes;
                attrs.buffer = new Uint8Array(size), attrs.list.length = 0;
                for (var offset = 0, buffer = attrs.buffer.buffer, _j2 = 0; _j2 < attributes.length; _j2++) {
                    var _attribute = attributes[_j2];
                    if (_attribute.isInstanced) {
                        var format = _attribute.format, info = GFXFormatInfos[format], view = new (getTypedArrayConstructor(info))(buffer, offset, info.count), isNormalized = _attribute.isNormalized;
                        offset += info.size, attrs.list.push({
                            name: _attribute.name,
                            format: format,
                            isNormalized: isNormalized,
                            view: view
                        });
                    }
                }
                pass.instancedBuffer && pass.instancedBuffer.destroy(), this._instMatWorldIdx = this.getInstancedAttributeIndex("a_matWorld0"), 
                this._transformUpdated = !0;
            }
        }
    }, {
        key: "getInstancedAttributeIndex",
        value: function getInstancedAttributeIndex(name) {
            for (var list = this.instancedAttributes.list, i = 0; i < list.length; i++) if (list[i].name === name) return i;
            return -1;
        }
    }, {
        key: "initLocalBindings",
        value: function initLocalBindings(mat) {
            if (this._localBuffer || (this._localBuffer = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: UBOLocal.SIZE,
                stride: UBOLocal.SIZE
            })), mat) {
                for (var _step3, hasForwardLight = !1, _iterator3 = _createForOfIteratorHelperLoose(mat.passes); !(_step3 = _iterator3()).done; ) {
                    var p = _step3.value;
                    if (programLib.getTemplate(p.program).builtins.locals.blocks.find((function(b) {
                        return b.name === UBOForwardLight.BLOCK.name;
                    }))) {
                        hasForwardLight = !0;
                        break;
                    }
                }
                hasForwardLight && !this._lightBuffer && (this._lightBuffer = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: UBOForwardLight.SIZE,
                    stride: UBOForwardLight.SIZE
                }));
            }
        }
    }, {
        key: "_updatePass",
        value: function _updatePass(psos, mat) {
            for (var i = 0; i < mat.passes.length; i++) mat.passes[i].update();
            for (var _i = 0; _i < psos.length; _i++) psos[_i].pipelineLayout.layouts[0].update();
        }
    }, {
        key: "allocatePSO",
        value: function allocatePSO(mat, subModelIdx) {
            null == this._matRefCount.get(mat) ? (this._matRefCount.set(mat, 1), this._matPSORecord.set(mat, this.createPipelineStates(mat, subModelIdx))) : this._matRefCount.set(mat, this._matRefCount.get(mat) + 1);
        }
    }, {
        key: "releasePSO",
        value: function releasePSO(mat) {
            this._matRefCount.set(mat, this._matRefCount.get(mat) - 1), 0 === this._matRefCount.get(mat) && (this.destroyPipelineStates(mat, this._matPSORecord.get(mat)), 
            this._matPSORecord.delete(mat), this._matRefCount.delete(mat));
        }
    } ]), Model;
}(), MorphModel = function(_Model) {
    function MorphModel() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, MorphModel);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MorphModel)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._morphRenderingInstance = null, 
        _this._usedMaterials = new Set, _this;
    }
    return _inherits(MorphModel, Model), _createClass(MorphModel, [ {
        key: "createPipelineState",
        value: function createPipelineState(pass, subModelIndex, patches) {
            var _patches$concat;
            if (!this._morphRenderingInstance) return _get(_getPrototypeOf(MorphModel.prototype), "createPipelineState", this).apply(this, arguments);
            var myPatches = this._morphRenderingInstance.requiredPatches(subModelIndex), pipelineState = _get(_getPrototypeOf(MorphModel.prototype), "createPipelineState", this).call(this, pass, subModelIndex, myPatches ? null !== (_patches$concat = null == patches ? void 0 : patches.concat(myPatches)) && void 0 !== _patches$concat ? _patches$concat : myPatches : patches);
            return this._morphRenderingInstance.adaptPipelineState(subModelIndex, pipelineState), 
            pipelineState;
        }
    }, {
        key: "initSubModel",
        value: function initSubModel(subModelIndex, subMeshData, material) {
            return _get(_getPrototypeOf(MorphModel.prototype), "initSubModel", this).call(this, subModelIndex, subMeshData, this._launderMaterial(material));
        }
    }, {
        key: "setSubModelMaterial",
        value: function setSubModelMaterial(subModelIndex, material) {
            return _get(_getPrototypeOf(MorphModel.prototype), "setSubModelMaterial", this).call(this, subModelIndex, material ? this._launderMaterial(material) : material);
        }
    }, {
        key: "_launderMaterial",
        value: function _launderMaterial(material) {
            return material;
        }
    }, {
        key: "setMorphRendering",
        value: function setMorphRendering(morphRendering) {
            this._morphRenderingInstance = morphRendering;
        }
    } ]), MorphModel;
}();

!function(NodeSpace) {
    NodeSpace[NodeSpace.LOCAL = 0] = "LOCAL", NodeSpace[NodeSpace.WORLD = 1] = "WORLD";
}(NodeSpace || (NodeSpace = {})), function(TransformBit) {
    TransformBit[TransformBit.NONE = 0] = "NONE", TransformBit[TransformBit.POSITION = 1] = "POSITION", 
    TransformBit[TransformBit.ROTATION = 2] = "ROTATION", TransformBit[TransformBit.SCALE = 4] = "SCALE", 
    TransformBit[TransformBit.RS = TransformBit.ROTATION | TransformBit.SCALE] = "RS", 
    TransformBit[TransformBit.TRS = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS", 
    TransformBit[TransformBit.TRS_MASK = ~TransformBit.TRS] = "TRS_MASK";
}(TransformBit || (TransformBit = {})), cc.internal.TransformBit = TransformBit;

var phases, phaseNum, _class$b, _class2$8, _descriptor$7, _descriptor2$3, _descriptor3$3, _class3$5, _temp$b, _localBatched = new UBOLocalBatched, BatchedBuffer = function() {
    function BatchedBuffer(pass) {
        _classCallCheck(this, BatchedBuffer), this.batches = [], this.pass = void 0, this.pass = pass;
    }
    return _createClass(BatchedBuffer, [ {
        key: "destroy",
        value: function destroy() {
            for (var i = 0; i < this.batches.length; ++i) {
                for (var batch = this.batches[i], j = 0; j < batch.vbs.length; ++j) batch.vbs[j].destroy();
                batch.vbIdx.destroy(), batch.ia.destroy(), batch.ubo.destroy();
            }
            this.batches.length = 0;
        }
    }, {
        key: "merge",
        value: function merge(subModel, ro, pso) {
            var flatBuffers = subModel.subMeshData.flatBuffers;
            if (0 !== flatBuffers.length) {
                for (var vbSize = 0, vbIdxSize = 0, vbCount = flatBuffers[0].count, bindingLayout = pso.pipelineLayout.layouts[0], isBatchExist = !1, i = 0; i < this.batches.length; ++i) {
                    var batch = this.batches[i];
                    if (batch.vbs.length === flatBuffers.length && batch.mergeCount < UBOLocalBatched.BATCHING_COUNT) {
                        isBatchExist = !0;
                        for (var j = 0; j < batch.vbs.length; ++j) {
                            if (batch.vbs[j].stride !== flatBuffers[j].stride) {
                                isBatchExist = !1;
                                break;
                            }
                        }
                        if (isBatchExist) {
                            for (var _j = 0; _j < batch.vbs.length; ++_j) {
                                var flatBuff = flatBuffers[_j], batchVB = batch.vbs[_j], vbBuf = batch.vbDatas[_j];
                                (vbSize = (vbCount + batch.vbCount) * flatBuff.stride) > batchVB.size && (batchVB.resize(vbSize), 
                                vbBuf = batch.vbDatas[_j] = new Uint8Array(batchVB.bufferView.buffer)), vbBuf.set(flatBuff.buffer, batch.vbCount * flatBuff.stride);
                            }
                            (vbIdxSize = 4 * (vbCount + batch.vbCount)) > batch.vbIdx.size && (batch.vbIdx.resize(vbIdxSize), 
                            batch.vbIdxData = new Float32Array(batch.vbIdx.bufferView.buffer));
                            var start = batch.vbCount, end = start + vbCount, vbIdxBuf = batch.vbIdxData, mergeCount = batch.mergeCount;
                            if (vbIdxBuf[start] !== mergeCount || vbIdxBuf[end - 1] !== mergeCount) for (var _j2 = start; _j2 < end; _j2++) vbIdxBuf[_j2] = mergeCount + .1;
                            return Mat4.toArray(batch.uboData.view, ro.model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET + 16 * batch.mergeCount), 
                            batch.mergeCount || batch.pso === pso || (bindingLayout.bindBuffer(UBOLocalBatched.BLOCK.binding, batch.ubo), 
                            bindingLayout.update(), batch.pso = pso), ++batch.mergeCount, batch.vbCount += vbCount, 
                            void (batch.ia.vertexCount += vbCount);
                        }
                    }
                }
                for (var device = this.pass.device, vbs = [], vbDatas = [], totalVBs = [], _i = 0; _i < flatBuffers.length; ++_i) {
                    var _flatBuff = flatBuffers[_i], newVB = device.createBuffer({
                        usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                        size: _flatBuff.count * _flatBuff.stride,
                        stride: _flatBuff.stride,
                        flags: exports.GFXBufferFlagBit.BAKUP_BUFFER
                    });
                    newVB.update(_flatBuff.buffer.buffer), vbs.push(newVB), vbDatas.push(new Uint8Array(newVB.bufferView.buffer)), 
                    totalVBs.push(newVB);
                }
                var vbIdx = device.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 4 * vbCount,
                    stride: 4,
                    flags: exports.GFXBufferFlagBit.BAKUP_BUFFER
                }), vbIndices = new Float32Array(vbCount);
                vbIndices.fill(0), vbIdx.update(vbIndices), totalVBs.push(vbIdx);
                for (var vbIdxData = new Float32Array(vbIdx.bufferView.buffer), attributes = subModel.inputAssembler.attributes, attrs = new Array(attributes.length + 1), a = 0; a < attributes.length; ++a) attrs[a] = attributes[a];
                attrs[attributes.length] = {
                    name: "a_dyn_batch_id",
                    format: exports.GFXFormat.R32F,
                    stream: flatBuffers.length
                };
                var ia = device.createInputAssembler({
                    attributes: attrs,
                    vertexBuffers: totalVBs
                }), ubo = this.pass.device.createBuffer({
                    usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: UBOLocalBatched.SIZE
                });
                bindingLayout.bindBuffer(UBOLocalBatched.BLOCK.binding, ubo), bindingLayout.update();
                var uboData = new UBOLocalBatched;
                Mat4.toArray(uboData.view, ro.model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET), 
                this.batches.push({
                    mergeCount: 1,
                    vbs: vbs,
                    vbDatas: vbDatas,
                    vbIdx: vbIdx,
                    vbIdxData: vbIdxData,
                    vbCount: vbCount,
                    ia: ia,
                    ubo: ubo,
                    uboData: uboData,
                    pso: pso
                });
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var i = 0; i < this.batches.length; ++i) {
                var batch = this.batches[i];
                batch.vbCount = 0, batch.mergeCount = 0, batch.ia.vertexCount = 0;
            }
        }
    }, {
        key: "clearUBO",
        value: function clearUBO() {
            for (var i = 0; i < this.batches.length; ++i) {
                this.batches[i].ubo.update(_localBatched.view.buffer);
            }
        }
    } ]), BatchedBuffer;
}(), InstancedBuffer = function() {
    function InstancedBuffer(pass) {
        _classCallCheck(this, InstancedBuffer), this.instances = [], this.pass = void 0, 
        this.pass = pass;
    }
    return _createClass(InstancedBuffer, [ {
        key: "destroy",
        value: function destroy() {
            for (var i = 0; i < this.instances.length; ++i) {
                var instance = this.instances[i];
                instance.vb.destroy(), instance.ia.destroy();
            }
            this.instances.length = 0;
        }
    }, {
        key: "merge",
        value: function merge(subModel, attrs, pso) {
            var stride = attrs.buffer.length;
            if (stride) {
                for (var sourceIA = subModel.inputAssembler, i = 0; i < this.instances.length; ++i) {
                    var instance = this.instances[i];
                    if (!(instance.ia.indexBuffer !== sourceIA.indexBuffer || instance.count >= 1024)) {
                        if (instance.pso !== pso) {
                            var binding1 = instance.pso.pipelineLayout.layouts[0].getBindingUnit(UniformLightingMapSampler.binding), binding2 = pso.pipelineLayout.layouts[0].getBindingUnit(UniformLightingMapSampler.binding);
                            if ((null == binding1 ? void 0 : binding1.texView) !== (null == binding2 ? void 0 : binding2.texView)) continue;
                        }
                        if (instance.stride !== stride) return;
                        if (instance.count >= instance.capacity) {
                            instance.capacity <<= 1;
                            var newSize = instance.stride * instance.capacity, oldData = instance.data;
                            instance.data = new Uint8Array(newSize), instance.data.set(oldData), instance.vb.resize(newSize);
                        }
                        return void instance.data.set(attrs.buffer, instance.stride * instance.count++);
                    }
                }
                for (var device = this.pass.device, vb = device.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 32 * stride,
                    stride: stride
                }), data = new Uint8Array(32 * stride), vertexBuffers = sourceIA.vertexBuffers.slice(), attributes = sourceIA.attributes.slice(), indexBuffer = sourceIA.indexBuffer || void 0, _i = 0; _i < attrs.list.length; _i++) {
                    var attr = attrs.list[_i], newAttr = {
                        name: attr.name,
                        format: attr.format,
                        stream: vertexBuffers.length,
                        isInstanced: !0
                    };
                    void 0 !== attr.isNormalized && (newAttr.isNormalized = attr.isNormalized), attributes.push(newAttr);
                }
                data.set(attrs.buffer), vertexBuffers.push(vb);
                var ia = device.createInputAssembler({
                    attributes: attributes,
                    vertexBuffers: vertexBuffers,
                    indexBuffer: indexBuffer
                });
                this.instances.push({
                    pso: pso,
                    count: 1,
                    capacity: 32,
                    vb: vb,
                    data: data,
                    ia: ia,
                    stride: stride
                });
            }
        }
    }, {
        key: "uploadBuffers",
        value: function uploadBuffers() {
            for (var i = 0; i < this.instances.length; ++i) {
                var instance = this.instances[i];
                instance.count && (instance.ia.instanceCount = instance.count, instance.vb.update(instance.data));
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var i = 0; i < this.instances.length; ++i) {
                this.instances[i].count = 0;
            }
        }
    } ]), InstancedBuffer;
}(), getPhaseID = (phases = new Map, phaseNum = 0, function(phaseName) {
    return "number" == typeof phaseName ? phaseName : (phases.has(phaseName) || (phases.set(phaseName, 1 << phaseNum), 
    phaseNum++), phases.get(phaseName));
}), _bfInfo = {
    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
    size: 0,
    usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST
}, _blInfo = {
    bindings: null
}, _plInfo = {
    layouts: null
}, _psoInfo = {
    primitive: 0,
    shader: null,
    inputState: null,
    rasterizerState: null,
    depthStencilState: null,
    blendState: null,
    dynamicStates: null,
    layout: null,
    renderPass: null,
    hash: 0,
    program: "",
    defines: null,
    stage: 0
}, Pass = function() {
    function Pass(device) {
        _classCallCheck(this, Pass), this._buffers = {}, this._samplers = {}, this._textureViews = {}, 
        this._resources = [], this._phase = getPhaseID("default"), this._idxInTech = 0, 
        this._programName = "", this._priority = RenderPriority.DEFAULT, this._primitive = exports.GFXPrimitiveMode.TRIANGLE_LIST, 
        this._stage = RenderPassStage.DEFAULT, this._bindings = [], this._inputState = new GFXInputState, 
        this._bs = new GFXBlendState, this._dss = new GFXDepthStencilState, this._rs = new GFXRasterizerState, 
        this._dynamicStates = [], this._dynamics = {}, this._customizations = [], this._handleMap = {}, 
        this._blocks = [], this._shaderInfo = null, this._defines = {}, this._properties = {}, 
        this._hash = 0, this._device = void 0, this._renderPass = null, this._shader = null, 
        this._batchedBuffer = null, this._instancedBuffer = null, this._device = device;
    }
    return _createClass(Pass, null, [ {
        key: "fillinPipelineInfo",
        value: function fillinPipelineInfo(target, info) {
            void 0 !== info.priority && (target._priority = info.priority), void 0 !== info.primitive && (target._primitive = info.primitive), 
            void 0 !== info.stage && (target._stage = info.stage), void 0 !== info.dynamicStates && (target._dynamicStates = info.dynamicStates), 
            info.customizations && (target._customizations = info.customizations), info.phase && (target._phase = getPhaseID(info.phase));
            var bs = target._bs;
            if (info.blendState) {
                var bsInfo = Object.assign({}, info.blendState);
                bsInfo.targets && bsInfo.targets.forEach((function(t, i) {
                    return Object.assign(bs.targets[i] || (bs.targets[i] = new GFXBlendTarget), t);
                })), delete bsInfo.targets, Object.assign(bs, bsInfo);
            }
            Object.assign(target._rs, info.rasterizerState), Object.assign(target._dss, info.depthStencilState);
        }
    }, {
        key: "getPSOHash",
        value: function getPSOHash(psoInfo) {
            var res = programLib.getKey(psoInfo.program, psoInfo.defines) + "," + psoInfo.primitive;
            return res += function serializeBlendState(bs) {
                for (var _step6, res = ",bs,".concat(bs.isA2C, ",").concat(bs.blendColor), _iterator6 = _createForOfIteratorHelperLoose(bs.targets); !(_step6 = _iterator6()).done; ) {
                    var t = _step6.value;
                    res += ",bt,".concat(t.blend, ",").concat(t.blendEq, ",").concat(t.blendAlphaEq, ",").concat(t.blendColorMask), 
                    res += ",".concat(t.blendSrc, ",").concat(t.blendDst, ",").concat(t.blendSrcAlpha, ",").concat(t.blendDstAlpha);
                }
                return res;
            }(psoInfo.blendState), res += function serializeDepthStencilState(dss) {
                var res = ",dss,".concat(dss.depthTest, ",").concat(dss.depthWrite, ",").concat(dss.depthFunc);
                return res += ",".concat(dss.stencilTestFront, ",").concat(dss.stencilFuncFront, ",").concat(dss.stencilRefFront, ",").concat(dss.stencilReadMaskFront), 
                res += ",".concat(dss.stencilFailOpFront, ",").concat(dss.stencilZFailOpFront, ",").concat(dss.stencilPassOpFront, ",").concat(dss.stencilWriteMaskFront), 
                res += ",".concat(dss.stencilTestBack, ",").concat(dss.stencilFuncBack, ",").concat(dss.stencilRefBack, ",").concat(dss.stencilReadMaskBack), 
                res += ",".concat(dss.stencilFailOpBack, ",").concat(dss.stencilZFailOpBack, ",").concat(dss.stencilPassOpBack, ",").concat(dss.stencilWriteMaskBack);
            }(psoInfo.depthStencilState), res += function serializeRasterizerState(rs) {
                return ",rs," + rs.cullMode + "," + rs.depthBias + "," + rs.isFrontFaceCCW;
            }(psoInfo.rasterizerState), murmurhash2_32_gc(res += function serializeDynamicState(dynamicStates) {
                var res = ",ds";
                for (var ds in dynamicStates) res += "," + ds;
                return res;
            }(psoInfo.dynamicStates), 666);
        }
    } ]), _createClass(Pass, [ {
        key: "initialize",
        value: function initialize(info) {
            this._doInit(info), this.resetUBOs(), this.resetTextures();
        }
    }, {
        key: "getHandle",
        value: function getHandle(name) {
            var offset = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, targetType = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : exports.GFXType.UNKNOWN, handle = this._handleMap[name];
            if (handle) return targetType ? handle = customizeType(handle, targetType) : offset && (handle = customizeType(handle, getTypeFromHandle(handle) - offset)), 
            handle + offset;
        }
    }, {
        key: "getBinding",
        value: function getBinding(name) {
            var handle = this.getHandle(name);
            if (void 0 !== handle) return Pass.getBindingFromHandle(handle);
        }
    }, {
        key: "setUniform",
        value: function setUniform(handle, value) {
            var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), ofs = Pass.getOffsetFromHandle(handle), block = this._blocks[binding];
            type2writer[type](block.view, value, ofs), block.dirty = !0;
        }
    }, {
        key: "getUniform",
        value: function getUniform(handle, out) {
            var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), ofs = Pass.getOffsetFromHandle(handle), block = this._blocks[binding];
            return type2reader[type](block.view, out, ofs);
        }
    }, {
        key: "setUniformArray",
        value: function setUniformArray(handle, value) {
            for (var binding = Pass.getBindingFromHandle(handle), type = Pass.getTypeFromHandle(handle), stride = GFXGetTypeSize(type) >> 2, block = this._blocks[binding], ofs = Pass.getOffsetFromHandle(handle), i = 0; i < value.length; i++, 
            ofs += stride) null !== value[i] && type2writer[type](block.view, value[i], ofs);
            block.dirty = !0;
        }
    }, {
        key: "bindBuffer",
        value: function bindBuffer(binding, value) {
            if (this._buffers[binding] !== value) {
                this._buffers[binding] = value;
                for (var len = this._resources.length, i = 0; i < len; i++) {
                    this._resources[i].bindingLayout.bindBuffer(binding, value);
                }
            }
        }
    }, {
        key: "bindTextureView",
        value: function bindTextureView(binding, value) {
            if (this._textureViews[binding] !== value) {
                this._textureViews[binding] = value;
                for (var len = this._resources.length, i = 0; i < len; i++) {
                    this._resources[i].bindingLayout.bindTextureView(binding, value);
                }
            }
        }
    }, {
        key: "bindSampler",
        value: function bindSampler(binding, value) {
            if (this._samplers[binding] !== value) {
                this._samplers[binding] = value;
                for (var len = this._resources.length, i = 0; i < len; i++) {
                    this._resources[i].bindingLayout.bindSampler(binding, value);
                }
            }
        }
    }, {
        key: "setDynamicState",
        value: function setDynamicState(state, value) {
            var ds = this._dynamics[state];
            ds && ds.value === value || (ds.value = value, ds.dirty = !0);
        }
    }, {
        key: "overridePipelineStates",
        value: function overridePipelineStates(original, overrides) {
            console.warn("base pass cannot override states, please use pass instance instead.");
        }
    }, {
        key: "update",
        value: function update() {
            for (var len = this._blocks.length, i = 0; i < len; i++) {
                var block = this._blocks[i];
                block.dirty && (this._buffers[i].update(block.view), block.dirty = !1);
            }
            for (var source = cc.director.root.pipeline.globalBindings, target = this._shaderInfo.builtins.globals, samplerLen = target.samplers.length, _i = 0; _i < samplerLen; _i++) {
                var s = target.samplers[_i], info = source.get(s.name);
                info.sampler && this.bindSampler(info.samplerInfo.binding, info.sampler), this.bindTextureView(info.samplerInfo.binding, info.textureView);
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._shaderInfo.blocks); !(_step = _iterator()).done; ) {
                var u = _step.value;
                isBuiltinBinding(u.binding) || this._buffers[u.binding].destroy();
            }
            this._buffers = {}, this._samplers = {}, this._textureViews = {}, this._instancedBuffer && (this._instancedBuffer.destroy(), 
            this._instancedBuffer = null), this._batchedBuffer && (this._batchedBuffer.destroy(), 
            this._batchedBuffer = null);
        }
    }, {
        key: "resetUniform",
        value: function resetUniform(name) {
            var handle = this.getHandle(name), type = Pass.getTypeFromHandle(handle), binding = Pass.getBindingFromHandle(handle), ofs = Pass.getOffsetFromHandle(handle), block = this._blocks[binding], info = this._properties[name], value = info && info.value || getDefaultFromType(type);
            type2writer[type](block.view, value, ofs), block.dirty = !0;
        }
    }, {
        key: "resetTexture",
        value: function resetTexture(name) {
            var handle = this.getHandle(name), type = Pass.getTypeFromHandle(handle), binding = Pass.getBindingFromHandle(handle), info = this._properties[name], value = info && info.value, texName = value ? value + "-texture" : getDefaultFromType(type), texture = builtinResMgr.get(texName), textureView = texture && texture.getGFXTextureView(), samplerHash = info && void 0 !== info.samplerHash ? info.samplerHash : texture.getSamplerHash(), sampler = samplerLib.getSampler(this._device, samplerHash);
            this._textureViews[binding] = textureView, this._samplers[binding] = sampler;
            for (var i = 0; i < this._resources.length; i++) {
                var res = this._resources[i];
                res.bindingLayout.bindSampler(binding, sampler), res.bindingLayout.bindTextureView(binding, textureView);
            }
        }
    }, {
        key: "resetUBOs",
        value: function resetUBOs() {
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._shaderInfo.blocks); !(_step2 = _iterator2()).done; ) {
                var u = _step2.value;
                if (!isBuiltinBinding(u.binding)) {
                    var block = this._blocks[u.binding];
                    if (block) {
                        for (var ofs = 0, i = 0; i < u.members.length; i++) {
                            for (var cur = u.members[i], info = this._properties[cur.name], givenDefault = info && info.value, value = givenDefault || getDefaultFromType(cur.type), size = (GFXGetTypeSize(cur.type) >> 2) * cur.count, j = 0; j + value.length <= size; j += value.length) block.view.set(value, ofs + j);
                            ofs += size;
                        }
                        block.dirty = !0;
                    }
                }
            }
        }
    }, {
        key: "resetTextures",
        value: function resetTextures() {
            for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._shaderInfo.samplers); !(_step3 = _iterator3()).done; ) {
                var u = _step3.value;
                isBuiltinBinding(u.binding) || this.resetTexture(u.name);
            }
        }
    }, {
        key: "tryCompile",
        value: function tryCompile() {
            var pipeline = cc.director.root.pipeline;
            if (!pipeline) return this._hash = Pass.getPSOHash(this), null;
            if (this._dynamicBatchingSync(), this._renderPass = pipeline.getRenderPass(this._stage), 
            !this._renderPass) return console.warn("illegal pass stage."), !1;
            Object.assign(this._defines, pipeline.macros);
            var key = programLib.getKey(this._programName, this._defines), res = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline, key);
            return res.shader ? (this._shader = res.shader, this._bindings = res.bindings, this._inputState = res.inputState, 
            this._hash = Pass.getPSOHash(this), !0) : (console.warn("create shader ".concat(this._programName, " failed")), 
            !1);
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState(patches) {
            if (!(this._renderPass && this._shader && this._bindings.length || this.tryCompile())) return console.warn("pass resources not complete, create PSO failed"), 
            null;
            var res = patches ? this._getShaderWithBuiltinMacroPatches(patches) : null, shader = res && res.shader || this._shader;
            _blInfo.bindings = res && res.bindings || this._bindings;
            var bindingLayout = this._device.createBindingLayout(_blInfo);
            for (var b in this._buffers) bindingLayout.bindBuffer(parseInt(b), this._buffers[b]);
            for (var s in this._samplers) bindingLayout.bindSampler(parseInt(s), this._samplers[s]);
            for (var t in this._textureViews) bindingLayout.bindTextureView(parseInt(t), this._textureViews[t]);
            for (var _step4, source = cc.director.root.pipeline.globalBindings, target = this._shaderInfo.builtins.globals, _iterator4 = _createForOfIteratorHelperLoose(target.blocks); !(_step4 = _iterator4()).done; ) {
                var _b = _step4.value, info = source.get(_b.name);
                info && info.type === exports.GFXBindingType.UNIFORM_BUFFER ? bindingLayout.bindBuffer(info.blockInfo.binding, info.buffer) : console.warn("builtin UBO '".concat(_b.name, "' not available!"));
            }
            for (var _step5, _iterator5 = _createForOfIteratorHelperLoose(target.samplers); !(_step5 = _iterator5()).done; ) {
                var _s = _step5.value, _info = source.get(_s.name);
                _info && _info.type === exports.GFXBindingType.SAMPLER ? (_info.sampler && bindingLayout.bindSampler(_info.samplerInfo.binding, _info.sampler), 
                bindingLayout.bindTextureView(_info.samplerInfo.binding, _info.textureView)) : console.warn("builtin texture '".concat(_s.name, "' not available!"));
            }
            _plInfo.layouts = [ bindingLayout ];
            var pipelineLayout = this._device.createPipelineLayout(_plInfo);
            _psoInfo.inputState = res && res.inputState || this._inputState, _psoInfo.primitive = this._primitive, 
            _psoInfo.shader = shader, _psoInfo.rasterizerState = this._rs, _psoInfo.depthStencilState = this._dss, 
            _psoInfo.blendState = this._bs, _psoInfo.dynamicStates = this._dynamicStates, _psoInfo.layout = pipelineLayout, 
            _psoInfo.renderPass = this._renderPass, _psoInfo.program = this._programName, _psoInfo.defines = this._defines, 
            _psoInfo.stage = this._stage, _psoInfo.hash = this._hash;
            var pipelineState = this._device.createPipelineState(_psoInfo);
            return this._resources.push({
                bindingLayout: bindingLayout,
                pipelineLayout: pipelineLayout,
                pipelineState: pipelineState
            }), pipelineState;
        }
    }, {
        key: "destroyPipelineState",
        value: function destroyPipelineState(pipelineStates) {
            var idx = this._resources.findIndex((function(res) {
                return res.pipelineState === pipelineStates;
            }));
            if (idx >= 0) {
                var _this$_resources$idx = this._resources[idx], bl = _this$_resources$idx.bindingLayout, pl = _this$_resources$idx.pipelineLayout, ps = _this$_resources$idx.pipelineState;
                bl.destroy(), pl.destroy(), ps.destroy(), this._resources.splice(idx, 1);
            }
        }
    }, {
        key: "beginChangeStatesSilently",
        value: function beginChangeStatesSilently() {}
    }, {
        key: "endChangeStatesSilently",
        value: function endChangeStatesSilently() {}
    }, {
        key: "_doInit",
        value: function _doInit(info) {
            var copyDefines = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            this._idxInTech = info.idxInTech, this._programName = info.program, this._defines = copyDefines ? Object.assign({}, info.defines) : info.defines, 
            this._shaderInfo = programLib.getTemplate(info.program), this._properties = info.properties || this._properties;
            var device = this._device;
            Pass.fillinPipelineInfo(this, info), info.stateOverrides && Pass.fillinPipelineInfo(this, info.stateOverrides);
            for (var blocks = this._shaderInfo.blocks, i = 0; i < blocks.length; i++) {
                var _blocks$i = blocks[i], size = _blocks$i.size, binding = _blocks$i.binding;
                if (!isBuiltinBinding(binding)) {
                    _bfInfo.size = 16 * Math.ceil(size / 16), this._buffers[binding] = device.createBuffer(_bfInfo);
                    var buffer = new ArrayBuffer(size);
                    this._blocks[binding] = {
                        view: new Float32Array(buffer),
                        dirty: !1
                    };
                }
            }
            var directHandleMap = this._handleMap = this._shaderInfo.handleMap, indirectHandleMap = {};
            for (var name in this._properties) {
                var prop = this._properties[name];
                prop.handleInfo && (indirectHandleMap[name] = this.getHandle.apply(this, prop.handleInfo));
            }
            Object.assign(directHandleMap, indirectHandleMap), this.tryCompile();
        }
    }, {
        key: "_dynamicBatchingSync",
        value: function _dynamicBatchingSync() {
            this._defines.USE_INSTANCING ? this._device.hasFeature(exports.GFXFeature.INSTANCED_ARRAYS) ? this._instancedBuffer || (this._instancedBuffer = new InstancedBuffer(this)) : this._defines.USE_INSTANCING = !1 : this._defines.USE_BATCHING && (this._batchedBuffer || (this._batchedBuffer = new BatchedBuffer(this))), 
            !this._defines.USE_INSTANCING && this._instancedBuffer && (this._instancedBuffer.destroy(), 
            this._instancedBuffer = null), !this._defines.USE_BATCHING && this._batchedBuffer && (this._batchedBuffer.destroy(), 
            this._batchedBuffer = null);
        }
    }, {
        key: "_getShaderWithBuiltinMacroPatches",
        value: function _getShaderWithBuiltinMacroPatches(patches) {
            var pipeline = cc.director.root.pipeline;
            if (!pipeline) return null;
            for (var _i2 = 0; _i2 < patches.length; _i2++) {
                var patch = patches[_i2];
                this._defines[patch.name] = patch.value;
            }
            for (var res = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline), _i3 = 0; _i3 < patches.length; _i3++) {
                var _patch = patches[_i3];
                delete this._defines[_patch.name];
            }
            return res;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        }
    }, {
        key: "primitive",
        get: function get() {
            return this._primitive;
        }
    }, {
        key: "stage",
        get: function get() {
            return this._stage;
        }
    }, {
        key: "inputState",
        get: function get() {
            return this._inputState;
        }
    }, {
        key: "rasterizerState",
        get: function get() {
            return this._rs;
        }
    }, {
        key: "depthStencilState",
        get: function get() {
            return this._dss;
        }
    }, {
        key: "blendState",
        get: function get() {
            return this._bs;
        }
    }, {
        key: "dynamicStates",
        get: function get() {
            return this._dynamicStates;
        }
    }, {
        key: "customizations",
        get: function get() {
            return this._customizations;
        }
    }, {
        key: "phase",
        get: function get() {
            return this._phase;
        }
    }, {
        key: "device",
        get: function get() {
            return this._device;
        }
    }, {
        key: "shaderInfo",
        get: function get() {
            return this._shaderInfo;
        }
    }, {
        key: "program",
        get: function get() {
            return this._programName;
        }
    }, {
        key: "properties",
        get: function get() {
            return this._properties;
        }
    }, {
        key: "defines",
        get: function get() {
            return this._defines;
        }
    }, {
        key: "idxInTech",
        get: function get() {
            return this._idxInTech;
        }
    }, {
        key: "bindings",
        get: function get() {
            return this._bindings;
        }
    }, {
        key: "shader",
        get: function get() {
            return this._shader;
        }
    }, {
        key: "renderPass",
        get: function get() {
            return this._renderPass;
        }
    }, {
        key: "dynamics",
        get: function get() {
            return this._dynamics;
        }
    }, {
        key: "batchedBuffer",
        get: function get() {
            return this._batchedBuffer;
        }
    }, {
        key: "instancedBuffer",
        get: function get() {
            return this._instancedBuffer;
        }
    }, {
        key: "blocks",
        get: function get() {
            return this._blocks;
        }
    }, {
        key: "hash",
        get: function get() {
            return this._hash;
        }
    } ]), Pass;
}();

Pass.getBindingTypeFromHandle = getBindingTypeFromHandle, Pass.getTypeFromHandle = getTypeFromHandle, 
Pass.getBindingFromHandle = getBindingFromHandle, Pass.getOffsetFromHandle = getOffsetFromHandle;

var _dec$c, _dec2$4, _class$c, _class2$9, _descriptor$8, _descriptor2$4, _descriptor3$4, _descriptor4$2, _descriptor5$2, effects$1 = {}, EffectAsset = ccclass("cc.EffectAsset")((_temp$b = _class3$5 = function(_Asset) {
    function EffectAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, EffectAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EffectAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "techniques", _descriptor$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "shaders", _descriptor2$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "combinations", _descriptor3$3, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(EffectAsset, Asset), _createClass(EffectAsset, [ {
        key: "onLoaded",
        value: function onLoaded() {
            this.shaders.forEach((function(s) {
                return programLib.define(s);
            })), cc.game.once(cc.Game.EVENT_ENGINE_INITED, this._precompile, this), EffectAsset.register(this);
        }
    }, {
        key: "_precompile",
        value: function _precompile() {
            for (var _this2 = this, root = cc.director.root, _loop = function _loop(i) {
                var shader = _this2.shaders[i], combination = _this2.combinations[i];
                if (!combination) return "continue";
                Object.keys(combination).reduce((function(out, name) {
                    return out.reduce((function(acc, cur) {
                        var choices = combination[name], next = [ cur ].concat(_toConsumableArray(Array(choices.length - 1)).map((function() {
                            return Object.assign({}, cur);
                        })));
                        return next.forEach((function(defines, idx) {
                            return defines[name] = choices[idx];
                        })), acc.concat(next);
                    }), []);
                }), [ {} ]).forEach((function(defines) {
                    return programLib.getGFXShader(root.device, shader.name, defines, root.pipeline);
                }));
            }, i = 0; i < this.shaders.length; i++) _loop(i);
        }
    } ], [ {
        key: "register",
        value: function register(asset) {
            effects$1[asset.name] = asset;
        }
    }, {
        key: "remove",
        value: function remove(name) {
            if (effects$1[name]) delete effects$1[name]; else for (var n in effects$1) if (effects$1[n]._uuid === name) return void delete effects$1[n];
        }
    }, {
        key: "get",
        value: function get(name) {
            if (effects$1[name]) return effects$1[name];
            for (var n in effects$1) if (effects$1[n]._uuid === name) return effects$1[n];
            return null;
        }
    }, {
        key: "getAll",
        value: function getAll() {
            return effects$1;
        }
    } ]), EffectAsset;
}(), _class3$5._effects = {}, _descriptor$7 = _applyDecoratedDescriptor((_class2$8 = _temp$b).prototype, "techniques", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$3 = _applyDecoratedDescriptor(_class2$8.prototype, "shaders", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$3 = _applyDecoratedDescriptor(_class2$8.prototype, "combinations", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$b = _class2$8)) || _class$b;

cc.EffectAsset = EffectAsset;

var _class$d, _class2$a, _class3$6, Material = (_dec$c = ccclass("cc.Material"), 
_dec2$4 = property(EffectAsset), _dec$c((_descriptor$8 = _applyDecoratedDescriptor((_class2$9 = function(_Asset) {
    function Material() {
        var _this;
        return _classCallCheck(this, Material), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this)), "_effectAsset", _descriptor$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_techIdx", _descriptor2$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_defines", _descriptor3$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_states", _descriptor4$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_props", _descriptor5$2, _assertThisInitialized(_this)), 
        _this._passes = [], _this._hash = 0, _this.loaded = !1, _this;
    }
    return _inherits(Material, Asset), _createClass(Material, [ {
        key: "effectAsset",
        get: function get() {
            return this._effectAsset;
        }
    }, {
        key: "effectName",
        get: function get() {
            return this._effectAsset ? this._effectAsset.name : "";
        }
    }, {
        key: "technique",
        get: function get() {
            return this._techIdx;
        }
    }, {
        key: "passes",
        get: function get() {
            return this._passes;
        }
    }, {
        key: "hash",
        get: function get() {
            return this._hash;
        }
    }, {
        key: "parent",
        get: function get() {
            return null;
        }
    }, {
        key: "owner",
        get: function get() {
            return null;
        }
    } ], [ {
        key: "getHash",
        value: function getHash(material) {
            for (var _step, hash = 0, _iterator = _createForOfIteratorHelperLoose(material.passes); !(_step = _iterator()).done; ) {
                hash ^= _step.value.hash;
            }
            return hash;
        }
    } ]), _createClass(Material, [ {
        key: "initialize",
        value: function initialize(info) {
            this._defines || (this._defines = []), this._states || (this._states = []), this._props || (this._props = []), 
            void 0 !== info.technique && (this._techIdx = info.technique), info.effectAsset ? this._effectAsset = info.effectAsset : info.effectName && (this._effectAsset = EffectAsset.get(info.effectName)), 
            info.defines && this._prepareInfo(info.defines, this._defines), info.states && this._prepareInfo(info.states, this._states), 
            this._update();
        }
    }, {
        key: "reset",
        value: function reset(info) {
            this.initialize(info);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._doDestroy(), _get(_getPrototypeOf(Material.prototype), "destroy", this).call(this);
        }
    }, {
        key: "recompileShaders",
        value: function recompileShaders(overrides, passIdx) {
            console.warn("Shaders in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.");
        }
    }, {
        key: "overridePipelineStates",
        value: function overridePipelineStates(overrides, passIdx) {
            console.warn("Pipeline states in material asset '" + this.name + "' cannot be modified at runtime, please instantiate the material first.");
        }
    }, {
        key: "onLoaded",
        value: function onLoaded() {
            this._update(), this.loaded = !0, this.emit("load");
        }
    }, {
        key: "resetUniforms",
        value: function resetUniforms() {
            var clearPasses = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            this._props.length = this._passes.length;
            for (var i = 0; i < this._props.length; i++) this._props[i] = {};
            if (clearPasses) for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._passes); !(_step2 = _iterator2()).done; ) {
                var pass = _step2.value;
                pass.resetUBOs(), pass.resetTextures();
            }
        }
    }, {
        key: "setProperty",
        value: function setProperty(name, val, passIdx) {
            var success = !1;
            if (void 0 === passIdx) for (var passes = this._passes, len = passes.length, i = 0; i < len; i++) {
                var pass = passes[i];
                this._uploadProperty(pass, name, val) && (this._props[i][name] = val, success = !0);
            } else {
                if (passIdx >= this._passes.length) return void console.warn("illegal pass index: ".concat(passIdx, "."));
                var _pass = this._passes[passIdx];
                this._uploadProperty(_pass, name, val) && (this._props[passIdx][name] = val, success = !0);
            }
            success || console.warn("illegal property name: ".concat(name, "."));
        }
    }, {
        key: "getProperty",
        value: function getProperty(name, passIdx) {
            if (void 0 === passIdx) for (var propsArray = this._props, len = propsArray.length, i = 0; i < len; i++) {
                var props = propsArray[i];
                for (var p in props) if (p === name) return props[p];
            } else {
                if (passIdx >= this._props.length) return console.warn("illegal pass index: ".concat(passIdx, ".")), 
                null;
                var _props = this._props[passIdx];
                for (var _p in _props) if (_p === name) return _props[_p];
            }
            return null;
        }
    }, {
        key: "copy",
        value: function copy(mat) {
            this._techIdx = mat._techIdx, this._props.length = mat._props.length;
            for (var i = 0; i < mat._props.length; i++) this._props[i] = Object.assign({}, mat._props[i]);
            this._defines.length = mat._defines.length;
            for (var _i = 0; _i < mat._defines.length; _i++) this._defines[_i] = Object.assign({}, mat._defines[_i]);
            this._states.length = mat._states.length;
            for (var _i2 = 0; _i2 < mat._states.length; _i2++) this._states[_i2] = Object.assign({}, mat._states[_i2]);
            this._effectAsset = mat._effectAsset, this._update();
        }
    }, {
        key: "_prepareInfo",
        value: function _prepareInfo(patch, cur) {
            if (!Array.isArray(patch)) {
                var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                patch = Array(len).fill(patch);
            }
            for (var i = 0; i < patch.length; ++i) Object.assign(cur[i] || (cur[i] = {}), patch[i]);
        }
    }, {
        key: "_createPasses",
        value: function _createPasses() {
            var tech = this._effectAsset.techniques[this._techIdx || 0];
            if (!tech) return [];
            for (var passNum = tech.passes.length, passes = [], k = 0; k < passNum; ++k) {
                var passInfo = tech.passes[k], defs = passInfo.defines = this._defines.length > k ? this._defines[k] : {};
                if (!passInfo.switch || defs[passInfo.switch]) {
                    passInfo.stateOverrides = this._states.length > k ? this._states[k] : {}, passInfo.idxInTech = k;
                    var pass = new Pass(cc.director.root.device);
                    pass.initialize(passInfo), passes.push(pass);
                }
            }
            return passes;
        }
    }, {
        key: "_update",
        value: function _update() {
            var _this2 = this, keepProps = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            if (this._effectAsset) {
                if (this._passes && this._passes.length) for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._passes); !(_step3 = _iterator3()).done; ) {
                    var pass = _step3.value;
                    pass.destroy();
                }
                this._passes = this._createPasses();
                var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
                if (this._props.length = totalPasses, keepProps) this._passes.forEach((function(pass, i) {
                    var props = _this2._props[pass.idxInTech];
                    for (var p in props || (props = _this2._props[i] = {}), props) _this2._uploadProperty(pass, p, props[p]);
                })); else for (var i = 0; i < this._props.length; i++) this._props[i] = {};
            } else {
                var missing = builtinResMgr.get("missing-effect-material");
                missing && (this._passes = missing._passes.slice());
            }
            this._hash = Material.getHash(this);
        }
    }, {
        key: "_uploadProperty",
        value: function _uploadProperty(pass, name, val) {
            var handle = pass.getHandle(name);
            if (void 0 === handle) return !1;
            var bindingType = Pass.getBindingTypeFromHandle(handle);
            if (bindingType === exports.GFXBindingType.UNIFORM_BUFFER) Array.isArray(val) ? pass.setUniformArray(handle, val) : null !== val ? pass.setUniform(handle, val) : pass.resetUniform(name); else if (bindingType === exports.GFXBindingType.SAMPLER) {
                var binding = Pass.getBindingFromHandle(handle);
                if (val instanceof GFXTextureView) pass.bindTextureView(binding, val); else if (val instanceof TextureBase || val instanceof SpriteFrame) {
                    var textureView = val.getGFXTextureView();
                    if (!textureView || !textureView.texture.width || !textureView.texture.height) return !1;
                    pass.bindTextureView(binding, textureView), val instanceof TextureBase && pass.bindSampler(binding, samplerLib.getSampler(cc.director.root.device, val.getSamplerHash()));
                } else val || pass.resetTexture(name);
            }
            return !0;
        }
    }, {
        key: "_doDestroy",
        value: function _doDestroy() {
            if (this._passes && this._passes.length) for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._passes); !(_step4 = _iterator4()).done; ) {
                _step4.value.destroy();
            }
            this._effectAsset = null, this._passes.length = 0, this._props.length = 0, this._defines.length = 0, 
            this._states.length = 0;
        }
    } ]), Material;
}()).prototype, "_effectAsset", [ _dec2$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$4 = _applyDecoratedDescriptor(_class2$9.prototype, "_techIdx", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor3$4 = _applyDecoratedDescriptor(_class2$9.prototype, "_defines", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor4$2 = _applyDecoratedDescriptor(_class2$9.prototype, "_states", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor5$2 = _applyDecoratedDescriptor(_class2$9.prototype, "_props", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$c = _class2$9)) || _class$c);

cc.Material = Material;

var Script = ccclass("cc.Script")(_class$d = function(_Asset) {
    function Script() {
        return _classCallCheck(this, Script), _possibleConstructorReturn(this, _getPrototypeOf(Script).apply(this, arguments));
    }
    return _inherits(Script, Asset), Script;
}()) || _class$d;

cc._Script = Script;

var JavaScript = ccclass("cc.JavaScript")(_class2$a = function(_Script) {
    function JavaScript() {
        return _classCallCheck(this, JavaScript), _possibleConstructorReturn(this, _getPrototypeOf(JavaScript).apply(this, arguments));
    }
    return _inherits(JavaScript, Script), JavaScript;
}()) || _class2$a;

cc._JavaScript = JavaScript;

var _dec$e, _dec2$6, _dec3$1, _dec4, _dec5, _dec6, _dec7, _class$e, _class2$b, _descriptor$9, _descriptor2$5, _class3$7, _temp$d, TypeScript = ccclass("cc.TypeScript")(_class3$6 = function(_Script2) {
    function TypeScript() {
        return _classCallCheck(this, TypeScript), _possibleConstructorReturn(this, _getPrototypeOf(TypeScript).apply(this, arguments));
    }
    return _inherits(TypeScript, Script), TypeScript;
}()) || _class3$6;

cc._TypeScript = TypeScript;

var idGenerator$1 = new IDGenerator("Comp"), IsOnLoadCalled$1 = (CCObject.Flags.IsOnEnableCalled, 
CCObject.Flags.IsOnLoadCalled), Component = (_dec$e = ccclass("cc.Component"), _dec2$6 = property({
    visible: !1
}), _dec3$1 = property({
    visible: !1
}), _dec4 = property({
    displayName: "Script",
    type: Script,
    tooltip: void 0
}), _dec5 = property({
    visible: !1
}), _dec6 = property({
    visible: !1
}), _dec7 = property({
    visible: !1
}), _dec$e((_temp$d = _class3$7 = function(_CCObject) {
    function Component() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Component);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Component)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "node", _descriptor$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_enabled", _descriptor2$5, _assertThisInitialized(_this)), 
        _this._sceneGetter = null, _this._id = idGenerator$1.getNewId(), _this;
    }
    return _inherits(Component, CCObject), _createClass(Component, [ {
        key: "_getRenderScene",
        value: function _getRenderScene() {
            return this._sceneGetter ? this._sceneGetter() : this.node.scene._renderScene;
        }
    }, {
        key: "addComponent",
        value: function addComponent(typeOrClassName) {
            return this.node.addComponent(typeOrClassName);
        }
    }, {
        key: "getComponent",
        value: function getComponent(typeOrClassName) {
            return this.node.getComponent(typeOrClassName);
        }
    }, {
        key: "getComponents",
        value: function getComponents(typeOrClassName) {
            return this.node.getComponents(typeOrClassName);
        }
    }, {
        key: "getComponentInChildren",
        value: function getComponentInChildren(typeOrClassName) {
            return this.node.getComponentInChildren(typeOrClassName);
        }
    }, {
        key: "getComponentsInChildren",
        value: function getComponentsInChildren(typeOrClassName) {
            return this.node.getComponentsInChildren(typeOrClassName);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            _get(_getPrototypeOf(Component.prototype), "destroy", this).call(this) && this._enabled && this.node.activeInHierarchy && cc.director._compScheduler.disableComp(this);
        }
    }, {
        key: "_onPreDestroy",
        value: function _onPreDestroy() {
            this.unscheduleAllCallbacks(), cc.director._nodeActivator.destroyComp(this), this.node._removeComponent(this);
        }
    }, {
        key: "_instantiate",
        value: function _instantiate(cloned) {
            return cloned || (cloned = cc.instantiate._clone(this, this)), cloned.node = null, 
            cloned;
        }
    }, {
        key: "schedule",
        value: function schedule(callback) {
            var interval = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, repeat = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : cc.macro.REPEAT_FOREVER, delay = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            cc.assertID(callback, 1619), cc.assertID(interval >= 0, 1620), interval = interval || 0, 
            repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat, delay = delay || 0;
            var scheduler = cc.director.getScheduler(), paused = scheduler.isTargetPaused(this);
            scheduler.schedule(callback, this, interval, repeat, delay, paused);
        }
    }, {
        key: "scheduleOnce",
        value: function scheduleOnce(callback) {
            var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            this.schedule(callback, 0, 0, delay);
        }
    }, {
        key: "unschedule",
        value: function unschedule(callback_fn) {
            callback_fn && cc.director.getScheduler().unschedule(callback_fn, this);
        }
    }, {
        key: "unscheduleAllCallbacks",
        value: function unscheduleAllCallbacks() {
            cc.director.getScheduler().unscheduleAllForTarget(this);
        }
    }, {
        key: "name",
        get: function get() {
            if (this._name) return this._name;
            var className = getClassName(this), trimLeft = className.lastIndexOf(".");
            return trimLeft >= 0 && (className = className.slice(trimLeft + 1)), this.node.name + "<" + className + ">";
        },
        set: function set(value) {
            this._name = value;
        }
    }, {
        key: "uuid",
        get: function get() {
            return this._id;
        }
    }, {
        key: "__scriptAsset",
        get: function get() {
            return null;
        }
    }, {
        key: "enabled",
        get: function get() {
            return this._enabled;
        },
        set: function set(value) {
            if (this._enabled !== value && (this._enabled = value, this.node.activeInHierarchy)) {
                var compScheduler = cc.director._compScheduler;
                value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
            }
        }
    }, {
        key: "enabledInHierarchy",
        get: function get() {
            return this._enabled && this.node && this.node.activeInHierarchy;
        }
    }, {
        key: "_isOnLoadCalled",
        get: function get() {
            return this._objFlags & IsOnLoadCalled$1;
        }
    } ]), Component;
}(), _class3$7.system = null, _applyDecoratedDescriptor((_class2$b = _temp$d).prototype, "name", [ _dec2$6 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "name"), _class2$b.prototype), 
_applyDecoratedDescriptor(_class2$b.prototype, "uuid", [ _dec3$1 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "uuid"), _class2$b.prototype), 
_applyDecoratedDescriptor(_class2$b.prototype, "__scriptAsset", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "__scriptAsset"), _class2$b.prototype), 
_applyDecoratedDescriptor(_class2$b.prototype, "enabled", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "enabled"), _class2$b.prototype), 
_applyDecoratedDescriptor(_class2$b.prototype, "enabledInHierarchy", [ _dec6 ], Object.getOwnPropertyDescriptor(_class2$b.prototype, "enabledInHierarchy"), _class2$b.prototype), 
_descriptor$9 = _applyDecoratedDescriptor(_class2$b.prototype, "node", [ _dec7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$5 = _applyDecoratedDescriptor(_class2$b.prototype, "_enabled", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _class$e = _class2$b)) || _class$e), proto = Component.prototype;

proto.update = null, proto.lateUpdate = null, proto.__preload = null, proto.onLoad = null, 
proto.start = null, proto.onEnable = null, proto.onDisable = null, proto.onDestroy = null, 
proto.onFocusInEditor = null, proto.onLostFocusInEditor = null, proto.resetInEditor = null, 
proto._getLocalBounds = null, proto.onRestore = null, Component._requireComponent = null, 
Component._executionOrder = 0, value(Component, "_registerEditorProps", (function(cls, props) {
    var reqComp = props.requireComponent;
    reqComp && (cls._requireComponent = reqComp);
    var order = props.executionOrder;
    order && "number" == typeof order && (cls._executionOrder = order);
})), cc.Component = Component;

var _dec$f, _dec2$7, _dec3$2, _dec4$1, _class$f, _class2$c, _descriptor$a, _descriptor2$6, _dec$g, _dec2$8, _dec3$3, _dec4$2, _class$g, _class2$d, _descriptor$b, _descriptor2$7, _descriptor3$5, _descriptor4$3, _descriptor5$3, _descriptor6$1, _dec5$1, _dec6$1, _dec7$1, _dec8, _dec9, _dec10, _dec11, _class4, _class5, _descriptor7$1, _descriptor8$1, _descriptor9$1, _descriptor10$1, _class6, _temp2, PassInstance = function(_Pass) {
    function PassInstance(parent, owner) {
        var _this;
        _classCallCheck(this, PassInstance), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PassInstance).call(this, parent.device)))._parent = void 0, 
        _this._owner = void 0, _this._dontNotify = !1, _this._parent = parent, _this._owner = owner, 
        _this._doInit(_this._parent, !0);
        for (var _step, _iterator = _createForOfIteratorHelperLoose(_this._shaderInfo.blocks); !(_step = _iterator()).done; ) {
            var u = _step.value;
            if (!isBuiltinBinding(u.binding)) {
                var block = _this._blocks[u.binding], parentBlock = _this._parent.blocks[u.binding];
                block.view.set(parentBlock.view), block.dirty = !0;
            }
        }
        for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(_this._shaderInfo.samplers); !(_step2 = _iterator2()).done; ) {
            var _u = _step2.value;
            isBuiltinBinding(_u.binding) || (_this._textureViews[_u.binding] = _this._parent._textureViews[_u.binding], 
            _this._samplers[_u.binding] = _this._parent._samplers[_u.binding]);
        }
        return _this;
    }
    return _inherits(PassInstance, Pass), _createClass(PassInstance, [ {
        key: "parent",
        get: function get() {
            return this._parent;
        }
    } ]), _createClass(PassInstance, [ {
        key: "overridePipelineStates",
        value: function overridePipelineStates(original, overrides) {
            this._bs = new GFXBlendState, this._dss = new GFXDepthStencilState, this._rs = new GFXRasterizerState, 
            Pass.fillinPipelineInfo(this, original), Pass.fillinPipelineInfo(this, overrides), 
            this._onStateChange();
        }
    }, {
        key: "tryCompile",
        value: function tryCompile(defineOverrides) {
            if (defineOverrides && !assignDefines(this._defines, defineOverrides)) return !1;
            var res = _get(_getPrototypeOf(PassInstance.prototype), "tryCompile", this).call(this);
            return this._onStateChange(), res;
        }
    }, {
        key: "beginChangeStatesSilently",
        value: function beginChangeStatesSilently() {
            this._dontNotify = !0;
        }
    }, {
        key: "endChangeStatesSilently",
        value: function endChangeStatesSilently() {
            this._dontNotify = !1;
        }
    }, {
        key: "_dynamicBatchingSync",
        value: function _dynamicBatchingSync() {
            this._defines.USE_BATCHING = this._defines.USE_INSTANCING = !1;
        }
    }, {
        key: "_onStateChange",
        value: function _onStateChange() {
            this._hash = Pass.getPSOHash(this), this._owner.onPassStateChange(this._dontNotify);
        }
    } ]), PassInstance;
}(), MaterialInstance = function(_Material) {
    function MaterialInstance(info) {
        var _this;
        return _classCallCheck(this, MaterialInstance), (_this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialInstance).call(this)))._passes = [], 
        _this._parent = void 0, _this._owner = void 0, _this._subModelIdx = 0, _this._parent = info.parent, 
        _this._owner = info.owner || null, _this._subModelIdx = info.subModelIdx || 0, _this.copy(_this._parent), 
        _this;
    }
    return _inherits(MaterialInstance, Material), _createClass(MaterialInstance, [ {
        key: "parent",
        get: function get() {
            return this._parent;
        }
    }, {
        key: "owner",
        get: function get() {
            return this._owner;
        }
    } ]), _createClass(MaterialInstance, [ {
        key: "recompileShaders",
        value: function recompileShaders(overrides, passIdx) {
            if (this._passes && this.effectAsset) if (void 0 === passIdx) for (var _step, _iterator = _createForOfIteratorHelperLoose(this._passes); !(_step = _iterator()).done; ) {
                _step.value.tryCompile(overrides);
            } else this._passes[passIdx].tryCompile(overrides);
        }
    }, {
        key: "overridePipelineStates",
        value: function overridePipelineStates(overrides, passIdx) {
            if (this._passes && this.effectAsset) {
                var passInfos = this.effectAsset.techniques[this.technique].passes;
                if (void 0 === passIdx) for (var i = 0; i < this._passes.length; i++) {
                    var pass = this._passes[i];
                    this._states[i] = overrides, pass.overridePipelineStates(passInfos[pass.idxInTech], overrides);
                } else this._states[passIdx] = overrides, this._passes[passIdx].overridePipelineStates(passInfos[passIdx], overrides);
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return this._doDestroy(), !0;
        }
    }, {
        key: "onPassStateChange",
        value: function onPassStateChange(dontNotify) {
            this._hash = Material.getHash(this), !dontNotify && this._owner && this._owner._onRebuildPSO(this._subModelIdx, this);
        }
    }, {
        key: "_createPasses",
        value: function _createPasses() {
            var passes = [], parentPasses = this._parent.passes;
            if (!parentPasses) return passes;
            for (var k = 0; k < parentPasses.length; ++k) passes.push(new PassInstance(parentPasses[k], this));
            return passes;
        }
    } ]), MaterialInstance;
}(), _matInsInfo = {
    parent: null,
    owner: null,
    subModelIdx: 0
}, RenderableComponent = (_dec$f = ccclass("cc.RenderableComponent"), _dec2$7 = property({
    type: [ Material ]
}), _dec3$2 = property({
    visible: !1
}), _dec4$1 = property({
    type: Material,
    displayName: "Materials"
}), _dec$f((_descriptor$a = _applyDecoratedDescriptor((_class2$c = function(_Component) {
    function RenderableComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, RenderableComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderableComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_materials", _descriptor$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_visFlags", _descriptor2$6, _assertThisInitialized(_this)), 
        _this._materialInstances = [], _this._models = [], _this;
    }
    return _inherits(RenderableComponent, Component), _createClass(RenderableComponent, [ {
        key: "getMaterial",
        value: function getMaterial(idx) {
            return idx < 0 || idx >= this._materials.length ? null : this._materials[idx];
        }
    }, {
        key: "setMaterial",
        value: function setMaterial(material, index) {
            material && material instanceof MaterialInstance && console.error("Can't set a material instance to a sharedMaterial slot"), 
            this._materials[index] = material;
            var inst = this._materialInstances[index];
            inst ? inst.parent !== this._materials[index] && (inst.destroy(), this._materialInstances[index] = null, 
            this._onMaterialModified(index, this._materials[index])) : this._onMaterialModified(index, this._materials[index]);
        }
    }, {
        key: "getMaterialInstance",
        value: function getMaterialInstance(idx) {
            if (!this._materials[idx]) return null;
            if (!this._materialInstances[idx]) {
                _matInsInfo.parent = this._materials[idx], _matInsInfo.owner = this, _matInsInfo.subModelIdx = idx;
                var instantiated = new MaterialInstance(_matInsInfo);
                this.setMaterialInstance(idx, instantiated);
            }
            return this._materialInstances[idx];
        }
    }, {
        key: "setMaterialInstance",
        value: function setMaterialInstance(index, matInst) {
            matInst && matInst.parent ? matInst !== this._materialInstances[index] && (this._materialInstances[index] = matInst, 
            this._onMaterialModified(index, matInst)) : matInst !== this._materials[index] && this.setMaterial(matInst, index);
        }
    }, {
        key: "getRenderMaterial",
        value: function getRenderMaterial(index) {
            return this._materialInstances[index] || this._materials[index];
        }
    }, {
        key: "_collectModels",
        value: function _collectModels() {
            return this._models;
        }
    }, {
        key: "_attachToScene",
        value: function _attachToScene() {}
    }, {
        key: "_detachFromScene",
        value: function _detachFromScene() {}
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(index, material) {}
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(index, material) {}
    }, {
        key: "_clearMaterials",
        value: function _clearMaterials() {}
    }, {
        key: "_onVisibilityChange",
        value: function _onVisibilityChange(val) {}
    }, {
        key: "visibility",
        get: function get() {
            return this._visFlags;
        },
        set: function set(val) {
            this._visFlags = val, this._onVisibilityChange(val);
        }
    }, {
        key: "sharedMaterials",
        get: function get() {
            return this._materials;
        },
        set: function set(val) {
            for (var i = 0; i < val.length; i++) val[i] !== this._materials[i] && this.setMaterial(val[i], i);
            if (val.length < this._materials.length) {
                for (var _i = val.length; _i < this._materials.length; _i++) this.setMaterial(null, _i);
                this._materials.splice(val.length);
            }
        }
    }, {
        key: "materials",
        get: function get() {
            for (var i = 0; i < this._materials.length; i++) this._materialInstances[i] = this.getMaterialInstance(i);
            return this._materialInstances;
        },
        set: function set(val) {
            var dLen = val.length - this._materials.length;
            if (dLen > 0) this._materials.length = val.length, this._materialInstances.length = val.length; else if (dLen < 0) for (var i = this._materials.length - dLen; i < this._materials.length; ++i) this.setMaterialInstance(i, null);
            for (var _i2 = 0; _i2 < this._materialInstances.length; _i2++) this._materialInstances[_i2] != val[_i2] && this.setMaterialInstance(_i2, val[_i2]);
        }
    }, {
        key: "sharedMaterial",
        get: function get() {
            return this.getMaterial(0);
        }
    }, {
        key: "material",
        get: function get() {
            return this.getMaterialInstance(0);
        },
        set: function set(val) {
            1 === this._materials.length && this._materials[0] === val || this.setMaterialInstance(0, val);
        }
    } ]), RenderableComponent;
}()).prototype, "_materials", [ _dec2$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$6 = _applyDecoratedDescriptor(_class2$c.prototype, "_visFlags", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Layers.Enum.NONE;
    }
}), _applyDecoratedDescriptor(_class2$c.prototype, "visibility", [ _dec3$2 ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "visibility"), _class2$c.prototype), 
_applyDecoratedDescriptor(_class2$c.prototype, "sharedMaterials", [ _dec4$1 ], Object.getOwnPropertyDescriptor(_class2$c.prototype, "sharedMaterials"), _class2$c.prototype), 
_class$f = _class2$c)) || _class$f), ModelShadowCastingMode = Enum({
    OFF: 0,
    ON: 1
}), ModelLightmapSettings = (_dec$g = ccclass("cc.ModelLightmapSettings"), _dec2$8 = property({
    visible: !1
}), _dec3$3 = property({
    visible: !1
}), _dec4$2 = property({
    formerlySerializedAs: "_recieveShadow"
}), _dec$g((_descriptor$b = _applyDecoratedDescriptor((_class2$d = function() {
    function ModelLightmapSettings() {
        _classCallCheck(this, ModelLightmapSettings), _initializerDefineProperty(this, "texture", _descriptor$b, this), 
        _initializerDefineProperty(this, "uvParam", _descriptor2$7, this), _initializerDefineProperty(this, "_bakeable", _descriptor3$5, this), 
        _initializerDefineProperty(this, "_castShadow", _descriptor4$3, this), _initializerDefineProperty(this, "_receiveShadow", _descriptor5$3, this), 
        _initializerDefineProperty(this, "_lightmapSize", _descriptor6$1, this);
    }
    return _createClass(ModelLightmapSettings, [ {
        key: "bakeable",
        get: function get() {
            return this._bakeable;
        },
        set: function set(val) {
            this._bakeable = val;
        }
    }, {
        key: "castShadow",
        get: function get() {
            return this._castShadow;
        },
        set: function set(val) {
            this._castShadow = val;
        }
    }, {
        key: "receiveShadow",
        get: function get() {
            return this._receiveShadow;
        },
        set: function set(val) {
            this._receiveShadow = val;
        }
    }, {
        key: "lightmapSize",
        get: function get() {
            return this._lightmapSize;
        },
        set: function set(val) {
            this._lightmapSize = val;
        }
    } ]), ModelLightmapSettings;
}()).prototype, "texture", [ _dec2$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$7 = _applyDecoratedDescriptor(_class2$d.prototype, "uvParam", [ _dec3$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec4;
    }
}), _descriptor3$5 = _applyDecoratedDescriptor(_class2$d.prototype, "_bakeable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor4$3 = _applyDecoratedDescriptor(_class2$d.prototype, "_castShadow", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5$3 = _applyDecoratedDescriptor(_class2$d.prototype, "_receiveShadow", [ _dec4$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor6$1 = _applyDecoratedDescriptor(_class2$d.prototype, "_lightmapSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 64;
    }
}), _applyDecoratedDescriptor(_class2$d.prototype, "bakeable", [ property ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "bakeable"), _class2$d.prototype), 
_applyDecoratedDescriptor(_class2$d.prototype, "castShadow", [ property ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "castShadow"), _class2$d.prototype), 
_applyDecoratedDescriptor(_class2$d.prototype, "receiveShadow", [ property ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "receiveShadow"), _class2$d.prototype), 
_applyDecoratedDescriptor(_class2$d.prototype, "lightmapSize", [ property ], Object.getOwnPropertyDescriptor(_class2$d.prototype, "lightmapSize"), _class2$d.prototype), 
_class$g = _class2$d)) || _class$g);

function checkMaterialisSame(comp1, comp2) {
    var matNum = comp1.sharedMaterials.length;
    if (matNum !== comp2.sharedMaterials.length) return !1;
    for (var i = 0; i < matNum; i++) if (comp1.getRenderMaterial(i) !== comp2.getRenderMaterial(i)) return !1;
    return !0;
}

exports.ModelComponent = (_dec5$1 = ccclass("cc.ModelComponent"), _dec6$1 = help("i18n:cc.ModelComponent"), 
_dec7$1 = executionOrder(100), _dec8 = menu("Components/Model"), _dec9 = property({
    type: ModelShadowCastingMode,
    tooltip: "i18n:model.shadow_casting_model"
}), _dec10 = property({
    type: Mesh,
    tooltip: "i18n:model.mesh"
}), _dec11 = property({
    visible: function visible() {
        return !!(this.mesh && this.mesh.struct.morph && this.mesh.struct.morph.subMeshMorphs.some((function(subMeshMorph) {
            return !!subMeshMorph;
        })));
    }
}), _dec5$1(_class4 = _dec6$1(_class4 = _dec7$1(_class4 = _dec8(_class4 = executeInEditMode((_temp2 = _class6 = function(_RenderableComponent) {
    function ModelComponent() {
        var _this;
        return _classCallCheck(this, ModelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(ModelComponent).call(this)), "lightmapSettings", _descriptor7$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_mesh", _descriptor8$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_shadowCastingMode", _descriptor9$1, _assertThisInitialized(_this)), 
        _this._modelType = void 0, _this._model = null, _this._morphInstance = null, _initializerDefineProperty(_this, "_enableMorph", _descriptor10$1, _assertThisInitialized(_this)), 
        _this._modelType = Model, _this;
    }
    return _inherits(ModelComponent, RenderableComponent), _createClass(ModelComponent, [ {
        key: "shadowCastingMode",
        get: function get() {
            return this._shadowCastingMode;
        },
        set: function set(val) {
            this._shadowCastingMode = val, this._updateCastShadow();
        }
    }, {
        key: "mesh",
        get: function get() {
            return this._mesh;
        },
        set: function set(val) {
            var _this$_mesh, old = this._mesh;
            this._mesh = val, null === (_this$_mesh = this._mesh) || void 0 === _this$_mesh || _this$_mesh.initialize(), 
            this._watchMorphInMesh(), this._onMeshChanged(old), this._updateModels(), this.enabledInHierarchy && this._attachToScene();
        }
    }, {
        key: "model",
        get: function get() {
            return this._model;
        }
    }, {
        key: "enableMorph",
        get: function get() {
            return this._enableMorph;
        },
        set: function set(value) {
            this._enableMorph = value;
        }
    } ]), _createClass(ModelComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            var _this$_mesh2;
            null === (_this$_mesh2 = this._mesh) || void 0 === _this$_mesh2 || _this$_mesh2.initialize(), 
            this._watchMorphInMesh(), this._updateModels(), this._updateCastShadow();
        }
    }, {
        key: "onRestore",
        value: function onRestore() {
            this._updateModels();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._model || this._updateModels(), this._attachToScene();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._model && this._detachFromScene();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._model && (cc.director.root.destroyModel(this._model), this._model = null, 
            this._models.length = 0), this._morphInstance && this._morphInstance.destroy();
        }
    }, {
        key: "setWeights",
        value: function setWeights(weights, subMeshIndex) {
            this._morphInstance && this._morphInstance.setWeights(subMeshIndex, weights);
        }
    }, {
        key: "setInstancedAttribute",
        value: function setInstancedAttribute(name, value) {
            if (this.model) for (var list = this.model.instancedAttributes.list, i = 0; i < list.length; i++) if (list[i].name === name) {
                list[i].view.set(value);
                break;
            }
        }
    }, {
        key: "_updateLightmap",
        value: function _updateLightmap(lightmap, uOff, vOff, uScale, vScale) {
            this.lightmapSettings.texture = lightmap, this.lightmapSettings.uvParam.x = uOff, 
            this.lightmapSettings.uvParam.y = vOff, this.lightmapSettings.uvParam.z = uScale, 
            this.lightmapSettings.uvParam.w = vScale, this._onUpdateLightingmap();
        }
    }, {
        key: "_updateModels",
        value: function _updateModels() {
            this.enabledInHierarchy && this._mesh && (this._model ? (this._model.destroy(), 
            this._model.initialize(this.node)) : this._createModel(), this._updateModelParams(), 
            this._onUpdateLightingmap());
        }
    }, {
        key: "_createModel",
        value: function _createModel() {
            var modelType = !!this._morphInstance && this._modelType === Model ? MorphModel : this._modelType;
            this._model = cc.director.root.createModel(modelType), this._model.visFlags = this.visibility, 
            this._model.initialize(this.node), this._models.length = 0, this._models.push(this._model), 
            this._morphInstance && this._model instanceof MorphModel && this._model.setMorphRendering(this._morphInstance);
        }
    }, {
        key: "_attachToScene",
        value: function _attachToScene() {
            if (this.node.scene && this._model) {
                var scene = this._getRenderScene();
                null != this._model.scene && this._detachFromScene(), scene.addModel(this._model);
            }
        }
    }, {
        key: "_detachFromScene",
        value: function _detachFromScene() {
            this._model && this._model.scene && this._model.scene.removeModel(this._model);
        }
    }, {
        key: "_updateModelParams",
        value: function _updateModelParams() {
            if (this._mesh && this._model) {
                this.node.hasChangedFlags |= TransformBit.POSITION, this._model.transform.hasChangedFlags |= TransformBit.POSITION, 
                this._model.isDynamicBatching = this._isBatchingEnabled();
                var meshCount = this._mesh ? this._mesh.subMeshCount : 0, renderingMesh = this._mesh.renderingSubMeshes;
                if (renderingMesh) for (var i = 0; i < meshCount; ++i) {
                    var material = this.getRenderMaterial(i), subMeshData = renderingMesh[i];
                    subMeshData && this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                }
                this._model.createBoundingShape(this._mesh.minPosition, this._mesh.maxPosition), 
                this._model.enabled = !0;
            }
        }
    }, {
        key: "_onUpdateLightingmap",
        value: function _onUpdateLightingmap() {
            null !== this.model && this.model.updateLightingmap(this.lightmapSettings.texture, this.lightmapSettings.uvParam), 
            this.setInstancedAttribute("a_lightingMapUVParam", [ this.lightmapSettings.uvParam.x, this.lightmapSettings.uvParam.y, this.lightmapSettings.uvParam.z, this.lightmapSettings.uvParam.w ]);
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(idx, material) {
            this._model && this._model.inited && this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
        }
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(idx, material) {
            this._model && this._model.inited && (this._model.isDynamicBatching = this._isBatchingEnabled(), 
            this._model.setSubModelMaterial(idx, material), this._onUpdateLightingmap());
        }
    }, {
        key: "_onMeshChanged",
        value: function _onMeshChanged(old) {}
    }, {
        key: "_clearMaterials",
        value: function _clearMaterials() {
            if (this._model) for (var i = 0; i < this._model.subModelNum; ++i) this._onMaterialModified(i, null);
        }
    }, {
        key: "_getBuiltinMaterial",
        value: function _getBuiltinMaterial() {
            return builtinResMgr.get("missing-material");
        }
    }, {
        key: "_onVisibilityChange",
        value: function _onVisibilityChange(val) {
            this._model && (this._model.visFlags = val);
        }
    }, {
        key: "_updateCastShadow",
        value: function _updateCastShadow() {
            this._model && (this._shadowCastingMode === ModelShadowCastingMode.OFF ? this._model.castShadow = !1 : (assertIsTrue(this._shadowCastingMode === ModelShadowCastingMode.ON, "ShadowCastingMode ".concat(this._shadowCastingMode, " is not supported.")), 
            this._model.castShadow = !0));
        }
    }, {
        key: "_isBatchingEnabled",
        value: function _isBatchingEnabled() {
            for (var i = 0; i < this._materials.length; ++i) {
                var mat = this._materials[i];
                if (mat) for (var p = 0; p < mat.passes.length; ++p) {
                    var pass = mat.passes[p];
                    if (pass.instancedBuffer || pass.batchedBuffer) return !0;
                }
            }
            return !1;
        }
    }, {
        key: "_watchMorphInMesh",
        value: function _watchMorphInMesh() {
            if (this._morphInstance && (this._morphInstance.destroy(), this._morphInstance = null), 
            this._enableMorph && this._mesh && this._mesh.struct.morph && this._mesh.morphRendering) {
                var morph = this._mesh.struct.morph;
                this._morphInstance = this._mesh.morphRendering.createInstance();
                for (var nSubMeshes = this._mesh.struct.primitives.length, iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                    var subMeshMorph = morph.subMeshMorphs[iSubMesh];
                    if (subMeshMorph) {
                        var initialWeights = subMeshMorph.weights || morph.weights, weights = initialWeights ? initialWeights.slice() : new Array(subMeshMorph.targets.length).fill(0);
                        this._morphInstance.setWeights(iSubMesh, weights);
                    }
                }
                this._model && this._model instanceof MorphModel && this._model.setMorphRendering(this._morphInstance);
            }
        }
    }, {
        key: "_syncMorphWeights",
        value: function _syncMorphWeights(subMeshIndex) {
            if (this._morphInstance) {
                var subMeshMorphInstance = this._morphInstance[subMeshIndex];
                subMeshMorphInstance && subMeshMorphInstance.renderResources && subMeshMorphInstance.renderResources.setWeights(subMeshMorphInstance.weights);
            }
        }
    } ]), ModelComponent;
}(), _class6.ShadowCastingMode = ModelShadowCastingMode, _descriptor7$1 = _applyDecoratedDescriptor((_class5 = _temp2).prototype, "lightmapSettings", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new ModelLightmapSettings;
    }
}), _descriptor8$1 = _applyDecoratedDescriptor(_class5.prototype, "_mesh", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor9$1 = _applyDecoratedDescriptor(_class5.prototype, "_shadowCastingMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ModelShadowCastingMode.OFF;
    }
}), _applyDecoratedDescriptor(_class5.prototype, "shadowCastingMode", [ _dec9 ], Object.getOwnPropertyDescriptor(_class5.prototype, "shadowCastingMode"), _class5.prototype), 
_applyDecoratedDescriptor(_class5.prototype, "mesh", [ _dec10 ], Object.getOwnPropertyDescriptor(_class5.prototype, "mesh"), _class5.prototype), 
_applyDecoratedDescriptor(_class5.prototype, "enableMorph", [ _dec11 ], Object.getOwnPropertyDescriptor(_class5.prototype, "enableMorph"), _class5.prototype), 
_descriptor10$1 = _applyDecoratedDescriptor(_class5.prototype, "_enableMorph", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _class4 = _class5)) || _class4) || _class4) || _class4) || _class4) || _class4), 
exports.ModelComponent || (exports.ModelComponent = {});

var BatchingUtility = function() {
    function BatchingUtility() {
        _classCallCheck(this, BatchingUtility);
    }
    return _createClass(BatchingUtility, null, [ {
        key: "batchStaticModel",
        value: function batchStaticModel(staticModelRoot, batchedRoot) {
            var modelComponents = staticModelRoot.getComponentsInChildren(exports.ModelComponent);
            if (modelComponents.length < 2) return console.error("the number of static models to batch is less than 2,it needn't batch."), 
            !1;
            for (var i = 1; i < modelComponents.length; i++) {
                if (!modelComponents[0].mesh.validateMergingMesh(modelComponents[i].mesh)) return console.error("the meshes of " + modelComponents[0].node.name + " and " + modelComponents[i].node.name + " can't be merged"), 
                !1;
                if (!checkMaterialisSame(modelComponents[0], modelComponents[i])) return console.error("the materials of " + modelComponents[0].node.name + " and " + modelComponents[i].node.name + " can't be merged"), 
                !1;
            }
            var batchedMesh = new Mesh, worldMat = new Mat4, rootWorldMatInv = new Mat4;
            staticModelRoot.getWorldMatrix(rootWorldMatInv), Mat4.invert(rootWorldMatInv, rootWorldMatInv);
            for (var _i = 0; _i < modelComponents.length; _i++) {
                var comp = modelComponents[_i];
                comp.node.getWorldMatrix(worldMat), Mat4.multiply(worldMat, rootWorldMatInv, worldMat), 
                batchedMesh.merge(modelComponents[_i].mesh, worldMat), comp.enabled = !1;
            }
            var batchedModelComponent = batchedRoot.addComponent(exports.ModelComponent);
            return batchedModelComponent.mesh = batchedMesh, batchedModelComponent.sharedMaterials = modelComponents[0].sharedMaterials, 
            !0;
        }
    }, {
        key: "unbatchStaticModel",
        value: function unbatchStaticModel(staticModelRoot, batchedRoot) {
            for (var modelComponents = staticModelRoot.getComponentsInChildren(exports.ModelComponent), i = 0; i < modelComponents.length; i++) {
                modelComponents[i].enabled = !0;
            }
            var batchedModelComponent = batchedRoot.getComponent(exports.ModelComponent);
            return batchedModelComponent && batchedModelComponent.destroy(), !0;
        }
    } ]), BatchingUtility;
}(), _vec3 = new Vec3;

function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
    out || (out = new Vec3), mainCamera.convertToUINode(wpos, uiNode, out);
    var pos = uiNode.position;
    return out.add(pos), out;
}

function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
    return out || (out = new Vec3), mainCamera.worldToScreen(wpos, out), out.x = out.x / cc.view.getScaleX(), 
    out.y = out.y / cc.view.getScaleY(), out;
}

var _dec$h, _dec2$9, _class$h, _class2$e, _descriptor$c, _dec3$4, _dec4$3, _dec5$2, _dec6$2, _class4$1, _class5$1, _descriptor2$8, _descriptor3$6, convertUtils = {
    WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
    WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI
};

cc.pipelineUtils = convertUtils, exports.replaceProperty(cc.pipelineUtils, "cc.pipelineUtils", [ {
    name: "WorldNode3DToLocalNodeUI",
    newName: "convertToUINode",
    targetName: "cc.CameraComponent.prototype",
    customFunction: function customFunction() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        var camera = args[0], out = args[3] || _vec3;
        return camera.convertToUINode(args[1], args[2], out), out.add(args[2].position), 
        args[3] || out.clone();
    }
} ]);

var MissingClass = (_dec$h = ccclass("cc.MissingClass"), _dec2$9 = property({
    visible: !1,
    editorOnly: !0
}), _dec$h((_descriptor$c = _applyDecoratedDescriptor((_class2$e = function MissingClass() {
    _classCallCheck(this, MissingClass), _initializerDefineProperty(this, "_$erialized", _descriptor$c, this);
}).prototype, "_$erialized", [ _dec2$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$h = _class2$e)) || _class$h), MissingScript = (_dec3$4 = ccclass("cc.MissingScript"), 
_dec4$3 = inspector("packages://inspector/inspectors/comps/missing-script.js"), 
_dec5$2 = property({
    serializable: !1
}), _dec6$2 = property({
    visible: !1,
    editorOnly: !0
}), _dec3$4(_class4$1 = _dec4$3((_descriptor2$8 = _applyDecoratedDescriptor((_class5$1 = function(_Component) {
    function MissingScript() {
        var _this;
        return _classCallCheck(this, MissingScript), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MissingScript).call(this)), "compiled", _descriptor2$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_$erialized", _descriptor3$6, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(MissingScript, Component), _createClass(MissingScript, null, [ {
        key: "safeFindClass",
        value: function safeFindClass(id, data) {
            var cls = _getClassById(id);
            return cls || (id ? (cc.deserialize.reportMissingClass(id), MissingScript.getMissingWrapper(id, data)) : null);
        }
    }, {
        key: "getMissingWrapper",
        value: function getMissingWrapper(id, data) {
            return data.node && (/^[0-9a-zA-Z+/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id)) ? MissingScript : MissingClass;
        }
    } ]), _createClass(MissingScript, [ {
        key: "onLoad",
        value: function onLoad() {
            cc.warnID(4600, this.node.name);
        }
    } ]), MissingScript;
}()).prototype, "compiled", [ _dec5$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$6 = _applyDecoratedDescriptor(_class5$1.prototype, "_$erialized", [ _dec6$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class4$1 = _class5$1)) || _class4$1) || _class4$1);

cc._MissingScript = MissingScript;

var Details = function() {
    function Details() {
        _classCallCheck(this, Details), this.uuidList = void 0, this.uuidObjList = void 0, 
        this.uuidPropList = void 0, this._stillUseUrl = void 0, this.uuidList = [], this.uuidObjList = [], 
        this.uuidPropList = [], this._stillUseUrl = createMap(!0);
    }
    return _createClass(Details, [ {
        key: "reset",
        value: function reset() {
            this.uuidList.length = 0, this.uuidObjList.length = 0, this.uuidPropList.length = 0, 
            clear(this._stillUseUrl);
        }
    }, {
        key: "push",
        value: function push(obj, propName, uuid, _stillUseUrl) {
            _stillUseUrl && (this._stillUseUrl[this.uuidList.length] = !0), this.uuidList.push(uuid), 
            this.uuidObjList.push(obj), this.uuidPropList.push(propName);
        }
    } ]), Details;
}();

Details.pool = void 0, Details.pool = new Pool((function(obj) {
    obj.reset();
}), 10), Details.pool.get = function() {
    return this._get() || new Details;
};

function _deserializeFireClass(self, obj, serialized, klass, target) {
    var deserialize;
    klass.hasOwnProperty("__deserialize__") ? deserialize = klass.__deserialize__ : (deserialize = function(self, klass) {
        var shouldCopyRawData, fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass)), shouldCopyId = cc.js.isChildClassOf(klass, cc._BaseNode) || cc.js.isChildClassOf(klass, cc.Component), simpleProps = [], simplePropsToRead = simpleProps, advancedProps = [], advancedPropsToRead = advancedProps, advancedPropsUseUrl = [], advancedPropsValueType = [];
        return function() {
            var props = klass.__values__;
            shouldCopyRawData = "_$erialized" === props[props.length - 1];
            for (var attrs = getClassAttrs(klass), p = 0; p < props.length; p++) {
                var propName = props[p], propNameToRead = propName;
                attrs[propName + "$_$formerlySerializedAs"] && (propNameToRead = attrs[propName + "$_$formerlySerializedAs"]);
                var stillUseUrl = attrs[propName + "$_$saveUrlAsAsset"], defaultValue = CCClass.getDefault(attrs[propName + "$_$default"]), isPrimitiveType = !1;
                if (fastMode) {
                    var userType = attrs[propName + "$_$type"];
                    if (void 0 === defaultValue && userType) isPrimitiveType = userType === cc.String || userType === cc.Integer || userType === cc.Float || userType === cc.Boolean; else {
                        var defaultType = _typeof(defaultValue);
                        isPrimitiveType = "string" === defaultType && !stillUseUrl || "number" === defaultType || "boolean" === defaultType;
                    }
                }
                fastMode && isPrimitiveType ? (propNameToRead !== propName && simplePropsToRead === simpleProps && (simplePropsToRead = simpleProps.slice()), 
                simpleProps.push(propName), simplePropsToRead !== simpleProps && simplePropsToRead.push(propNameToRead)) : (propNameToRead !== propName && advancedPropsToRead === advancedProps && (advancedPropsToRead = advancedProps.slice()), 
                advancedProps.push(propName), advancedPropsToRead !== advancedProps && advancedPropsToRead.push(propNameToRead), 
                advancedPropsUseUrl.push(stillUseUrl), advancedPropsValueType.push(defaultValue instanceof cc.ValueType && defaultValue.constructor));
            }
        }(), function(s, o, d, k, t) {
            for (var i = 0; i < simpleProps.length; ++i) {
                var prop = d[simplePropsToRead[i]];
                void 0 !== prop && (o[simpleProps[i]] = prop);
            }
            for (var _i = 0; _i < advancedProps.length; ++_i) {
                var propName = advancedProps[_i], _prop = d[advancedPropsToRead[_i]];
                if (void 0 !== _prop) if (fastMode || "object" === _typeof(_prop)) {
                    var valueTypeCtor = advancedPropsValueType[_i];
                    valueTypeCtor ? fastMode || _prop ? s._deserializeTypedObject(o[propName], _prop, valueTypeCtor) : o[propName] = null : _prop ? s._deserializeObjField(o, _prop, propName, null, advancedPropsUseUrl[_i]) : o[propName] = null;
                } else o[propName] = _prop;
            }
            shouldCopyId && d._id && (o._id = d._id), shouldCopyRawData && (o._$erialized = JSON.parse(JSON.stringify(d)), 
            s._deserializePrimitiveObject(o._$erialized, d));
        };
    }(0, klass), value(klass, "__deserialize__", deserialize, !0)), deserialize(self, obj, serialized, klass, target), 
    obj.__postDeserialize && obj.__postDeserialize();
}

var _Deserializer = function() {
    function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
        _classCallCheck(this, _Deserializer), this.result = void 0, this.customEnv = void 0, 
        this.deserializedList = void 0, this.deserializedData = void 0, this._classFinder = void 0, 
        this._target = void 0, this._ignoreEditorOnly = void 0, this._idList = void 0, this._idObjList = void 0, 
        this._idPropList = void 0, this.result = result, this.customEnv = customEnv, this.deserializedList = [], 
        this.deserializedData = null, this._classFinder = classFinder, this._idList = [], 
        this._idObjList = [], this._idPropList = [];
    }
    return _createClass(_Deserializer, [ {
        key: "deserialize",
        value: function deserialize(jsonObj) {
            if (Array.isArray(jsonObj)) {
                var jsonArray = jsonObj, refCount = jsonArray.length;
                this.deserializedList.length = refCount;
                for (var i = 0; i < refCount; i++) jsonArray[i] && (this.deserializedList[i] = this._deserializeObject(jsonArray[i], !1));
                this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
            } else this.deserializedList.length = 1, this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, !1) : null, 
            this.deserializedList[0] = this.deserializedData;
            return function _dereference(self) {
                var i, propName, id, deserializedList = self.deserializedList, idPropList = self._idPropList, idList = self._idList, idObjList = self._idObjList;
                for (self._classFinder && self._classFinder.onDereferenced, i = 0; i < idList.length; i++) propName = idPropList[i], 
                id = idList[i], idObjList[i][propName] = deserializedList[id];
            }(this), this.deserializedData;
        }
    }, {
        key: "_deserializeObject",
        value: function _deserializeObject(serialized, _stillUseUrl, target, owner, propName) {
            var prop, obj = null, klass = null, type = serialized.__type__;
            if ("TypedArray" === type) {
                var array = serialized.array;
                obj = new window[serialized.ctor](array.length);
                for (var i = 0; i < array.length; ++i) obj[i] = array[i];
                return obj;
            }
            if (type) {
                if (!(klass = this._classFinder(type, serialized, owner, propName))) return this._classFinder === _getClassById && cc.deserialize.reportMissingClass(type), 
                null;
                var self = this;
                !function deserializeByType() {
                    (obj = new klass)._deserialize ? obj._deserialize(serialized.content, self) : cc.Class._isCCClass(klass) ? _deserializeFireClass(self, obj, serialized, klass, target) : self._deserializeTypedObject(obj, serialized, klass);
                }();
            } else if (Array.isArray(serialized)) {
                obj = new Array(serialized.length);
                for (var _i2 = 0; _i2 < serialized.length; _i2++) "object" === _typeof(prop = serialized[_i2]) && prop ? this._deserializeObjField(obj, prop, "" + _i2, null, _stillUseUrl) : obj[_i2] = prop;
            } else obj = {}, this._deserializePrimitiveObject(obj, serialized);
            return obj;
        }
    }, {
        key: "_deserializeObjField",
        value: function _deserializeObjField(obj, jsonObj, propName, target, _stillUseUrl) {
            var id = jsonObj.__id__;
            if (void 0 === id) {
                var uuid = jsonObj.__uuid__;
                uuid ? this.result.push(obj, propName, uuid, _stillUseUrl) : obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
            } else {
                var dObj = this.deserializedList[id];
                dObj ? obj[propName] = dObj : (this._idList.push(id), this._idObjList.push(obj), 
                this._idPropList.push(propName));
            }
        }
    }, {
        key: "_deserializePrimitiveObject",
        value: function _deserializePrimitiveObject(instance, serialized) {
            for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
                var prop = serialized[propName];
                "object" !== _typeof(prop) ? "__type__" !== propName && (instance[propName] = prop) : prop ? this._deserializeObjField(instance, prop, propName) : instance[propName] = null;
            }
        }
    }, {
        key: "_deserializeTypedObject",
        value: function _deserializeTypedObject(instance, serialized, klass) {
            if (klass === cc.Vec2) return instance.x = serialized.x || 0, void (instance.y = serialized.y || 0);
            if (klass === cc.Vec3) return instance.x = serialized.x || 0, instance.y = serialized.y || 0, 
            void (instance.z = serialized.z || 0);
            if (klass !== cc.Color) {
                if (klass === cc.Size) return instance.width = serialized.width || 0, void (instance.height = serialized.height || 0);
                for (var attrs = getClassAttrs(klass), fastDefinedProps = klass.__props__ || Object.keys(instance), i = 0; i < fastDefinedProps.length; i++) {
                    var propName = fastDefinedProps[i], value = serialized[propName];
                    void 0 !== value && serialized.hasOwnProperty(propName) || (value = CCClass.getDefault(attrs[propName + "$_$default"])), 
                    "object" !== _typeof(value) ? instance[propName] = value : value ? this._deserializeObjField(instance, value, propName) : instance[propName] = null;
                }
            } else {
                instance.r = serialized.r || 0, instance.g = serialized.g || 0, instance.b = serialized.b || 0;
                var a = serialized.a;
                instance.a = void 0 === a ? 255 : a;
            }
        }
    } ]), _Deserializer;
}();

function deserialize(data, details, options) {
    var classFinder = (options = options || {}).classFinder || _getClassById, createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE, customEnv = options.customEnv, ignoreEditorOnly = options.ignoreEditorOnly;
    "string" == typeof data && (data = JSON.parse(data));
    var tempDetails = !details;
    details = details || Details.pool.get();
    var deserializer = _Deserializer.pool.get(details, !1, classFinder, customEnv, ignoreEditorOnly);
    cc.game._isCloning = !0;
    var res = deserializer.deserialize(data);
    return cc.game._isCloning = !1, _Deserializer.pool.put(deserializer), createAssetRefs && details.assignAssetsBy(EditorExtends.serialize.asAsset), 
    tempDetails && Details.pool.put(details), res;
}

_Deserializer.pool = void 0, _Deserializer.pool = new Pool((function(obj) {
    obj.result = null, obj.customEnv = null, obj.deserializedList.length = 0, obj.deserializedData = null, 
    obj._classFinder = null, obj._idList.length = 0, obj._idObjList.length = 0, obj._idPropList.length = 0;
}), 1), _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
    var cache = this._get();
    return cache ? (cache.result = result, cache.customEnv = customEnv, cache._classFinder = classFinder, 
    cache) : new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
}, deserialize.Details = Details, deserialize.reportMissingClass = function(id) {
    warnID(5302, id);
}, cc.deserialize = deserialize;

var _class$i, _class2$f, _descriptor$d, _descriptor2$9, _descriptor3$7, _descriptor4$4, _class3$8, _temp$h, _BuiltinElementTypeTr, StorageUnit, ElementType, Destroyed$1 = CCObject.Flags.Destroyed, PersistentMask$1 = CCObject.Flags.PersistentMask, objsToClearTmpVar = [];

function instantiate(original, internal_force) {
    if (!internal_force) {
        if ("object" !== _typeof(original) || Array.isArray(original)) return null;
        if (!original) return null;
        if (!cc.isValid(original)) return null;
    }
    var clone;
    if (original instanceof CCObject) {
        if ((original = original)._instantiate) return cc.game._isCloning = !0, clone = original._instantiate(), 
        cc.game._isCloning = !1, clone;
        if (original instanceof cc.Asset) return null;
    }
    return cc.game._isCloning = !0, clone = doInstantiate(original), cc.game._isCloning = !1, 
    clone;
}

function doInstantiate(obj, parent) {
    if (Array.isArray(obj)) return null;
    if (isDomNode && isDomNode(obj)) return null;
    var clone;
    if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
        clone = new (0, obj.constructor);
    } else clone = Object.create(null);
    enumerateObject(obj, clone, parent);
    for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
    return objsToClearTmpVar.length = 0, clone;
}

function enumerateObject(obj, clone, parent) {
    value(obj, "_iN$t", clone, !0), objsToClearTmpVar.push(obj);
    var klass = obj.constructor;
    if (cc.Class._isCCClass(klass)) !function enumerateCCClass(klass, obj, clone, parent) {
        for (var props = klass.__values__, p = 0; p < props.length; p++) {
            var key = props[p], value = obj[key];
            if ("object" === _typeof(value) && value) {
                var initValue = clone[key];
                initValue instanceof ValueType && initValue.constructor === value.constructor ? initValue.set(value) : clone[key] = value._iN$t || instantiateObj(value, parent);
            } else clone[key] = value;
        }
    }(klass, obj, clone, parent); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
        var value$1 = obj[key];
        if ("object" === _typeof(value$1) && value$1) {
            if (value$1 === clone) continue;
            clone[key] = value$1._iN$t || instantiateObj(value$1, parent);
        } else clone[key] = value$1;
    }
    obj instanceof CCObject && (clone._objFlags &= PersistentMask$1);
}

function instantiateObj(obj, parent) {
    if (obj instanceof ValueType) return obj.clone();
    if (obj instanceof cc.Asset) return obj;
    var clone;
    if (Array.isArray(obj)) {
        var len = obj.length;
        clone = new Array(len), obj._iN$t = clone;
        for (var i = 0; i < len; ++i) {
            var value = obj[i];
            "object" === _typeof(value) && value ? clone[i] = value._iN$t || instantiateObj(value, parent) : clone[i] = value;
        }
        return objsToClearTmpVar.push(obj), clone;
    }
    if (obj._objFlags & Destroyed$1) return null;
    var ctor = obj.constructor;
    if (cc.Class._isCCClass(ctor)) {
        if (parent) if (parent instanceof cc.Component) {
            if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
        } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
            if (!obj.isChildOf(parent)) return obj;
        } else if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) return obj;
        clone = new ctor;
    } else if (ctor === Object) clone = {}; else {
        if (ctor) return obj;
        clone = Object.create(null);
    }
    return enumerateObject(obj, clone, parent), clone;
}

instantiate._clone = doInstantiate, cc.instantiate = instantiate, function(StorageUnit) {
    StorageUnit[StorageUnit.Uint8 = 0] = "Uint8", StorageUnit[StorageUnit.Uint16 = 1] = "Uint16", 
    StorageUnit[StorageUnit.Uint32 = 2] = "Uint32", StorageUnit[StorageUnit.Int8 = 3] = "Int8", 
    StorageUnit[StorageUnit.Int16 = 4] = "Int16", StorageUnit[StorageUnit.Int32 = 5] = "Int32", 
    StorageUnit[StorageUnit.Float32 = 6] = "Float32", StorageUnit[StorageUnit.Float64 = 7] = "Float64";
}(StorageUnit || (StorageUnit = {})), function(ElementType) {
    ElementType[ElementType.Scalar = 0] = "Scalar", ElementType[ElementType.Vec2 = 1] = "Vec2", 
    ElementType[ElementType.Vec3 = 2] = "Vec3", ElementType[ElementType.Vec4 = 3] = "Vec4", 
    ElementType[ElementType.Quat = 4] = "Quat", ElementType[ElementType.Mat4 = 5] = "Mat4";
}(ElementType || (ElementType = {}));

function combineStorageUnitElementType(unit, elementType) {
    return (elementType << 3) + unit;
}

var CompactValueTypeArray = ccclass("cc.CompactValueTypeArray")((_temp$h = _class3$8 = function() {
    function CompactValueTypeArray() {
        _classCallCheck(this, CompactValueTypeArray), _initializerDefineProperty(this, "_byteOffset", _descriptor$d, this), 
        _initializerDefineProperty(this, "_unitCount", _descriptor2$9, this), _initializerDefineProperty(this, "_unitElement", _descriptor3$7, this), 
        _initializerDefineProperty(this, "_length", _descriptor4$4, this);
    }
    return _createClass(CompactValueTypeArray, [ {
        key: "decompress",
        value: function decompress(arrayBuffer) {
            for (var _extractStorageUnitEl = function extractStorageUnitElementType(combined) {
                return {
                    storageUnit: 7 & combined,
                    elementType: combined >> 3
                };
            }(this._unitElement), storageUnit = _extractStorageUnitEl.storageUnit, elementTraits = getElementTraits(_extractStorageUnitEl.elementType), storage = new (getStorageConstructor(storageUnit))(arrayBuffer, this._byteOffset, this._unitCount), result = new Array(this._length), i = 0; i < this._length; ++i) result[i] = elementTraits.decompress(storage, i);
            return result;
        }
    } ], [ {
        key: "lengthFor",
        value: function lengthFor(values, elementType, unit) {
            return getElementTraits(elementType).requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
        }
    }, {
        key: "compress",
        value: function compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
            for (var elementTraits = getElementTraits(elementType), storageConstructor = getStorageConstructor(unit), unitCount = elementTraits.requiredUnits * values.length, storage = new storageConstructor(arrayBuffer, byteOffset, unitCount), i = 0; i < values.length; ++i) elementTraits.compress(storage, i, values[i]);
            var result = new CompactValueTypeArray;
            return result._unitElement = combineStorageUnitElementType(unit, elementType), result._byteOffset = presumedByteOffset, 
            result._unitCount = unitCount, result._length = values.length, result;
        }
    } ]), CompactValueTypeArray;
}(), _class3$8.StorageUnit = StorageUnit, _class3$8.ElementType = ElementType, _descriptor$d = _applyDecoratedDescriptor((_class2$f = _temp$h).prototype, "_byteOffset", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$9 = _applyDecoratedDescriptor(_class2$f.prototype, "_unitCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor3$7 = _applyDecoratedDescriptor(_class2$f.prototype, "_unitElement", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
    }
}), _descriptor4$4 = _applyDecoratedDescriptor(_class2$f.prototype, "_length", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$i = _class2$f)) || _class$i;

function getElementTraits(elementType) {
    return BuiltinElementTypeTraits[elementType];
}

function getStorageConstructor(unit) {
    switch (unit) {
      case StorageUnit.Uint8:
        return Uint8Array;

      case StorageUnit.Uint16:
        return Uint16Array;

      case StorageUnit.Uint32:
        return Uint32Array;

      case StorageUnit.Int8:
        return Int8Array;

      case StorageUnit.Int16:
        return Int16Array;

      case StorageUnit.Int32:
        return Int32Array;

      case StorageUnit.Float32:
        return Float32Array;

      case StorageUnit.Float64:
        return Float64Array;
    }
}

var BuiltinElementTypeTraits = (_defineProperty(_BuiltinElementTypeTr = {}, ElementType.Scalar, {
    requiredUnits: 1,
    compress: function compress(storage, index, value) {
        storage[index] = value;
    },
    decompress: function decompress(storage, index) {
        return storage[index];
    }
}), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec2, {
    requiredUnits: 2,
    compress: function compress(storage, index, value) {
        storage[2 * index] = value.x, storage[2 * index + 1] = value.y;
    },
    decompress: function decompress(storage, index) {
        return new Vec3(storage[2 * index], storage[2 * index + 1]);
    }
}), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec3, {
    requiredUnits: 3,
    compress: function compress(storage, index, value) {
        storage[3 * index] = value.x, storage[3 * index + 1] = value.y, storage[3 * index + 2] = value.z;
    },
    decompress: function decompress(storage, index) {
        return new Vec3(storage[3 * index], storage[3 * index + 1], storage[3 * index + 2]);
    }
}), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec4, {
    requiredUnits: 4,
    compress: function compress(storage, index, value) {
        storage[4 * index] = value.x, storage[4 * index + 1] = value.y, storage[4 * index + 2] = value.z, 
        storage[4 * index + 3] = value.w;
    },
    decompress: function decompress(storage, index) {
        return new Vec4(storage[4 * index], storage[4 * index + 1], storage[4 * index + 2], storage[4 * index + 3]);
    }
}), _defineProperty(_BuiltinElementTypeTr, ElementType.Quat, {
    requiredUnits: 4,
    compress: function compress(storage, index, value) {
        storage[4 * index] = value.x, storage[4 * index + 1] = value.y, storage[4 * index + 2] = value.z, 
        storage[4 * index + 3] = value.w;
    },
    decompress: function decompress(storage, index) {
        return new Quat(storage[4 * index], storage[4 * index + 1], storage[4 * index + 2], storage[4 * index + 3]);
    }
}), _defineProperty(_BuiltinElementTypeTr, ElementType.Mat4, {
    requiredUnits: 16,
    compress: function compress(storage, index, value) {
        Mat4.toArray(storage, value, 16 * index);
    },
    decompress: function decompress(storage, index) {
        return Mat4.fromArray(new Mat4, storage, 16 * index);
    }
}), _BuiltinElementTypeTr);

function flattenCodeArray(array) {
    var strList = [];
    return function deepFlatten(strList, array) {
        for (var _step, _iterator = _createForOfIteratorHelperLoose(array); !(_step = _iterator()).done; ) {
            var item = _step.value;
            Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
        }
    }(strList, array), strList.join("");
}

cc._decorator = _decorator;

var Destroyed$2 = CCObject.Flags.Destroyed, PersistentMask$2 = CCObject.Flags.PersistentMask, IDENTIFIER_RE$1 = CCClass.IDENTIFIER_RE, DEFAULT_MODULE_CACHE = {
    "cc.Node": "cc.Node",
    "cc.Sprite": "cc.Sprite",
    "cc.Label": "cc.Label",
    "cc.Button": "cc.Button",
    "cc.Widget": "cc.Widget",
    "cc.Animation": "cc.Animation",
    "cc.ClickEvent": !1,
    "cc.PrefabInfo": !1
}, escapeForJS$1 = CCClass.escapeForJS, Declaration = function() {
    function Declaration(varName, expression) {
        _classCallCheck(this, Declaration), this.varName = void 0, this.expression = void 0, 
        this.varName = varName, this.expression = expression;
    }
    return _createClass(Declaration, [ {
        key: "toString",
        value: function toString() {
            return "var " + this.varName + "=" + this.expression + ";";
        }
    } ]), Declaration;
}();

function mergeDeclaration(statement, expression) {
    return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
}

function writeAssignment(codeArray, statement, expression) {
    Array.isArray(expression) ? (expression[0] = mergeDeclaration(statement, expression[0]), 
    codeArray.push(expression)) : codeArray.push(mergeDeclaration(statement, expression) + ";");
}

var Assignments = function() {
    function Assignments(targetExpression) {
        _classCallCheck(this, Assignments), this._exps = void 0, this._targetExp = void 0, 
        this._exps = [], this._targetExp = targetExpression;
    }
    return _createClass(Assignments, [ {
        key: "append",
        value: function append(key, expression) {
            this._exps.push([ key, expression ]);
        }
    }, {
        key: "writeCode",
        value: function writeCode(codeArray) {
            var targetVar;
            if (this._exps.length > 1) codeArray.push("t=" + this._targetExp + ";"), targetVar = "t"; else {
                if (1 !== this._exps.length) return;
                targetVar = this._targetExp;
            }
            for (var i = 0; i < this._exps.length; i++) {
                var pair = this._exps[i];
                writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
            }
        }
    } ]), Assignments;
}();

function getPropAccessor(key) {
    return IDENTIFIER_RE$1.test(key) ? "." + key : "[" + escapeForJS$1(key) + "]";
}

Assignments.pool = void 0, Assignments.pool = new Pool((function(obj) {
    obj._exps.length = 0, obj._targetExp = null;
}), 1), Assignments.pool.get = function(targetExpression) {
    var cache = this._get() || new Assignments;
    return cache._targetExp = targetExpression, cache;
};

var _class$j, _class2$g, _descriptor$e, _descriptor2$a, _descriptor3$8, _class3$9, _temp$i, Parser = function() {
    function Parser(obj, parent) {
        var globalVariablesDeclaration;
        _classCallCheck(this, Parser), this.parent = void 0, this.objsToClear_iN$t = void 0, 
        this.codeArray = void 0, this.objs = void 0, this.funcs = void 0, this.funcModuleCache = void 0, 
        this.globalVariables = void 0, this.globalVariableId = void 0, this.localVariableId = void 0, 
        this.result = void 0, this.parent = parent, this.objsToClear_iN$t = [], this.codeArray = [], 
        this.objs = [], this.funcs = [], this.funcModuleCache = createMap(), mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE), 
        this.globalVariables = [], this.globalVariableId = 0, this.localVariableId = 0, 
        this.codeArray.push("var o,t;", "if(R){", "o=R;", "}else{", "o=R=new " + this.getFuncModule(obj.constructor, !0) + "();", "}"), 
        obj._iN$t = {
            globalVar: "R"
        }, this.objsToClear_iN$t.push(obj), this.enumerateObject(this.codeArray, obj), this.globalVariables.length > 0 && (globalVariablesDeclaration = "var " + this.globalVariables.join(",") + ";");
        var code = flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
        this.result = Function("O", "F", code)(this.objs, this.funcs);
        for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
        this.objsToClear_iN$t.length = 0;
    }
    return _createClass(Parser, [ {
        key: "getFuncModule",
        value: function getFuncModule(func, usedInNew) {
            var clsName = getClassName(func);
            if (clsName) {
                var cache = this.funcModuleCache[clsName];
                if (cache) return cache;
                if (void 0 === cache) {
                    var clsNameIsModule = -1 !== clsName.indexOf(".");
                    if (clsNameIsModule) try {
                        if (clsNameIsModule = func === Function("return " + clsName)()) return this.funcModuleCache[clsName] = clsName, 
                        clsName;
                    } catch (e) {}
                }
            }
            var index = this.funcs.indexOf(func);
            index < 0 && (index = this.funcs.length, this.funcs.push(func));
            var res = "F[" + index + "]";
            return usedInNew && (res = "(" + res + ")"), this.funcModuleCache[clsName] = res, 
            res;
        }
    }, {
        key: "getObjRef",
        value: function getObjRef(obj) {
            var index = this.objs.indexOf(obj);
            return index < 0 && (index = this.objs.length, this.objs.push(obj)), "O[" + index + "]";
        }
    }, {
        key: "setValueType",
        value: function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
            var assignments = Assignments.pool.get(targetExpression), fastDefinedProps = defaultValue.constructor.__props__;
            fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
            for (var i = 0; i < fastDefinedProps.length; i++) {
                var propName = fastDefinedProps[i], prop = srcValue[propName];
                if (defaultValue[propName] !== prop) {
                    var expression = this.enumerateField(srcValue, propName, prop);
                    assignments.append(propName, expression);
                }
            }
            assignments.writeCode(codeArray), Assignments.pool.put(assignments);
        }
    }, {
        key: "enumerateCCClass",
        value: function enumerateCCClass(codeArray, obj, klass) {
            for (var props = klass.__values__, attrs = getClassAttrs(klass), p = 0; p < props.length; p++) {
                var key = props[p], val = obj[key], defaultValue = attrs[key + "$_$default"];
                if (!equalsToDefault(defaultValue, val)) if ("object" === _typeof(val) && val instanceof cc.ValueType && (defaultValue = CCClass.getDefault(defaultValue)) && defaultValue.constructor === val.constructor) {
                    var targetExpression = "o" + getPropAccessor(key);
                    this.setValueType(codeArray, defaultValue, val, targetExpression);
                } else this.setObjProp(codeArray, obj, key, val);
            }
        }
    }, {
        key: "instantiateArray",
        value: function instantiateArray(value) {
            if (0 === value.length) return "[]";
            var arrayVar = "a" + ++this.localVariableId, codeArray = [ new Declaration(arrayVar, "new Array(" + value.length + ")") ];
            value._iN$t = {
                globalVar: "",
                source: codeArray
            }, this.objsToClear_iN$t.push(value);
            for (var i = 0; i < value.length; ++i) {
                writeAssignment(codeArray, arrayVar + "[" + i + "]=", this.enumerateField(value, i, value[i]));
            }
            return codeArray;
        }
    }, {
        key: "enumerateField",
        value: function enumerateField(obj, key, value) {
            if ("object" === _typeof(value) && value) {
                var _iN$t = value._iN$t;
                if (_iN$t) {
                    var globalVar = _iN$t.globalVar;
                    if (!globalVar) {
                        globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId, this.globalVariables.push(globalVar);
                        var line = _iN$t.source[0];
                        _iN$t.source[0] = mergeDeclaration(globalVar + "=", line);
                    }
                    return globalVar;
                }
                return Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
            }
            return "function" == typeof value ? this.getFuncModule(value) : "string" == typeof value ? escapeForJS$1(value) : ("_objFlags" === key && obj instanceof CCObject && (value &= PersistentMask$2), 
            value);
        }
    }, {
        key: "setObjProp",
        value: function setObjProp(codeArray, obj, key, value) {
            writeAssignment(codeArray, "o" + getPropAccessor(key) + "=", this.enumerateField(obj, key, value));
        }
    }, {
        key: "enumerateObject",
        value: function enumerateObject(codeArray, obj) {
            var klass = obj.constructor;
            if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) if (obj.hasOwnProperty(key) && (95 !== key.charCodeAt(0) || 95 !== key.charCodeAt(1) || "__type__" === key)) {
                var value = obj[key];
                "object" === _typeof(value) && value && value === obj._iN$t || this.setObjProp(codeArray, obj, key, value);
            }
        }
    }, {
        key: "instantiateObj",
        value: function instantiateObj(obj) {
            if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
            if (obj instanceof cc.Asset) return this.getObjRef(obj);
            if (obj._objFlags & Destroyed$2) return null;
            var createCode, ctor = obj.constructor;
            if (cc.Class._isCCClass(ctor)) {
                if (this.parent) if (this.parent instanceof cc.Component) {
                    if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
                } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
                    if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
                } else if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) return this.getObjRef(obj);
                createCode = new Declaration("o", "new " + this.getFuncModule(ctor, !0) + "()");
            } else if (ctor === Object) createCode = new Declaration("o", "{}"); else {
                if (ctor) return this.getObjRef(obj);
                createCode = new Declaration("o", "Object.create(null)");
            }
            var codeArray = [ createCode ];
            return obj._iN$t = {
                globalVar: "",
                source: codeArray
            }, this.objsToClear_iN$t.push(obj), this.enumerateObject(codeArray, obj), [ "(function(){", codeArray, "return o;})();" ];
        }
    } ]), Parser;
}();

function equalsToDefault(def, value) {
    if ("function" == typeof def) try {
        def = def();
    } catch (e) {
        return !1;
    }
    if (def === value) return !0;
    if (def && value) {
        if (def instanceof cc.ValueType && def.equals(value)) return !0;
        if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) try {
            return Array.isArray(def) && Array.isArray(value) && 0 === def.length && 0 === value.length;
        } catch (e) {}
    }
    return !1;
}

var _class$k, _class2$h, _descriptor$f, _descriptor2$b, OptimizationPolicy = Enum({
    AUTO: 0,
    SINGLE_INSTANCE: 1,
    MULTI_INSTANCE: 2
}), Prefab = ccclass("cc.Prefab")((_temp$i = _class3$9 = function(_Asset) {
    function Prefab() {
        var _this;
        return _classCallCheck(this, Prefab), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Prefab).call(this)), "data", _descriptor$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "optimizationPolicy", _descriptor2$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor3$8, _assertThisInitialized(_this)), 
        _this._createFunction = void 0, _this._instantiatedTimes = void 0, _this._createFunction = null, 
        _this._instantiatedTimes = 0, _this;
    }
    return _inherits(Prefab, Asset), _createClass(Prefab, [ {
        key: "createNode",
        value: function createNode(cb) {
            var node = cc.instantiate(this);
            node.name = this.name, cb(null, node);
        }
    }, {
        key: "compileCreateFunction",
        value: function compileCreateFunction() {
            this._createFunction = function compile(node) {
                var root = node instanceof cc._BaseNode && node;
                return new Parser(node, root).result;
            }(this.data);
        }
    }, {
        key: "_doInstantiate",
        value: function _doInstantiate(rootToRedirect) {
            return this.data._prefab ? this.data._prefab._synced = !0 : cc.warnID(3700), this._createFunction || this.compileCreateFunction(), 
            this._createFunction(rootToRedirect);
        }
    }, {
        key: "_instantiate",
        value: function _instantiate() {
            var node;
            return this.data._prefab._synced = !0, node = this.data._instantiate(), ++this._instantiatedTimes, 
            node;
        }
    } ]), Prefab;
}(), _class3$9.OptimizationPolicy = OptimizationPolicy, _class3$9.OptimizationPolicyThreshold = 3, 
_descriptor$e = _applyDecoratedDescriptor((_class2$g = _temp$i).prototype, "data", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$a = _applyDecoratedDescriptor(_class2$g.prototype, "optimizationPolicy", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return OptimizationPolicy.AUTO;
    }
}), _descriptor3$8 = _applyDecoratedDescriptor(_class2$g.prototype, "asyncLoadAssets", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$j = _class2$g)) || _class$j;

cc.Prefab = Prefab, obsolete(cc, "cc._Prefab", "Prefab");

var _class$l, _class2$i, _descriptor$g, SceneAsset = ccclass("cc.SceneAsset")((_descriptor$f = _applyDecoratedDescriptor((_class2$h = function(_Asset) {
    function SceneAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SceneAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SceneAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "scene", _descriptor$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor2$b, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SceneAsset, Asset), SceneAsset;
}()).prototype, "scene", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$b = _applyDecoratedDescriptor(_class2$h.prototype, "asyncLoadAssets", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$k = _class2$h)) || _class$k;

cc.SceneAsset = SceneAsset;

var _class$m, _class2$j, _descriptor$h, SpriteAtlas = ccclass("cc.SpriteAtlas")((_descriptor$g = _applyDecoratedDescriptor((_class2$i = function(_Asset) {
    function SpriteAtlas() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SpriteAtlas);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteAtlas)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spriteFrames", _descriptor$g, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SpriteAtlas, Asset), _createClass(SpriteAtlas, [ {
        key: "getTexture",
        value: function getTexture() {
            var keys = Object.keys(this.spriteFrames);
            if (keys.length > 0) {
                var spriteFrame = this.spriteFrames[keys[0]];
                return spriteFrame && spriteFrame.texture;
            }
            return null;
        }
    }, {
        key: "getSpriteFrame",
        value: function getSpriteFrame(key) {
            var sf = this.spriteFrames[key];
            return sf ? (sf.name || (sf.name = key), sf) : null;
        }
    }, {
        key: "getSpriteFrames",
        value: function getSpriteFrames() {
            for (var frames = [], spriteFrames = this.spriteFrames, _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
                var _key2 = _Object$keys[_i];
                frames.push(spriteFrames[_key2]);
            }
            return frames;
        }
    }, {
        key: "_serialize",
        value: function _serialize(exporting) {
            for (var frames = [], _i2 = 0, _Object$keys2 = Object.keys(this.spriteFrames); _i2 < _Object$keys2.length; _i2++) {
                var _key3 = _Object$keys2[_i2], spriteFrame = this.spriteFrames[_key3], id = spriteFrame ? spriteFrame._uuid : "";
                id && exporting && (id = EditorExtends.UuidUtils.compressUuid(id, !0)), frames.push(_key3), 
                frames.push(id);
            }
            return {
                name: this._name,
                spriteFrames: frames
            };
        }
    }, {
        key: "_deserialize",
        value: function _deserialize(serializeData, handle) {
            var data = serializeData;
            this._name = data.name;
            var frames = data.spriteFrames;
            this.spriteFrames = createMap();
            for (var i = 0; i < frames.length; i += 2) handle.result.push(this.spriteFrames, frames[i], frames[i + 1]);
        }
    } ]), SpriteAtlas;
}()).prototype, "spriteFrames", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return createMap();
    }
}), _class$l = _class2$i)) || _class$l;

cc.SpriteAtlas = SpriteAtlas;

var _class$n, _class2$k, _descriptor$i, TextAsset = ccclass("cc.TextAsset")((_descriptor$h = _applyDecoratedDescriptor((_class2$j = function(_Asset) {
    function TextAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TextAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "text", _descriptor$h, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(TextAsset, Asset), _createClass(TextAsset, [ {
        key: "toString",
        value: function toString() {
            return this.text;
        }
    } ]), TextAsset;
}()).prototype, "text", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$m = _class2$j)) || _class$m;

cc.TextAsset = TextAsset;

var JsonAsset = ccclass("cc.JsonAsset")((_descriptor$i = _applyDecoratedDescriptor((_class2$k = function(_Asset) {
    function JsonAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, JsonAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(JsonAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "json", _descriptor$i, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(JsonAsset, Asset), JsonAsset;
}()).prototype, "json", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$n = _class2$k)) || _class$n;

cc.JsonAsset = JsonAsset;

var HexChars = "0123456789abcdef".split(""), _t = [ "", "", "", "" ], UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t), Indices = UuidTemplate.map((function(x, i) {
    return "-" === x ? NaN : i;
})).filter(isFinite);

function decodeUuid(base64) {
    var uuid = base64.split("@")[0];
    if (22 !== uuid.length) return base64;
    UuidTemplate[0] = base64[0], UuidTemplate[1] = base64[1];
    for (var i = 2, j = 2; i < 22; i += 2) {
        var lhs = BASE64_VALUES[base64.charCodeAt(i)], rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
        UuidTemplate[Indices[j++]] = HexChars[lhs >> 2], UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4], 
        UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
    }
    return base64.replace(uuid, UuidTemplate.join(""));
}

var url = {
    _rawAssets: "",
    normalize: function normalize(url) {
        return url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1))), 
        url;
    },
    raw: function raw(url) {
        if ((url = this.normalize(url)).startsWith("resources/")) {
            var uuid = cc.loader._getResUuid(url.slice(10), cc.Asset, null, !0);
            if (uuid) return cc.AssetLibrary.getLibUrlNoExt(uuid, !0) + extname(url);
        } else errorID(7002, url);
        return this._rawAssets + url;
    },
    _init: function _init(assets) {
        this._rawAssets = stripSep(assets) + "/";
    }
};

cc.url = url;

var Entry = function Entry(uuid, type) {
    _classCallCheck(this, Entry), this.uuid = void 0, this.type = void 0, this.uuid = uuid, 
    this.type = type;
};

function isMatchByWord(path, test) {
    return !(path.length > test.length) || 47 === path.charCodeAt(test.length);
}

var AssetTable = function() {
    function AssetTable() {
        _classCallCheck(this, AssetTable), this._pathToUuid = void 0, this._pathToUuid = createMap(!0);
    }
    return _createClass(AssetTable, [ {
        key: "getUuid",
        value: function getUuid(path, type) {
            path = url.normalize(path);
            var item = this._pathToUuid[path];
            if (item) if (Array.isArray(item)) {
                if (!type) return item[0].uuid;
                for (var i = 0; i < item.length; i++) {
                    var entry = item[i];
                    if (isChildClassOf(entry.type, type)) return entry.uuid;
                }
                if (isChildClassOf(type, SpriteFrame)) for (var _i = 0; _i < item.length; _i++) {
                    if (isChildClassOf(item[_i].type, SpriteAtlas)) {
                        errorID(4932, path);
                        break;
                    }
                }
            } else {
                if (!type || isChildClassOf(item.type, type)) return item.uuid;
                isChildClassOf(type, SpriteFrame) && isChildClassOf(item.type, SpriteAtlas) && errorID(4932, path);
            }
            return "";
        }
    }, {
        key: "getUuidArray",
        value: function getUuidArray(path, type, out_urls) {
            "/" === (path = url.normalize(path))[path.length - 1] && (path = path.slice(0, -1));
            var _foundAtlasUrl, path2uuid = this._pathToUuid, uuids = [];
            for (var p in path2uuid) if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                var item = path2uuid[p];
                if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                    var entry = item[i];
                    !type || isChildClassOf(entry.type, type) ? (uuids.push(entry.uuid), out_urls && out_urls.push(p)) : entry.type === SpriteAtlas && (_foundAtlasUrl = p);
                } else !type || isChildClassOf(item.type, type) ? (uuids.push(item.uuid), out_urls && out_urls.push(p)) : item.type === SpriteAtlas && (_foundAtlasUrl = p);
            }
            return 0 === uuids.length && _foundAtlasUrl && isChildClassOf(type, SpriteFrame) && errorID(4932, _foundAtlasUrl), 
            uuids;
        }
    }, {
        key: "add",
        value: function add(path, uuid, type, isMainAsset) {
            isMainAsset && (path = path.substring(0, path.length - extname(path).length));
            var newEntry = new Entry(uuid, type);
            pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
        }
    }, {
        key: "_getInfo_DEBUG",
        value: function _getInfo_DEBUG(uuid, out_info) {
            for (var path2uuid = this._pathToUuid, paths = Object.keys(path2uuid), p = 0; p < paths.length; ++p) {
                var path = paths[p], item = path2uuid[path];
                if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
                    var entry = item[i];
                    if (entry.uuid === uuid) return out_info.path = path, out_info.type = entry.type, 
                    !0;
                } else if (item.uuid === uuid) return out_info.path = path, out_info.type = item.type, 
                !0;
            }
            return !1;
        }
    }, {
        key: "reset",
        value: function reset() {
            this._pathToUuid = createMap(!0);
        }
    } ]), AssetTable;
}();

function parseDepends(key, parsed) {
    var item = cc.loader.getItem(key);
    if (item) {
        var depends = item.dependKeys;
        if (depends) for (var i = 0; i < depends.length; i++) {
            var depend = depends[i];
            parsed[depend] || (parsed[depend] = !0, parseDepends(depend, parsed));
        }
    }
}

function visitAsset(asset, excludeMap) {
    if (asset._uuid) {
        var key = cc.loader._getReferenceKey(asset);
        excludeMap[key] || (excludeMap[key] = !0, parseDepends(key, excludeMap));
    }
}

function visitComponent(comp, excludeMap) {
    for (var props = Object.getOwnPropertyNames(comp), i = 0; i < props.length; i++) {
        var value = comp[props[i]];
        if ("object" === _typeof(value) && value) if (Array.isArray(value)) for (var j = 0; j < value.length; j++) {
            var val = value[j];
            val instanceof RawAsset && visitAsset(val, excludeMap);
        } else if (value.constructor && value.constructor !== Object) value instanceof RawAsset && visitAsset(value, excludeMap); else for (var keys = Object.getOwnPropertyNames(value), _j = 0; _j < keys.length; _j++) {
            var _val = value[keys[_j]];
            _val instanceof RawAsset && visitAsset(_val, excludeMap);
        }
    }
}

function visitNode(node, excludeMap) {
    for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], excludeMap);
    for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], excludeMap);
}

function getDependsRecursively(key) {
    var depends = {};
    return parseDepends(key, depends), Object.keys(depends);
}

var ItemState, _qid = 0 | 998 * Math.random(), _queues = createMap(!0), _pool = [];

!function(ItemState) {
    ItemState[ItemState.WORKING = 0] = "WORKING", ItemState[ItemState.COMPLETE = 1] = "COMPLETE", 
    ItemState[ItemState.ERROR = 2] = "ERROR";
}(ItemState || (ItemState = {}));

var _queueDeps = createMap(!0);

function _parseUrlParam(url) {
    if (url) {
        var split = url.split("?");
        if (split && split[0] && split[1]) {
            var urlParam = {};
            return split[1].split("&").forEach((function(item) {
                var itemSplit = item.split("=");
                urlParam[itemSplit[0]] = itemSplit[1];
            })), urlParam;
        }
    }
}

function createItem(id, queueId) {
    var url = "object" === _typeof(id) ? id.url : id, result = {
        queueId: queueId,
        id: url,
        url: url,
        rawUrl: void 0,
        urlParam: _parseUrlParam(url),
        type: "",
        error: null,
        content: null,
        complete: !1,
        states: {},
        deps: null,
        isScene: id.uuid && cc.game._sceneInfos.find((function(info) {
            return info.uuid === id.uuid;
        }))
    };
    if ("object" === _typeof(id) && (mixin(result, id), id.skips)) for (var i = 0; i < id.skips.length; i++) {
        var skip = id.skips[i];
        result.states[skip] = ItemState.COMPLETE;
    }
    return result.rawUrl = result.url, url && !result.type && (result.type = extname(url).toLowerCase().substr(1)), 
    result;
}

var _checkedIds = [];

function checkCircleReference(owner, item, recursiveCall) {
    if (!owner || !item) return !1;
    var result = !1;
    if (_checkedIds.push(item.id), item.deps) {
        var i, subDep, deps = item.deps;
        for (i = 0; i < deps.length; i++) {
            if ((subDep = deps[i]).id === owner.id) {
                result = !0;
                break;
            }
            if (!(_checkedIds.indexOf(subDep.id) >= 0) && (subDep.deps && checkCircleReference(owner, subDep, !0))) {
                result = !0;
                break;
            }
        }
    }
    return recursiveCall || (_checkedIds.length = 0), result;
}

var LoadingItems = function(_CallbacksInvoker) {
    function LoadingItems(pipeline, urlList, onProgress, onComplete) {
        var _this;
        return _classCallCheck(this, LoadingItems), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LoadingItems).call(this))).onProgress = void 0, 
        _this.onComplete = void 0, _this.map = createMap(!0), _this.completed = {}, _this.totalCount = 0, 
        _this.completedCount = 0, _this.active = void 0, _this._id = void 0, _this._pipeline = void 0, 
        _this._errorUrls = [], _this._appending = !1, _this._ownerQueue = null, _this._id = ++_qid, 
        _queues[_this._id] = _assertThisInitialized(_this), _this._pipeline = pipeline, 
        _this.onProgress = onProgress, _this.onComplete = onComplete, _this._pipeline ? _this.active = !0 : _this.active = !1, 
        urlList && (urlList.length > 0 ? _this.append(urlList) : _this.allComplete()), _this;
    }
    return _inherits(LoadingItems, CallbacksInvoker), _createClass(LoadingItems, [ {
        key: "append",
        value: function append(urlList, owner) {
            var _this2 = this;
            if (!this.active) return [];
            owner && !owner.deps && (owner.deps = []), this._appending = !0;
            var i, url, item, id, accepted = [];
            for (i = 0; i < urlList.length; ++i) {
                if ((url = urlList[i]).queueId && !this.map[url.id]) {
                    if (this.map[url.id] = url, owner && owner.deps.push(url), url.complete || checkCircleReference(owner, url)) {
                        this.totalCount++, this.itemComplete(url.id);
                        continue;
                    }
                    if ("continue" === function() {
                        var self = _this2, queue = _queues[url.queueId];
                        return queue && (_this2.totalCount++, LoadingItems.registerQueueDep(owner || _this2._id, url.id), 
                        queue.addListener(url.id, (function(item) {
                            self.itemComplete(item.id);
                        }))), "continue";
                    }()) continue;
                }
                if ("string" == typeof ((id = url).url || id)) {
                    var key = (item = createItem(url, this._id)).id;
                    this.map[key] || (this.map[key] = item, this.totalCount++, owner && owner.deps.push(item), 
                    LoadingItems.registerQueueDep(owner || this._id, key), accepted.push(item));
                }
            }
            return this._appending = !1, this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted), 
            accepted;
        }
    }, {
        key: "_childOnProgress",
        value: function _childOnProgress(item) {
            if (this.onProgress) {
                var dep = _queueDeps[this._id];
                this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
            }
        }
    }, {
        key: "allComplete",
        value: function allComplete() {
            var errors = 0 === this._errorUrls.length ? null : this._errorUrls;
            this.onComplete && this.onComplete(errors, this);
        }
    }, {
        key: "isCompleted",
        value: function isCompleted() {
            return this.completedCount >= this.totalCount;
        }
    }, {
        key: "isItemCompleted",
        value: function isItemCompleted(id) {
            return !!this.completed[id];
        }
    }, {
        key: "exists",
        value: function exists(id) {
            return !!this.map[id];
        }
    }, {
        key: "getContent",
        value: function getContent(id) {
            var item = this.map[id], ret = null;
            return item && (item.content ? ret = item.content : item.alias && (ret = item.alias.content)), 
            ret;
        }
    }, {
        key: "getError",
        value: function getError(id) {
            var item = this.map[id], ret = null;
            return item && (item.error ? ret = item.error : item.alias && (ret = item.alias.error)), 
            ret;
        }
    }, {
        key: "removeItem",
        value: function removeItem(url) {
            var item = this.map[url];
            item && this.completed[item.alias || url] && (delete this.completed[url], delete this.map[url], 
            item.alias && (delete this.completed[item.alias.id], delete this.map[item.alias.id]), 
            this.completedCount--, this.totalCount--);
        }
    }, {
        key: "itemComplete",
        value: function itemComplete(id) {
            var item = this.map[id];
            if (item) {
                var errorListId = this._errorUrls.indexOf(id);
                if (item.error && -1 === errorListId ? this._errorUrls.push(id) : item.error || -1 === errorListId || this._errorUrls.splice(errorListId, 1), 
                this.completed[id] = item, this.completedCount++, LoadingItems.finishDep(item.id), 
                this.onProgress) {
                    var dep = _queueDeps[this._id];
                    this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                }
                this.emit(id, item), this.removeAll(id), !this._appending && this.completedCount >= this.totalCount && this.allComplete();
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.active = !1, this._appending = !1, this._pipeline = null, this._ownerQueue = null, 
            this._errorUrls.length = 0, this.onProgress = void 0, this.onComplete = void 0, 
            this.map = createMap(!0), this.completed = {}, this.totalCount = 0, this.completedCount = 0, 
            this.clear(), _queues[this._id] = null, _queueDeps[this._id] && (_queueDeps[this._id].completed.length = 0, 
            _queueDeps[this._id].deps.length = 0), -1 === _pool.indexOf(this) && _pool.length < 10 && _pool.push(this);
        }
    }, {
        key: "addListener",
        value: function addListener(key, callback, target) {
            return _get(_getPrototypeOf(LoadingItems.prototype), "on", this).call(this, key, callback, target);
        }
    }, {
        key: "hasListener",
        value: function hasListener(key, callback, target) {
            return _get(_getPrototypeOf(LoadingItems.prototype), "hasEventListener", this).call(this, key, callback, target);
        }
    }, {
        key: "removeListener",
        value: function removeListener(key, callback, target) {
            return _get(_getPrototypeOf(LoadingItems.prototype), "off", this).call(this, key, callback, target);
        }
    }, {
        key: "removeAllListeners",
        value: function removeAllListeners(key) {
            _get(_getPrototypeOf(LoadingItems.prototype), "removeAll", this).call(this, key);
        }
    } ], [ {
        key: "create",
        value: function create(pipeline, urlList, onProgress, onComplete) {
            void 0 === onProgress ? "function" == typeof urlList && (onComplete = urlList, urlList = onProgress = null) : void 0 === onComplete && ("function" == typeof urlList ? (onComplete = onProgress, 
            onProgress = urlList, urlList = null) : (onComplete = onProgress, onProgress = null));
            var queue = _pool.pop();
            return queue ? (queue._pipeline = pipeline, queue.onProgress = onProgress, queue.onComplete = onComplete, 
            _queues[queue._id] = queue, queue._pipeline && (queue.active = !0), urlList && queue.append(urlList)) : queue = new LoadingItems(pipeline, urlList, onProgress, onComplete), 
            queue;
        }
    }, {
        key: "getQueue",
        value: function getQueue(item) {
            return item.queueId ? _queues[item.queueId] : null;
        }
    }, {
        key: "itemComplete",
        value: function itemComplete(item) {
            var queue = _queues[item.queueId];
            queue && queue.itemComplete(item.id);
        }
    }, {
        key: "initQueueDeps",
        value: function initQueueDeps(queue) {
            var dep = _queueDeps[queue._id];
            dep ? (dep.completed.length = 0, dep.deps.length = 0) : dep = _queueDeps[queue._id] = {
                completed: [],
                deps: []
            };
        }
    }, {
        key: "registerQueueDep",
        value: function registerQueueDep(owner, depId) {
            var queueId = owner.queueId || owner;
            if (!queueId) return !1;
            var queueDepList = _queueDeps[queueId];
            if (queueDepList) -1 === queueDepList.deps.indexOf(depId) && queueDepList.deps.push(depId); else if (owner.id) for (var id in _queueDeps) {
                var queue = _queueDeps[id];
                -1 !== queue.deps.indexOf(owner.id) && -1 === queue.deps.indexOf(depId) && queue.deps.push(depId);
            }
        }
    }, {
        key: "finishDep",
        value: function finishDep(depId) {
            for (var id in _queueDeps) {
                var queue = _queueDeps[id];
                -1 !== queue.deps.indexOf(depId) && -1 === queue.completed.indexOf(depId) && queue.completed.push(depId);
            }
        }
    } ]), LoadingItems;
}();

LoadingItems.ItemState = new cc.Enum(ItemState), cc.LoadingItems = LoadingItems;

var ItemState$1 = LoadingItems.ItemState;

function flow(pipe, item) {
    var pipeId = pipe.id, itemState = item.states[pipeId], next = pipe.next, pipeline = pipe.pipeline;
    if (!item.error && itemState !== ItemState$1.WORKING && itemState !== ItemState$1.ERROR) if (itemState === ItemState$1.COMPLETE) next ? flow(next, item) : pipeline.flowOut(item); else {
        item.states[pipeId] = ItemState$1.WORKING;
        var result = pipe.handle(item, (function(err, result) {
            err ? (item.error = err, item.states[pipeId] = ItemState$1.ERROR, pipeline.flowOut(item)) : (result && (item.content = result), 
            item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
        }));
        result instanceof Error ? (item.error = result, item.states[pipeId] = ItemState$1.ERROR, 
        pipeline.flowOut(item)) : void 0 !== result && (null !== result && (item.content = result), 
        item.states[pipeId] = ItemState$1.COMPLETE, next ? flow(next, item) : pipeline.flowOut(item));
    }
}

var Pipeline = function() {
    function Pipeline(pipes) {
        _classCallCheck(this, Pipeline), this._pipes = void 0, this._cache = createMap(!0), 
        this._pipes = pipes;
        for (var i = 0; i < pipes.length; ++i) {
            var pipe = pipes[i];
            pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null);
        }
    }
    return _createClass(Pipeline, [ {
        key: "insertPipe",
        value: function insertPipe(pipe, index) {
            if (!pipe.handle || !pipe.id || index > this._pipes.length) cc.warnID(4921); else if (this._pipes.indexOf(pipe) > 0) cc.warnID(4922); else {
                pipe.pipeline = this;
                var nextPipe = null;
                index < this._pipes.length && (nextPipe = this._pipes[index]);
                var previousPipe = null;
                index > 0 && (previousPipe = this._pipes[index - 1]), previousPipe && (previousPipe.next = pipe), 
                pipe.next = nextPipe, this._pipes.splice(index, 0, pipe);
            }
        }
    }, {
        key: "insertPipeAfter",
        value: function insertPipeAfter(refPipe, newPipe) {
            var index = this._pipes.indexOf(refPipe);
            index < 0 || this.insertPipe(newPipe, index + 1);
        }
    }, {
        key: "appendPipe",
        value: function appendPipe(pipe) {
            pipe.handle && pipe.id && (pipe.pipeline = this, pipe.next = null, this._pipes.length > 0 && (this._pipes[this._pipes.length - 1].next = pipe), 
            this._pipes.push(pipe));
        }
    }, {
        key: "flowIn",
        value: function flowIn(items) {
            var i, item, pipe = this._pipes[0];
            if (pipe) {
                for (i = 0; i < items.length; i++) (item = items[i]).isScene || (this._cache[item.id] = item);
                for (i = 0; i < items.length; i++) flow(pipe, item = items[i]);
            } else for (i = 0; i < items.length; i++) this.flowOut(items[i]);
        }
    }, {
        key: "flowInDeps",
        value: function flowInDeps(owner, urlList, callback) {
            return LoadingItems.create(this, (function(errors, items) {
                callback(errors, items), items.destroy();
            })).append(urlList, owner);
        }
    }, {
        key: "flowOut",
        value: function flowOut(item) {
            item.error ? delete this._cache[item.id] : this._cache[item.id] || item.isScene || (this._cache[item.id] = item), 
            item.complete = !0, LoadingItems.itemComplete(item);
        }
    }, {
        key: "copyItemStates",
        value: function copyItemStates(srcItem, dstItems) {
            if (dstItems instanceof Array) for (var i = 0; i < dstItems.length; ++i) dstItems[i].states = srcItem.states; else dstItems.states = srcItem.states;
        }
    }, {
        key: "getItem",
        value: function getItem(id) {
            var item = this._cache[id];
            return item ? (item.alias && (item = item.alias), item) : item;
        }
    }, {
        key: "removeItem",
        value: function removeItem(id) {
            var removed = this._cache[id];
            return removed && removed.complete && delete this._cache[id], removed;
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var id in this._cache) {
                var _item = this._cache[id];
                delete this._cache[id], _item.complete || (_item.error = new Error("Canceled manually"), 
                this.flowOut(_item));
            }
        }
    } ]), Pipeline;
}();

Pipeline.ItemState = ItemState$1, cc.Pipeline = Pipeline;

var ID = "MD5Pipe", ExtnameRegex = /(\.[^.\n\\/]*)$/, UuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;

var MD5Pipe = function() {
    function MD5Pipe(md5AssetsMap, md5NativeAssetsMap, libraryBase) {
        _classCallCheck(this, MD5Pipe), this.id = ID, this.async = !1, this.pipeline = null, 
        this.md5AssetsMap = void 0, this.md5NativeAssetsMap = void 0, this.libraryBase = void 0, 
        this.id = ID, this.async = !1, this.pipeline = null, this.md5AssetsMap = md5AssetsMap, 
        this.md5NativeAssetsMap = md5NativeAssetsMap, this.libraryBase = libraryBase;
    }
    return _createClass(MD5Pipe, [ {
        key: "handle",
        value: function handle(item) {
            var hashPatchInFolder = !1;
            return "ttf" === item.type && (hashPatchInFolder = !0), item.url = this.transformURL(item.url, hashPatchInFolder), 
            item;
        }
    }, {
        key: "transformURL",
        value: function transformURL(url, hashPatchInFolder) {
            var uuid = function getUuidFromURL(url) {
                var matches = url.match(UuidRegex);
                return matches ? matches[1] : "";
            }(url);
            if (uuid) {
                var hashValue = (!url.match(this.libraryBase) ? this.md5NativeAssetsMap : this.md5AssetsMap)[uuid];
                if (hashValue) if (hashPatchInFolder) {
                    var dirname = cc.path.dirname(url), basename = cc.path.basename(url);
                    url = "".concat(dirname, ".").concat(hashValue, "/").concat(basename);
                } else {
                    var matched = !1;
                    url = url.replace(ExtnameRegex, (function(match, p1) {
                        return matched = !0, "." + hashValue + p1;
                    })), matched || (url = url + "." + hashValue);
                }
            }
            return url;
        }
    } ]), MD5Pipe;
}();

MD5Pipe.ID = ID, Pipeline.MD5Pipe = MD5Pipe;

var PackState, JsonUnpacker = function() {
    function JsonUnpacker() {
        _classCallCheck(this, JsonUnpacker), this.jsons = {};
    }
    return _createClass(JsonUnpacker, [ {
        key: "load",
        value: function load(indices, packedJson) {
            packedJson.length !== indices.length && errorID(4915);
            for (var i = 0; i < indices.length; i++) {
                var key = indices[i], json = packedJson[i];
                this.jsons[key] = json;
            }
        }
    }, {
        key: "retrieve",
        value: function retrieve(key) {
            return this.jsons[key] || null;
        }
    } ]), JsonUnpacker;
}(), TextureUnpacker = function() {
    function TextureUnpacker() {
        _classCallCheck(this, TextureUnpacker), this.contents = {};
    }
    return _createClass(TextureUnpacker, [ {
        key: "load",
        value: function load(indices, packedJson) {
            var datas = packedJson.data;
            datas.length !== indices.length && errorID(4915);
            for (var i = 0; i < indices.length; i++) this.contents[indices[i]] = {
                base: datas[i][0],
                mipmaps: datas[i][1]
            };
        }
    }, {
        key: "retrieve",
        value: function retrieve(key) {
            var content = this.contents[key];
            return content ? {
                __type__: js._getClassId(Texture2D),
                content: content
            } : null;
        }
    } ]), TextureUnpacker;
}(), _noCacheRex = /\?/;

function urlAppendTimestamp(url) {
    return cc.game.config.noCache && "string" == typeof url && (_noCacheRex.test(url) ? url += "&_t=" + (new Date - 0) : url += "?_t=" + (new Date - 0)), 
    url;
}

!function(PackState) {
    PackState[PackState.Invalid = 0] = "Invalid", PackState[PackState.Removed = 1] = "Removed", 
    PackState[PackState.Downloading = 2] = "Downloading", PackState[PackState.Loaded = 3] = "Loaded";
}(PackState || (PackState = {}));

var UnpackerData = function UnpackerData() {
    _classCallCheck(this, UnpackerData), this.unpacker = void 0, this.state = void 0, 
    this.unpacker = null, this.state = PackState.Invalid;
}, uuidToPack = {}, packIndices = {}, globalUnpackers = {};

function error$1(uuid, packUuid) {
    return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
}

function initPacks(packs) {
    for (var packUuid in packIndices = packs, packs) for (var uuids = packs[packUuid], i = 0; i < uuids.length; i++) {
        var uuid = uuids[i], pushFront = 1 === uuids.length;
        pushToMap(uuidToPack, uuid, packUuid, pushFront);
    }
}

function _loadNewPack(uuid, packUuid, callback) {
    var packUrl = cc.AssetLibrary.getLibUrlNoExt(packUuid) + ".json";
    cc.loader.load({
        url: packUrl,
        ignoreMaxConcurrency: !0
    }, (function(err, packJson) {
        if (err) return errorID(4916, uuid), callback(err);
        var res = _doLoadNewPack(uuid, packUuid, packJson);
        res ? callback(null, res) : callback(error$1(uuid, packUuid));
    }));
}

function _doLoadNewPack(uuid, packUuid, packedJson) {
    var unpackerData = globalUnpackers[packUuid];
    return unpackerData.state !== PackState.Loaded && ("string" == typeof packedJson && (packedJson = JSON.parse(packedJson)), 
    Array.isArray(packedJson) ? unpackerData.unpacker = new JsonUnpacker : packedJson.type === _getClassId(Texture2D) && (unpackerData.unpacker = new TextureUnpacker), 
    unpackerData.unpacker.load(packIndices[packUuid], packedJson), unpackerData.state = PackState.Loaded), 
    unpackerData.unpacker.retrieve(uuid);
}

function _selectLoadedPack(packUuids) {
    for (var existsPackState = PackState.Invalid, existsPackUuid = "", i = 0; i < packUuids.length; i++) {
        var packUuid = packUuids[i], unpackerData = globalUnpackers[packUuid];
        if (unpackerData) {
            var state = unpackerData.state;
            if (state === PackState.Loaded) return packUuid;
            state > existsPackState && (existsPackState = state, existsPackUuid = packUuid);
        }
    }
    return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
}

function load(item, callback) {
    var uuid = item.uuid, packUuid = uuidToPack[uuid];
    if (packUuid) {
        Array.isArray(packUuid) && (packUuid = _selectLoadedPack(packUuid));
        var unpackerData = globalUnpackers[packUuid];
        if (unpackerData && unpackerData.state === PackState.Loaded) {
            var json = unpackerData.unpacker.retrieve(uuid);
            return json || error$1(uuid, packUuid);
        }
        return unpackerData || (console.log("Create unpacker %s for %s", packUuid, uuid), 
        (unpackerData = globalUnpackers[packUuid] = new UnpackerData).state = PackState.Downloading), 
        _loadNewPack(uuid, packUuid, callback), null;
    }
}

var PackDownloader = Object.freeze({
    __proto__: null,
    initPacks: initPacks,
    _loadNewPack: _loadNewPack,
    _doPreload: function _doPreload(packUuid, packJson) {
        var unpackerData = globalUnpackers[packUuid];
        unpackerData || ((unpackerData = globalUnpackers[packUuid] = new UnpackerData).state = PackState.Downloading), 
        unpackerData.state !== PackState.Loaded && (unpackerData.unpacker = new JsonUnpacker, 
        unpackerData.unpacker.load(packIndices[packUuid], packJson), unpackerData.state = PackState.Loaded);
    },
    _doLoadNewPack: _doLoadNewPack,
    _selectLoadedPack: _selectLoadedPack,
    load: load
}), UuidRegex$1 = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;

var _uuidToSubPack = Object.create(null), SubPackPipe = function() {
    function SubPackPipe(subpackage) {
        _classCallCheck(this, SubPackPipe), this.id = "SubPackPipe", this.async = !1, this.pipeline = null;
        var _loop = function _loop(packName) {
            var pack = subpackage[packName];
            pack.uuids && pack.uuids.forEach((function(val) {
                var uuid = decodeUuid(val), uuids = uuid.split("@").map((function(name) {
                    return encodeURIComponent(name);
                }));
                uuid = uuids.join("@"), _uuidToSubPack[uuid] = pack.path;
            }));
        };
        for (var packName in subpackage) _loop(packName);
    }
    return _createClass(SubPackPipe, [ {
        key: "handle",
        value: function handle(item) {
            return item.url = this.transformURL(item.url), null;
        }
    }, {
        key: "transformURL",
        value: function transformURL(url) {
            var uuid = function getUuidFromURL$1(url) {
                var matches = url.match(UuidRegex$1);
                return matches ? matches[1] : "";
            }(url);
            if (uuid) {
                var subpackage = _uuidToSubPack[uuid];
                if (subpackage) return url.replace("res/raw-assets/", subpackage + "raw-assets/");
            }
            return url;
        }
    } ]), SubPackPipe;
}();

SubPackPipe.ID = "SubPackPipe", Pipeline.SubPackPipe = SubPackPipe;

var _libraryBase = "", _rawAssetsBase = "", _uuidToRawAsset = createMap(!0);

function RawAssetEntry(url, type) {
    this.url = url, this.type = type;
}

var _class$o, AssetLibrary = {
    _uuidToAsset: {},
    loadAsset: function loadAsset(uuid, callback, options) {
        if ("string" != typeof uuid) return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
        var item = {
            uuid: uuid,
            type: "uuid"
        };
        options && options.existingAsset && (item.existingAsset = options.existingAsset), 
        cc.loader.load(item, (function(error$1, asset) {
            if (error$1 || !asset) error$1 = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error$1 ? error$1.message : "Unknown error")); else if (asset.constructor === cc.SceneAsset) {
                var key = cc.loader._getReferenceKey(uuid);
                asset.scene.dependAssets = getDependsRecursively(key);
            }
            callback && callback(error$1, asset);
        }));
    },
    getLibUrlNoExt: function getLibUrlNoExt(uuid, inRawAssetsDir) {
        var uuids = (uuid = decodeUuid(uuid)).split("@").map((function(name) {
            return encodeURIComponent(name);
        }));
        return uuid = uuids.join("@"), (inRawAssetsDir ? _rawAssetsBase + "assets/" : _libraryBase) + uuid.slice(0, 2) + "/" + uuid;
    },
    _queryAssetInfoInEditor: function _queryAssetInfoInEditor(uuid, callback) {
        callback(new Error("Unable to load resource: EditorExtends is not defined."));
    },
    _getAssetInfoInRuntime: function _getAssetInfoInRuntime(uuid, result) {
        result = result || {
            url: null,
            raw: !1
        };
        var info = _uuidToRawAsset[uuid];
        return info && !isChildClassOf(info.type, cc.Asset) ? (result.url = _rawAssetsBase + info.url, 
        result.raw = !0) : (result.url = this.getLibUrlNoExt(uuid) + ".json", result.raw = !1), 
        result;
    },
    _uuidInSettings: function _uuidInSettings(uuid) {
        return uuid in _uuidToRawAsset;
    },
    queryAssetInfo: function queryAssetInfo(uuid, callback) {
        var info = this._getAssetInfoInRuntime(uuid);
        callback(null, info.url, info.raw);
    },
    parseUuidInEditor: function parseUuidInEditor(url) {},
    loadJson: function loadJson(json, callback) {
        var randomUuid = "" + ((new Date).getTime() + Math.random()), item = {
            uuid: randomUuid,
            type: "uuid",
            content: json,
            skips: [ cc.loader.assetLoader.id, cc.loader.downloader.id ]
        };
        cc.loader.load(item, (function(error, asset) {
            if (error) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message); else {
                if (asset.constructor === cc.SceneAsset) {
                    var key = cc.loader._getReferenceKey(randomUuid);
                    asset.scene.dependAssets = getDependsRecursively(key);
                }
                if (function isScene(asset) {
                    return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
                }(asset)) {
                    var id = cc.loader._getReferenceKey(randomUuid);
                    cc.loader.removeItem(id);
                }
            }
            asset._uuid = "", callback && callback(error, asset);
        }));
    },
    getAssetByUuid: function getAssetByUuid(uuid) {
        return AssetLibrary._uuidToAsset[uuid] || null;
    },
    init: function init(options) {
        var libraryPath = options.libraryPath;
        libraryPath = libraryPath.replace(/\\/g, "/"), _libraryBase = cc.path.stripSep(libraryPath) + "/", 
        _rawAssetsBase = options.rawAssetsBase;
        var md5AssetsMap = options.md5AssetsMap;
        if (md5AssetsMap && md5AssetsMap.import) {
            var i = 0, md5ImportMap = createMap(!0), md5Entries = md5AssetsMap.import;
            for (i = 0; i < md5Entries.length; i += 2) {
                var uuids = decodeUuid(md5Entries[i]).split("@").map((function(name) {
                    return encodeURIComponent(name);
                }));
                md5ImportMap[uuids.join("@")] = md5Entries[i + 1];
            }
            var md5RawAssetsMap = createMap(!0);
            for (md5Entries = md5AssetsMap["raw-assets"], i = 0; i < md5Entries.length; i += 2) {
                var _uuids = decodeUuid(md5Entries[i]).split("@").map((function(name) {
                    return encodeURIComponent(name);
                }));
                md5RawAssetsMap[_uuids.join("@")] = md5Entries[i + 1];
            }
            var md5Pipe = new MD5Pipe(md5ImportMap, md5RawAssetsMap, _libraryBase);
            cc.loader.insertPipeAfter(cc.loader.assetLoader, md5Pipe), cc.loader.md5Pipe = md5Pipe;
        }
        var subPackages = options.subPackages;
        if (subPackages) {
            cc.loader.downloader.setSubPackages(subPackages);
            var subPackPipe = new SubPackPipe(subPackages);
            cc.loader.insertPipeAfter(cc.loader.assetLoader, subPackPipe), cc.loader.subPackPipe = subPackPipe;
        }
        var assetTables = cc.loader._assetTables;
        for (var mount in assetTables) assetTables[mount].reset();
        var rawAssets = options.rawAssets;
        if (rawAssets) for (var mountPoint in rawAssets) {
            var assets = rawAssets[mountPoint];
            for (var _uuid in assets) {
                var info = assets[_uuid], url = info[0], typeId = info[1], type = _getClassById(typeId);
                if (type) {
                    _uuidToRawAsset[_uuid] = new RawAssetEntry(mountPoint + "/" + url, type);
                    var isSubAsset = 1 === info[2];
                    assetTables[mountPoint] || (assetTables[mountPoint] = new AssetTable), assetTables[mountPoint].add(url, _uuid, type, !isSubAsset);
                } else cc.error("Cannot get", typeId);
            }
        }
        options.packedAssets && initPacks(options.packedAssets), cc.url._init(options.mountPaths && options.mountPaths.assets || _rawAssetsBase + "assets");
    }
};

cc.AssetLibrary = AssetLibrary;

var _dec$p, _dec2$a, _class$p, _class2$l, _descriptor$j, Font = ccclass("cc.Font")(_class$o = function(_Asset) {
    function Font() {
        return _classCallCheck(this, Font), _possibleConstructorReturn(this, _getPrototypeOf(Font).apply(this, arguments));
    }
    return _inherits(Font, Asset), Font;
}()) || _class$o;

cc.Font = Font;

var _dec$q, _dec2$b, _class$q, _class2$m, _descriptor$k, _descriptor2$c, _descriptor3$9, _descriptor4$5, TTFFont = (_dec$p = ccclass("cc.TTFFont"), 
_dec2$a = property({
    override: !0
}), _dec$p((_descriptor$j = _applyDecoratedDescriptor((_class2$l = function(_Font) {
    function TTFFont() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TTFFont);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TTFFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_fontFamily", _descriptor$j, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(TTFFont, Font), _createClass(TTFFont, [ {
        key: "_nativeAsset",
        get: function get() {
            return this._fontFamily;
        },
        set: function set(value) {
            this._fontFamily = value || "Arial";
        }
    } ]), TTFFont;
}()).prototype, "_fontFamily", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$l.prototype, "_nativeAsset", [ _dec2$a, string ], Object.getOwnPropertyDescriptor(_class2$l.prototype, "_nativeAsset"), _class2$l.prototype), 
_class$p = _class2$l)) || _class$p);

cc.TTFFont = TTFFont;

var _class$r, BitmapFont = (_dec$q = ccclass("cc.BitmapFont"), _dec2$b = property({
    type: SpriteFrame
}), _dec$q((_descriptor$k = _applyDecoratedDescriptor((_class2$m = function(_Font) {
    function BitmapFont() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, BitmapFont);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BitmapFont)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "fntDataStr", _descriptor$k, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "spriteFrame", _descriptor2$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "fontSize", _descriptor3$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "fntConfig", _descriptor4$5, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(BitmapFont, Font), BitmapFont;
}()).prototype, "fntDataStr", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor2$c = _applyDecoratedDescriptor(_class2$m.prototype, "spriteFrame", [ _dec2$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$9 = _applyDecoratedDescriptor(_class2$m.prototype, "fontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _descriptor4$5 = _applyDecoratedDescriptor(_class2$m.prototype, "fntConfig", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$q = _class2$m)) || _class$q);

cc.BitmapFont = BitmapFont;

var LabelAtlas = ccclass("cc.LabelAtlas")(_class$r = function(_BitmapFont) {
    function LabelAtlas() {
        return _classCallCheck(this, LabelAtlas), _possibleConstructorReturn(this, _getPrototypeOf(LabelAtlas).apply(this, arguments));
    }
    return _inherits(LabelAtlas, BitmapFont), LabelAtlas;
}()) || _class$r;

cc.LabelAtlas = LabelAtlas;

var reusedArray = [], AssetLoader = function() {
    function AssetLoader() {
        _classCallCheck(this, AssetLoader), this.id = "AssetLoader", this.async = !0, this.pipeline = null;
    }
    return _createClass(AssetLoader, [ {
        key: "handle",
        value: function handle(item, callback) {
            var uuid = item.uuid;
            if (!uuid) return item.content || null;
            cc.AssetLibrary.queryAssetInfo(uuid, (function(error, url, isRawAsset) {
                if (error) callback(error); else if (item.url = item.rawUrl = url, item.isRawAsset = isRawAsset, 
                isRawAsset) {
                    var ext = extname(url).toLowerCase();
                    if (!ext) return void callback(new Error(getError(4931, uuid, url)));
                    ext = ext.substr(1);
                    var queue = LoadingItems.getQueue(item);
                    reusedArray[0] = {
                        queueId: item.queueId,
                        id: url,
                        url: url,
                        type: ext,
                        error: null,
                        alias: item,
                        complete: !0
                    }, queue && queue.append(reusedArray), item.type = ext, callback(null, item.content);
                } else item.type = "uuid", callback(null, item.content);
            }));
        }
    } ]), AssetLoader;
}();

function downloadBinary(item, callback) {
    var url = item.url, xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load binary data failed: " + url;
    xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
        var arrayBuffer = xhr.response;
        arrayBuffer ? callback(null, arrayBuffer) : callback({
            status: xhr.status,
            errorMessage: errInfo + "(no response)"
        });
    }, xhr.onerror = function() {
        callback({
            status: xhr.status,
            errorMessage: errInfo + "(error)"
        });
    }, xhr.ontimeout = function() {
        callback({
            status: xhr.status,
            errorMessage: errInfo + "(time out)"
        });
    }, xhr.send(null);
}

function downloadText(item, callback) {
    var url = item.url;
    url = urlAppendTimestamp(url);
    var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load text file failed: " + url;
    xhr.open("GET", url, !0), xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8"), 
    xhr.onload = function() {
        4 === xhr.readyState ? 200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
            status: xhr.status,
            errorMessage: errInfo + "(wrong status)"
        }) : callback({
            status: xhr.status,
            errorMessage: errInfo + "(wrong readyState)"
        });
    }, xhr.onerror = function() {
        callback({
            status: xhr.status,
            errorMessage: errInfo + "(error)"
        });
    }, xhr.ontimeout = function() {
        callback({
            status: xhr.status,
            errorMessage: errInfo + "(time out)"
        });
    }, xhr.send(null);
}

AssetLoader.ID = "AssetLoader", Pipeline.AssetLoader = AssetLoader;

var PlayingState = {
    INITIALIZING: 0,
    PLAYING: 1,
    STOPPED: 2
}, AudioPlayer = function() {
    function AudioPlayer(info) {
        var _this = this;
        _classCallCheck(this, AudioPlayer), this._state = PlayingState.STOPPED, this._duration = 0, 
        this._eventTarget = void 0, this._onHide = void 0, this._onShow = void 0, this._interrupted = !1, 
        this._blocking = !1, this._duration = info.duration, this._eventTarget = info.eventTarget, 
        this._onHide = function() {
            _this._blocking = !0, _this._state === PlayingState.PLAYING && (_this.pause(), _this._interrupted = !0);
        }, this._onShow = function() {
            _this._blocking = !1, _this._interrupted && (_this.play(), _this._interrupted = !1);
        }, cc.game.on(cc.Game.EVENT_HIDE, this._onHide), cc.game.on(cc.Game.EVENT_SHOW, this._onShow);
    }
    return _createClass(AudioPlayer, [ {
        key: "getState",
        value: function getState() {
            return this._state;
        }
    }, {
        key: "getDuration",
        value: function getDuration() {
            return this._duration;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            cc.game.off(cc.Game.EVENT_HIDE, this._onHide), cc.game.off(cc.Game.EVENT_SHOW, this._onShow);
        }
    } ]), AudioPlayer;
}();

cc.internal.AudioPlayer = AudioPlayer;

var _dec$s, _dec2$c, _class$s, _class2$n, _descriptor$l, _descriptor2$d, _class3$a, _temp$p, AudioPlayerDOM = function(_AudioPlayer) {
    function AudioPlayerDOM(info) {
        var _this;
        return _classCallCheck(this, AudioPlayerDOM), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerDOM).call(this, info)))._volume = 1, 
        _this._loop = !1, _this._oneShotOngoing = !1, _this._audio = void 0, _this._cbRegistered = !1, 
        _this._remove_cb = void 0, _this._post_play = void 0, _this._on_gesture = void 0, 
        _this._post_gesture = void 0, _this._audio = info.clip, _this._remove_cb = function() {
            _this._cbRegistered && (cc.game.canvas.removeEventListener("touchend", _this._on_gesture), 
            cc.game.canvas.removeEventListener("mouseup", _this._on_gesture), _this._cbRegistered = !1);
        }, _this._post_play = function() {
            _this._state = PlayingState.PLAYING, _this._eventTarget.emit("started"), _this._remove_cb();
        }, _this._post_gesture = function() {
            _this._interrupted ? (_this._post_play(), _this._interrupted = !1) : (_this._audio.pause(), 
            _this._audio.currentTime = 0);
        }, _this._on_gesture = function() {
            if (_this._audio) {
                var promise = _this._audio.play();
                if (!promise) return _this._state = PlayingState.PLAYING, void cc.director.once(cc.Director.EVENT_AFTER_UPDATE, _this._post_gesture);
                promise.then(_this._post_gesture), _this._remove_cb();
            }
        }, _this._audio.volume = _this._volume, _this._audio.loop = _this._loop, _this._audio.addEventListener("ended", (function() {
            _this._oneShotOngoing || (_this._state = PlayingState.STOPPED, _this._audio.currentTime = 0, 
            _this._eventTarget.emit("ended"));
        })), cc.game.canvas.addEventListener("touchend", _this._on_gesture), cc.game.canvas.addEventListener("mouseup", _this._on_gesture), 
        _this._cbRegistered = !0, _this;
    }
    return _inherits(AudioPlayerDOM, AudioPlayer), _createClass(AudioPlayerDOM, [ {
        key: "play",
        value: function play() {
            var _this2 = this;
            if (this._audio && this._state !== PlayingState.PLAYING) if (this._blocking) this._interrupted = !0; else {
                var promise = this._audio.play();
                if (!promise) return this._state = PlayingState.PLAYING, void cc.director.once(cc.Director.EVENT_AFTER_UPDATE, this._post_play);
                promise.then(this._post_play).catch((function() {
                    _this2._interrupted = !0;
                }));
            }
        }
    }, {
        key: "pause",
        value: function pause() {
            this._audio && this._state === PlayingState.PLAYING && (this._audio.pause(), this._state = PlayingState.STOPPED, 
            this._oneShotOngoing = !1);
        }
    }, {
        key: "stop",
        value: function stop() {
            this._audio && (this._audio.currentTime = 0, this._state === PlayingState.PLAYING && (this._audio.pause(), 
            this._state = PlayingState.STOPPED, this._oneShotOngoing = !1));
        }
    }, {
        key: "playOneShot",
        value: function playOneShot() {
            var _this3 = this, volume = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, clip = this._audio;
            clip && (clip.currentTime = 0, clip.volume = volume, this._oneShotOngoing || (clip.loop = !1, 
            this._oneShotOngoing = !0, clip.play().then((function() {
                clip.addEventListener("ended", (function() {
                    clip.currentTime = 0, clip.volume = _this3._volume, clip.loop = _this3._loop, _this3._oneShotOngoing = !1;
                }), {
                    once: !0
                });
            })).catch((function() {
                _this3._oneShotOngoing = !1;
            }))));
        }
    }, {
        key: "setCurrentTime",
        value: function setCurrentTime(val) {
            this._audio && (this._audio.currentTime = clamp(val, 0, this._duration));
        }
    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this._audio ? this._audio.currentTime : 0;
        }
    }, {
        key: "setVolume",
        value: function setVolume(val, immediate) {
            this._volume = val, this._audio && (this._audio.volume = val);
        }
    }, {
        key: "getVolume",
        value: function getVolume() {
            return this._audio ? this._audio.volume : this._volume;
        }
    }, {
        key: "setLoop",
        value: function setLoop(val) {
            this._loop = val, this._audio && (this._audio.loop = val);
        }
    }, {
        key: "getLoop",
        value: function getLoop() {
            return this._loop;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._audio && (this._audio.src = ""), _get(_getPrototypeOf(AudioPlayerDOM.prototype), "destroy", this).call(this);
        }
    } ]), AudioPlayerDOM;
}(), audioSupport = sys.__audioSupport, AudioPlayerWeb = function(_AudioPlayer) {
    function AudioPlayerWeb(info) {
        var _this;
        return _classCallCheck(this, AudioPlayerWeb), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioPlayerWeb).call(this, info)))._startTime = 0, 
        _this._offset = 0, _this._volume = 1, _this._loop = !1, _this._currentTimer = 0, 
        _this._audio = void 0, _this._context = void 0, _this._sourceNode = void 0, _this._gainNode = void 0, 
        _this._startInvoked = !1, _this._onEndedCB = void 0, _this._onGestureCB = void 0, 
        _this._onGestureProceedCB = void 0, _this._audio = info.clip, _this._context = audioSupport.context, 
        _this._sourceNode = _this._context.createBufferSource(), _this._gainNode = _this._context.createGain(), 
        _this._gainNode.connect(_this._context.destination), _this._onEndedCB = _this._onEnded.bind(_assertThisInitialized(_this)), 
        _this._onGestureCB = _this._onGesture.bind(_assertThisInitialized(_this)), _this._onGestureProceedCB = _this._onGestureProceed.bind(_assertThisInitialized(_this)), 
        "running" !== _this._context.state && _this._context.resume && (cc.game.canvas.addEventListener("touchend", _this._onGestureCB), 
        cc.game.canvas.addEventListener("mouseup", _this._onGestureCB)), _this;
    }
    return _inherits(AudioPlayerWeb, AudioPlayer), _createClass(AudioPlayerWeb, [ {
        key: "play",
        value: function play() {
            this._audio && this._state !== PlayingState.PLAYING && (this._blocking || "running" !== this._context.state ? this._interrupted = !0 : this._doPlay());
        }
    }, {
        key: "pause",
        value: function pause() {
            this._state === PlayingState.PLAYING && (this._doStop(), this._offset += this._context.currentTime - this._startTime, 
            this._state = PlayingState.STOPPED, clearInterval(this._currentTimer));
        }
    }, {
        key: "stop",
        value: function stop() {
            this._offset = 0, this._state === PlayingState.PLAYING && (this._doStop(), this._state = PlayingState.STOPPED, 
            clearInterval(this._currentTimer));
        }
    }, {
        key: "playOneShot",
        value: function playOneShot() {
            var volume = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
            if (this._audio) {
                var gainNode = this._context.createGain();
                gainNode.connect(this._context.destination), gainNode.gain.value = volume;
                var sourceNode = this._context.createBufferSource();
                sourceNode.buffer = this._audio, sourceNode.loop = !1, sourceNode.connect(gainNode), 
                sourceNode.start();
            }
        }
    }, {
        key: "setCurrentTime",
        value: function setCurrentTime(val) {
            this._offset = clamp(val, 0, this._audio && this._audio.duration || this._duration), 
            this._state === PlayingState.PLAYING && (this._doStop(), this._doPlay());
        }
    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this._state !== PlayingState.PLAYING ? this._offset : this._context.currentTime - this._startTime + this._offset;
        }
    }, {
        key: "setVolume",
        value: function setVolume(val, immediate) {
            this._volume = val, !immediate && this._gainNode.gain.setTargetAtTime ? this._gainNode.gain.setTargetAtTime(val, this._context.currentTime, .01) : this._gainNode.gain.value = val;
        }
    }, {
        key: "getVolume",
        value: function getVolume() {
            return this._volume;
        }
    }, {
        key: "setLoop",
        value: function setLoop(val) {
            this._loop = val, this._sourceNode.loop = val;
        }
    }, {
        key: "getLoop",
        value: function getLoop() {
            return this._loop;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            _get(_getPrototypeOf(AudioPlayerWeb.prototype), "destroy", this).call(this);
        }
    }, {
        key: "_doPlay",
        value: function _doPlay() {
            var _this2 = this;
            this._state = PlayingState.PLAYING, this._sourceNode = this._context.createBufferSource(), 
            this._sourceNode.buffer = this._audio, this._sourceNode.loop = this._loop, this._sourceNode.connect(this._gainNode), 
            this._startTime = this._context.currentTime, this._startInvoked = !1, cc.director.once(cc.Director.EVENT_AFTER_UPDATE, this._playAndEmit, this), 
            clearInterval(this._currentTimer), this._currentTimer = window.setInterval((function() {
                _this2._onEnded(), clearInterval(_this2._currentTimer), _this2._sourceNode.loop && (_this2._currentTimer = window.setInterval(_this2._onEndedCB, 1e3 * _this2._audio.duration));
            }), 1e3 * (this._audio.duration - this._offset));
        }
    }, {
        key: "_doStop",
        value: function _doStop() {
            this._startInvoked ? this._sourceNode.stop() : cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this._playAndEmit, this);
        }
    }, {
        key: "_playAndEmit",
        value: function _playAndEmit() {
            this._sourceNode.start(0, this._offset), this._eventTarget.emit("started"), this._startInvoked = !0;
        }
    }, {
        key: "_onEnded",
        value: function _onEnded() {
            this._offset = 0, this._startTime = this._context.currentTime, this._sourceNode.loop || (this._eventTarget.emit("ended"), 
            this._state = PlayingState.STOPPED);
        }
    }, {
        key: "_onGestureProceed",
        value: function _onGestureProceed() {
            this._interrupted && (this._doPlay(), this._interrupted = !1), cc.game.canvas.removeEventListener("touchend", this._onGestureCB), 
            cc.game.canvas.removeEventListener("mouseup", this._onGestureCB);
        }
    }, {
        key: "_onGesture",
        value: function _onGesture() {
            "running" !== this._context.state ? this._context.resume().then(this._onGestureProceedCB) : this._onGestureProceed();
        }
    } ]), AudioPlayerWeb;
}(), AudioType = Enum({
    WEB_AUDIO: 0,
    DOM_AUDIO: 1,
    JSB_AUDIO: 2,
    UNKNOWN_AUDIO: 3
});

exports.AudioClip = (_dec$s = ccclass("cc.AudioClip"), _dec2$c = property({
    type: AudioType
}), _dec$s((_temp$p = _class3$a = function(_Asset) {
    function AudioClip() {
        var _this;
        return _classCallCheck(this, AudioClip), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(AudioClip).call(this)), "_duration", _descriptor$l, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_loadMode", _descriptor2$d, _assertThisInitialized(_this)), 
        _this._audio = null, _this._player = null, _this.loaded = !1, _this;
    }
    return _inherits(AudioClip, Asset), _createClass(AudioClip, [ {
        key: "destroy",
        value: function destroy() {
            return this._player && this._player.destroy(), _get(_getPrototypeOf(AudioClip.prototype), "destroy", this).call(this);
        }
    }, {
        key: "play",
        value: function play() {
            this._player && this._player.play();
        }
    }, {
        key: "pause",
        value: function pause() {
            this._player && this._player.pause();
        }
    }, {
        key: "stop",
        value: function stop() {
            this._player && this._player.stop();
        }
    }, {
        key: "playOneShot",
        value: function playOneShot(volume) {
            this._player && this._player.playOneShot(volume);
        }
    }, {
        key: "setCurrentTime",
        value: function setCurrentTime(val) {
            this._player && this._player.setCurrentTime(val);
        }
    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this._player ? this._player.getCurrentTime() : 0;
        }
    }, {
        key: "getDuration",
        value: function getDuration() {
            return this._player ? this._player.getDuration() : this._duration;
        }
    }, {
        key: "setVolume",
        value: function setVolume(val, immediate) {
            this._player && this._player.setVolume(val, immediate || !1);
        }
    }, {
        key: "getVolume",
        value: function getVolume() {
            return this._player ? this._player.getVolume() : 1;
        }
    }, {
        key: "setLoop",
        value: function setLoop(val) {
            this._player && this._player.setLoop(val);
        }
    }, {
        key: "getLoop",
        value: function getLoop() {
            return !!this._player && this._player.getLoop();
        }
    }, {
        key: "_getPlayer",
        value: function _getPlayer(clip) {
            var ctor;
            return "undefined" != typeof AudioBuffer && clip instanceof AudioBuffer ? (ctor = AudioPlayerWeb, 
            this._loadMode = AudioType.WEB_AUDIO) : (ctor = AudioPlayerDOM, this._loadMode = AudioType.DOM_AUDIO), 
            ctor;
        }
    }, {
        key: "_nativeAsset",
        set: function set(clip) {
            if (this._audio = clip, clip) {
                var ctor = this._getPlayer(clip);
                this._player = new ctor({
                    clip: clip,
                    duration: this._duration,
                    eventTarget: this
                }), this.loaded = !0, this.emit("load");
            } else this._player = null, this._loadMode = AudioType.UNKNOWN_AUDIO, this._duration = 0, 
            this.loaded = !1;
        },
        get: function get() {
            return this._audio;
        }
    }, {
        key: "loadMode",
        get: function get() {
            return this._loadMode;
        }
    }, {
        key: "state",
        get: function get() {
            return this._player ? this._player.getState() : PlayingState.INITIALIZING;
        }
    } ]), AudioClip;
}(), _class3$a.PlayingState = PlayingState, _class3$a.AudioType = AudioType, _class3$a.preventDeferredLoadDependents = !0, 
_descriptor$l = _applyDecoratedDescriptor((_class2$n = _temp$p).prototype, "_duration", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$d = _applyDecoratedDescriptor(_class2$n.prototype, "_loadMode", [ _dec2$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return AudioType.UNKNOWN_AUDIO;
    }
}), _class$s = _class2$n)) || _class$s), exports.AudioClip || (exports.AudioClip = {}), 
cc.AudioClip = exports.AudioClip;

var __audioSupport$1 = sys.__audioSupport, formatSupport$1 = __audioSupport$1.format;

function loadDomAudio(item, callback) {
    var dom = document.createElement("audio");
    dom.src = item.url;
    var clearEvent = function clearEvent() {
        clearTimeout(timer), dom.removeEventListener("canplaythrough", success, !1), dom.removeEventListener("error", failure, !1), 
        __audioSupport$1.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
    }, timer = setTimeout((function() {
        0 === dom.readyState ? failure() : success();
    }), 8e3), success = function success() {
        clearEvent(), callback(null, dom);
    }, failure = function failure() {
        clearEvent();
        var message = "load audio failure - " + item.url;
        log(message), callback(message);
    };
    dom.addEventListener("canplaythrough", success, !1), dom.addEventListener("error", failure, !1), 
    __audioSupport$1.USE_LOADER_EVENT && dom.addEventListener(__audioSupport$1.USE_LOADER_EVENT, success, !1);
}

function loadWebAudio(item, callback) {
    var context = __audioSupport$1.context;
    context || callback(new Error(getError(4926)));
    var request = cc.loader.getXMLHttpRequest();
    request.open("GET", item.url, !0), request.responseType = "arraybuffer", request.onload = function() {
        context.decodeAudioData(request.response, (function(buffer) {
            callback(null, buffer);
        }), (function() {
            callback("decode error - " + item.id, null);
        }));
    }, request.onerror = function() {
        callback("request error - " + item.id, null);
    }, request.send();
}

function downloadAudio(item, callback) {
    if (0 === formatSupport$1.length) return new Error(getError(4927));
    var audioLoader;
    __audioSupport$1.WEB_AUDIO ? audioLoader = item._owner instanceof exports.AudioClip ? item._owner.loadMode === AudioType.WEB_AUDIO ? loadWebAudio : loadDomAudio : item.urlParam && item.urlParam.useDom ? loadDomAudio : loadWebAudio : audioLoader = loadDomAudio;
    audioLoader(item, callback);
}

function skip() {
    return null;
}

function downloadScript(item, callback, isAsync) {
    var url = item.url, d = document, s = document.createElement("script");
    function loadHandler() {
        s.parentNode && s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), 
        s.removeEventListener("error", errorHandler, !1), callback(null, url);
    }
    function errorHandler() {
        s.parentNode && s.parentNode.removeChild(s), s.removeEventListener("load", loadHandler, !1), 
        s.removeEventListener("error", errorHandler, !1), callback(new Error(getError(4928, url)));
    }
    s.async = !!isAsync, s.src = urlAppendTimestamp(url), s.addEventListener("load", loadHandler, !1), 
    s.addEventListener("error", errorHandler, !1), d.body.appendChild(s);
}

function downloadImage(item, callback, isCrossOrigin, img) {
    void 0 === isCrossOrigin && (isCrossOrigin = !0);
    var url = urlAppendTimestamp(item.url);
    function loadCallback() {
        img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
        img.id = item.id, callback(null, img);
    }
    function errorCallback() {
        img.removeEventListener("load", loadCallback), img.removeEventListener("error", errorCallback), 
        "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, !1, img) : callback(new Error(getError(4930, url)));
    }
    if (img = img || new Image, isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null, 
    img.complete && img.naturalWidth > 0 && img.src === url) return img;
    img.addEventListener("load", loadCallback), img.addEventListener("error", errorCallback), 
    img.src = url;
}

var defaultMap = {
    js: downloadScript,
    png: downloadImage,
    jpg: downloadImage,
    bmp: downloadImage,
    jpeg: downloadImage,
    gif: downloadImage,
    ico: downloadImage,
    tiff: downloadImage,
    webp: downloadImage,
    image: downloadImage,
    pvr: downloadBinary,
    pkm: downloadBinary,
    mp3: downloadAudio,
    ogg: downloadAudio,
    wav: downloadAudio,
    m4a: downloadAudio,
    txt: downloadText,
    xml: downloadText,
    vsh: downloadText,
    fsh: downloadText,
    atlas: downloadText,
    tmx: downloadText,
    tsx: downloadText,
    json: downloadText,
    ExportJson: downloadText,
    plist: downloadText,
    fnt: downloadText,
    font: skip,
    eot: skip,
    ttf: skip,
    woff: skip,
    svg: skip,
    ttc: skip,
    uuid: function downloadUuid(item, callback) {
        var result = load(item, callback);
        return void 0 === result ? this.extMap.json(item, callback) : result || void 0;
    },
    binary: downloadBinary,
    bin: downloadBinary,
    default: downloadText
}, Downloader = function() {
    function Downloader(extMap) {
        _classCallCheck(this, Downloader), this.id = "Downloader", this.async = !0, this.pipeline = null, 
        this.extMap = void 0, this._curConcurrent = 0, this._loadQueue = [], this._subPackages = {}, 
        this.extMap = mixin(extMap, defaultMap);
    }
    return _createClass(Downloader, [ {
        key: "setSubPackages",
        value: function setSubPackages(subPackages) {
            this._subPackages = subPackages;
        }
    }, {
        key: "addHandlers",
        value: function addHandlers(extMap) {
            mixin(this.extMap, extMap);
        }
    }, {
        key: "_handleLoadQueue",
        value: function _handleLoadQueue() {
            for (;this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT; ) {
                var nextOne = this._loadQueue.shift();
                if (!nextOne) break;
                var syncRet = this.handle(nextOne.item, nextOne.callback);
                void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
            }
        }
    }, {
        key: "handle",
        value: function handle(item, callback) {
            var self = this, downloadFunc = this.extMap[item.type] || this.extMap.default, syncRet = void 0;
            if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
                if (this._curConcurrent++, void 0 !== (syncRet = downloadFunc.call(this, item, (function(err, result) {
                    self._curConcurrent = Math.max(0, self._curConcurrent - 1), self._handleLoadQueue(), 
                    callback && callback(err, result);
                })))) return this._curConcurrent = Math.max(0, this._curConcurrent - 1), this._handleLoadQueue(), 
                syncRet;
            } else if (item.ignoreMaxConcurrency) {
                if (void 0 !== (syncRet = downloadFunc.call(this, item, callback))) return syncRet;
            } else this._loadQueue.push({
                item: item,
                callback: callback
            });
        }
    }, {
        key: "loadSubpackage",
        value: function loadSubpackage(name, completeCallback) {
            var pac = this._subPackages[name];
            pac ? pac.loaded ? completeCallback && completeCallback() : downloadScript({
                url: pac.path
            }, (function(err) {
                err || (pac.loaded = !0), completeCallback && completeCallback(err);
            })) : completeCallback && completeCallback(new Error("Can't find subpackage ".concat(name)));
        }
    } ]), Downloader;
}();

Downloader.ID = "Downloader", Downloader.PackDownloader = PackDownloader, Pipeline.Downloader = Downloader;

var SAXParser = function() {
    function SAXParser() {
        _classCallCheck(this, SAXParser), this._isSupportDOMParser = void 0, this._parser = void 0, 
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : (this._isSupportDOMParser = !1, 
        this._parser = null);
    }
    return _createClass(SAXParser, [ {
        key: "parse",
        value: function parse(xmlTxt) {
            return this._parseXML(xmlTxt);
        }
    }, {
        key: "_parseXML",
        value: function _parseXML(textxml) {
            var xmlDoc;
            return this._isSupportDOMParser ? xmlDoc = this._parser.parseFromString(textxml, "text/xml") : ((xmlDoc = new ActiveXObject("Microsoft.XMLDOM")).async = "false", 
            xmlDoc.loadXML(textxml)), xmlDoc;
        }
    } ]), SAXParser;
}(), plistParser = new (function(_SAXParser) {
    function PlistParser() {
        return _classCallCheck(this, PlistParser), _possibleConstructorReturn(this, _getPrototypeOf(PlistParser).apply(this, arguments));
    }
    return _inherits(PlistParser, SAXParser), _createClass(PlistParser, [ {
        key: "parse",
        value: function parse(xmlTxt) {
            var xmlDoc = this._parseXML(xmlTxt), plist = xmlDoc.documentElement;
            if ("plist" !== plist.tagName) return warnID(5100), {};
            for (var node = null, i = 0, len = plist.childNodes.length; i < len && 1 !== (node = plist.childNodes[i]).nodeType; i++) ;
            return xmlDoc = null, this._parseNode(node);
        }
    }, {
        key: "_parseNode",
        value: function _parseNode(node) {
            var data = null, tagName = node.tagName;
            if ("dict" === tagName) data = this._parseDict(node); else if ("array" === tagName) data = this._parseArray(node); else if ("string" === tagName) if (1 === node.childNodes.length) data = node.firstChild.nodeValue; else {
                data = "";
                for (var i = 0; i < node.childNodes.length; i++) data += node.childNodes[i].nodeValue;
            } else "false" === tagName ? data = !1 : "true" === tagName ? data = !0 : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
            return data;
        }
    }, {
        key: "_parseArray",
        value: function _parseArray(node) {
            for (var data = [], i = 0, len = node.childNodes.length; i < len; i++) {
                var child = node.childNodes[i];
                1 === child.nodeType && data.push(this._parseNode(child));
            }
            return data;
        }
    }, {
        key: "_parseDict",
        value: function _parseDict(node) {
            for (var data = {}, key = null, i = 0, len = node.childNodes.length; i < len; i++) {
                var child = node.childNodes[i];
                1 === child.nodeType && ("key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child));
            }
            return data;
        }
    } ]), PlistParser;
}());

function isSceneObj(json) {
    return json && (json[0] && "cc.Scene" === json[0].__type__ || json[1] && "cc.Scene" === json[1].__type__ || json[0] && "cc.Prefab" === json[0].__type__);
}

function loadUuid(item, callback) {
    var json, classFinder;
    if ("string" == typeof item.content) try {
        json = JSON.parse(item.content);
    } catch (e) {
        return new Error(getError(4923, item.id, e.stack));
    } else {
        if ("object" !== _typeof(item.content)) return new Error(getError(4924));
        json = item.content;
    }
    if (null == json) return new Error(getError(4923, item.id));
    var isScene = isSceneObj(json);
    classFinder = isScene ? cc._MissingScript.safeFindClass : function classFinder(id) {
        var cls = _getClassById(id);
        return cls || (cc.warnID(4903, id), Object);
    };
    var asset, tdInfo = cc.deserialize.Details.pool.get();
    try {
        asset = cc.deserialize(json, tdInfo, {
            classFinder: classFinder,
            target: item.existingAsset,
            customEnv: item
        });
    } catch (e) {
        return cc.deserialize.Details.pool.put(tdInfo), console.error(e), new Error("Failed to load asset ".concat(item.id, ", exception occurs during deserialization: ").concat(e.stack, "."));
    }
    asset._uuid = item.uuid;
    var depends = function parseDepends$1(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
        var depends, i, dependUuid, uuidList = tdInfo.uuidList, objList = tdInfo.uuidObjList, propList = tdInfo.uuidPropList, stillUseUrl = tdInfo._stillUseUrl, dependKeys = item.dependKeys = [];
        if (deferredLoadRawAssetsInRuntime) for (depends = [], i = 0; i < uuidList.length; i++) {
            dependUuid = uuidList[i];
            var obj = objList[i], prop = propList[i], info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
            if (info.raw) {
                var url = info.url;
                obj[prop] = url, dependKeys.push(url);
            } else depends.push({
                type: "uuid",
                uuid: dependUuid,
                deferredLoadRaw: !0,
                _owner: obj,
                _ownerProp: prop,
                _stillUseUrl: stillUseUrl[i]
            });
        } else {
            for (depends = new Array(uuidList.length), i = 0; i < uuidList.length; i++) dependUuid = uuidList[i], 
            depends[i] = {
                type: "uuid",
                uuid: dependUuid,
                _owner: objList[i],
                _ownerProp: propList[i],
                _stillUseUrl: stillUseUrl[i]
            };
            asset._native && !asset.constructor.preventPreloadNativeObject && depends.push({
                url: asset.nativeUrl,
                _owner: asset,
                _ownerProp: "_nativeAsset"
            });
        }
        return depends;
    }(item, asset, tdInfo, function canDeferredLoad(asset, item, isScene) {
        var res = item.deferredLoadRaw;
        return res ? asset instanceof cc.Asset && asset.constructor.preventDeferredLoadDependents && (res = !1) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets), 
        res;
    }(asset, item, isScene));
    cc.deserialize.Details.pool.put(tdInfo);
    var wrappedCallback = function wrappedCallback(err, asset) {
        if (!err && asset.onLoaded) try {
            asset.onLoaded();
        } catch (error) {
            err = error;
        }
        callback(err, asset);
    };
    if (0 === depends.length) return wrappedCallback(null, asset);
    !function loadDepends(pipeline, item, asset, depends, callback) {
        item.content = asset;
        var dependKeys = item.dependKeys;
        pipeline.flowInDeps(item, depends, (function(errors, items) {
            var item, itemsMap = items.map;
            for (var src in itemsMap) (item = itemsMap[src]).uuid && item.content && (item.content._uuid = item.uuid);
            for (var i = 0; i < depends.length; i++) {
                var loadCallback = function loadCallback(item) {
                    var value = item.content;
                    this._stillUseUrl && (value = value ? value.nativeUrl : item.rawUrl), this._owner[this._ownerProp] = value, 
                    item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
                }, dep = depends[i], dependSrc = dep.uuid, dependUrl = dep.url;
                dep._owner, dep._ownerProp;
                if (item = itemsMap[dependUrl]) {
                    var loadCallbackCtx = dep;
                    if (item.complete || item.content) item.error ? cc._throw(item.error) : loadCallback.call(loadCallbackCtx, item); else {
                        var queue = LoadingItems.getQueue(item);
                        queue && queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
                    }
                }
            }
            callback(errors, asset);
        }));
    }(this.pipeline, item, asset, depends, wrappedCallback);
}

loadUuid.isSceneObj = isSceneObj;

var nativeCheck, _canvasContext = null, _fontFaces = {}, _intervalId = -1, _loadingFonts = [], useNativeCheck = function() {
    if (!nativeCheck) if (window.FontFace) {
        var match = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent), safari10Match = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
        nativeCheck = match ? parseInt(match[1], 10) > 42 : !safari10Match;
    } else nativeCheck = !1;
    return nativeCheck;
};

function _checkFontLoaded() {
    for (var allFontsLoaded = !0, now = Date.now(), i = _loadingFonts.length - 1; i >= 0; i--) {
        var fontLoadHandle = _loadingFonts[i], fontFamily = fontLoadHandle.fontFamilyName;
        if (now - fontLoadHandle.startTime > 3e3) cc.warnID(4933, fontFamily), fontLoadHandle.callback(null, fontFamily), 
        _loadingFonts.splice(i, 1); else {
            var oldWidth = fontLoadHandle.refWidth;
            _canvasContext.font = "40px " + fontFamily, oldWidth !== safeMeasureText(_canvasContext, "BES bswy:->@123丁ぁᄁ") ? (_loadingFonts.splice(i, 1), 
            fontLoadHandle.callback(null, fontFamily)) : allFontsLoaded = !1;
        }
    }
    allFontsLoaded && (clearInterval(_intervalId), _intervalId = -1);
}

function loadFont(item, callback) {
    var url = item.url, fontFamilyName = function _getFontFamily(fontHandle) {
        var ttfIndex = fontHandle.lastIndexOf(".ttf");
        if (-1 === ttfIndex) return fontHandle;
        var fontFamilyName, slashPos = fontHandle.lastIndexOf("/");
        fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
        -1 !== fontFamilyName.indexOf(" ") && (fontFamilyName = '"' + fontFamilyName + '"');
        return fontFamilyName;
    }(url);
    if (_fontFaces[fontFamilyName]) return fontFamilyName;
    if (!_canvasContext) {
        var labelCanvas = document.createElement("canvas");
        labelCanvas.width = 100, labelCanvas.height = 100, _canvasContext = labelCanvas.getContext("2d");
    }
    var fontDesc = "40px " + fontFamilyName;
    _canvasContext.font = fontDesc;
    var refWidth = safeMeasureText(_canvasContext, "BES bswy:->@123丁ぁᄁ"), fontStyle = document.createElement("style");
    fontStyle.type = "text/css";
    var fontStr = "";
    isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:", 
    fontStr += "url('" + url + "');", fontStyle.textContent = fontStr + "}", document.body.appendChild(fontStyle);
    var preloadDiv = document.createElement("div"), divStyle = preloadDiv.style;
    if (divStyle.fontFamily = fontFamilyName, preloadDiv.innerHTML = ".", divStyle.position = "absolute", 
    divStyle.left = "-100px", divStyle.top = "-100px", document.body.appendChild(preloadDiv), 
    useNativeCheck()) !function nativeCheckFontLoaded(start, font, callback) {
        var timeoutId, loader = new Promise((function(resolve, reject) {
            !function check() {
                Date.now() - start >= 3e3 ? reject() : document.fonts.load("40px " + font).then((function(fonts) {
                    fonts.length >= 1 ? resolve() : setTimeout(check, 100);
                }), (function() {
                    reject();
                }));
            }();
        })), timer = new Promise((function(resolve, reject) {
            timeoutId = setTimeout(reject, 3e3);
        }));
        Promise.race([ timer, loader ]).then((function() {
            timeoutId && (clearTimeout(timeoutId), timeoutId = null), callback(null, font);
        }), (function() {
            cc.warnID(4933, font), callback(null, font);
        }));
    }(Date.now(), fontFamilyName, callback); else {
        var fontLoadHandle = {
            fontFamilyName: fontFamilyName,
            refWidth: refWidth,
            callback: callback,
            startTime: Date.now()
        };
        _loadingFonts.push(fontLoadHandle), -1 === _intervalId && (_intervalId = setInterval(_checkFontLoaded, 100));
    }
    _fontFaces[fontFamilyName] = fontStyle;
}

function loadJSON(item) {
    if ("string" != typeof item.content) return new Error("JSON Loader: Input item doesn't contain string content");
    try {
        return JSON.parse(item.content);
    } catch (e) {
        return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
    }
}

function loadImage(item) {
    if (item._owner instanceof cc.Asset) return null;
    var image = item.content;
    if (cc.sys.platform !== cc.sys.FB_PLAYABLE_ADS && !(image instanceof Image)) return new Error("Image Loader: Input item doesn't contain Image content");
    var rawUrl = item.rawUrl, imageAsset = item.imageAsset || new ImageAsset;
    return imageAsset._uuid = item.uuid, imageAsset._url = rawUrl, imageAsset._setRawAsset(rawUrl, !1), 
    imageAsset._nativeAsset = image, imageAsset;
}

function loadAudioAsAsset(item, callback) {
    if (item._owner instanceof cc.Asset) return null;
    var audioClip = new cc.AudioClip;
    return audioClip._setRawAsset(item.rawUrl, !1), audioClip._nativeAsset = item.content, 
    audioClip;
}

function loadBinary(item) {
    return item.load ? item.load(item.content) : item.content;
}

function readBEUint16(header, offset) {
    return header[offset] << 8 | header[offset + 1];
}

var defaultMap$1 = {
    png: loadImage,
    jpg: loadImage,
    bmp: loadImage,
    jpeg: loadImage,
    gif: loadImage,
    ico: loadImage,
    tiff: loadImage,
    webp: loadImage,
    image: loadImage,
    pvr: function loadPVRTex(item) {
        var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Int32Array(buffer, 0, 13);
        if (55727696 === header[0]) {
            var width = header[7], height = header[6], dataOffset = header[12] + 52;
            return buffer = buffer.slice(dataOffset, buffer.byteLength), {
                _data: new Uint8Array(buffer),
                _compressed: !0,
                width: width,
                height: height
            };
        }
        if (559044176 === header[11]) {
            var headerLength = header[0], _height = header[1], _width = header[2];
            return buffer = buffer.slice(headerLength, buffer.byteLength), {
                _data: new Uint8Array(buffer),
                _compressed: !0,
                width: _width,
                height: _height
            };
        }
        return new Error("Invalid magic number in PVR header");
    },
    pkm: function loadPKMTex(item) {
        var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer, header = new Uint8Array(buffer), format = readBEUint16(header, 6);
        if (0 !== format && 1 !== format && 3 !== format) return new Error("Invalid magic number in ETC header");
        var width = readBEUint16(header, 12), height = readBEUint16(header, 14);
        return readBEUint16(header, 8), readBEUint16(header, 10), buffer = buffer.slice(16, buffer.byteLength), 
        {
            _data: new Uint8Array(buffer),
            _compressed: !0,
            width: width,
            height: height
        };
    },
    mp3: loadAudioAsAsset,
    ogg: loadAudioAsAsset,
    wav: loadAudioAsAsset,
    m4a: loadAudioAsAsset,
    json: loadJSON,
    ExportJson: loadJSON,
    plist: function loadPlist(item) {
        if ("string" != typeof item.content) return new Error("Plist Loader: Input item doesn't contain string content");
        var result = plistParser.parse(item.content);
        return result || new Error("Plist Loader: Parse [" + item.id + "] failed");
    },
    uuid: loadUuid,
    prefab: loadUuid,
    fire: loadUuid,
    scene: loadUuid,
    binary: loadBinary,
    bin: loadBinary,
    font: loadFont,
    eot: loadFont,
    ttf: loadFont,
    woff: loadFont,
    svg: loadFont,
    ttc: loadFont,
    default: function loadNothing() {
        return null;
    }
}, Loader = function() {
    function Loader(extMap) {
        _classCallCheck(this, Loader), this.id = "Loader", this.async = !0, this.pipeline = null, 
        this.extMap = void 0, this.extMap = mixin(extMap, defaultMap$1);
    }
    return _createClass(Loader, [ {
        key: "addHandlers",
        value: function addHandlers(extMap) {
            this.extMap = mixin(this.extMap, extMap);
        }
    }, {
        key: "handle",
        value: function handle(item, callback) {
            return (this.extMap[item.type] || this.extMap.default).call(this, item, callback);
        }
    } ]), Loader;
}();

Loader.ID = "Loader", Pipeline.Loader = Loader;

var _tmpInfo = null;

function doCheckCouldRelease(releasedKey, refOwnerItem, caches) {
    caches[releasedKey] || cc.log('"'.concat(releasedKey, '" was released but maybe still referenced by ').concat(function getItemDesc(item) {
        return item.uuid ? (_tmpInfo || (_tmpInfo = {
            path: "",
            type: null
        }), cc.loader._assetTables.assets._getInfo_DEBUG(item.uuid, _tmpInfo) ? (_tmpInfo.path = "resources/" + _tmpInfo.path, 
        '"'.concat(_tmpInfo.path, '" (type: ').concat(getClassName(_tmpInfo.type), ", uuid: ").concat(item.uuid, ")")) : '"'.concat(item.rawUrl, '" (').concat(item.uuid, ")")) : '"'.concat(item.rawUrl, '"');
    }(refOwnerItem)));
}

var ReleasedAssetChecker = function() {
    function ReleasedAssetChecker() {
        _classCallCheck(this, ReleasedAssetChecker), this._releasedKeys = void 0, this._dirty = void 0, 
        this._releasedKeys = createMap(!0), this._dirty = !1;
    }
    return _createClass(ReleasedAssetChecker, [ {
        key: "setReleased",
        value: function setReleased(item, releasedKey) {
            this._releasedKeys[releasedKey] = !0, this._dirty = !0;
        }
    }, {
        key: "checkCouldRelease",
        value: function checkCouldRelease(caches) {
            if (this._dirty) {
                this._dirty = !1;
                var released = this._releasedKeys;
                for (var id in caches) {
                    var item = caches[id];
                    item.alias && (item = item.alias);
                    var depends = item.dependKeys;
                    if (depends) for (var i = 0; i < depends.length; ++i) {
                        var depend = depends[i];
                        released[depend] && (doCheckCouldRelease(depend, item, caches), delete released[depend]);
                    }
                }
                clear(released);
            }
        }
    } ]), ReleasedAssetChecker;
}(), assetTables = Object.create(null);

function getXMLHttpRequest() {
    return window.XMLHttpRequest ? new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP");
}

assetTables.assets = new AssetTable, assetTables.internal = new AssetTable;

var _info = {
    url: null,
    raw: !1
};

function getResWithUrl(res) {
    var id, result, isUuid;
    if ("object" === _typeof(res)) {
        if (result = res, res.url) return result;
        id = res.uuid;
    } else result = {}, id = res;
    return isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._uuidInSettings(id), 
    cc.AssetLibrary._getAssetInfoInRuntime(id, _info), result.url = isUuid ? _info.url : id, 
    _info.url && "uuid" === result.type && _info.raw ? (result.type = null, result.isRawAsset = !0) : isUuid || (result.isRawAsset = !0), 
    result;
}

var _sharedResources = [], _sharedList = [], CCLoader = function(_Pipeline) {
    function CCLoader() {
        var _this;
        _classCallCheck(this, CCLoader);
        var assetLoader = new AssetLoader, downloader = new Downloader, loader = new Loader;
        return (_this = _possibleConstructorReturn(this, _getPrototypeOf(CCLoader).call(this, [ assetLoader, downloader, loader ]))).getXMLHttpRequest = void 0, 
        _this.assetLoader = void 0, _this.md5Pipe = void 0, _this.downloader = void 0, _this.loader = void 0, 
        _this.onProgress = void 0, _this._assetTables = void 0, _this._autoReleaseSetting = void 0, 
        _this._releasedAssetChecker_DEBUG = void 0, _this.getXMLHttpRequest = getXMLHttpRequest, 
        _this.assetLoader = assetLoader, _this.md5Pipe = null, _this.downloader = downloader, 
        _this.loader = loader, _this.onProgress = null, _this._assetTables = assetTables, 
        _this._autoReleaseSetting = createMap(!0), _this._releasedAssetChecker_DEBUG = new ReleasedAssetChecker, 
        _this;
    }
    return _inherits(CCLoader, Pipeline), _createClass(CCLoader, [ {
        key: "init",
        value: function init(director) {
            var self = this;
            director.on(cc.Director.EVENT_AFTER_UPDATE, (function() {
                self._releasedAssetChecker_DEBUG.checkCouldRelease(self._cache);
            }));
        }
    }, {
        key: "addDownloadHandlers",
        value: function addDownloadHandlers(extMap) {
            this.downloader.addHandlers(extMap);
        }
    }, {
        key: "addLoadHandlers",
        value: function addLoadHandlers(extMap) {
            this.loader.addHandlers(extMap);
        }
    }, {
        key: "load",
        value: function load(resources, progressCallback, completeCallback) {
            void 0 === completeCallback && (completeCallback = progressCallback, progressCallback = this.onProgress || null);
            var resList, res, self = this, singleRes = !1;
            resources instanceof Array ? resList = resources : resources ? (singleRes = !0, 
            resList = [ resources ]) : resList = [], _sharedResources.length = 0;
            for (var i = 0; i < resList.length; ++i) {
                var resource = resList[i];
                if (resource && resource.id && (warnID(4920, resource.id), resource.uuid || resource.url || (resource.url = resource.id)), 
                (res = getResWithUrl(resource)).url || res.uuid) {
                    var item = this._cache[res.url];
                    _sharedResources.push(item || res);
                }
            }
            var queue = LoadingItems.create(this, progressCallback, (function(errors, items) {
                callInNextTick((function() {
                    if (completeCallback) {
                        if (singleRes) {
                            var id = res.url;
                            completeCallback.call(self, items.getError(id), items.getContent(id));
                        } else completeCallback.call(self, errors, items);
                        completeCallback = null;
                    }
                    items.destroy();
                }));
            }));
            LoadingItems.initQueueDeps(queue), queue.append(_sharedResources), _sharedResources.length = 0;
        }
    }, {
        key: "flowInDeps",
        value: function flowInDeps(owner, urlList, callback) {
            _sharedList.length = 0;
            for (var i = 0; i < urlList.length; ++i) {
                var res = getResWithUrl(urlList[i]);
                if (res.url || res.uuid) {
                    var item = this._cache[res.url];
                    item ? _sharedList.push(item) : _sharedList.push(res);
                }
            }
            var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
                queue._ownerQueue && queue._ownerQueue.onProgress && queue._ownerQueue._childOnProgress(item);
            } : null, (function(errors, items) {
                callback(errors, items), owner && owner.deps && (owner.deps.length = 0), items.destroy();
            }));
            if (owner) {
                var ownerQueue = LoadingItems.getQueue(owner);
                queue._ownerQueue = ownerQueue && ownerQueue._ownerQueue || ownerQueue;
            }
            var accepted = queue.append(_sharedList, owner);
            return _sharedList.length = 0, accepted;
        }
    }, {
        key: "loadRes",
        value: function loadRes(url, type, mount, progressCallback, completeCallback) {
            5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
            mount = "assets");
            var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
            type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
            var self = this, uuid = self._getResUuid(url, type, mount, !0);
            uuid ? this.load({
                type: "uuid",
                uuid: uuid
            }, progressCallback, (function(err, asset) {
                asset && self.setAutoReleaseRecursively(uuid, !1), completeCallback && completeCallback(err, asset);
            })) : self._urlNotFound(url, type, completeCallback);
        }
    }, {
        key: "loadResDir",
        value: function loadResDir(url, type, mount, progressCallback, completeCallback) {
            if (5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
            mount = "assets"), assetTables[mount]) {
                var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
                type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
                var urls = [], uuids = assetTables[mount].getUuidArray(url, type, urls);
                this._loadResUuids(uuids, progressCallback, (function(errors, assetRes, urlRes) {
                    for (var assetResLength = assetRes.length, i = 0; i < assetResLength; ++i) if (assetRes[i] instanceof SpriteAtlas) {
                        var spriteFrames = assetRes[i].getSpriteFrames();
                        for (var k in spriteFrames) {
                            var sf = spriteFrames[k];
                            assetRes.push(sf), urlRes && urlRes.push("".concat(urlRes[i], "/").concat(sf.name));
                        }
                    }
                    completeCallback && completeCallback(errors, assetRes, urlRes);
                }), urls);
            }
        }
    }, {
        key: "loadResArray",
        value: function loadResArray(urls, type, mount, progressCallback, completeCallback) {
            5 !== arguments.length && (completeCallback = progressCallback, progressCallback = mount, 
            mount = "assets");
            var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
            type = args.type, progressCallback = args.onProgress, completeCallback = args.onComplete;
            for (var uuids = [], i = 0; i < urls.length; i++) {
                var _url = urls[i], uuid = this._getResUuid(_url, type, mount, !0);
                if (!uuid) return void this._urlNotFound(_url, type, completeCallback);
                uuids.push(uuid);
            }
            this._loadResUuids(uuids, progressCallback, completeCallback);
        }
    }, {
        key: "getRes",
        value: function getRes(url, type) {
            var item = this._cache[url];
            if (!item) {
                var uuid = this._getResUuid(url, type, null, !0);
                if (!uuid) return null;
                var ref = this._getReferenceKey(uuid);
                item = this._cache[ref];
            }
            return item && item.alias && (item = item.alias), item && item.complete ? item.content : null;
        }
    }, {
        key: "getResCount",
        value: function getResCount() {
            return Object.keys(this._cache).length;
        }
    }, {
        key: "getDependsRecursively",
        value: function getDependsRecursively$1(owner) {
            if (owner) {
                var key = this._getReferenceKey(owner), assets = getDependsRecursively(key);
                return assets.push(key), assets;
            }
            return [];
        }
    }, {
        key: "release",
        value: function release(asset) {
            if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
                var key = asset[i];
                this.release(key);
            } else if (asset) {
                var id = this._getReferenceKey(asset), item = this.getItem(id);
                if (item) {
                    var removed = this.removeItem(id);
                    if ((asset = item.content) instanceof Asset) {
                        var nativeUrl = asset.nativeUrl;
                        nativeUrl && this.release(nativeUrl), asset.destroy();
                    }
                    removed && this._releasedAssetChecker_DEBUG.setReleased(item, id);
                }
            }
        }
    }, {
        key: "releaseAsset",
        value: function releaseAsset(asset) {
            var uuid = asset._uuid;
            uuid && this.release(uuid);
        }
    }, {
        key: "releaseRes",
        value: function releaseRes(url, type, mount) {
            var uuid = this._getResUuid(url, type, mount, !0);
            uuid ? this.release(uuid) : errorID(4914, url);
        }
    }, {
        key: "releaseResDir",
        value: function releaseResDir(url, type, mount) {
            if (assetTables[mount = mount || "assets"]) for (var uuids = assetTables[mount].getUuidArray(url, type), i = 0; i < uuids.length; i++) {
                var uuid = uuids[i];
                this.release(uuid);
            }
        }
    }, {
        key: "releaseAll",
        value: function releaseAll() {
            for (var id in this._cache) this.release(id);
        }
    }, {
        key: "removeItem",
        value: function removeItem(key) {
            var removed = Pipeline.prototype.removeItem.call(this, key);
            return delete this._autoReleaseSetting[key], removed;
        }
    }, {
        key: "setAutoRelease",
        value: function setAutoRelease(assetOrUrlOrUuid, autoRelease) {
            var key = this._getReferenceKey(assetOrUrlOrUuid);
            key && (this._autoReleaseSetting[key] = !!autoRelease);
        }
    }, {
        key: "setAutoReleaseRecursively",
        value: function setAutoReleaseRecursively(assetOrUrlOrUuid, autoRelease) {
            autoRelease = !!autoRelease;
            var key = this._getReferenceKey(assetOrUrlOrUuid);
            if (key) {
                this._autoReleaseSetting[key] = autoRelease;
                for (var depends = getDependsRecursively(key), i = 0; i < depends.length; i++) {
                    var depend = depends[i];
                    this._autoReleaseSetting[depend] = autoRelease;
                }
            }
        }
    }, {
        key: "isAutoRelease",
        value: function isAutoRelease(assetOrUrl) {
            var key = this._getReferenceKey(assetOrUrl);
            return !!key && !!this._autoReleaseSetting[key];
        }
    }, {
        key: "_getResUuid",
        value: function _getResUuid(url, type, mount, quiet) {
            var uuid = "", assetTable = assetTables[mount = mount || "assets"];
            if (url && assetTable) {
                var index = url.indexOf("?");
                if (-1 !== index && (url = url.substr(0, index)), !(uuid = assetTable.getUuid(url, type))) {
                    var extname$1 = extname(url);
                    extname$1 && (url = url.slice(0, -extname$1.length), (uuid = assetTable.getUuid(url, type)) && !quiet && warnID(4901, url, extname$1));
                }
            }
            return !uuid && type && (isChildClassOf(type, SpriteFrame) || isChildClassOf(type, Texture2D) || isChildClassOf(type, TextureCube)) && warnID(4934), 
            uuid;
        }
    }, {
        key: "_getReferenceKey",
        value: function _getReferenceKey(assetOrUrlOrUuid) {
            var key;
            return "object" === _typeof(assetOrUrlOrUuid) ? key = assetOrUrlOrUuid._uuid || null : "string" == typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, void 0, void 0, !0) || assetOrUrlOrUuid), 
            key ? (cc.AssetLibrary._getAssetInfoInRuntime(key, _info), this._cache[_info.url] ? _info.url : key) : (warnID(4800, assetOrUrlOrUuid), 
            key);
        }
    }, {
        key: "_urlNotFound",
        value: function _urlNotFound(url, type, completeCallback) {
            callInNextTick((function() {
                url = cc.url.normalize(url);
                var info = "".concat(type ? getClassName(type) : "Asset", ' in "resources/').concat(url, '" does not exist.');
                completeCallback && completeCallback(new Error(info), []);
            }));
        }
    }, {
        key: "_parseLoadResArgs",
        value: function _parseLoadResArgs(type, onProgress, onComplete) {
            if (void 0 === onComplete) {
                var isValidType = isChildClassOf(type, cc.RawAsset);
                onProgress ? (onComplete = onProgress, isValidType && (onProgress = this.onProgress || null)) : void 0 !== onProgress || isValidType || (onComplete = type, 
                onProgress = this.onProgress || null, type = null), void 0 === onProgress || isValidType || (onProgress = type, 
                type = null);
            }
            return {
                type: type,
                onProgress: onProgress,
                onComplete: onComplete
            };
        }
    }, {
        key: "_loadResUuids",
        value: function _loadResUuids(uuids, progressCallback, completeCallback, urls) {
            if (uuids.length > 0) {
                var self = this, res = uuids.map((function(uuid) {
                    return {
                        type: "uuid",
                        uuid: uuid
                    };
                }));
                this.load(res, progressCallback, (function(errors, items) {
                    if (completeCallback) {
                        for (var assetRes = [], urlRes = urls && [], i = 0; i < res.length; ++i) {
                            var uuid = res[i].uuid, id = self._getReferenceKey(uuid), item = items.getContent(id);
                            item && (self.setAutoReleaseRecursively(uuid, !1), assetRes.push(item), urlRes && urlRes.push(urls[i]));
                        }
                        urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
                    }
                }));
            } else completeCallback && callInNextTick((function() {
                urls ? completeCallback(null, [], []) : completeCallback(null, []);
            }));
        }
    } ]), CCLoader;
}(), loader = cc.loader = new CCLoader;

var _dec$t, _dec2$d, _dec3$5, _class$t, _class2$o, _descriptor$m, _descriptor2$e, _descriptor3$a, CameraFOVAxis, CameraProjection, CameraAperture, CameraISO, CameraShutter, textureUtil = Object.freeze({
    __proto__: null,
    loadImage: function loadImage$1(url, callback, target) {
        assertID(!!url, 3103);
        var imageAsset = loader.getRes(url);
        return imageAsset ? imageAsset.loaded ? (callback && callback.call(target, null, imageAsset), 
        imageAsset) : (imageAsset.once("load", (function() {
            callback && callback.call(target, null, imageAsset);
        }), target), imageAsset) : (imageAsset = new ImageAsset, loader.load({
            url: url,
            imageAsset: imageAsset
        }, (function(err, asset) {
            if (err) return callback && callback.call(target, err || new Error("Unknown error")), 
            imageAsset;
            callback && callback.call(target, null, asset);
        })), imageAsset);
    },
    cacheImage: function cacheImage(url, image) {
        if (url && image) {
            var imageAsset = new ImageAsset(image), item = {
                id: url,
                url: url,
                error: null,
                content: imageAsset,
                complete: !1
            };
            return loader.flowOut(item), imageAsset;
        }
    },
    postLoadImage: function postLoadImage(imageAsset, callback) {
        imageAsset.loaded ? callback && callback() : imageAsset.nativeUrl ? loader.load({
            url: imageAsset.nativeUrl,
            skips: imageAsset.isCompressed ? void 0 : [ "Loader" ]
        }, (function(err, image) {
            if (image) {
                if (image instanceof ImageAsset) return error("internal error: loader handle pipe must be skipped");
                imageAsset.loaded || (imageAsset._nativeAsset = image);
            }
            callback && callback(err);
        })) : callback && callback();
    }
}), Skeleton = (_dec$t = ccclass("cc.Skeleton"), _dec2$d = property([ CCString ]), 
_dec3$5 = property([ Mat4 ]), _dec$t((_descriptor$m = _applyDecoratedDescriptor((_class2$o = function(_Asset) {
    function Skeleton() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Skeleton);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Skeleton)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_joints", _descriptor$m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_bindposes", _descriptor2$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_hash", _descriptor3$a, _assertThisInitialized(_this)), 
        _this._invBindposes = null, _this;
    }
    return _inherits(Skeleton, Asset), _createClass(Skeleton, [ {
        key: "destroy",
        value: function destroy() {
            return cc.director.root.dataPoolManager.releaseSkeleton(this), _get(_getPrototypeOf(Skeleton.prototype), "destroy", this).call(this);
        }
    }, {
        key: "joints",
        get: function get() {
            return this._joints;
        },
        set: function set(value) {
            this._joints = value;
        }
    }, {
        key: "bindposes",
        get: function get() {
            return this._bindposes;
        },
        set: function set(value) {
            this._bindposes = value;
        }
    }, {
        key: "inverseBindposes",
        get: function get() {
            if (!this._invBindposes) {
                this._invBindposes = [];
                for (var i = 0; i < this._bindposes.length; i++) {
                    var inv = new Mat4;
                    Mat4.invert(inv, this._bindposes[i]), this._invBindposes.push(inv);
                }
            }
            return this._invBindposes;
        }
    }, {
        key: "hash",
        get: function get() {
            if (!this._hash) {
                for (var str = "", i = 0; i < this._bindposes.length; i++) {
                    var ibm = this._bindposes[i];
                    str += ibm.m00.toPrecision(2) + " " + ibm.m01.toPrecision(2) + " " + ibm.m02.toPrecision(2) + " " + ibm.m03.toPrecision(2) + " " + ibm.m04.toPrecision(2) + " " + ibm.m05.toPrecision(2) + " " + ibm.m06.toPrecision(2) + " " + ibm.m07.toPrecision(2) + " " + ibm.m08.toPrecision(2) + " " + ibm.m09.toPrecision(2) + " " + ibm.m10.toPrecision(2) + " " + ibm.m11.toPrecision(2) + " " + ibm.m12.toPrecision(2) + " " + ibm.m13.toPrecision(2) + " " + ibm.m14.toPrecision(2) + " " + ibm.m15.toPrecision(2) + "\n";
                }
                this._hash = murmurhash2_32_gc(str, 666);
            }
            return this._hash;
        }
    } ]), Skeleton;
}()).prototype, "_joints", [ _dec2$d ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$e = _applyDecoratedDescriptor(_class2$o.prototype, "_bindposes", [ _dec3$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$a = _applyDecoratedDescriptor(_class2$o.prototype, "_hash", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$t = _class2$o)) || _class$t);

cc.Skeleton = Skeleton, function(CameraFOVAxis) {
    CameraFOVAxis[CameraFOVAxis.VERTICAL = 0] = "VERTICAL", CameraFOVAxis[CameraFOVAxis.HORIZONTAL = 1] = "HORIZONTAL";
}(CameraFOVAxis || (CameraFOVAxis = {})), function(CameraProjection) {
    CameraProjection[CameraProjection.ORTHO = 0] = "ORTHO", CameraProjection[CameraProjection.PERSPECTIVE = 1] = "PERSPECTIVE";
}(CameraProjection || (CameraProjection = {})), function(CameraAperture) {
    CameraAperture[CameraAperture.F1_8 = 0] = "F1_8", CameraAperture[CameraAperture.F2_0 = 1] = "F2_0", 
    CameraAperture[CameraAperture.F2_2 = 2] = "F2_2", CameraAperture[CameraAperture.F2_5 = 3] = "F2_5", 
    CameraAperture[CameraAperture.F2_8 = 4] = "F2_8", CameraAperture[CameraAperture.F3_2 = 5] = "F3_2", 
    CameraAperture[CameraAperture.F3_5 = 6] = "F3_5", CameraAperture[CameraAperture.F4_0 = 7] = "F4_0", 
    CameraAperture[CameraAperture.F4_5 = 8] = "F4_5", CameraAperture[CameraAperture.F5_0 = 9] = "F5_0", 
    CameraAperture[CameraAperture.F5_6 = 10] = "F5_6", CameraAperture[CameraAperture.F6_3 = 11] = "F6_3", 
    CameraAperture[CameraAperture.F7_1 = 12] = "F7_1", CameraAperture[CameraAperture.F8_0 = 13] = "F8_0", 
    CameraAperture[CameraAperture.F9_0 = 14] = "F9_0", CameraAperture[CameraAperture.F10_0 = 15] = "F10_0", 
    CameraAperture[CameraAperture.F11_0 = 16] = "F11_0", CameraAperture[CameraAperture.F13_0 = 17] = "F13_0", 
    CameraAperture[CameraAperture.F14_0 = 18] = "F14_0", CameraAperture[CameraAperture.F16_0 = 19] = "F16_0", 
    CameraAperture[CameraAperture.F18_0 = 20] = "F18_0", CameraAperture[CameraAperture.F20_0 = 21] = "F20_0", 
    CameraAperture[CameraAperture.F22_0 = 22] = "F22_0";
}(CameraAperture || (CameraAperture = {})), function(CameraISO) {
    CameraISO[CameraISO.ISO100 = 0] = "ISO100", CameraISO[CameraISO.ISO200 = 1] = "ISO200", 
    CameraISO[CameraISO.ISO400 = 2] = "ISO400", CameraISO[CameraISO.ISO800 = 3] = "ISO800";
}(CameraISO || (CameraISO = {})), function(CameraShutter) {
    CameraShutter[CameraShutter.D1 = 0] = "D1", CameraShutter[CameraShutter.D2 = 1] = "D2", 
    CameraShutter[CameraShutter.D4 = 2] = "D4", CameraShutter[CameraShutter.D8 = 3] = "D8", 
    CameraShutter[CameraShutter.D15 = 4] = "D15", CameraShutter[CameraShutter.D30 = 5] = "D30", 
    CameraShutter[CameraShutter.D60 = 6] = "D60", CameraShutter[CameraShutter.D125 = 7] = "D125", 
    CameraShutter[CameraShutter.D250 = 8] = "D250", CameraShutter[CameraShutter.D500 = 9] = "D500", 
    CameraShutter[CameraShutter.D1000 = 10] = "D1000", CameraShutter[CameraShutter.D2000 = 11] = "D2000", 
    CameraShutter[CameraShutter.D4000 = 12] = "D4000";
}(CameraShutter || (CameraShutter = {}));

var SystemEventType, FSTOPS = [ 1.8, 2, 2.2, 2.5, 2.8, 3.2, 3.5, 4, 4.5, 5, 5.6, 6.3, 7.1, 8, 9, 10, 11, 13, 14, 16, 18, 20, 22 ], SHUTTERS = [ 1, .5, 1 / 4, 1 / 8, 1 / 15, 1 / 30, 1 / 60, .008, .004, .002, .001, 5e-4, 1 / 4e3 ], ISOS = [ 100, 200, 400, 800 ], v_a = new Vec3, v_b = new Vec3, _tempMat1 = new Mat4, _tempMat2 = new Mat4, SKYBOX_FLAG = exports.GFXClearFlag.STENCIL << 1, Camera = function() {
    function Camera() {
        _classCallCheck(this, Camera), this.isWindowSize = !0, this.screenScale = void 0, 
        this.viewport = new Rect(0, 0, 1, 1), this.clearStencil = 0, this.clearDepth = 1, 
        this.clearFlag = exports.GFXClearFlag.NONE, this._scene = null, this._node = null, 
        this._name = null, this._enabled = !1, this._proj = -1, this._width = void 0, this._height = void 0, 
        this._aspect = void 0, this._orthoHeight = 10, this._fovAxis = CameraFOVAxis.VERTICAL, 
        this._fov = toRadian(45), this._nearClip = 1, this._farClip = 1e3, this._clearColor = {
            r: .2,
            g: .2,
            b: .2,
            a: 1
        }, this._isProjDirty = !0, this._matView = new Mat4, this._matViewInv = null, this._matProj = new Mat4, 
        this._matProjInv = new Mat4, this._matViewProj = new Mat4, this._matViewProjInv = new Mat4, 
        this._frustum = new frustum, this._forward = new Vec3, this._position = new Vec3, 
        this._view = null, this._visibility = CAMERA_DEFAULT_MASK, this._priority = 0, this._aperture = CameraAperture.F16_0, 
        this._apertureValue = void 0, this._shutter = CameraShutter.D125, this._shutterValue = 0, 
        this._iso = CameraISO.ISO100, this._isoValue = 0, this._ec = 0, this._exposure = 0, 
        this._apertureValue = FSTOPS[this._aperture], this._shutterValue = SHUTTERS[this._shutter], 
        this._isoValue = ISOS[this._iso], this.updateExposure(), this._aspect = this._width = this._height = this.screenScale = 1;
    }
    return _createClass(Camera, [ {
        key: "initialize",
        value: function initialize(info) {
            this._name = info.name, this._node = info.node, this._proj = info.projection, this._priority = info.priority || 0, 
            this._view = cc.director.root.createView({
                camera: this,
                name: this._name,
                priority: this._priority,
                flows: info.flows
            }), this.changeTargetWindow(info.window), console.log("Created Camera: " + this._name + " " + this._width + "x" + this._height);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            cc.director.root.destroyView(this._view), this._view = null, this._name = null;
        }
    }, {
        key: "attachToScene",
        value: function attachToScene(scene) {
            this._scene = scene, this._view && this._view.enable(!0);
        }
    }, {
        key: "detachFromScene",
        value: function detachFromScene() {
            this._scene = null, this._view && this._view.enable(!1);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._width = width, this._height = height, this._aspect = this._width / this._height, 
            this._isProjDirty = !0;
        }
    }, {
        key: "setFixedSize",
        value: function setFixedSize(width, height) {
            this._width = width, this._height = height, this._aspect = this._width / this._height, 
            this.isWindowSize = !1;
        }
    }, {
        key: "update",
        value: function update() {
            var forceUpdate = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (this._node) {
                if ((this._node.hasChangedFlags || forceUpdate) && (Mat4.invert(this._matView, this._node.worldMatrix), 
                this._forward.x = -this._matView.m02, this._forward.y = -this._matView.m06, this._forward.z = -this._matView.m10, 
                this._node.getWorldPosition(this._position)), this._isProjDirty) {
                    if (this._proj === CameraProjection.PERSPECTIVE) Mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip, this._fovAxis === CameraFOVAxis.VERTICAL); else {
                        var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                        Mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip);
                    }
                    Mat4.invert(this._matProjInv, this._matProj);
                }
                (this._node.hasChangedFlags || this._isProjDirty || forceUpdate) && (Mat4.multiply(this._matViewProj, this._matProj, this._matView), 
                Mat4.invert(this._matViewProjInv, this._matViewProj), this._frustum.update(this._matViewProj, this._matViewProjInv)), 
                this._isProjDirty = !1;
            }
        }
    }, {
        key: "getSplitFrustum",
        value: function getSplitFrustum(out, nearClip, farClip) {
            if (this._node) {
                if (nearClip = Math.max(nearClip, this._nearClip), farClip = Math.min(farClip, this._farClip), 
                Mat4.invert(this._matView, this._node.worldMatrix), this._proj === CameraProjection.PERSPECTIVE) Mat4.perspective(_tempMat1, this._fov, this._aspect, nearClip, farClip, this._fovAxis === CameraFOVAxis.VERTICAL); else {
                    var x = this._orthoHeight * this._aspect, y = this._orthoHeight;
                    Mat4.ortho(_tempMat1, -x, x, -y, y, nearClip, farClip);
                }
                Mat4.multiply(_tempMat2, _tempMat1, this._matView), Mat4.invert(_tempMat1, _tempMat2), 
                out.update(_tempMat2, _tempMat1);
            }
        }
    }, {
        key: "changeTargetWindow",
        value: function changeTargetWindow() {
            var window = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, win = window || cc.director.root.mainWindow;
            win && this._view && (this._view.window = win, this.resize(win.width, win.height));
        }
    }, {
        key: "screenPointToRay",
        value: function screenPointToRay(out, x, y) {
            var cx = this.viewport.x * this._width, cy = this.viewport.y * this._height, cw = this.viewport.width * this._width, ch = this.viewport.height * this._height;
            return Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, 1), Vec3.transformMat4(v_a, v_a, this._matViewProjInv), 
            this._proj === CameraProjection.PERSPECTIVE ? this._node && this._node.getWorldPosition(v_b) : (Vec3.set(v_b, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, -1), 
            Vec3.transformMat4(v_b, v_b, this._matViewProjInv)), ray.fromPoints(out, v_b, v_a);
        }
    }, {
        key: "screenToWorld",
        value: function screenToWorld(out, screenPos) {
            var cx = this.viewport.x * this._width, cy = this.viewport.y * this._height, cw = this.viewport.width * this._width, ch = this.viewport.height * this._height;
            return this._proj === CameraProjection.PERSPECTIVE ? (Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1), 
            Vec3.transformMat4(out, out, this._matViewProjInv), this._node && this._node.getWorldPosition(v_a), 
            Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z))) : (Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 2 * screenPos.z - 1), 
            Vec3.transformMat4(out, out, this.matViewProjInv)), out;
        }
    }, {
        key: "worldToScreen",
        value: function worldToScreen(out, worldPos) {
            var cx = this.viewport.x * this._width, cy = this.viewport.y * this._height, cw = this.viewport.width * this._width, ch = this.viewport.height * this._height;
            return Vec3.transformMat4(out, worldPos, this.matViewProj), out.x = cx + .5 * (out.x + 1) * cw, 
            out.y = cy + .5 * (out.y + 1) * ch, out.z = .5 * out.z + .5, out;
        }
    }, {
        key: "updateExposure",
        value: function updateExposure() {
            var ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100 / this._isoValue);
            this._exposure = .833333 / Math.pow(2, ev100);
        }
    }, {
        key: "node",
        set: function set(val) {
            this._node = val;
        },
        get: function get() {
            return this._node;
        }
    }, {
        key: "enabled",
        set: function set(val) {
            this._enabled = val, this._view && this._view.enable(val);
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "view",
        get: function get() {
            return this._view;
        }
    }, {
        key: "orthoHeight",
        set: function set(val) {
            this._orthoHeight = val, this._isProjDirty = !0;
        },
        get: function get() {
            return this._orthoHeight;
        }
    }, {
        key: "projectionType",
        set: function set(val) {
            this._proj = val, this._isProjDirty = !0;
        },
        get: function get() {
            return this._proj;
        }
    }, {
        key: "fovAxis",
        set: function set(axis) {
            this._fovAxis = axis, this._isProjDirty = !0;
        },
        get: function get() {
            return this._fovAxis;
        }
    }, {
        key: "fov",
        set: function set(fov) {
            this._fov = fov, this._isProjDirty = !0;
        },
        get: function get() {
            return this._fov;
        }
    }, {
        key: "nearClip",
        set: function set(nearClip) {
            this._nearClip = nearClip, this._isProjDirty = !0;
        },
        get: function get() {
            return this._nearClip;
        }
    }, {
        key: "farClip",
        set: function set(farClip) {
            this._farClip = farClip, this._isProjDirty = !0;
        },
        get: function get() {
            return this._farClip;
        }
    }, {
        key: "clearColor",
        set: function set(val) {
            this._clearColor.r = val.r, this._clearColor.g = val.g, this._clearColor.b = val.b, 
            this._clearColor.a = val.a;
        },
        get: function get() {
            return this._clearColor;
        }
    }, {
        key: "scene",
        get: function get() {
            return this._scene;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    }, {
        key: "aspect",
        get: function get() {
            return this._aspect;
        }
    }, {
        key: "matView",
        set: function set(val) {
            this._matView = val;
        },
        get: function get() {
            return this._matView;
        }
    }, {
        key: "matViewInv",
        set: function set(val) {
            this._matViewInv = val;
        },
        get: function get() {
            return this._matViewInv || this._node.worldMatrix;
        }
    }, {
        key: "matProj",
        set: function set(val) {
            this._matProj = val;
        },
        get: function get() {
            return this._matProj;
        }
    }, {
        key: "matProjInv",
        set: function set(val) {
            this._matProjInv = val;
        },
        get: function get() {
            return this._matProjInv;
        }
    }, {
        key: "matViewProj",
        set: function set(val) {
            this._matViewProj = val;
        },
        get: function get() {
            return this._matViewProj;
        }
    }, {
        key: "matViewProjInv",
        set: function set(val) {
            this._matViewProjInv = val;
        },
        get: function get() {
            return this._matViewProjInv;
        }
    }, {
        key: "frustum",
        set: function set(val) {
            this._frustum = val;
        },
        get: function get() {
            return this._frustum;
        }
    }, {
        key: "forward",
        set: function set(val) {
            this._forward = val;
        },
        get: function get() {
            return this._forward;
        }
    }, {
        key: "position",
        set: function set(val) {
            this._position = val;
        },
        get: function get() {
            return this._position;
        }
    }, {
        key: "visibility",
        set: function set(vis) {
            this._visibility = vis, this._view && (this._view.visibility = vis);
        },
        get: function get() {
            return this._visibility;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._view ? this._view.priority : -1;
        },
        set: function set(val) {
            this._priority = val, this._view && (this._view.priority = this._priority);
        }
    }, {
        key: "aperture",
        set: function set(val) {
            this._aperture = val, this._apertureValue = FSTOPS[this._aperture], this.updateExposure();
        },
        get: function get() {
            return this._aperture;
        }
    }, {
        key: "apertureValue",
        get: function get() {
            return this._apertureValue;
        }
    }, {
        key: "shutter",
        set: function set(val) {
            this._shutter = val, this._shutterValue = SHUTTERS[this._shutter], this.updateExposure();
        },
        get: function get() {
            return this._shutter;
        }
    }, {
        key: "shutterValue",
        get: function get() {
            return this._shutterValue;
        }
    }, {
        key: "iso",
        set: function set(val) {
            this._iso = val, this._isoValue = ISOS[this._iso], this.updateExposure();
        },
        get: function get() {
            return this._iso;
        }
    }, {
        key: "isoValue",
        get: function get() {
            return this._isoValue;
        }
    }, {
        key: "ec",
        set: function set(val) {
            this._ec = val;
        },
        get: function get() {
            return this._ec;
        }
    }, {
        key: "exposure",
        get: function get() {
            return this._exposure;
        }
    }, {
        key: "flows",
        set: function set(val) {
            this._view && this._view.setExecuteFlows(val);
        }
    } ]), Camera;
}();

(SystemEventType = exports.SystemEventType || (exports.SystemEventType = {})).TOUCH_START = "touch-start", 
SystemEventType.TOUCH_MOVE = "touch-move", SystemEventType.TOUCH_END = "touch-end", 
SystemEventType.TOUCH_CANCEL = "touch-cancel", SystemEventType.MOUSE_DOWN = "mouse-down", 
SystemEventType.MOUSE_MOVE = "mouse-move", SystemEventType.MOUSE_UP = "mouse-up", 
SystemEventType.MOUSE_WHEEL = "mouse-wheel", SystemEventType.MOUSE_ENTER = "mouse-enter", 
SystemEventType.MOUSE_LEAVE = "mouse-leave", SystemEventType.KEY_DOWN = "keydown", 
SystemEventType.KEY_UP = "keyup", SystemEventType.DEVICEMOTION = "devicemotion", 
SystemEventType.TRANSFORM_CHANGED = "transform-changed", SystemEventType.SCENE_CHANGED_FOR_PERSISTS = "scene-changed-for-persists", 
SystemEventType.SIZE_CHANGED = "size-changed", SystemEventType.ANCHOR_CHANGED = "anchor-changed", 
SystemEventType.CHILD_ADDED = "child-added", SystemEventType.CHILD_REMOVED = "child-removed", 
SystemEventType.PARENT_CHANGED = "parent-changed", SystemEventType.NODE_DESTROYED = "node-destroyed", 
ccenum(exports.SystemEventType), cc.SystemEventType = exports.SystemEventType;

var _vec2 = new Vec2, EventMouse = function(_Event) {
    function EventMouse(eventType, bubbles, prevLoc) {
        var _this;
        return _classCallCheck(this, EventMouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(EventMouse).call(this, Event.MOUSE, bubbles))).movementX = 0, 
        _this.movementY = 0, _this.eventType = void 0, _this._button = EventMouse.BUTTON_MISSING, 
        _this._x = 0, _this._y = 0, _this._prevX = 0, _this._prevY = 0, _this._scrollX = 0, 
        _this._scrollY = 0, _this.eventType = eventType, prevLoc && (_this._prevX = prevLoc.x, 
        _this._prevY = prevLoc.y), _this;
    }
    return _inherits(EventMouse, Event), _createClass(EventMouse, [ {
        key: "setScrollData",
        value: function setScrollData(scrollX, scrollY) {
            this._scrollX = scrollX, this._scrollY = scrollY;
        }
    }, {
        key: "getScrollX",
        value: function getScrollX() {
            return this._scrollX;
        }
    }, {
        key: "getScrollY",
        value: function getScrollY() {
            return this._scrollY;
        }
    }, {
        key: "setLocation",
        value: function setLocation(x, y) {
            this._x = x, this._y = y;
        }
    }, {
        key: "getLocation",
        value: function getLocation(out) {
            return out || (out = new Vec2), Vec2.set(out, this._x, this._y), out;
        }
    }, {
        key: "getLocationInView",
        value: function getLocationInView(out) {
            return out || (out = new Vec2), Vec2.set(out, this._x, cc.view._designResolutionSize.height - this._y), 
            out;
        }
    }, {
        key: "getUILocation",
        value: function getUILocation(out) {
            return out || (out = new Vec2), Vec2.set(out, this._x, this._y), cc.view._convertPointWithScale(out), 
            out;
        }
    }, {
        key: "getPreviousLocation",
        value: function getPreviousLocation(out) {
            return out || (out = new Vec2), Vec2.set(out, this._prevX, this._prevY), out;
        }
    }, {
        key: "getUIPreviousLocation",
        value: function getUIPreviousLocation(out) {
            return out || (out = new Vec2), Vec2.set(out, this._prevX, this._prevY), cc.view._convertPointWithScale(out), 
            out;
        }
    }, {
        key: "getDelta",
        value: function getDelta(out) {
            return out || (out = new Vec2), Vec2.set(out, this._x - this._prevX, this._y - this._prevY), 
            out;
        }
    }, {
        key: "getDeltaX",
        value: function getDeltaX() {
            return this._x - this._prevX;
        }
    }, {
        key: "getDeltaY",
        value: function getDeltaY() {
            return this._y - this._prevY;
        }
    }, {
        key: "getUIDelta",
        value: function getUIDelta(out) {
            return out || (out = new Vec2), Vec2.set(out, (this._x - this._prevX) / cc.view.getScaleX(), (this._y - this._prevY) / cc.view.getScaleY()), 
            out;
        }
    }, {
        key: "getUIDeltaX",
        value: function getUIDeltaX() {
            return (this._x - this._prevX) / cc.view.getScaleX();
        }
    }, {
        key: "getUIDeltaY",
        value: function getUIDeltaY() {
            return (this._y - this._prevY) / cc.view.getScaleY();
        }
    }, {
        key: "setButton",
        value: function setButton(button) {
            this._button = button;
        }
    }, {
        key: "getButton",
        value: function getButton() {
            return this._button;
        }
    }, {
        key: "getLocationX",
        value: function getLocationX() {
            return this._x;
        }
    }, {
        key: "getLocationY",
        value: function getLocationY() {
            return this._y;
        }
    }, {
        key: "getUILocationX",
        value: function getUILocationX() {
            var viewport = cc.view.getViewportRect();
            return (this._x - viewport.x) / cc.view.getScaleX();
        }
    }, {
        key: "getUILocationY",
        value: function getUILocationY() {
            var viewport = cc.view.getViewportRect();
            return (this._y - viewport.y) / cc.view.getScaleY();
        }
    } ]), EventMouse;
}();

EventMouse.NONE = 0, EventMouse.DOWN = 1, EventMouse.UP = 2, EventMouse.MOVE = 3, 
EventMouse.SCROLL = 4, EventMouse.BUTTON_MISSING = -1, EventMouse.BUTTON_LEFT = 0, 
EventMouse.BUTTON_RIGHT = 2, EventMouse.BUTTON_MIDDLE = 1, EventMouse.BUTTON_4 = 3, 
EventMouse.BUTTON_5 = 4, EventMouse.BUTTON_6 = 5, EventMouse.BUTTON_7 = 6, EventMouse.BUTTON_8 = 7;

var EventTouch = function(_Event2) {
    function EventTouch(touches, bubbles, eventCode) {
        var _this2;
        return _classCallCheck(this, EventTouch), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(EventTouch).call(this, Event.TOUCH, bubbles))).touch = null, 
        _this2.simulate = !1, _this2._eventCode = void 0, _this2._touches = void 0, _this2._eventCode = eventCode || 0, 
        _this2._touches = touches || [], _this2;
    }
    return _inherits(EventTouch, Event), _createClass(EventTouch, [ {
        key: "getEventCode",
        value: function getEventCode() {
            return this._eventCode;
        }
    }, {
        key: "getTouches",
        value: function getTouches() {
            return this._touches;
        }
    }, {
        key: "setLocation",
        value: function setLocation(x, y) {
            this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
        }
    }, {
        key: "getLocation",
        value: function getLocation(out) {
            return this.touch ? this.touch.getLocation(out) : new Vec2;
        }
    }, {
        key: "getUILocation",
        value: function getUILocation(out) {
            return this.touch ? this.touch.getUILocation(out) : new Vec2;
        }
    }, {
        key: "getLocationInView",
        value: function getLocationInView(out) {
            return this.touch ? this.touch.getLocationInView(out) : new Vec2;
        }
    }, {
        key: "getPreviousLocation",
        value: function getPreviousLocation(out) {
            return this.touch ? this.touch.getPreviousLocation(out) : new Vec2;
        }
    }, {
        key: "getStartLocation",
        value: function getStartLocation(out) {
            return this.touch ? this.touch.getStartLocation(out) : new Vec2;
        }
    }, {
        key: "getUIStartLocation",
        value: function getUIStartLocation(out) {
            return this.touch ? this.touch.getUIStartLocation(out) : new Vec2;
        }
    }, {
        key: "getID",
        value: function getID() {
            return this.touch ? this.touch.getID() : null;
        }
    }, {
        key: "getDelta",
        value: function getDelta(out) {
            return this.touch ? this.touch.getDelta(out) : new Vec2;
        }
    }, {
        key: "getUIDelta",
        value: function getUIDelta(out) {
            return this.touch ? this.touch.getUIDelta(out) : new Vec2;
        }
    }, {
        key: "getDeltaX",
        value: function getDeltaX() {
            return this.touch ? this.touch.getDelta(_vec2).x : 0;
        }
    }, {
        key: "getDeltaY",
        value: function getDeltaY() {
            return this.touch ? this.touch.getDelta(_vec2).y : 0;
        }
    }, {
        key: "getLocationX",
        value: function getLocationX() {
            return this.touch ? this.touch.getLocationX() : 0;
        }
    }, {
        key: "getLocationY",
        value: function getLocationY() {
            return this.touch ? this.touch.getLocationY() : 0;
        }
    } ]), EventTouch;
}();

EventTouch.MAX_TOUCHES = 5, EventTouch.BEGAN = 0, EventTouch.MOVED = 1, EventTouch.ENDED = 2, 
EventTouch.CANCELLED = 3;

var EventAcceleration = function(_Event3) {
    function EventAcceleration(acc, bubbles) {
        var _this3;
        return _classCallCheck(this, EventAcceleration), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(EventAcceleration).call(this, Event.ACCELERATION, bubbles))).acc = void 0, 
        _this3.acc = acc, _this3;
    }
    return _inherits(EventAcceleration, Event), EventAcceleration;
}(), EventKeyboard = function(_Event4) {
    function EventKeyboard(keyCode, isPressed, bubbles) {
        var _this4;
        return _classCallCheck(this, EventKeyboard), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(EventKeyboard).call(this, Event.KEYBOARD, bubbles))).keyCode = void 0, 
        _this4.rawEvent = void 0, _this4.isPressed = void 0, "number" == typeof keyCode ? _this4.keyCode = keyCode : (_this4.keyCode = keyCode.keyCode, 
        _this4.rawEvent = keyCode), _this4.isPressed = isPressed, _this4;
    }
    return _inherits(EventKeyboard, Event), EventKeyboard;
}();

Event.EventMouse = EventMouse, Event.EventTouch = EventTouch, Event.EventAcceleration = EventAcceleration, 
Event.EventKeyboard = EventKeyboard;

var EventListener = function() {
    function EventListener(type, listenerID, callback) {
        _classCallCheck(this, EventListener), this.owner = null, this.mask = null, this._previousIn = !1, 
        this._target = null, this._onEvent = void 0, this._type = void 0, this._listenerID = void 0, 
        this._registered = !1, this._fixedPriority = 0, this._node = null, this._paused = !0, 
        this._isEnabled = !0, this._onEvent = callback, this._type = type || 0, this._listenerID = listenerID || "";
    }
    return _createClass(EventListener, [ {
        key: "onEvent",
        get: function get() {
            return this._onEvent;
        }
    } ], [ {
        key: "create",
        value: function create(argObj) {
            cc.assertID(argObj && argObj.event, 1900);
            var listenerType = argObj.event;
            delete argObj.event;
            var listener = null;
            if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? listener = new TouchOneByOne : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? listener = new TouchAllAtOnce : listenerType === cc.EventListener.MOUSE ? listener = new Mouse : listenerType === cc.EventListener.KEYBOARD ? listener = new Keyboard : listenerType === cc.EventListener.ACCELERATION && (listener = new Acceleration(argObj.callback), 
            delete argObj.callback), listener) for (var _i = 0, _Object$keys = Object.keys(argObj); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                listener[key] = argObj[key];
            }
            return listener;
        }
    } ]), _createClass(EventListener, [ {
        key: "_setPaused",
        value: function _setPaused(paused) {
            this._paused = paused;
        }
    }, {
        key: "_isPaused",
        value: function _isPaused() {
            return this._paused;
        }
    }, {
        key: "_setRegistered",
        value: function _setRegistered(registered) {
            this._registered = registered;
        }
    }, {
        key: "_isRegistered",
        value: function _isRegistered() {
            return this._registered;
        }
    }, {
        key: "_getType",
        value: function _getType() {
            return this._type;
        }
    }, {
        key: "_getListenerID",
        value: function _getListenerID() {
            return this._listenerID;
        }
    }, {
        key: "_setFixedPriority",
        value: function _setFixedPriority(fixedPriority) {
            this._fixedPriority = fixedPriority;
        }
    }, {
        key: "_getFixedPriority",
        value: function _getFixedPriority() {
            return this._fixedPriority;
        }
    }, {
        key: "_setSceneGraphPriority",
        value: function _setSceneGraphPriority(node) {
            this._target = node, this._node = node;
        }
    }, {
        key: "_getSceneGraphPriority",
        value: function _getSceneGraphPriority() {
            return this._node;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return null !== this._onEvent;
        }
    }, {
        key: "clone",
        value: function clone() {
            return null;
        }
    }, {
        key: "setEnabled",
        value: function setEnabled(enabled) {
            this._isEnabled = enabled;
        }
    }, {
        key: "isEnabled",
        value: function isEnabled() {
            return this._isEnabled;
        }
    } ]), EventListener;
}();

EventListener.UNKNOWN = 0, EventListener.TOUCH_ONE_BY_ONE = 1, EventListener.TOUCH_ALL_AT_ONCE = 2, 
EventListener.KEYBOARD = 3, EventListener.MOUSE = 4, EventListener.ACCELERATION = 6, 
EventListener.CUSTOM = 8, EventListener.ListenerID = {
    MOUSE: "__cc_mouse",
    TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
    TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
    KEYBOARD: "__cc_keyboard",
    ACCELERATION: "__cc_acceleration"
};

var ListenerID = EventListener.ListenerID, Mouse = function(_EventListener) {
    function Mouse() {
        var _this;
        return _classCallCheck(this, Mouse), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Mouse).call(this, EventListener.MOUSE, ListenerID.MOUSE, null))).onMouseDown = null, 
        _this.onMouseUp = null, _this.onMouseMove = null, _this.onMouseScroll = null, _this._onEvent = function(event) {
            return _this._callback(event);
        }, _this;
    }
    return _inherits(Mouse, EventListener), _createClass(Mouse, [ {
        key: "_callback",
        value: function _callback(event) {
            var eventType = cc.Event.EventMouse;
            switch (event.eventType) {
              case eventType.DOWN:
                this.onMouseDown && this.onMouseDown(event);
                break;

              case eventType.UP:
                this.onMouseUp && this.onMouseUp(event);
                break;

              case eventType.MOVE:
                this.onMouseMove && this.onMouseMove(event);
                break;

              case eventType.SCROLL:
                this.onMouseScroll && this.onMouseScroll(event);
            }
        }
    }, {
        key: "clone",
        value: function clone() {
            var eventListener = new Mouse;
            return eventListener.onMouseDown = this.onMouseDown, eventListener.onMouseUp = this.onMouseUp, 
            eventListener.onMouseMove = this.onMouseMove, eventListener.onMouseScroll = this.onMouseScroll, 
            eventListener;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return !0;
        }
    } ]), Mouse;
}(), TouchOneByOne = function(_EventListener2) {
    function TouchOneByOne() {
        var _this2;
        return _classCallCheck(this, TouchOneByOne), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(TouchOneByOne).call(this, EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null))).swallowTouches = !1, 
        _this2.onTouchBegan = null, _this2.onTouchMoved = null, _this2.onTouchEnded = null, 
        _this2.onTouchCancelled = null, _this2._claimedTouches = [], _this2;
    }
    return _inherits(TouchOneByOne, EventListener), _createClass(TouchOneByOne, [ {
        key: "setSwallowTouches",
        value: function setSwallowTouches(needSwallow) {
            this.swallowTouches = needSwallow;
        }
    }, {
        key: "isSwallowTouches",
        value: function isSwallowTouches() {
            return this.swallowTouches;
        }
    }, {
        key: "clone",
        value: function clone() {
            var eventListener = new TouchOneByOne;
            return eventListener.onTouchBegan = this.onTouchBegan, eventListener.onTouchMoved = this.onTouchMoved, 
            eventListener.onTouchEnded = this.onTouchEnded, eventListener.onTouchCancelled = this.onTouchCancelled, 
            eventListener.swallowTouches = this.swallowTouches, eventListener;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return !!this.onTouchBegan || (cc.logID(1801), !1);
        }
    } ]), TouchOneByOne;
}(), TouchAllAtOnce = function(_EventListener3) {
    function TouchAllAtOnce() {
        var _this3;
        return _classCallCheck(this, TouchAllAtOnce), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(TouchAllAtOnce).call(this, EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null))).onTouchesBegan = null, 
        _this3.onTouchesMoved = null, _this3.onTouchesEnded = null, _this3.onTouchesCancelled = null, 
        _this3;
    }
    return _inherits(TouchAllAtOnce, EventListener), _createClass(TouchAllAtOnce, [ {
        key: "clone",
        value: function clone() {
            var eventListener = new TouchAllAtOnce;
            return eventListener.onTouchesBegan = this.onTouchesBegan, eventListener.onTouchesMoved = this.onTouchesMoved, 
            eventListener.onTouchesEnded = this.onTouchesEnded, eventListener.onTouchesCancelled = this.onTouchesCancelled, 
            eventListener;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return null !== this.onTouchesBegan || null !== this.onTouchesMoved || null !== this.onTouchesEnded || null !== this.onTouchesCancelled || (cc.logID(1802), 
            !1);
        }
    } ]), TouchAllAtOnce;
}(), Acceleration = function(_EventListener4) {
    function Acceleration(callback) {
        var _this4;
        return _classCallCheck(this, Acceleration), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(Acceleration).call(this, EventListener.ACCELERATION, ListenerID.ACCELERATION, null)))._onAccelerationEvent = null, 
        _this4._onEvent = function(event) {
            return _this4._callback(event);
        }, _this4._onAccelerationEvent = callback, _this4;
    }
    return _inherits(Acceleration, EventListener), _createClass(Acceleration, [ {
        key: "_callback",
        value: function _callback(event) {
            this._onAccelerationEvent && this._onAccelerationEvent(event.acc, event);
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return cc.assertID(this._onAccelerationEvent, 1803), !0;
        }
    }, {
        key: "clone",
        value: function clone() {
            return new Acceleration(this._onAccelerationEvent);
        }
    } ]), Acceleration;
}(), Keyboard = function(_EventListener5) {
    function Keyboard() {
        var _this5;
        return _classCallCheck(this, Keyboard), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(Keyboard).call(this, EventListener.KEYBOARD, ListenerID.KEYBOARD, null))).onKeyPressed = null, 
        _this5.onKeyReleased = null, _this5._onEvent = function(event) {
            return _this5._callback(event);
        }, _this5;
    }
    return _inherits(Keyboard, EventListener), _createClass(Keyboard, [ {
        key: "_callback",
        value: function _callback(event) {
            event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
        }
    }, {
        key: "clone",
        value: function clone() {
            var eventListener = new Keyboard;
            return eventListener.onKeyPressed = this.onKeyPressed, eventListener.onKeyReleased = this.onKeyReleased, 
            eventListener;
        }
    }, {
        key: "checkAvailable",
        value: function checkAvailable() {
            return null !== this.onKeyPressed || null !== this.onKeyReleased || (cc.logID(1800), 
            !1);
        }
    } ]), Keyboard;
}();

cc.EventListener = EventListener;

var ListenerID$1 = EventListener.ListenerID;

var _EventListenerVector = function() {
    function _EventListenerVector() {
        _classCallCheck(this, _EventListenerVector), this.gt0Index = 0, this._fixedListeners = [], 
        this._sceneGraphListeners = [];
    }
    return _createClass(_EventListenerVector, [ {
        key: "size",
        value: function size() {
            return this._fixedListeners.length + this._sceneGraphListeners.length;
        }
    }, {
        key: "empty",
        value: function empty() {
            return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
        }
    }, {
        key: "push",
        value: function push(listener) {
            0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
        }
    }, {
        key: "clearSceneGraphListeners",
        value: function clearSceneGraphListeners() {
            this._sceneGraphListeners.length = 0;
        }
    }, {
        key: "clearFixedListeners",
        value: function clearFixedListeners() {
            this._fixedListeners.length = 0;
        }
    }, {
        key: "clear",
        value: function clear() {
            this._sceneGraphListeners.length = 0, this._fixedListeners.length = 0;
        }
    }, {
        key: "getFixedPriorityListeners",
        value: function getFixedPriorityListeners() {
            return this._fixedListeners;
        }
    }, {
        key: "getSceneGraphPriorityListeners",
        value: function getSceneGraphPriorityListeners() {
            return this._sceneGraphListeners;
        }
    } ]), _EventListenerVector;
}();

var eventManager = new (function() {
    function EventManager() {
        _classCallCheck(this, EventManager), this._listenersMap = {}, this._priorityDirtyFlagMap = {}, 
        this._nodeListenersMap = {}, this._toAddedListeners = [], this._toRemovedListeners = [], 
        this._dirtyListeners = [], this._inDispatch = 0, this._isEnabled = !1, this._internalCustomListenerIDs = [], 
        this._currentTouch = null, this._currentTouchListener = null;
    }
    return _createClass(EventManager, [ {
        key: "pauseTarget",
        value: function pauseTarget(node) {
            var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (node instanceof cc._BaseNode) {
                var listeners = this._nodeListenersMap[node.uuid];
                if (listeners) for (var i = 0; i < listeners.length; ++i) {
                    var listener = listeners[i];
                    listener._setPaused(!0);
                }
                if (!0 === recursive) {
                    var locChildren = node.children;
                    if (locChildren) for (var _i = 0; _i < locChildren.length; ++_i) {
                        var locChild = locChildren[_i];
                        this.pauseTarget(locChild, !0);
                    }
                }
            } else cc.warnID(3506);
        }
    }, {
        key: "resumeTarget",
        value: function resumeTarget(node) {
            var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (node instanceof cc._BaseNode) {
                var listeners = this._nodeListenersMap[node.uuid];
                if (listeners) for (var i = 0; i < listeners.length; ++i) {
                    var listener = listeners[i];
                    listener._setPaused(!1);
                }
                if (this._setDirtyForNode(node), !0 === recursive && node.children.length > 0) {
                    var locChildren = node.children;
                    if (locChildren) for (var _i2 = 0; _i2 < locChildren.length; ++_i2) {
                        var locChild = locChildren[_i2];
                        this.resumeTarget(locChild, !0);
                    }
                }
            } else cc.warnID(3506);
        }
    }, {
        key: "frameUpdateListeners",
        value: function frameUpdateListeners() {
            var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
            for (var selKey in locListenersMap) locListenersMap[selKey].empty() && (delete locPriorityDirtyFlagMap[selKey], 
            delete locListenersMap[selKey]);
            var locToAddedListeners = this._toAddedListeners;
            if (0 !== locToAddedListeners.length) {
                for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                locToAddedListeners.length = 0;
            }
            0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
        }
    }, {
        key: "hasEventListener",
        value: function hasEventListener(listenerID) {
            return !!this._getListeners(listenerID);
        }
    }, {
        key: "addListener",
        value: function addListener(listener, nodeOrPriority) {
            if (cc.assertID(listener && nodeOrPriority, 3503), cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode) {
                if (listener instanceof cc.EventListener) {
                    if (listener._isRegistered()) return void cc.logID(3505);
                } else cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504), listener = cc.EventListener.create(listener);
                if (listener.checkAvailable()) {
                    if (cc.js.isNumber(nodeOrPriority)) {
                        if (0 === nodeOrPriority) return void cc.logID(3500);
                        listener._setSceneGraphPriority(null), listener._setFixedPriority(nodeOrPriority), 
                        listener._setRegistered(!0), listener._setPaused(!1), this._addListener(listener);
                    } else {
                        if (!function checkUINode(node) {
                            return !(!node || !node.getComponent("cc.UITransformComponent"));
                        }(nodeOrPriority)) return void cc.logID(3512);
                        listener._setSceneGraphPriority(nodeOrPriority), listener._setFixedPriority(0), 
                        listener._setRegistered(!0), this._addListener(listener);
                    }
                    return listener;
                }
            } else cc.warnID(3506);
        }
    }, {
        key: "addCustomListener",
        value: function addCustomListener(eventName, callback) {
            var listener = EventListener.create({
                event: cc.EventListener.CUSTOM,
                eventName: eventName,
                callback: callback
            });
            return this.addListener(listener, 1), listener;
        }
    }, {
        key: "removeListener",
        value: function removeListener(listener) {
            if (null != listener) {
                var isFound = !1, locListener = this._listenersMap;
                for (var selKey in locListener) {
                    var listeners = locListener[selKey], fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    if ((isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener)) ? this._setDirty(listener._getListenerID(), 2) : (isFound = this._removeListenerInVector(fixedPriorityListeners, listener)) && this._setDirty(listener._getListenerID(), 1), 
                    listeners.empty() && (delete this._priorityDirtyFlagMap[listener._getListenerID()], 
                    delete locListener[selKey]), isFound) break;
                }
                if (!isFound) for (var locToAddedListeners = this._toAddedListeners, i = locToAddedListeners.length - 1; i >= 0; i--) {
                    var selListener = locToAddedListeners[i];
                    if (selListener === listener) {
                        cc.js.array.removeAt(locToAddedListeners, i), selListener._setRegistered(!1);
                        break;
                    }
                }
            }
        }
    }, {
        key: "removeListeners",
        value: function removeListeners(listenerType) {
            var recursive = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode) if (void 0 !== listenerType._id) {
                var listeners = this._nodeListenersMap[listenerType._id];
                if (listeners) {
                    for (var listenersCopy = cc.js.array.copy(listeners), i = 0; i < listenersCopy.length; ++i) {
                        var listenerCopy = listenersCopy[i];
                        this.removeListener(listenerCopy);
                    }
                    delete this._nodeListenersMap[listenerType._id];
                }
                for (var locToAddedListeners = this._toAddedListeners, _i3 = 0; _i3 < locToAddedListeners.length; ) {
                    var listener = locToAddedListeners[_i3];
                    listener._getSceneGraphPriority() === listenerType ? (listener._setSceneGraphPriority(null), 
                    listener._setRegistered(!1), locToAddedListeners.splice(_i3, 1)) : ++_i3;
                }
                if (!0 === recursive) for (var locChildren = listenerType.getChildren(), _i4 = 0; _i4 < locChildren.length; ++_i4) {
                    var locChild = locChildren[_i4];
                    this.removeListeners(locChild, !0);
                }
            } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ONE_BY_ONE) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(ListenerID$1.TOUCH_ALL_AT_ONCE) : listenerType === cc.EventListener.MOUSE ? this._removeListenersForListenerID(ListenerID$1.MOUSE) : listenerType === cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(ListenerID$1.ACCELERATION) : listenerType === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(ListenerID$1.KEYBOARD) : cc.logID(3501); else cc.warnID(3506);
        }
    }, {
        key: "removeCustomListeners",
        value: function removeCustomListeners(customEventName) {
            this._removeListenersForListenerID(customEventName);
        }
    }, {
        key: "removeAllListeners",
        value: function removeAllListeners() {
            var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
            for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
        }
    }, {
        key: "setPriority",
        value: function setPriority(listener, fixedPriority) {
            if (null != listener) {
                var locListeners = this._listenersMap;
                for (var selKey in locListeners) {
                    var fixedPriorityListeners = locListeners[selKey].getFixedPriorityListeners();
                    if (fixedPriorityListeners) if (-1 !== fixedPriorityListeners.indexOf(listener)) return null != listener._getSceneGraphPriority() && cc.logID(3502), 
                    void (listener._getFixedPriority() !== fixedPriority && (listener._setFixedPriority(fixedPriority), 
                    this._setDirty(listener._getListenerID(), 1)));
                }
            }
        }
    }, {
        key: "setEnabled",
        value: function setEnabled(enabled) {
            this._isEnabled = enabled;
        }
    }, {
        key: "isEnabled",
        value: function isEnabled() {
            return this._isEnabled;
        }
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
            if (this._isEnabled) if (this._updateDirtyFlagForSceneGraph(), this._inDispatch++, 
            event && event.getType) {
                if (event.getType().startsWith(cc.Event.TOUCH)) return this._dispatchTouchEvent(event), 
                void this._inDispatch--;
                var listenerID = function __getListenerID(event) {
                    var eventType = Event, type = event.type;
                    return type === eventType.ACCELERATION ? ListenerID$1.ACCELERATION : type === eventType.KEYBOARD ? ListenerID$1.KEYBOARD : type.startsWith(eventType.MOUSE) ? ListenerID$1.MOUSE : (type.startsWith(eventType.TOUCH) && cc.logID(2e3), 
                    "");
                }(event);
                this._sortEventListeners(listenerID);
                var selListeners = this._listenersMap[listenerID];
                null != selListeners && (this._dispatchEventToListeners(selListeners, this._onListenerCallback, event), 
                this._onUpdateListeners(selListeners)), this._inDispatch--;
            } else cc.errorID(3511);
        }
    }, {
        key: "_onListenerCallback",
        value: function _onListenerCallback(listener, event) {
            event.currentTarget = listener._target;
            var onEvent = listener.onEvent;
            return onEvent && onEvent(event), event.isStopped();
        }
    }, {
        key: "dispatchCustomEvent",
        value: function dispatchCustomEvent(eventName, optionalUserData) {
            var ev = new cc.Event.EventCustom(eventName);
            ev.setUserData(optionalUserData), this.dispatchEvent(ev);
        }
    }, {
        key: "_setDirtyForNode",
        value: function _setDirtyForNode(node) {
            var selListeners = this._nodeListenersMap[node._id];
            if (void 0 !== selListeners) for (var j = 0, len = selListeners.length; j < len; j++) {
                var listenerID = selListeners[j]._getListenerID();
                null == this._dirtyListeners[listenerID] && (this._dirtyListeners[listenerID] = !0);
            }
            if (node.children.length > 0) for (var _children = node.children, i = 0, _len = _children ? _children.length : 0; i < _len; i++) this._setDirtyForNode(_children[i]);
        }
    }, {
        key: "_addListener",
        value: function _addListener(listener) {
            0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
        }
    }, {
        key: "_forceAddEventListener",
        value: function _forceAddEventListener(listener) {
            var listenerID = listener._getListenerID(), listeners = this._listenersMap[listenerID];
            if (listeners || (listeners = new _EventListenerVector, this._listenersMap[listenerID] = listeners), 
            listeners.push(listener), 0 === listener._getFixedPriority()) {
                this._setDirty(listenerID, 2);
                var node = listener._getSceneGraphPriority();
                null === node && cc.logID(3507), this._associateNodeAndEventListener(node, listener), 
                node.activeInHierarchy && this.resumeTarget(node);
            } else this._setDirty(listenerID, 1);
        }
    }, {
        key: "_getListeners",
        value: function _getListeners(listenerID) {
            return this._listenersMap[listenerID];
        }
    }, {
        key: "_updateDirtyFlagForSceneGraph",
        value: function _updateDirtyFlagForSceneGraph() {
            var locDirtyListeners = this._dirtyListeners;
            for (var selKey in locDirtyListeners) this._setDirty(selKey, 2);
            this._dirtyListeners.length = 0;
        }
    }, {
        key: "_removeAllListenersInVector",
        value: function _removeAllListenersInVector(listenerVector) {
            if (listenerVector) for (var selListener, i = listenerVector.length - 1; i >= 0; i--) (selListener = listenerVector[i])._setRegistered(!1), 
            null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
            selListener._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.js.array.removeAt(listenerVector, i);
        }
    }, {
        key: "_removeListenersForListenerID",
        value: function _removeListenersForListenerID(listenerID) {
            var listeners = this._listenersMap[listenerID];
            if (listeners) {
                var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                this._removeAllListenersInVector(sceneGraphPriorityListeners), this._removeAllListenersInVector(fixedPriorityListeners), 
                delete this._priorityDirtyFlagMap[listenerID], this._inDispatch || (listeners.clear(), 
                delete this._listenersMap[listenerID]);
            }
            for (var locToAddedListeners = this._toAddedListeners, i = locToAddedListeners.length - 1; i >= 0; i--) {
                var listener = locToAddedListeners[i];
                listener && listener._getListenerID() === listenerID && cc.js.array.removeAt(locToAddedListeners, i);
            }
        }
    }, {
        key: "_sortEventListeners",
        value: function _sortEventListeners(listenerID) {
            var dirtyFlag = 0, locFlagMap = this._priorityDirtyFlagMap;
            (locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]), 0 !== dirtyFlag) && (locFlagMap[listenerID] = 0, 
            1 & dirtyFlag && this._sortListenersOfFixedPriority(listenerID), 2 & dirtyFlag && cc.director.getScene() && this._sortListenersOfSceneGraphPriority(listenerID));
        }
    }, {
        key: "_sortListenersOfSceneGraphPriority",
        value: function _sortListenersOfSceneGraphPriority(listenerID) {
            var listeners = this._getListeners(listenerID);
            if (listeners) {
                var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
                sceneGraphListener && 0 !== sceneGraphListener.length && listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
            }
        }
    }, {
        key: "_sortEventListenersOfSceneGraphPriorityDes",
        value: function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
            var node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
            if (!(l2 && node2 && node2._activeInHierarchy && node2._uiProps.uiTransformComp)) return -1;
            if (!(l1 && node1 && node1._activeInHierarchy && node1._uiProps.uiTransformComp)) return 1;
            var p1 = node1, p2 = node2, trans1 = node1._uiProps.uiTransformComp, trans2 = node2._uiProps.uiTransformComp, ex = !1;
            if (trans1.visibility !== trans2.visibility) return trans2.visibility - trans1.visibility;
            for (;p1.parent._id !== p2.parent._id; ) p1 = null === p1.parent.parent ? (ex = !0) && node2 : p1.parent, 
            p2 = null === p2.parent.parent ? (ex = !0) && node1 : p2.parent;
            if (p1._id === p2._id) {
                if (p1._id === node2._id) return -1;
                if (p1._id === node1._id) return 1;
            }
            var priority1 = p1.getSiblingIndex(), priority2 = p2.getSiblingIndex();
            return ex ? priority1 - priority2 : priority2 - priority1;
        }
    }, {
        key: "_sortListenersOfFixedPriority",
        value: function _sortListenersOfFixedPriority(listenerID) {
            var listeners = this._listenersMap[listenerID];
            if (listeners) {
                var fixedListeners = listeners.getFixedPriorityListeners();
                if (fixedListeners && 0 !== fixedListeners.length) {
                    fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
                    for (var index = 0, len = fixedListeners.length; index < len && !(fixedListeners[index]._getFixedPriority() >= 0); ) ++index;
                    listeners.gt0Index = index;
                }
            }
        }
    }, {
        key: "_sortListenersOfFixedPriorityAsc",
        value: function _sortListenersOfFixedPriorityAsc(l1, l2) {
            return l1._getFixedPriority() - l2._getFixedPriority();
        }
    }, {
        key: "_onUpdateListeners",
        value: function _onUpdateListeners(listeners) {
            var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), toRemovedListeners = this._toRemovedListeners;
            if (sceneGraphPriorityListeners) for (var i = sceneGraphPriorityListeners.length - 1; i >= 0; i--) {
                var selListener = sceneGraphPriorityListeners[i];
                if (!selListener._isRegistered()) {
                    cc.js.array.removeAt(sceneGraphPriorityListeners, i);
                    var idx = toRemovedListeners.indexOf(selListener);
                    -1 !== idx && toRemovedListeners.splice(idx, 1);
                }
            }
            if (fixedPriorityListeners) for (var _i5 = fixedPriorityListeners.length - 1; _i5 >= 0; _i5--) {
                var _selListener = fixedPriorityListeners[_i5];
                if (!_selListener._isRegistered()) {
                    cc.js.array.removeAt(fixedPriorityListeners, _i5);
                    var _idx = toRemovedListeners.indexOf(_selListener);
                    -1 !== _idx && toRemovedListeners.splice(_idx, 1);
                }
            }
            sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners(), 
            fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
        }
    }, {
        key: "_updateTouchListeners",
        value: function _updateTouchListeners(event) {
            var locInDispatch = this._inDispatch;
            if (cc.assertID(locInDispatch > 0, 3508), !(locInDispatch > 1)) {
                var listeners;
                (listeners = this._listenersMap[ListenerID$1.TOUCH_ONE_BY_ONE]) && this._onUpdateListeners(listeners), 
                (listeners = this._listenersMap[ListenerID$1.TOUCH_ALL_AT_ONCE]) && this._onUpdateListeners(listeners), 
                cc.assertID(1 === locInDispatch, 3509);
                var locToAddedListeners = this._toAddedListeners;
                if (0 !== locToAddedListeners.length) {
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
                    this._toAddedListeners.length = 0;
                }
                0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
            }
        }
    }, {
        key: "_cleanToRemovedListeners",
        value: function _cleanToRemovedListeners() {
            for (var toRemovedListeners = this._toRemovedListeners, i = 0; i < toRemovedListeners.length; ++i) {
                var selListener = toRemovedListeners[i], listeners = this._listenersMap[selListener._getListenerID()];
                if (listeners) {
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    if (sceneGraphPriorityListeners) {
                        var idx = sceneGraphPriorityListeners.indexOf(selListener);
                        -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
                    }
                    if (fixedPriorityListeners) {
                        var _idx2 = fixedPriorityListeners.indexOf(selListener);
                        -1 !== _idx2 && fixedPriorityListeners.splice(_idx2, 1);
                    }
                }
            }
            toRemovedListeners.length = 0;
        }
    }, {
        key: "_onTouchEventCallback",
        value: function _onTouchEventCallback(listener, argsObj) {
            if (!listener._isRegistered()) return !1;
            var event = argsObj.event, selTouch = event.touch;
            event.currentTarget = listener._getSceneGraphPriority();
            var isClaimed = !1, removedIdx = -1, getCode = event.getEventCode();
            if (getCode === EventTouch.BEGAN) {
                if (!macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch) {
                    var node = eventManager._currentTouchListener._node;
                    if (!node || node.activeInHierarchy) return !1;
                }
                listener.onTouchBegan && (isClaimed = listener.onTouchBegan(selTouch, event)) && listener._isRegistered() && (listener._claimedTouches.push(selTouch), 
                eventManager._currentTouch = selTouch, eventManager._currentTouchListener = listener);
            } else if (listener._claimedTouches.length > 0 && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch))) {
                if (isClaimed = !0, !macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch && eventManager._currentTouch !== selTouch) return !1;
                getCode === EventTouch.MOVED && listener.onTouchMoved ? listener.onTouchMoved(selTouch, event) : getCode === EventTouch.ENDED ? (listener.onTouchEnded && listener.onTouchEnded(selTouch, event), 
                listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1), eventManager._currentTouch = null, 
                eventManager._currentTouchListener = null) : getCode === EventTouch.CANCELLED && (listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event), 
                listener._isRegistered() && listener._claimedTouches.splice(removedIdx, 1), eventManager._currentTouch = null, 
                eventManager._currentTouchListener = null);
            }
            return event.isStopped() ? (eventManager._updateTouchListeners(event), !0) : !!(isClaimed && listener._isRegistered() && listener.swallowTouches) && (argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1), 
            !0);
        }
    }, {
        key: "_dispatchTouchEvent",
        value: function _dispatchTouchEvent(event) {
            this._sortEventListeners(ListenerID$1.TOUCH_ONE_BY_ONE), this._sortEventListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
            var oneByOneListeners = this._getListeners(ListenerID$1.TOUCH_ONE_BY_ONE), allAtOnceListeners = this._getListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);
            if (null !== oneByOneListeners || null !== allAtOnceListeners) {
                var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches), oneByOneArgsObj = {
                    event: event,
                    needsMutableSet: oneByOneListeners && allAtOnceListeners,
                    touches: mutableTouches,
                    selTouch: null
                };
                if (oneByOneListeners) for (var i = 0; i < originalTouches.length; ++i) {
                    var originalTouch = originalTouches[i];
                    event.touch = originalTouch, event.propagationStopped = event.propagationImmediateStopped = !1, 
                    this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                }
                allAtOnceListeners && mutableTouches.length > 0 && (this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                    event: event,
                    touches: mutableTouches
                }), event.isStopped()) || this._updateTouchListeners(event);
            }
        }
    }, {
        key: "_onTouchesEventCallback",
        value: function _onTouchesEventCallback(listener, callbackParams) {
            if (!listener._isRegistered()) return !1;
            var event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
            return event.currentTarget = listener._getSceneGraphPriority(), getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event), 
            !!event.isStopped() && (eventManager._updateTouchListeners(event), !0);
        }
    }, {
        key: "_associateNodeAndEventListener",
        value: function _associateNodeAndEventListener(node, listener) {
            var listeners = this._nodeListenersMap[node.uuid];
            listeners || (listeners = [], this._nodeListenersMap[node.uuid] = listeners), listeners.push(listener);
        }
    }, {
        key: "_dissociateNodeAndEventListener",
        value: function _dissociateNodeAndEventListener(node, listener) {
            var listeners = this._nodeListenersMap[node.uuid];
            listeners && (cc.js.array.remove(listeners, listener), 0 === listeners.length && delete this._nodeListenersMap[node.uuid]);
        }
    }, {
        key: "_dispatchEventToListeners",
        value: function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
            var shouldStopPropagation = !1, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners(), i = 0;
            if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
                var selListener = fixedPriorityListeners[i];
                if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                    shouldStopPropagation = !0;
                    break;
                }
            }
            if (sceneGraphPriorityListeners && !shouldStopPropagation) for (var _i6 = 0; _i6 < sceneGraphPriorityListeners.length; ++_i6) {
                var _selListener2 = sceneGraphPriorityListeners[_i6];
                if (_selListener2.isEnabled() && !_selListener2._isPaused() && _selListener2._isRegistered() && onEvent(_selListener2, eventOrArgs)) {
                    shouldStopPropagation = !0;
                    break;
                }
            }
            if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
                var _selListener3 = fixedPriorityListeners[i];
                if (_selListener3.isEnabled() && !_selListener3._isPaused() && _selListener3._isRegistered() && onEvent(_selListener3, eventOrArgs)) {
                    shouldStopPropagation = !0;
                    break;
                }
            }
        }
    }, {
        key: "_setDirty",
        value: function _setDirty(listenerID, flag) {
            var locDirtyFlagMap = this._priorityDirtyFlagMap;
            null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
        }
    }, {
        key: "_sortNumberAsc",
        value: function _sortNumberAsc(a, b) {
            return a - b;
        }
    }, {
        key: "_removeListenerInCallback",
        value: function _removeListenerInCallback(listeners, callback) {
            if (null == listeners) return !1;
            for (var i = listeners.length - 1; i >= 0; i--) {
                var selListener = listeners[i];
                if (selListener._onCustomEvent === callback || selListener.onEvent === callback) return selListener._setRegistered(!1), 
                null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener), 
                !0;
            }
            return !1;
        }
    }, {
        key: "_removeListenerInVector",
        value: function _removeListenerInVector(listeners, listener) {
            if (null == listeners) return !1;
            for (var i = listeners.length - 1; i >= 0; i--) {
                var selListener = listeners[i];
                if (selListener === listener) return selListener._setRegistered(!1), null != selListener._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener), 
                selListener._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener), 
                !0;
            }
            return !1;
        }
    } ]), EventManager;
}());

cc.eventManager = eventManager;

var _cachedArray = new Array(16), _currentHovered = null, pos = new Vec2, _touchEvents = [ exports.SystemEventType.TOUCH_START.toString(), exports.SystemEventType.TOUCH_MOVE.toString(), exports.SystemEventType.TOUCH_END.toString(), exports.SystemEventType.TOUCH_CANCEL.toString() ], _mouseEvents = [ exports.SystemEventType.MOUSE_DOWN.toString(), exports.SystemEventType.MOUSE_ENTER.toString(), exports.SystemEventType.MOUSE_MOVE.toString(), exports.SystemEventType.MOUSE_LEAVE.toString(), exports.SystemEventType.MOUSE_UP.toString(), exports.SystemEventType.MOUSE_WHEEL.toString() ];

function _touchStartHandler(touch, event) {
    var node = this.owner;
    return !(!node || !node._uiProps.uiTransformComp) && (touch.getUILocation(pos), 
    !!node._uiProps.uiTransformComp.isHit(pos, this) && (event.type = exports.SystemEventType.TOUCH_START.toString(), 
    event.touch = touch, event.bubbles = !0, node.dispatchEvent(event), !0));
}

function _touchMoveHandler(touch, event) {
    var node = this.owner;
    if (!node || !node._uiProps.uiTransformComp) return !1;
    event.type = exports.SystemEventType.TOUCH_MOVE.toString(), event.touch = touch, 
    event.bubbles = !0, node.dispatchEvent(event);
}

function _touchEndHandler(touch, event) {
    var node = this.owner;
    node && node._uiProps.uiTransformComp && (touch.getUILocation(pos), node._uiProps.uiTransformComp.isHit(pos, this) ? event.type = exports.SystemEventType.TOUCH_END.toString() : event.type = exports.SystemEventType.TOUCH_CANCEL.toString(), 
    event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
}

function _touchCancelHandler(touch, event) {
    var node = this.owner;
    node && node._uiProps.uiTransformComp && (event.type = exports.SystemEventType.TOUCH_CANCEL.toString(), 
    event.touch = touch, event.bubbles = !0, node.dispatchEvent(event));
}

function _mouseDownHandler(event) {
    var node = this.owner;
    node && node._uiProps.uiTransformComp && (pos = event.getUILocation(), node._uiProps.uiTransformComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_DOWN.toString(), 
    event.bubbles = !0, node.dispatchEvent(event)));
}

function _mouseMoveHandler(event) {
    var node = this.owner;
    if (node && node._uiProps.uiTransformComp) {
        if (pos = event.getUILocation(), node._uiProps.uiTransformComp.isHit(pos, this)) this._previousIn || (_currentHovered && _currentHovered.eventProcessor.mouseListener && (event.type = exports.SystemEventType.MOUSE_LEAVE, 
        _currentHovered.dispatchEvent(event), _currentHovered.eventProcessor.mouseListener && (_currentHovered.eventProcessor.mouseListener._previousIn = !1)), 
        _currentHovered = node, event.type = exports.SystemEventType.MOUSE_ENTER.toString(), 
        node.dispatchEvent(event), this._previousIn = !0), event.type = exports.SystemEventType.MOUSE_MOVE.toString(), 
        event.bubbles = !0, node.dispatchEvent(event); else {
            if (!this._previousIn) return;
            event.type = exports.SystemEventType.MOUSE_LEAVE.toString(), node.dispatchEvent(event), 
            this._previousIn = !1, _currentHovered = null;
        }
        event.propagationStopped = !0;
    }
}

function _mouseUpHandler(event) {
    var node = this.owner;
    node && node._uiProps.uiTransformComp && (pos = event.getUILocation(), node._uiProps.uiTransformComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_UP.toString(), 
    event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
}

function _mouseWheelHandler(event) {
    var node = this.owner;
    node && node._uiProps.uiTransformComp && (pos = event.getUILocation(), node._uiProps.uiTransformComp.isHit(pos, this) && (event.type = exports.SystemEventType.MOUSE_WHEEL.toString(), 
    event.bubbles = !0, node.dispatchEvent(event), event.propagationStopped = !0));
}

function _searchMaskInParent(node) {
    var Mask = cc.MaskComponent;
    if (Mask) for (var index = 0, curr = node; curr && cc.Node.isNode(curr); curr = curr.parent, 
    ++index) if (curr.getComponent(Mask)) return {
        index: index,
        node: curr
    };
    return null;
}

function _checkListeners(node, events) {
    if (!node._persistNode) {
        if (node.eventProcessor.bubblingTargets) for (var i = 0; i < events.length; ++i) if (node.eventProcessor.bubblingTargets.hasEventListener(events[i])) return !0;
        if (node.eventProcessor.capturingTargets) for (var _i = 0; _i < events.length; ++_i) if (node.eventProcessor.capturingTargets.hasEventListener(events[_i])) return !0;
        return !1;
    }
    return !0;
}

var NodeEventProcessor = function() {
    function NodeEventProcessor(node) {
        _classCallCheck(this, NodeEventProcessor), this.bubblingTargets = null, this.capturingTargets = null, 
        this.touchListener = null, this.mouseListener = null, this._node = void 0, this._node = node;
    }
    return _createClass(NodeEventProcessor, [ {
        key: "node",
        get: function get() {
            return this._node;
        }
    } ]), _createClass(NodeEventProcessor, [ {
        key: "reattach",
        value: function reattach() {
            if (this.touchListener) {
                var mask = this.touchListener.mask = _searchMaskInParent(this._node);
                this.mouseListener && (this.mouseListener.mask = mask);
            } else this.mouseListener && (this.mouseListener.mask = _searchMaskInParent(this._node));
        }
    }, {
        key: "destroy",
        value: function destroy() {
            _currentHovered === this._node && (_currentHovered = null), (this.touchListener || this.mouseListener) && (eventManager.removeListeners(this._node), 
            this.touchListener && (this.touchListener.owner = null, this.touchListener.mask = null, 
            this.touchListener = null), this.mouseListener && (this.mouseListener.owner = null, 
            this.mouseListener.mask = null, this.mouseListener = null)), this.capturingTargets && this.capturingTargets.clear(), 
            this.bubblingTargets && this.bubblingTargets.clear();
        }
    }, {
        key: "on",
        value: function on(type, callback, target, useCapture) {
            return this._checknSetupSysEvent(type) ? this._onDispatch(type, callback, target, useCapture) : (this.bubblingTargets || (this.bubblingTargets = new CallbacksInvoker), 
            this.bubblingTargets.on(type, callback, target));
        }
    }, {
        key: "once",
        value: function once(type, callback, target, useCapture) {
            var listeners, _this = this;
            (listeners = this._checknSetupSysEvent(type) && useCapture ? this.capturingTargets = this.capturingTargets || new CallbacksInvoker : this.bubblingTargets = this.bubblingTargets || new CallbacksInvoker).on(type, callback, target, !0), 
            listeners.on(type, (function() {
                _this.off(type, callback, target);
            }), void 0, !0);
        }
    }, {
        key: "off",
        value: function off(type, callback, target, useCapture) {
            var touchEvent = -1 !== _touchEvents.indexOf(type), mouseEvent = !touchEvent && -1 !== _mouseEvents.indexOf(type);
            touchEvent || mouseEvent ? (this._offDispatch(type, callback, target, useCapture), 
            touchEvent ? this.touchListener && !_checkListeners(this._node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
            this.touchListener = null) : mouseEvent && this.mouseListener && !_checkListeners(this._node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
            this.mouseListener = null)) : this.bubblingTargets && this.bubblingTargets.off(type, callback, target);
        }
    }, {
        key: "emit",
        value: function emit(type, arg0, arg1, arg2, arg3, arg4) {
            this.bubblingTargets && this.bubblingTargets.emit(type, arg0, arg1, arg2, arg3, arg4);
        }
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
            !function _doDispatchEvent(owner, event) {
                var target, i = 0;
                for (event.target = owner, _cachedArray.length = 0, owner.eventProcessor.getCapturingTargets(event.type, _cachedArray), 
                event.eventPhase = 1, i = _cachedArray.length - 1; i >= 0; --i) if ((target = _cachedArray[i]).eventProcessor.capturingTargets && (event.currentTarget = target, 
                target.eventProcessor.capturingTargets.emit(event.type, event, _cachedArray), event.propagationStopped)) return void (_cachedArray.length = 0);
                if (_cachedArray.length = 0, event.eventPhase = 2, event.currentTarget = owner, 
                owner.eventProcessor.capturingTargets && owner.eventProcessor.capturingTargets.emit(event.type, event), 
                !event.propagationImmediateStopped && owner.eventProcessor.bubblingTargets && owner.eventProcessor.bubblingTargets.emit(event.type, event), 
                !event.propagationStopped && event.bubbles) for (owner.eventProcessor.getBubblingTargets(event.type, _cachedArray), 
                event.eventPhase = 3, i = 0; i < _cachedArray.length; ++i) if ((target = _cachedArray[i]).eventProcessor.bubblingTargets && (event.currentTarget = target, 
                target.eventProcessor.bubblingTargets.emit(event.type, event), event.propagationStopped)) return void (_cachedArray.length = 0);
                _cachedArray.length = 0;
            }(this._node, event), _cachedArray.length = 0;
        }
    }, {
        key: "hasEventListener",
        value: function hasEventListener(type, callback, target) {
            var has = !1;
            return this.bubblingTargets && (has = this.bubblingTargets.hasEventListener(type, callback, target)), 
            !has && this.capturingTargets && (has = this.capturingTargets.hasEventListener(type, callback, target)), 
            has;
        }
    }, {
        key: "targetOff",
        value: function targetOff(target) {
            this.capturingTargets && this.capturingTargets.removeAll(target), this.bubblingTargets && this.bubblingTargets.removeAll(target), 
            this.touchListener && !_checkListeners(this.node, _touchEvents) && (eventManager.removeListener(this.touchListener), 
            this.touchListener = null), this.mouseListener && !_checkListeners(this.node, _mouseEvents) && (eventManager.removeListener(this.mouseListener), 
            this.mouseListener = null);
        }
    }, {
        key: "getCapturingTargets",
        value: function getCapturingTargets(type, targets) {
            for (var parent = this._node.parent; parent; ) parent.eventProcessor.capturingTargets && parent.eventProcessor.capturingTargets.hasEventListener(type) && targets.push(parent), 
            parent = parent.parent;
        }
    }, {
        key: "getBubblingTargets",
        value: function getBubblingTargets(type, targets) {
            for (var parent = this._node.parent; parent; ) parent.eventProcessor.bubblingTargets && parent.eventProcessor.bubblingTargets.hasEventListener(type) && targets.push(parent), 
            parent = parent.parent;
        }
    }, {
        key: "_checknSetupSysEvent",
        value: function _checknSetupSysEvent(type) {
            var _this2 = this, newAdded = !1, forDispatch = !1;
            return -1 !== _touchEvents.indexOf(type) ? (this.touchListener || (this.touchListener = cc.EventListener.create({
                event: cc.EventListener.TOUCH_ONE_BY_ONE,
                swallowTouches: !0,
                owner: this._node,
                mask: _searchMaskInParent(this._node),
                onTouchBegan: _touchStartHandler,
                onTouchMoved: _touchMoveHandler,
                onTouchEnded: _touchEndHandler,
                onTouchCancelled: _touchCancelHandler
            }), eventManager.addListener(this.touchListener, this._node), newAdded = !0), forDispatch = !0) : -1 !== _mouseEvents.indexOf(type) && (this.mouseListener || (this.mouseListener = cc.EventListener.create({
                event: cc.EventListener.MOUSE,
                _previousIn: !1,
                owner: this._node,
                mask: _searchMaskInParent(this._node),
                onMouseDown: _mouseDownHandler,
                onMouseMove: _mouseMoveHandler,
                onMouseUp: _mouseUpHandler,
                onMouseScroll: _mouseWheelHandler
            }), eventManager.addListener(this.mouseListener, this._node), newAdded = !0), forDispatch = !0), 
            newAdded && !this._node.activeInHierarchy && cc.director.getScheduler().schedule((function() {
                _this2._node.activeInHierarchy || eventManager.pauseTarget(_this2._node);
            }), this._node, 0, 0, 0, !1), forDispatch;
        }
    }, {
        key: "_onDispatch",
        value: function _onDispatch(type, callback, target, useCapture) {
            if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
            callback) {
                var listeners = null;
                return (listeners = useCapture ? this.capturingTargets = this.capturingTargets || new CallbacksInvoker : this.bubblingTargets = this.bubblingTargets || new CallbacksInvoker).hasEventListener(type, callback, target) || listeners.on(type, callback, target), 
                callback;
            }
            cc.errorID(6800);
        }
    }, {
        key: "_offDispatch",
        value: function _offDispatch(type, callback, target, useCapture) {
            if ("boolean" == typeof target ? (useCapture = target, target = void 0) : useCapture = !!useCapture, 
            callback) {
                var listeners = useCapture ? this.capturingTargets : this.bubblingTargets;
                listeners && listeners.off(type, callback, target);
            } else this.capturingTargets && this.capturingTargets.removeAll(type), this.bubblingTargets && this.bubblingTargets.removeAll(type);
        }
    } ]), NodeEventProcessor;
}();

cc.NodeEventProcessor = NodeEventProcessor;

CCObject.Flags.Destroying;

var _class$u, _class2$p, _descriptor$n, _descriptor2$f, _descriptor3$b, _descriptor4$6, _descriptor5$4, _class3$b, _temp$r, Destroying$2 = CCObject.Flags.Destroying, DontDestroy$1 = CCObject.Flags.DontDestroy, Deactivating$1 = CCObject.Flags.Deactivating, ChangingState = CCObject.Flags.Activating | Deactivating$1, idGenerator$2 = new IDGenerator("Node");

function getConstructor(typeOrClassName) {
    return typeOrClassName ? "string" == typeof typeOrClassName ? getClassByName(typeOrClassName) : typeOrClassName : (errorID(3804), 
    null);
}

var _dec$v, _dec2$e, _dec3$6, _dec4$4, _dec5$3, _dec6$3, _dec7$2, _class$v, _class2$q, _descriptor$o, _descriptor2$g, _descriptor3$c, _class3$c, _temp$s, BaseNode = ccclass("cc.BaseNode")((_temp$r = _class3$b = function(_CCObject) {
    function BaseNode(name) {
        var _this;
        return _classCallCheck(this, BaseNode), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BaseNode).call(this, name)), "_parent", _descriptor$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_children", _descriptor2$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_active", _descriptor3$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_components", _descriptor4$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_prefab", _descriptor5$4, _assertThisInitialized(_this)), 
        _this._scene = null, _this._activeInHierarchy = !1, _this._id = idGenerator$2.getNewId(), 
        _this._name = void 0, _this._eventProcessor = new NodeEventProcessor(_assertThisInitialized(_this)), 
        _this._eventMask = 0, _this._siblingIndex = 0, _this._registerIfAttached = void 0, 
        _this._name = void 0 !== name ? name : "New Node", _this;
    }
    return _inherits(BaseNode, CCObject), _createClass(BaseNode, [ {
        key: "components",
        get: function get() {
            return this._components;
        }
    }, {
        key: "_persistNode",
        get: function get() {
            return (this._objFlags & DontDestroy$1) > 0;
        },
        set: function set(value) {
            value ? this._objFlags |= DontDestroy$1 : this._objFlags &= ~DontDestroy$1;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        },
        set: function set(value) {
            this._name = value;
        }
    }, {
        key: "uuid",
        get: function get() {
            return this._id;
        }
    }, {
        key: "children",
        get: function get() {
            return this._children;
        }
    }, {
        key: "active",
        get: function get() {
            return this._active;
        },
        set: function set(isActive) {
            if (this._active !== isActive) {
                this._active = isActive;
                var parent = this._parent;
                if (parent) parent._activeInHierarchy && cc.director._nodeActivator.activateNode(this, isActive);
            }
        }
    }, {
        key: "activeInHierarchy",
        get: function get() {
            return this._activeInHierarchy;
        }
    }, {
        key: "parent",
        get: function get() {
            return this._parent;
        },
        set: function set(value) {
            this.setParent(value);
        }
    }, {
        key: "scene",
        get: function get() {
            return this._scene;
        }
    }, {
        key: "eventProcessor",
        get: function get() {
            return this._eventProcessor;
        }
    } ], [ {
        key: "_setScene",
        value: function _setScene(node) {
            node instanceof cc.Scene ? node._scene = node : null == node._parent ? cc.error("Node %s(%s) has not attached to a scene.", node.name, node.uuid) : node._scene = node._parent._scene;
        }
    }, {
        key: "_findComponent",
        value: function _findComponent(node, constructor) {
            var cls = constructor, comps = node._components;
            if (cls._sealed) for (var i = 0; i < comps.length; ++i) {
                var comp = comps[i];
                if (comp.constructor === constructor) return comp;
            } else for (var _i = 0; _i < comps.length; ++_i) {
                var _comp = comps[_i];
                if (_comp instanceof constructor) return _comp;
            }
            return null;
        }
    }, {
        key: "_findComponents",
        value: function _findComponents(node, constructor, components) {
            var cls = constructor, comps = node._components;
            if (cls._sealed) for (var i = 0; i < comps.length; ++i) {
                var comp = comps[i];
                comp.constructor === constructor && components.push(comp);
            } else for (var _i2 = 0; _i2 < comps.length; ++_i2) {
                var _comp2 = comps[_i2];
                _comp2 instanceof constructor && components.push(_comp2);
            }
        }
    }, {
        key: "_findChildComponent",
        value: function _findChildComponent(children, constructor) {
            for (var i = 0; i < children.length; ++i) {
                var node = children[i], comp = BaseNode._findComponent(node, constructor);
                if (comp) return comp;
                if (node._children.length > 0 && (comp = BaseNode._findChildComponent(node._children, constructor))) return comp;
            }
            return null;
        }
    }, {
        key: "_findChildComponents",
        value: function _findChildComponents(children, constructor, components) {
            for (var i = 0; i < children.length; ++i) {
                var node = children[i];
                BaseNode._findComponents(node, constructor, components), node._children.length > 0 && BaseNode._findChildComponents(node._children, constructor, components);
            }
        }
    } ]), _createClass(BaseNode, [ {
        key: "attr",
        value: function attr(attrs) {
            mixin(this, attrs);
        }
    }, {
        key: "getParent",
        value: function getParent() {
            return this._parent;
        }
    }, {
        key: "setParent",
        value: function setParent(value) {
            var keepWorldTransform = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            if (this._parent !== value) {
                var oldParent = this._parent, newParent = value;
                if (oldParent && oldParent._objFlags & ChangingState && errorID(3821), this._parent = newParent, 
                this._siblingIndex = 0, this._onSetParent(oldParent, keepWorldTransform), this.emit && this.emit(exports.SystemEventType.PARENT_CHANGED, oldParent), 
                newParent && (newParent._objFlags & Deactivating$1 && errorID(3821), newParent._children.push(this), 
                this._siblingIndex = newParent._children.length - 1, newParent.emit && newParent.emit(exports.SystemEventType.CHILD_ADDED, this)), 
                oldParent && !(oldParent._objFlags & Destroying$2)) {
                    var removeAt = oldParent._children.indexOf(this);
                    oldParent._children.splice(removeAt, 1), oldParent._updateSiblingIndex(), oldParent.emit && oldParent.emit(exports.SystemEventType.CHILD_REMOVED, this);
                }
                this._onHierarchyChanged(oldParent);
            }
        }
    }, {
        key: "getChildByUuid",
        value: function getChildByUuid(uuid) {
            if (!uuid) return cc.log("Invalid uuid"), null;
            for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
            return null;
        }
    }, {
        key: "getChildByName",
        value: function getChildByName(name) {
            if (!name) return cc.log("Invalid name"), null;
            for (var locChildren = this._children, i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
            return null;
        }
    }, {
        key: "getChildByPath",
        value: function getChildByPath(path) {
            for (var segments = path.split("/"), lastNode = this, _loop = function _loop(i) {
                var segment = segments[i];
                if (0 === segment.length) return "continue";
                var next = lastNode.children.find((function(childNode) {
                    return childNode.name === segment;
                }));
                if (!next) return {
                    v: null
                };
                lastNode = next;
            }, i = 0; i < segments.length; ++i) {
                var _ret = _loop(i);
                switch (_ret) {
                  case "continue":
                    continue;

                  default:
                    if ("object" === _typeof(_ret)) return _ret.v;
                }
            }
            return lastNode;
        }
    }, {
        key: "addChild",
        value: function addChild(child) {
            cc.assertID(child, 1606), cc.assertID(null === child._parent, 1605), child.setParent(this);
        }
    }, {
        key: "insertChild",
        value: function insertChild(child, siblingIndex) {
            child.parent = this, child.setSiblingIndex(siblingIndex);
        }
    }, {
        key: "getSiblingIndex",
        value: function getSiblingIndex() {
            return this._siblingIndex;
        }
    }, {
        key: "setSiblingIndex",
        value: function setSiblingIndex(index) {
            if (this._parent) if (this._parent._objFlags & Deactivating$1) errorID(3821); else {
                var siblings = this._parent._children;
                index = -1 !== index ? index : siblings.length - 1;
                var oldIndex = siblings.indexOf(this);
                index !== oldIndex && (siblings.splice(oldIndex, 1), index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this), 
                this._parent._updateSiblingIndex(), this._onSiblingIndexChanged && this._onSiblingIndexChanged(index));
            }
        }
    }, {
        key: "walk",
        value: function walk(preFunc, postFunc) {
            var index = 1, children = null, curr = null, i = 0, stack = BaseNode._stacks[BaseNode._stackId];
            stack || (stack = [], BaseNode._stacks.push(stack)), BaseNode._stackId++, stack.length = 0, 
            stack[0] = this;
            for (var parent = null, afterChildren = !1; index; ) if (curr = stack[--index]) if (!afterChildren && preFunc ? preFunc(curr) : afterChildren && postFunc && postFunc(curr), 
            stack[index] = null, afterChildren) {
                if (afterChildren = !1, children) if (children[++i]) stack[index] = children[i], 
                index++; else if (parent && (stack[index] = parent, index++, afterChildren = !0, 
                parent._parent ? (i = (children = parent._parent._children).indexOf(parent), parent = parent._parent) : (parent = null, 
                children = null), i < 0)) break;
            } else curr._children.length > 0 ? (parent = curr, children = curr._children, i = 0, 
            stack[index] = children[i], index++) : (stack[index] = curr, index++, afterChildren = !0);
            stack.length = 0, BaseNode._stackId--;
        }
    }, {
        key: "removeFromParent",
        value: function removeFromParent() {
            this._parent && this._parent.removeChild(this);
        }
    }, {
        key: "removeChild",
        value: function removeChild(child) {
            this._children.indexOf(child) > -1 && (child.parent = null);
        }
    }, {
        key: "removeAllChildren",
        value: function removeAllChildren() {
            for (var children = this._children, i = children.length - 1; i >= 0; i--) {
                var node = children[i];
                node && (node.parent = null);
            }
            this._children.length = 0;
        }
    }, {
        key: "isChildOf",
        value: function isChildOf(parent) {
            var child = this;
            do {
                if (child === parent) return !0;
                child = child._parent;
            } while (child);
            return !1;
        }
    }, {
        key: "getComponent",
        value: function getComponent(typeOrClassName) {
            var constructor = getConstructor(typeOrClassName);
            return constructor ? BaseNode._findComponent(this, constructor) : null;
        }
    }, {
        key: "getComponents",
        value: function getComponents(typeOrClassName) {
            var constructor = getConstructor(typeOrClassName), components = [];
            return constructor && BaseNode._findComponents(this, constructor, components), components;
        }
    }, {
        key: "getComponentInChildren",
        value: function getComponentInChildren(typeOrClassName) {
            var constructor = getConstructor(typeOrClassName);
            return constructor ? BaseNode._findChildComponent(this._children, constructor) : null;
        }
    }, {
        key: "getComponentsInChildren",
        value: function getComponentsInChildren(typeOrClassName) {
            var constructor = getConstructor(typeOrClassName), components = [];
            return constructor && (BaseNode._findComponents(this, constructor, components), 
            BaseNode._findChildComponents(this._children, constructor, components)), components;
        }
    }, {
        key: "addComponent",
        value: function addComponent(typeOrClassName) {
            var constructor;
            if ("string" == typeof typeOrClassName) {
                if (!(constructor = getClassByName(typeOrClassName))) return errorID(3807, typeOrClassName), 
                cc._RF.peek() && errorID(3808, typeOrClassName), null;
            } else {
                if (!typeOrClassName) return errorID(3804), null;
                constructor = typeOrClassName;
            }
            if ("function" != typeof constructor) return errorID(3809), null;
            if (!isChildClassOf(constructor, cc.Component)) return errorID(3810), null;
            var ReqComp = constructor._requireComponent;
            if (ReqComp && !this.getComponent(ReqComp) && !this.addComponent(ReqComp)) return null;
            var component = new constructor;
            return component.node = this, this._components.push(component), this._activeInHierarchy && cc.director._nodeActivator.activateComp(component), 
            component;
        }
    }, {
        key: "removeComponent",
        value: function removeComponent(component) {
            if (component) {
                var componentInstance = null;
                (componentInstance = component instanceof Component ? component : this.getComponent(component)) && componentInstance.destroy();
            } else errorID(3813);
        }
    }, {
        key: "on",
        value: function on(type, callback, target) {
            var useCapture = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            switch (type) {
              case exports.SystemEventType.TRANSFORM_CHANGED:
                this._eventMask |= 1;
            }
            this._eventProcessor.on(type, callback, target, useCapture);
        }
    }, {
        key: "off",
        value: function off(type, callback, target) {
            var useCapture = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            this._eventProcessor.off(type, callback, target, useCapture);
            var hasListeners = this._eventProcessor.hasEventListener(type);
            if (!hasListeners) switch (type) {
              case exports.SystemEventType.TRANSFORM_CHANGED:
                this._eventMask &= -2;
            }
        }
    }, {
        key: "once",
        value: function once(type, callback, target, useCapture) {
            this._eventProcessor.once(type, callback, target, useCapture);
        }
    }, {
        key: "emit",
        value: function emit(type, arg0, arg1, arg2, arg3, arg4) {
            this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
        }
    }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
            this._eventProcessor.dispatchEvent(event);
        }
    }, {
        key: "hasEventListener",
        value: function hasEventListener(type, callback, target) {
            return this._eventProcessor.hasEventListener(type, callback, target);
        }
    }, {
        key: "targetOff",
        value: function targetOff(target) {
            this._eventProcessor.targetOff(target), 1 & this._eventMask && !this._eventProcessor.hasEventListener(exports.SystemEventType.TRANSFORM_CHANGED) && (this._eventMask &= -2);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return !!_get(_getPrototypeOf(BaseNode.prototype), "destroy", this).call(this) && (this._activeInHierarchy && this._disableChildComps(), 
            !0);
        }
    }, {
        key: "destroyAllChildren",
        value: function destroyAllChildren() {
            for (var children = this._children, i = 0; i < children.length; ++i) children[i].destroy();
        }
    }, {
        key: "_removeComponent",
        value: function _removeComponent(component) {
            if (component) {
                if (!(this._objFlags & Destroying$2)) {
                    var i = this._components.indexOf(component);
                    -1 !== i ? this._components.splice(i, 1) : component.node !== this && errorID(3815);
                }
            } else errorID(3814);
        }
    }, {
        key: "_updateSiblingIndex",
        value: function _updateSiblingIndex() {
            for (var i = 0; i < this._children.length; ++i) this._children[i]._siblingIndex = i;
        }
    }, {
        key: "_onSetParent",
        value: function _onSetParent(oldParent) {
            this._parent && (null != oldParent && oldParent._scene === this._parent._scene || null == this._parent._scene || this.walk((function(node) {
                BaseNode._setScene(node);
            })));
        }
    }, {
        key: "_onPostActivated",
        value: function _onPostActivated(active) {}
    }, {
        key: "_onBatchRestored",
        value: function _onBatchRestored() {}
    }, {
        key: "_onBatchCreated",
        value: function _onBatchCreated() {
            this._parent && (this._siblingIndex = this._parent.children.indexOf(this));
        }
    }, {
        key: "_onPreDestroy",
        value: function _onPreDestroy() {
            this._onPreDestroyBase();
        }
    }, {
        key: "_onHierarchyChanged",
        value: function _onHierarchyChanged(oldParent) {
            return this._onHierarchyChangedBase(oldParent);
        }
    }, {
        key: "_instantiate",
        value: function _instantiate(cloned) {
            cloned || (cloned = cc.instantiate._clone(this, this));
            var thisPrefabInfo = this._prefab;
            thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
            return cloned._parent = null, cloned._onBatchRestored(), cloned;
        }
    }, {
        key: "_onHierarchyChangedBase",
        value: function _onHierarchyChangedBase(oldParent) {
            var newParent = this._parent;
            !this._persistNode || newParent instanceof cc.Scene || cc.game.removePersistRootNode(this);
            var shouldActiveNow = this._active && !(!newParent || !newParent._activeInHierarchy);
            this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
        }
    }, {
        key: "_onPreDestroyBase",
        value: function _onPreDestroyBase() {
            this._objFlags |= Destroying$2;
            var parent = this._parent, destroyByParent = !!parent && 0 != (parent._objFlags & Destroying$2);
            if (this._persistNode && cc.game.removePersistRootNode(this), !destroyByParent && parent) {
                this.emit(exports.SystemEventType.PARENT_CHANGED, this);
                var childIndex = parent._children.indexOf(this);
                parent._children.splice(childIndex, 1), this._siblingIndex = 0, parent.emit && parent.emit(exports.SystemEventType.CHILD_REMOVED, this);
            }
            this.emit(exports.SystemEventType.NODE_DESTROYED, this), this._eventProcessor.destroy();
            for (var children = this._children, i = 0; i < children.length; ++i) children[i]._destroyImmediate();
            for (var comps = this._components, _i5 = 0; _i5 < comps.length; ++_i5) comps[_i5]._destroyImmediate();
            return destroyByParent;
        }
    }, {
        key: "_disableChildComps",
        value: function _disableChildComps() {
            for (var comps = this._components, i = 0; i < comps.length; ++i) {
                var component = comps[i];
                component._enabled && cc.director._compScheduler.disableComp(component);
            }
            for (var children = this._children, _i6 = 0; _i6 < children.length; ++_i6) {
                var node = children[_i6];
                node._active && node._disableChildComps();
            }
        }
    } ]), BaseNode;
}(), _class3$b.idGenerator = idGenerator$2, _class3$b._stacks = [ [] ], _class3$b._stackId = 0, 
_applyDecoratedDescriptor((_class2$p = _temp$r).prototype, "_persistNode", [ property ], Object.getOwnPropertyDescriptor(_class2$p.prototype, "_persistNode"), _class2$p.prototype), 
_applyDecoratedDescriptor(_class2$p.prototype, "name", [ property ], Object.getOwnPropertyDescriptor(_class2$p.prototype, "name"), _class2$p.prototype), 
_applyDecoratedDescriptor(_class2$p.prototype, "uuid", [ property ], Object.getOwnPropertyDescriptor(_class2$p.prototype, "uuid"), _class2$p.prototype), 
_applyDecoratedDescriptor(_class2$p.prototype, "children", [ property ], Object.getOwnPropertyDescriptor(_class2$p.prototype, "children"), _class2$p.prototype), 
_applyDecoratedDescriptor(_class2$p.prototype, "active", [ property ], Object.getOwnPropertyDescriptor(_class2$p.prototype, "active"), _class2$p.prototype), 
_applyDecoratedDescriptor(_class2$p.prototype, "activeInHierarchy", [ property ], Object.getOwnPropertyDescriptor(_class2$p.prototype, "activeInHierarchy"), _class2$p.prototype), 
_applyDecoratedDescriptor(_class2$p.prototype, "parent", [ property ], Object.getOwnPropertyDescriptor(_class2$p.prototype, "parent"), _class2$p.prototype), 
_descriptor$n = _applyDecoratedDescriptor(_class2$p.prototype, "_parent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$f = _applyDecoratedDescriptor(_class2$p.prototype, "_children", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$b = _applyDecoratedDescriptor(_class2$p.prototype, "_active", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$6 = _applyDecoratedDescriptor(_class2$p.prototype, "_components", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor5$4 = _applyDecoratedDescriptor(_class2$p.prototype, "_prefab", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$u = _class2$p)) || _class$u;

cc._BaseNode = BaseNode;

var _vec2a = new Vec2, _vec2b = new Vec2, _mat4_temp = new Mat4, _matrix = new Mat4, _worldMatrix = new Mat4, _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), _rect = new Rect, UITransformComponent = (_dec$v = ccclass("cc.UITransformComponent"), 
_dec2$e = help("i18n:cc.UITransformComponent"), _dec3$6 = executionOrder(110), _dec4$4 = menu("UI/UITransform"), 
_dec5$3 = property({
    displayOrder: 0,
    tooltip: "内容尺寸"
}), _dec6$3 = property({
    displayOrder: 1,
    tooltip: "锚点位置"
}), _dec7$2 = property({
    tooltip: "渲染排序优先级"
}), _dec$v(_class$v = _dec2$e(_class$v = _dec3$6(_class$v = _dec4$4(_class$v = executeInEditMode((_temp$s = _class3$c = function(_Component) {
    function UITransformComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UITransformComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UITransformComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_priority", _descriptor$o, _assertThisInitialized(_this)), 
        _this._canvas = null, _initializerDefineProperty(_this, "_contentSize", _descriptor2$g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_anchorPoint", _descriptor3$c, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(UITransformComponent, Component), _createClass(UITransformComponent, [ {
        key: "__preload",
        value: function __preload() {
            this.node._uiProps.uiTransformComp = this;
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._updateVisibility(), this.node.on(exports.SystemEventType.PARENT_CHANGED, this._parentChanged, this), 
            this._sortSiblings();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.node.off(exports.SystemEventType.PARENT_CHANGED, this._parentChanged, this), 
            this._canvas = null;
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.node._uiProps.uiTransformComp = null;
        }
    }, {
        key: "setContentSize",
        value: function setContentSize(size, height) {
            var locContentSize = this._contentSize;
            if (void 0 === height) {
                if ((size = size).width === locContentSize.width && size.height === locContentSize.height) return;
                locContentSize.width = size.width, locContentSize.height = size.height;
            } else {
                if (size === locContentSize.width && height === locContentSize.height) return;
                locContentSize.width = size, locContentSize.height = height;
            }
            this.node.emit(exports.SystemEventType.SIZE_CHANGED);
        }
    }, {
        key: "setAnchorPoint",
        value: function setAnchorPoint(point, y) {
            var locAnchorPoint = this._anchorPoint;
            if (void 0 === y) {
                if ((point = point).x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
                locAnchorPoint.x = point.x, locAnchorPoint.y = point.y;
            } else {
                if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
                locAnchorPoint.x = point, locAnchorPoint.y = y;
            }
            this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
        }
    }, {
        key: "isHit",
        value: function isHit(point, listener) {
            var w = this._contentSize.width, h = this._contentSize.height, cameraPt = _vec2a, testPt = _vec2b, canvas = this._canvas;
            if (canvas) {
                canvas.node.getWorldRT(_mat4_temp);
                var m12 = _mat4_temp.m12, m13 = _mat4_temp.m13, center = cc.visibleRect.center;
                if (_mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13), _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13), 
                Mat4.invert(_mat4_temp, _mat4_temp), Vec2.transformMat4(cameraPt, point, _mat4_temp), 
                this.node.getWorldMatrix(_worldMatrix), Mat4.invert(_mat4_temp, _worldMatrix), Mat4.strictEquals(_mat4_temp, _zeroMatrix)) return !1;
                if (Vec2.transformMat4(testPt, cameraPt, _mat4_temp), testPt.x += this._anchorPoint.x * w, 
                testPt.y += this._anchorPoint.y * h, testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    if (listener && listener.mask) {
                        for (var mask = listener.mask, parent = this.node, i = 0; parent && i < mask.index; ++i, 
                        parent = parent.parent) ;
                        if (parent === mask.node) {
                            var comp = parent.getComponent(cc.MaskComponent);
                            return !comp || !comp.enabledInHierarchy || comp.isHit(cameraPt);
                        }
                        return listener.mask = null, !0;
                    }
                    return !0;
                }
                return !1;
            }
        }
    }, {
        key: "convertToNodeSpaceAR",
        value: function convertToNodeSpaceAR(worldPoint, out) {
            return this.node.getWorldMatrix(_worldMatrix), Mat4.invert(_mat4_temp, _worldMatrix), 
            out || (out = new Vec3), Vec3.transformMat4(out, worldPoint, _mat4_temp);
        }
    }, {
        key: "convertToWorldSpaceAR",
        value: function convertToWorldSpaceAR(nodePoint, out) {
            return this.node.getWorldMatrix(_worldMatrix), out || (out = new Vec3), Vec3.transformMat4(out, nodePoint, _worldMatrix);
        }
    }, {
        key: "getBoundingBox",
        value: function getBoundingBox() {
            Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
            var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
            return rect.transformMat4(_matrix), rect;
        }
    }, {
        key: "getBoundingBoxToWorld",
        value: function getBoundingBoxToWorld() {
            return this.node.parent ? (this.node.parent.getWorldMatrix(_worldMatrix), this.getBoundingBoxTo(_worldMatrix)) : this.getBoundingBox();
        }
    }, {
        key: "getBoundingBoxTo",
        value: function getBoundingBoxTo(parentMat) {
            Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
            var width = this._contentSize.width, height = this._contentSize.height, rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
            if (Mat4.multiply(_worldMatrix, parentMat, _matrix), rect.transformMat4(_worldMatrix), 
            !this.node.children) return rect;
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this.node.children); !(_step = _iterator()).done; ) {
                var child = _step.value;
                if (child && child.active) {
                    var uiTransform = child.getComponent(UITransformComponent);
                    if (uiTransform) {
                        var childRect = uiTransform.getBoundingBoxTo(parentMat);
                        childRect && Rect.union(rect, rect, childRect);
                    }
                }
            }
            return rect;
        }
    }, {
        key: "getComputeAABB",
        value: function getComputeAABB(out) {
            var width = this._contentSize.width, height = this._contentSize.height;
            _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height), 
            _rect.transformMat4(this.node.worldMatrix);
            var px = _rect.x + .5 * _rect.width, py = _rect.y + .5 * _rect.height, pz = this.node.worldPosition.z, w = _rect.width / 2, h = _rect.height / 2;
            if (null == out) return new aabb(px, py, pz, w, h, .001);
            aabb.set(out, px, py, pz, w, h, .001);
        }
    }, {
        key: "_updateVisibility",
        value: function _updateVisibility() {
            for (var parent = this.node; parent; ) {
                if (parent) {
                    var canvasComp = parent.getComponent("cc.CanvasComponent");
                    if (canvasComp) {
                        this._canvas = canvasComp;
                        break;
                    }
                }
                parent = parent.parent;
            }
        }
    }, {
        key: "_parentChanged",
        value: function _parentChanged(node) {
            this._canvas && this._canvas.node === this.node || this._sortSiblings();
        }
    }, {
        key: "_sortSiblings",
        value: function _sortSiblings() {
            var siblings = this.node.parent && this.node.parent.children;
            siblings && (siblings.sort((function(a, b) {
                var aComp = a._uiProps.uiTransformComp, bComp = b._uiProps.uiTransformComp, diff = (aComp ? aComp.priority : 0) - (bComp ? bComp.priority : 0);
                return 0 === diff ? a.getSiblingIndex() - b.getSiblingIndex() : diff;
            })), this.node.parent._updateSiblingIndex());
        }
    }, {
        key: "contentSize",
        get: function get() {
            return this._contentSize;
        },
        set: function set(value) {
            this._contentSize.equals(value) || (this._contentSize.set(value), this.node.emit(exports.SystemEventType.SIZE_CHANGED));
        }
    }, {
        key: "width",
        get: function get() {
            return this._contentSize.width;
        },
        set: function set(value) {
            this._contentSize.width !== value && (this._contentSize.width = value, this.node.emit(exports.SystemEventType.SIZE_CHANGED));
        }
    }, {
        key: "height",
        get: function get() {
            return this._contentSize.height;
        },
        set: function set(value) {
            this.contentSize.height !== value && (this._contentSize.height = value, this.node.emit(exports.SystemEventType.SIZE_CHANGED));
        }
    }, {
        key: "anchorPoint",
        get: function get() {
            return this._anchorPoint;
        },
        set: function set(value) {
            this._anchorPoint.equals(value) || (this._anchorPoint.set(value), this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
        }
    }, {
        key: "anchorX",
        get: function get() {
            return this._anchorPoint.x;
        },
        set: function set(value) {
            this._anchorPoint.x !== value && (this._anchorPoint.x = value, this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
        }
    }, {
        key: "anchorY",
        get: function get() {
            return this._anchorPoint.y;
        },
        set: function set(value) {
            this._anchorPoint.y !== value && (this._anchorPoint.y = value, this.node.emit(exports.SystemEventType.ANCHOR_CHANGED, this._anchorPoint));
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        },
        set: function set(value) {
            this._priority !== value && (this._canvas && this._canvas.node === this.node ? cc.warn(9200) : (this._priority = value, 
            this._sortSiblings()));
        }
    }, {
        key: "visibility",
        get: function get() {
            return this._canvas ? this._canvas.visibility : -1;
        }
    } ]), UITransformComponent;
}(), _class3$c.EventType = exports.SystemEventType, _applyDecoratedDescriptor((_class2$q = _temp$s).prototype, "contentSize", [ _dec5$3 ], Object.getOwnPropertyDescriptor(_class2$q.prototype, "contentSize"), _class2$q.prototype), 
_applyDecoratedDescriptor(_class2$q.prototype, "anchorPoint", [ _dec6$3 ], Object.getOwnPropertyDescriptor(_class2$q.prototype, "anchorPoint"), _class2$q.prototype), 
_applyDecoratedDescriptor(_class2$q.prototype, "priority", [ _dec7$2 ], Object.getOwnPropertyDescriptor(_class2$q.prototype, "priority"), _class2$q.prototype), 
_descriptor$o = _applyDecoratedDescriptor(_class2$q.prototype, "_priority", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$g = _applyDecoratedDescriptor(_class2$q.prototype, "_contentSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Size(100, 100);
    }
}), _descriptor3$c = _applyDecoratedDescriptor(_class2$q.prototype, "_anchorPoint", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(.5, .5);
    }
}), _class$v = _class2$q)) || _class$v) || _class$v) || _class$v) || _class$v) || _class$v);

cc.UITransformComponent = UITransformComponent;

var _dec$w, _dec2$f, _class$w, _class2$r, _descriptor$p, _descriptor2$h, _descriptor3$d, _descriptor4$7, _descriptor5$5, _class3$d, _temp$t, NodeUIProperties = function() {
    function NodeUIProperties(node) {
        _classCallCheck(this, NodeUIProperties), this.uiComp = null, this.opacity = 1, this._uiTransformComp = null, 
        this._node = void 0, this._node = node;
    }
    return _createClass(NodeUIProperties, [ {
        key: "uiTransformComp",
        get: function get() {
            return this._uiTransformComp || (this._uiTransformComp = this._node.getComponent(UITransformComponent)), 
            this._uiTransformComp;
        },
        set: function set(value) {
            this._uiTransformComp = value;
        }
    } ]), NodeUIProperties;
}(), v3_a = new Vec3, q_a = new Quat, q_b = new Quat, array_a = new Array(10), qt_1$1 = new Quat, m3_1$2 = new Mat3, m3_scaling = new Mat3, m4_1$1 = new Mat4, bookOfChange = new Map, Node$1 = (_dec$w = ccclass("cc.Node"), 
_dec2$f = property({
    type: Vec3
}), _dec$w((_temp$t = _class3$d = function(_BaseNode) {
    function Node() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Node);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Node)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._uiProps = new NodeUIProperties(_assertThisInitialized(_this)), 
        _this._static = !1, _this._pos = new Vec3, _this._rot = new Quat, _this._scale = new Vec3(1, 1, 1), 
        _this._mat = new Mat4, _initializerDefineProperty(_this, "_lpos", _descriptor$p, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lrot", _descriptor2$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lscale", _descriptor3$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_layer", _descriptor4$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_euler", _descriptor5$5, _assertThisInitialized(_this)), 
        _this._dirtyFlags = TransformBit.NONE, _this._eulerDirty = !1, _this;
    }
    return _inherits(Node, BaseNode), _createClass(Node, [ {
        key: "setParent",
        value: function setParent(value) {
            var keepWorldTransform = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            keepWorldTransform && this.updateWorldTransform(), _get(_getPrototypeOf(Node.prototype), "setParent", this).call(this, value, keepWorldTransform);
        }
    }, {
        key: "_onSetParent",
        value: function _onSetParent(oldParent, keepWorldTransform) {
            if (_get(_getPrototypeOf(Node.prototype), "_onSetParent", this).call(this, oldParent, keepWorldTransform), 
            keepWorldTransform) {
                var parent = this._parent;
                parent ? (parent.updateWorldTransform(), Mat4.multiply(m4_1$1, Mat4.invert(m4_1$1, parent._mat), this._mat), 
                Mat4.toRTS(m4_1$1, this._lrot, this._lpos, this._lscale)) : (Vec3.copy(this._lpos, this._pos), 
                Quat.copy(this._lrot, this._rot), Vec3.copy(this._lscale, this._scale)), this._eulerDirty = !0;
            }
            this.invalidateChildren(TransformBit.TRS);
        }
    }, {
        key: "_onBatchCreated",
        value: function _onBatchCreated() {
            _get(_getPrototypeOf(Node.prototype), "_onBatchCreated", this).call(this), bookOfChange.set(this._id, TransformBit.TRS), 
            this._dirtyFlags = TransformBit.TRS;
            for (var len = this._children.length, i = 0; i < len; ++i) this._children[i]._onBatchCreated();
        }
    }, {
        key: "_onBatchRestored",
        value: function _onBatchRestored() {
            this._onBatchCreated();
        }
    }, {
        key: "_onBeforeSerialize",
        value: function _onBeforeSerialize() {
            this.eulerAngles;
        }
    }, {
        key: "_onPostActivated",
        value: function _onPostActivated(active) {
            active ? (eventManager.resumeTarget(this), this.eventProcessor.reattach(), this.invalidateChildren(TransformBit.TRS)) : eventManager.pauseTarget(this);
        }
    }, {
        key: "translate",
        value: function translate(trans, ns) {
            var space = ns || NodeSpace.LOCAL;
            if (space === NodeSpace.LOCAL) Vec3.transformQuat(v3_a, trans, this._lrot), this._lpos.x += v3_a.x, 
            this._lpos.y += v3_a.y, this._lpos.z += v3_a.z; else if (space === NodeSpace.WORLD) if (this._parent) {
                Quat.invert(q_a, this._parent.worldRotation), Vec3.transformQuat(v3_a, trans, q_a);
                var _scale = this.worldScale;
                this._lpos.x += v3_a.x / _scale.x, this._lpos.y += v3_a.y / _scale.y, this._lpos.z += v3_a.z / _scale.z;
            } else this._lpos.x += trans.x, this._lpos.y += trans.y, this._lpos.z += trans.z;
            this.invalidateChildren(TransformBit.POSITION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
        }
    }, {
        key: "rotate",
        value: function rotate(rot, ns) {
            var space = ns || NodeSpace.LOCAL;
            if (Quat.normalize(q_a, rot), space === NodeSpace.LOCAL) Quat.multiply(this._lrot, this._lrot, q_a); else if (space === NodeSpace.WORLD) {
                var worldRot = this.worldRotation;
                Quat.multiply(q_b, q_a, worldRot), Quat.invert(q_a, worldRot), Quat.multiply(q_b, q_a, q_b), 
                Quat.multiply(this._lrot, this._lrot, q_b);
            }
            this._eulerDirty = !0, this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
        }
    }, {
        key: "lookAt",
        value: function lookAt(pos, up) {
            this.getWorldPosition(v3_a), Vec3.subtract(v3_a, v3_a, pos), Vec3.normalize(v3_a, v3_a), 
            Quat.fromViewUp(q_a, v3_a, up), this.setWorldRotation(q_a);
        }
    }, {
        key: "invalidateChildren",
        value: function invalidateChildren(dirtyBit) {
            if ((this._dirtyFlags & this.hasChangedFlags & dirtyBit) !== dirtyBit) {
                this._dirtyFlags |= dirtyBit, bookOfChange.set(this._id, this.hasChangedFlags | dirtyBit), 
                dirtyBit |= TransformBit.POSITION;
                for (var len = this._children.length, i = 0; i < len; ++i) {
                    var child = this._children[i];
                    child.isValid && child.invalidateChildren(dirtyBit);
                }
            }
        }
    }, {
        key: "updateWorldTransform",
        value: function updateWorldTransform() {
            if (this._dirtyFlags) {
                for (var child, cur = this, i = 0; cur && cur._dirtyFlags; ) array_a[i++] = cur, 
                cur = cur._parent;
                for (var dirtyBits = 0; i; ) dirtyBits |= (child = array_a[--i])._dirtyFlags, cur ? (dirtyBits & TransformBit.POSITION && (Vec3.transformMat4(child._pos, child._lpos, cur._mat), 
                child._mat.m12 = child._pos.x, child._mat.m13 = child._pos.y, child._mat.m14 = child._pos.z), 
                dirtyBits & TransformBit.RS && (Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale), 
                Mat4.multiply(child._mat, cur._mat, child._mat), dirtyBits & TransformBit.ROTATION && Quat.multiply(child._rot, cur._rot, child._lrot), 
                Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, child._rot)), Mat3.multiplyMat4(m3_1$2, m3_1$2, child._mat), 
                child._scale.x = m3_1$2.m00, child._scale.y = m3_1$2.m04, child._scale.z = m3_1$2.m08)) : (dirtyBits & TransformBit.POSITION && (Vec3.copy(child._pos, child._lpos), 
                child._mat.m12 = child._pos.x, child._mat.m13 = child._pos.y, child._mat.m14 = child._pos.z), 
                dirtyBits & TransformBit.RS && (dirtyBits & TransformBit.ROTATION && Quat.copy(child._rot, child._lrot), 
                dirtyBits & TransformBit.SCALE && Vec3.copy(child._scale, child._lscale), Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale))), 
                child._dirtyFlags = TransformBit.NONE, cur = child;
            }
        }
    }, {
        key: "setPosition",
        value: function setPosition(val, y, z) {
            void 0 === y || void 0 === z ? Vec3.copy(this._lpos, val) : Vec3.set(this._lpos, val, y, z), 
            this.invalidateChildren(TransformBit.POSITION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
        }
    }, {
        key: "getPosition",
        value: function getPosition(out) {
            return out ? Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z) : Vec3.copy(new Vec3, this._lpos);
        }
    }, {
        key: "setRotation",
        value: function setRotation(val, y, z, w) {
            void 0 === y || void 0 === z || void 0 === w ? Quat.copy(this._lrot, val) : Quat.set(this._lrot, val, y, z, w), 
            this._eulerDirty = !0, this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
        }
    }, {
        key: "setRotationFromEuler",
        value: function setRotationFromEuler(x, y, z) {
            Vec3.set(this._euler, x, y, z), Quat.fromEuler(this._lrot, x, y, z), this._eulerDirty = !1, 
            this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
        }
    }, {
        key: "getRotation",
        value: function getRotation(out) {
            return out ? Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w) : Quat.copy(new Quat, this._lrot);
        }
    }, {
        key: "setScale",
        value: function setScale(val, y, z) {
            void 0 === y || void 0 === z ? Vec3.copy(this._lscale, val) : Vec3.set(this._lscale, val, y, z), 
            this.invalidateChildren(TransformBit.SCALE), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
        }
    }, {
        key: "getScale",
        value: function getScale(out) {
            return out ? Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z) : Vec3.copy(new Vec3, this._lscale);
        }
    }, {
        key: "inverseTransformPoint",
        value: function inverseTransformPoint(out, p) {
            Vec3.copy(out, p);
            for (var cur = this, i = 0; cur._parent; ) array_a[i++] = cur, cur = cur._parent;
            for (;i >= 0; ) Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale), 
            cur = array_a[--i];
            return out;
        }
    }, {
        key: "setWorldPosition",
        value: function setWorldPosition(val, y, z) {
            void 0 === y || void 0 === z ? Vec3.copy(this._pos, val) : Vec3.set(this._pos, val, y, z);
            var parent = this._parent, local = this._lpos;
            parent ? (parent.updateWorldTransform(), Vec3.transformMat4(local, this._pos, Mat4.invert(m4_1$1, parent._mat))) : Vec3.copy(local, this._pos), 
            this.invalidateChildren(TransformBit.POSITION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
        }
    }, {
        key: "getWorldPosition",
        value: function getWorldPosition(out) {
            return this.updateWorldTransform(), out ? Vec3.copy(out, this._pos) : Vec3.copy(new Vec3, this._pos);
        }
    }, {
        key: "setWorldRotation",
        value: function setWorldRotation(val, y, z, w) {
            void 0 === y || void 0 === z || void 0 === w ? Quat.copy(this._rot, val) : Quat.set(this._rot, val, y, z, w), 
            this._parent ? (this._parent.updateWorldTransform(), Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot)) : Quat.copy(this._lrot, this._rot), 
            this._eulerDirty = !0, this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
        }
    }, {
        key: "setWorldRotationFromEuler",
        value: function setWorldRotationFromEuler(x, y, z) {
            Quat.fromEuler(this._rot, x, y, z), this._parent ? (this._parent.updateWorldTransform(), 
            Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot)) : Quat.copy(this._lrot, this._rot), 
            this._eulerDirty = !0, this.invalidateChildren(TransformBit.ROTATION), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
        }
    }, {
        key: "getWorldRotation",
        value: function getWorldRotation(out) {
            return this.updateWorldTransform(), out ? Quat.copy(out, this._rot) : Quat.copy(new Quat, this._rot);
        }
    }, {
        key: "setWorldScale",
        value: function setWorldScale(val, y, z) {
            void 0 === y || void 0 === z ? Vec3.copy(this._scale, val) : Vec3.set(this._scale, val, y, z);
            var parent = this._parent;
            parent ? (parent.updateWorldTransform(), Mat3.fromQuat(m3_1$2, Quat.conjugate(qt_1$1, parent._rot)), 
            Mat3.multiplyMat4(m3_1$2, m3_1$2, parent._mat), m3_scaling.m00 = this._scale.x, 
            m3_scaling.m04 = this._scale.y, m3_scaling.m08 = this._scale.z, Mat3.multiply(m3_1$2, m3_scaling, Mat3.invert(m3_1$2, m3_1$2)), 
            this._lscale.x = Vec3.set(v3_a, m3_1$2.m00, m3_1$2.m01, m3_1$2.m02).length(), this._lscale.y = Vec3.set(v3_a, m3_1$2.m03, m3_1$2.m04, m3_1$2.m05).length(), 
            this._lscale.z = Vec3.set(v3_a, m3_1$2.m06, m3_1$2.m07, m3_1$2.m08).length()) : Vec3.copy(this._lscale, this._scale), 
            this.invalidateChildren(TransformBit.SCALE), 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
        }
    }, {
        key: "getWorldScale",
        value: function getWorldScale(out) {
            return this.updateWorldTransform(), out ? Vec3.copy(out, this._scale) : Vec3.copy(new Vec3, this._scale);
        }
    }, {
        key: "getWorldMatrix",
        value: function getWorldMatrix(out) {
            return this.updateWorldTransform(), out || (out = new Mat4), Mat4.copy(out, this._mat);
        }
    }, {
        key: "getWorldRS",
        value: function getWorldRS(out) {
            return this.updateWorldTransform(), out || (out = new Mat4), Mat4.copy(out, this._mat), 
            out.m12 = 0, out.m13 = 0, out.m14 = 0, out;
        }
    }, {
        key: "getWorldRT",
        value: function getWorldRT(out) {
            return this.updateWorldTransform(), out || (out = new Mat4), Mat4.fromRT(out, this._rot, this._pos);
        }
    }, {
        key: "setRTS",
        value: function setRTS(rot, pos, scale) {
            var dirtyBit = 0;
            rot && (dirtyBit |= TransformBit.ROTATION, void 0 !== rot.w ? (Quat.copy(this._lrot, rot), 
            this._eulerDirty = !0) : (Vec3.copy(this._euler, rot), Quat.fromEuler(this._lrot, rot.x, rot.y, rot.z), 
            this._eulerDirty = !1)), pos && (Vec3.copy(this._lpos, pos), dirtyBit |= TransformBit.POSITION), 
            scale && (Vec3.copy(this._lscale, scale), dirtyBit |= TransformBit.SCALE), dirtyBit && (this.invalidateChildren(dirtyBit), 
            1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, dirtyBit));
        }
    }, {
        key: "getAnchorPoint",
        value: function getAnchorPoint(out) {
            return out || (out = new Vec2), out.set(this._uiProps.uiTransformComp.anchorPoint), 
            out;
        }
    }, {
        key: "setAnchorPoint",
        value: function setAnchorPoint(point, y) {
            this._uiProps.uiTransformComp.setAnchorPoint(point, y);
        }
    }, {
        key: "getContentSize",
        value: function getContentSize(out) {
            return out || (out = new Size), out.set(this._uiProps.uiTransformComp.contentSize), 
            out;
        }
    }, {
        key: "setContentSize",
        value: function setContentSize(size, height) {
            this._uiProps.uiTransformComp.setContentSize(size, height);
        }
    }, {
        key: "pauseSystemEvents",
        value: function pauseSystemEvents(recursive) {
            eventManager.pauseTarget(this, recursive);
        }
    }, {
        key: "resumeSystemEvents",
        value: function resumeSystemEvents(recursive) {
            eventManager.resumeTarget(this, recursive);
        }
    }, {
        key: "position",
        get: function get() {
            return this._lpos;
        },
        set: function set(val) {
            this.setPosition(val);
        }
    }, {
        key: "worldPosition",
        get: function get() {
            return this.updateWorldTransform(), this._pos;
        },
        set: function set(val) {
            this.setWorldPosition(val);
        }
    }, {
        key: "rotation",
        get: function get() {
            return this._lrot;
        },
        set: function set(val) {
            this.setRotation(val);
        }
    }, {
        key: "eulerAngles",
        set: function set(val) {
            this.setRotationFromEuler(val.x, val.y, val.z);
        },
        get: function get() {
            return this._eulerDirty && (Quat.toEuler(this._euler, this._lrot), this._eulerDirty = !1), 
            this._euler;
        }
    }, {
        key: "worldRotation",
        get: function get() {
            return this.updateWorldTransform(), this._rot;
        },
        set: function set(val) {
            this.setWorldRotation(val);
        }
    }, {
        key: "scale",
        get: function get() {
            return this._lscale;
        },
        set: function set(val) {
            this.setScale(val);
        }
    }, {
        key: "worldScale",
        get: function get() {
            return this.updateWorldTransform(), this._scale;
        },
        set: function set(val) {
            this.setWorldScale(val);
        }
    }, {
        key: "matrix",
        set: function set(val) {
            Mat4.toRTS(val, this._lrot, this._lpos, this._lscale), this.invalidateChildren(TransformBit.TRS), 
            this._eulerDirty = !0, 1 & this._eventMask && this.emit(exports.SystemEventType.TRANSFORM_CHANGED, TransformBit.TRS);
        }
    }, {
        key: "worldMatrix",
        get: function get() {
            return this.updateWorldTransform(), this._mat;
        }
    }, {
        key: "forward",
        get: function get() {
            return Vec3.transformQuat(new Vec3, Vec3.FORWARD, this.worldRotation);
        },
        set: function set(dir) {
            var len = dir.length();
            Vec3.multiplyScalar(v3_a, dir, -1 / len), Quat.fromViewUp(q_a, v3_a), this.setWorldRotation(q_a);
        }
    }, {
        key: "layer",
        set: function set(l) {
            this._layer = l;
        },
        get: function get() {
            return this._layer;
        }
    }, {
        key: "hasChangedFlags",
        get: function get() {
            return bookOfChange.get(this._id) || 0;
        },
        set: function set(val) {
            bookOfChange.set(this._id, val);
        }
    }, {
        key: "width",
        get: function get() {
            return this._uiProps.uiTransformComp.width;
        },
        set: function set(value) {
            this._uiProps.uiTransformComp.width = value;
        }
    }, {
        key: "height",
        get: function get() {
            return this._uiProps.uiTransformComp.height;
        },
        set: function set(value) {
            this._uiProps.uiTransformComp.height = value;
        }
    }, {
        key: "anchorX",
        get: function get() {
            return this._uiProps.uiTransformComp.anchorX;
        },
        set: function set(value) {
            this._uiProps.uiTransformComp.anchorX = value;
        }
    }, {
        key: "anchorY",
        get: function get() {
            return this._uiProps.uiTransformComp.anchorY;
        },
        set: function set(value) {
            this._uiProps.uiTransformComp.anchorY = value;
        }
    } ], [ {
        key: "isNode",
        value: function isNode(obj) {
            return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
        }
    } ]), Node;
}(), _class3$d.bookOfChange = bookOfChange, _class3$d.EventType = exports.SystemEventType, 
_class3$d.NodeSpace = NodeSpace, _class3$d.TransformDirtyBit = TransformBit, _class3$d.TransformBit = TransformBit, 
_descriptor$p = _applyDecoratedDescriptor((_class2$r = _temp$t).prototype, "_lpos", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3;
    }
}), _descriptor2$h = _applyDecoratedDescriptor(_class2$r.prototype, "_lrot", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Quat;
    }
}), _descriptor3$d = _applyDecoratedDescriptor(_class2$r.prototype, "_lscale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _descriptor4$7 = _applyDecoratedDescriptor(_class2$r.prototype, "_layer", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Layers.Enum.DEFAULT;
    }
}), _descriptor5$5 = _applyDecoratedDescriptor(_class2$r.prototype, "_euler", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3;
    }
}), _applyDecoratedDescriptor(_class2$r.prototype, "eulerAngles", [ _dec2$f ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "eulerAngles"), _class2$r.prototype), 
_applyDecoratedDescriptor(_class2$r.prototype, "layer", [ property ], Object.getOwnPropertyDescriptor(_class2$r.prototype, "layer"), _class2$r.prototype), 
_class$w = _class2$r)) || _class$w);

cc.Node = Node$1;

var _dec$x, _dec2$g, _dec3$7, _class$x, _class2$s, _descriptor$q, _descriptor2$i, _descriptor3$e, _dec4$5, _dec5$4, _dec6$4, _dec7$3, _dec8$1, _dec9$1, _class4$2, _class5$2, _descriptor4$8, _descriptor5$6, _descriptor6$2, _descriptor7$2, _dec10$1, _dec11$1, _dec12, _dec13, _dec14, _class7, _class8, _descriptor8$2, _descriptor9$2, _descriptor10$2, _descriptor11, _dec15, _dec16, _class10, _class11, _descriptor12, _descriptor13, _descriptor14, Ambient = function() {
    function Ambient(scene) {
        _classCallCheck(this, Ambient), this._enabled = !0, this._skyColor = Float32Array.from([ .2, .5, .8, 1 ]), 
        this._skyIllum = Ambient.SKY_ILLUM, this._groundAlbedo = Float32Array.from([ .2, .2, .2, 1 ]), 
        this._scene = void 0, this._scene = scene;
    }
    return _createClass(Ambient, [ {
        key: "enabled",
        set: function set(val) {
            this._enabled = val;
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "skyColor",
        get: function get() {
            return this._skyColor;
        },
        set: function set(color) {
            this._skyColor = color;
        }
    }, {
        key: "skyIllum",
        set: function set(illum) {
            this._skyIllum = illum;
        },
        get: function get() {
            return this._skyIllum;
        }
    }, {
        key: "groundAlbedo",
        get: function get() {
            return this._groundAlbedo;
        },
        set: function set(color) {
            this._groundAlbedo = color;
        }
    } ]), _createClass(Ambient, [ {
        key: "update",
        value: function update() {}
    } ]), Ambient;
}();

Ambient.SUN_ILLUM = 65e3, Ambient.SKY_ILLUM = 2e4;

var _up = new Vec3(0, 1, 0), _v3 = new Vec3, _qt = new Quat, AmbientInfo = (_dec$x = ccclass("cc.AmbientInfo"), 
_dec2$g = property({
    type: Color
}), _dec3$7 = property({
    type: Color
}), _dec$x((_descriptor$q = _applyDecoratedDescriptor((_class2$s = function() {
    function AmbientInfo() {
        _classCallCheck(this, AmbientInfo), _initializerDefineProperty(this, "_skyColor", _descriptor$q, this), 
        _initializerDefineProperty(this, "_skyIllum", _descriptor2$i, this), _initializerDefineProperty(this, "_groundAlbedo", _descriptor3$e, this), 
        this._resource = null;
    }
    return _createClass(AmbientInfo, [ {
        key: "skyColor",
        set: function set(val) {
            this._skyColor.set(val), this._resource && Color.toArray(this._resource.skyColor, this.skyColor);
        },
        get: function get() {
            return this._skyColor;
        }
    }, {
        key: "skyIllum",
        set: function set(val) {
            this._skyIllum = val, this._resource && (this._resource.skyIllum = this.skyIllum);
        },
        get: function get() {
            return this._skyIllum;
        }
    }, {
        key: "groundAlbedo",
        set: function set(val) {
            this._groundAlbedo.set(val), this._resource && Vec3.toArray(this._resource.groundAlbedo, this.groundAlbedo);
        },
        get: function get() {
            return this._groundAlbedo;
        }
    }, {
        key: "renderScene",
        set: function set(rs) {
            this._resource = rs.ambient, this.skyColor = this._skyColor, this.skyIllum = this._skyIllum, 
            this.groundAlbedo = this._groundAlbedo;
        }
    } ]), AmbientInfo;
}()).prototype, "_skyColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(51, 128, 204, 1);
    }
}), _descriptor2$i = _applyDecoratedDescriptor(_class2$s.prototype, "_skyIllum", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Ambient.SKY_ILLUM;
    }
}), _descriptor3$e = _applyDecoratedDescriptor(_class2$s.prototype, "_groundAlbedo", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(51, 51, 51, 255);
    }
}), _applyDecoratedDescriptor(_class2$s.prototype, "skyColor", [ _dec2$g ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "skyColor"), _class2$s.prototype), 
_applyDecoratedDescriptor(_class2$s.prototype, "skyIllum", [ _float ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "skyIllum"), _class2$s.prototype), 
_applyDecoratedDescriptor(_class2$s.prototype, "groundAlbedo", [ _dec3$7 ], Object.getOwnPropertyDescriptor(_class2$s.prototype, "groundAlbedo"), _class2$s.prototype), 
_class$x = _class2$s)) || _class$x);

cc.AmbientInfo = AmbientInfo;

var SkyboxInfo = (_dec4$5 = ccclass("cc.SkyboxInfo"), _dec5$4 = property(TextureCube), 
_dec6$4 = property({
    type: CCBoolean
}), _dec7$3 = property({
    type: CCBoolean
}), _dec8$1 = property({
    type: TextureCube
}), _dec9$1 = property({
    type: CCBoolean
}), _dec4$5((_descriptor4$8 = _applyDecoratedDescriptor((_class5$2 = function() {
    function SkyboxInfo() {
        _classCallCheck(this, SkyboxInfo), _initializerDefineProperty(this, "_envmap", _descriptor4$8, this), 
        _initializerDefineProperty(this, "_isRGBE", _descriptor5$6, this), _initializerDefineProperty(this, "_enabled", _descriptor6$2, this), 
        _initializerDefineProperty(this, "_useIBL", _descriptor7$2, this), this._resource = null;
    }
    return _createClass(SkyboxInfo, [ {
        key: "enabled",
        set: function set(val) {
            this._enabled = val, this._resource && (this._resource.enabled = this._enabled);
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "useIBL",
        set: function set(val) {
            this._useIBL = val, this._resource && (this._resource.useIBL = this._useIBL);
        },
        get: function get() {
            return this._useIBL;
        }
    }, {
        key: "envmap",
        set: function set(val) {
            this._envmap = val, this._resource && (this._resource.envmap = this._envmap);
        },
        get: function get() {
            return this._envmap;
        }
    }, {
        key: "isRGBE",
        set: function set(val) {
            this._isRGBE = val, this._resource && (this._resource.isRGBE = this._isRGBE);
        },
        get: function get() {
            return this._isRGBE;
        }
    }, {
        key: "renderScene",
        set: function set(val) {
            this._resource = val.skybox, this.isRGBE = this._isRGBE, this.envmap = this._envmap, 
            this.enabled = this._enabled, this.useIBL = this._useIBL;
        }
    } ]), SkyboxInfo;
}()).prototype, "_envmap", [ _dec5$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor5$6 = _applyDecoratedDescriptor(_class5$2.prototype, "_isRGBE", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor6$2 = _applyDecoratedDescriptor(_class5$2.prototype, "_enabled", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor7$2 = _applyDecoratedDescriptor(_class5$2.prototype, "_useIBL", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class5$2.prototype, "enabled", [ _dec6$4 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "enabled"), _class5$2.prototype), 
_applyDecoratedDescriptor(_class5$2.prototype, "useIBL", [ _dec7$3 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "useIBL"), _class5$2.prototype), 
_applyDecoratedDescriptor(_class5$2.prototype, "envmap", [ _dec8$1 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "envmap"), _class5$2.prototype), 
_applyDecoratedDescriptor(_class5$2.prototype, "isRGBE", [ _dec9$1 ], Object.getOwnPropertyDescriptor(_class5$2.prototype, "isRGBE"), _class5$2.prototype), 
_class4$2 = _class5$2)) || _class4$2);

cc.SkyboxInfo = SkyboxInfo;

var PlanarShadowInfo = (_dec10$1 = ccclass("cc.PlanarShadowInfo"), _dec11$1 = property({
    type: CCBoolean
}), _dec12 = property({
    type: Vec3
}), _dec13 = property({
    type: CCFloat
}), _dec14 = property({
    type: Color
}), _dec10$1((_descriptor8$2 = _applyDecoratedDescriptor((_class8 = function() {
    function PlanarShadowInfo() {
        _classCallCheck(this, PlanarShadowInfo), _initializerDefineProperty(this, "_enabled", _descriptor8$2, this), 
        _initializerDefineProperty(this, "_normal", _descriptor9$2, this), _initializerDefineProperty(this, "_distance", _descriptor10$2, this), 
        _initializerDefineProperty(this, "_shadowColor", _descriptor11, this), this._resource = null;
    }
    return _createClass(PlanarShadowInfo, [ {
        key: "setPlaneFromNode",
        value: function setPlaneFromNode(node) {
            node.getWorldRotation(_qt), this.normal = Vec3.transformQuat(_v3, _up, _qt), node.getWorldPosition(_v3), 
            this.distance = Vec3.dot(this._normal, _v3);
        }
    }, {
        key: "enabled",
        set: function set(val) {
            this._enabled = val, this._resource && (this._resource.enabled = val);
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "normal",
        set: function set(val) {
            Vec3.copy(this._normal, val), this._resource && (this._resource.normal = val);
        },
        get: function get() {
            return this._normal;
        }
    }, {
        key: "distance",
        set: function set(val) {
            this._distance = val, this._resource && (this._resource.distance = val);
        },
        get: function get() {
            return this._distance;
        }
    }, {
        key: "shadowColor",
        set: function set(val) {
            this._shadowColor.set(val), this._resource && (this._resource.shadowColor = val);
        },
        get: function get() {
            return this._shadowColor;
        }
    }, {
        key: "renderScene",
        set: function set(val) {
            this._resource = val.planarShadows, this.normal = this._normal, this.distance = this._distance, 
            this.shadowColor = this._shadowColor, this.enabled = this._enabled;
        }
    } ]), PlanarShadowInfo;
}()).prototype, "_enabled", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor9$2 = _applyDecoratedDescriptor(_class8.prototype, "_normal", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 1, 0);
    }
}), _descriptor10$2 = _applyDecoratedDescriptor(_class8.prototype, "_distance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11 = _applyDecoratedDescriptor(_class8.prototype, "_shadowColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(0, 0, 0, 76);
    }
}), _applyDecoratedDescriptor(_class8.prototype, "enabled", [ _dec11$1 ], Object.getOwnPropertyDescriptor(_class8.prototype, "enabled"), _class8.prototype), 
_applyDecoratedDescriptor(_class8.prototype, "normal", [ _dec12 ], Object.getOwnPropertyDescriptor(_class8.prototype, "normal"), _class8.prototype), 
_applyDecoratedDescriptor(_class8.prototype, "distance", [ _dec13 ], Object.getOwnPropertyDescriptor(_class8.prototype, "distance"), _class8.prototype), 
_applyDecoratedDescriptor(_class8.prototype, "shadowColor", [ _dec14 ], Object.getOwnPropertyDescriptor(_class8.prototype, "shadowColor"), _class8.prototype), 
_class7 = _class8)) || _class7);

cc.PlanarShadowInfo = PlanarShadowInfo;

var _class$y, _class2$t, _descriptor$r, _descriptor2$j, SceneGlobals = (_dec15 = ccclass("cc.SceneGlobals"), 
_dec16 = property({
    type: SkyboxInfo
}), _dec15((_descriptor12 = _applyDecoratedDescriptor((_class11 = function() {
    function SceneGlobals() {
        _classCallCheck(this, SceneGlobals), _initializerDefineProperty(this, "ambient", _descriptor12, this), 
        _initializerDefineProperty(this, "planarShadows", _descriptor13, this), _initializerDefineProperty(this, "_skybox", _descriptor14, this);
    }
    return _createClass(SceneGlobals, [ {
        key: "skybox",
        get: function get() {
            return this._skybox;
        },
        set: function set(value) {
            this._skybox = value;
        }
    }, {
        key: "renderScene",
        set: function set(rs) {
            this.ambient.renderScene = rs, this.skybox.renderScene = rs, this.planarShadows.renderScene = rs;
        }
    } ]), SceneGlobals;
}()).prototype, "ambient", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new AmbientInfo;
    }
}), _descriptor13 = _applyDecoratedDescriptor(_class11.prototype, "planarShadows", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new PlanarShadowInfo;
    }
}), _descriptor14 = _applyDecoratedDescriptor(_class11.prototype, "_skybox", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new SkyboxInfo;
    }
}), _applyDecoratedDescriptor(_class11.prototype, "skybox", [ _dec16 ], Object.getOwnPropertyDescriptor(_class11.prototype, "skybox"), _class11.prototype), 
_class10 = _class11)) || _class10);

cc.SceneGlobals = SceneGlobals;

var _class$z, Scene = ccclass("cc.Scene")((_descriptor$r = _applyDecoratedDescriptor((_class2$t = function(_BaseNode) {
    function Scene(name) {
        var _this;
        return _classCallCheck(this, Scene), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this, name)), "autoReleaseAssets", _descriptor$r, _assertThisInitialized(_this)), 
        _this._renderScene = null, _this.dependAssets = null, _initializerDefineProperty(_this, "_globals", _descriptor2$j, _assertThisInitialized(_this)), 
        _this._inited = void 0, _this._prefabSyncedInLiveReload = !1, _this._pos = Vec3.ZERO, 
        _this._rot = Quat.IDENTITY, _this._scale = Vec3.ONE, _this._mat = Mat4.IDENTITY, 
        _this._dirtyFlags = 0, _this._activeInHierarchy = !1, cc.director && cc.director.root && (_this._renderScene = cc.director.root.createScene({})), 
        _this._inited = !cc.game || !cc.game._isCloning, _this;
    }
    return _inherits(Scene, BaseNode), _createClass(Scene, [ {
        key: "renderScene",
        get: function get() {
            return this._renderScene;
        }
    }, {
        key: "globals",
        get: function get() {
            return this._globals;
        }
    } ]), _createClass(Scene, [ {
        key: "destroy",
        value: function destroy() {
            var success = _get(_getPrototypeOf(Scene.prototype), "destroy", this).call(this);
            return cc.director.root.destroyScene(this._renderScene), this._activeInHierarchy = !1, 
            success;
        }
    }, {
        key: "addComponent",
        value: function addComponent(typeOrClassName) {
            return warnID(3822), null;
        }
    }, {
        key: "_onHierarchyChanged",
        value: function _onHierarchyChanged() {}
    }, {
        key: "_onBatchCreated",
        value: function _onBatchCreated() {
            _get(_getPrototypeOf(Scene.prototype), "_onBatchCreated", this).call(this);
            for (var len = this._children.length, i = 0; i < len; ++i) this._children[i]._onBatchCreated();
        }
    }, {
        key: "_onBatchRestored",
        value: function _onBatchRestored() {
            this._onBatchCreated();
        }
    }, {
        key: "getPosition",
        value: function getPosition(out) {
            return Vec3.copy(out || new Vec3, Vec3.ZERO);
        }
    }, {
        key: "getRotation",
        value: function getRotation(out) {
            return Quat.copy(out || new Quat, Quat.IDENTITY);
        }
    }, {
        key: "getScale",
        value: function getScale(out) {
            return Vec3.copy(out || new Vec3, Vec3.ONE);
        }
    }, {
        key: "getWorldPosition",
        value: function getWorldPosition(out) {
            return Vec3.copy(out || new Vec3, Vec3.ZERO);
        }
    }, {
        key: "getWorldRotation",
        value: function getWorldRotation(out) {
            return Quat.copy(out || new Quat, Quat.IDENTITY);
        }
    }, {
        key: "getWorldScale",
        value: function getWorldScale(out) {
            return Vec3.copy(out || new Vec3, Vec3.ONE);
        }
    }, {
        key: "getWorldMatrix",
        value: function getWorldMatrix(out) {
            return Mat4.copy(out || new Mat4, Mat4.IDENTITY);
        }
    }, {
        key: "getWorldRS",
        value: function getWorldRS(out) {
            return Mat4.copy(out || new Mat4, Mat4.IDENTITY);
        }
    }, {
        key: "getWorldRT",
        value: function getWorldRT(out) {
            return Mat4.copy(out || new Mat4, Mat4.IDENTITY);
        }
    }, {
        key: "updateWorldTransform",
        value: function updateWorldTransform() {}
    }, {
        key: "_instantiate",
        value: function _instantiate() {}
    }, {
        key: "_load",
        value: function _load() {
            this._inited || (this._onBatchCreated(), this._inited = !0), this.walk(BaseNode._setScene);
        }
    }, {
        key: "_activate",
        value: function _activate(active) {
            active = !1 !== active, cc.director._nodeActivator.activateNode(this, active), this._globals.renderScene = this._renderScene;
        }
    }, {
        key: "position",
        get: function get() {
            return Vec3.ZERO;
        }
    }, {
        key: "worldPosition",
        get: function get() {
            return Vec3.ZERO;
        }
    }, {
        key: "rotation",
        get: function get() {
            return Quat.IDENTITY;
        }
    }, {
        key: "worldRotation",
        get: function get() {
            return Quat.IDENTITY;
        }
    }, {
        key: "scale",
        get: function get() {
            return Vec3.ONE;
        }
    }, {
        key: "worldScale",
        get: function get() {
            return Vec3.ONE;
        }
    }, {
        key: "eulerAngles",
        get: function get() {
            return Vec3.ZERO;
        }
    }, {
        key: "worldMatrix",
        get: function get() {
            return Mat4.IDENTITY;
        }
    } ]), Scene;
}()).prototype, "autoReleaseAssets", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$j = _applyDecoratedDescriptor(_class2$t.prototype, "_globals", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new SceneGlobals;
    }
}), _class$y = _class2$t)) || _class$y;

function find(path, referenceNode) {
    if (!referenceNode) {
        var scene = cc.director.getScene();
        if (!scene) return null;
        referenceNode = scene;
    }
    return referenceNode.getChildByPath(path);
}

cc.Scene = Scene, cc.find = find;

var HideInHierarchy$1 = CCObject.Flags.HideInHierarchy, PrivateNode = ccclass("cc.PrivateNode")(_class$z = function(_Node) {
    function PrivateNode(name) {
        var _this;
        return _classCallCheck(this, PrivateNode), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PrivateNode).call(this, name)))._objFlags |= HideInHierarchy$1, 
        _this;
    }
    return _inherits(PrivateNode, Node$1), PrivateNode;
}()) || _class$z;

cc.PrivateNode = PrivateNode;

var fastRemoveAt$2 = array.fastRemoveAt, IsStartCalled$1 = CCObject.Flags.IsStartCalled, IsOnEnableCalled$2 = CCObject.Flags.IsOnEnableCalled;

CCObject.Flags.IsEditorOnEnableCalled;

function sortedIndex(array, comp) {
    for (var order = comp.constructor._executionOrder, id = comp._id, l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m], testOrder = test.constructor._executionOrder;
        if (testOrder > order) h = m - 1; else if (testOrder < order) l = m + 1; else {
            var testId = test._id;
            if (testId > id) h = m - 1; else {
                if (!(testId < id)) return m;
                l = m + 1;
            }
        }
    }
    return ~l;
}

function stableRemoveInactive(iterator, flagToClear) {
    for (var array = iterator.array, next = iterator.i + 1; next < array.length; ) {
        var comp = array[next];
        comp._enabled && comp.node._activeInHierarchy ? ++next : (iterator.removeAt(next), 
        flagToClear && (comp._objFlags &= ~flagToClear));
    }
}

var LifeCycleInvoker = function LifeCycleInvoker(invokeFunc) {
    _classCallCheck(this, LifeCycleInvoker), this._zero = void 0, this._neg = void 0, 
    this._pos = void 0, this._invoke = void 0;
    var Iterator = MutableForwardIterator;
    this._zero = new Iterator([]), this._neg = new Iterator([]), this._pos = new Iterator([]), 
    this._invoke = invokeFunc;
};

function compareOrder(a, b) {
    return a.constructor._executionOrder - b.constructor._executionOrder;
}

LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;

var OneOffInvoker = function(_LifeCycleInvoker) {
    function OneOffInvoker() {
        return _classCallCheck(this, OneOffInvoker), _possibleConstructorReturn(this, _getPrototypeOf(OneOffInvoker).apply(this, arguments));
    }
    return _inherits(OneOffInvoker, LifeCycleInvoker), _createClass(OneOffInvoker, [ {
        key: "add",
        value: function add(comp) {
            var order = comp.constructor._executionOrder;
            (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
        }
    }, {
        key: "remove",
        value: function remove(comp) {
            var order = comp.constructor._executionOrder;
            (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
        }
    }, {
        key: "cancelInactive",
        value: function cancelInactive(flagToClear) {
            stableRemoveInactive(this._zero, flagToClear), stableRemoveInactive(this._neg, flagToClear), 
            stableRemoveInactive(this._pos, flagToClear);
        }
    }, {
        key: "invoke",
        value: function invoke() {
            var compsNeg = this._neg;
            compsNeg.array.length > 0 && (compsNeg.array.sort(compareOrder), this._invoke(compsNeg), 
            compsNeg.array.length = 0), this._invoke(this._zero), this._zero.array.length = 0;
            var compsPos = this._pos;
            compsPos.array.length > 0 && (compsPos.array.sort(compareOrder), this._invoke(compsPos), 
            compsPos.array.length = 0);
        }
    } ]), OneOffInvoker;
}(), ReusableInvoker = function(_LifeCycleInvoker2) {
    function ReusableInvoker() {
        return _classCallCheck(this, ReusableInvoker), _possibleConstructorReturn(this, _getPrototypeOf(ReusableInvoker).apply(this, arguments));
    }
    return _inherits(ReusableInvoker, LifeCycleInvoker), _createClass(ReusableInvoker, [ {
        key: "add",
        value: function add(comp) {
            var order = comp.constructor._executionOrder;
            if (0 === order) this._zero.array.push(comp); else {
                var _array = order < 0 ? this._neg.array : this._pos.array, i = sortedIndex(_array, comp);
                i < 0 && _array.splice(~i, 0, comp);
            }
        }
    }, {
        key: "remove",
        value: function remove(comp) {
            var order = comp.constructor._executionOrder;
            if (0 === order) this._zero.fastRemove(comp); else {
                var iterator = order < 0 ? this._neg : this._pos, i = sortedIndex(iterator.array, comp);
                i >= 0 && iterator.removeAt(i);
            }
        }
    }, {
        key: "invoke",
        value: function invoke(dt) {
            this._neg.array.length > 0 && this._invoke(this._neg, dt), this._invoke(this._zero, dt), 
            this._pos.array.length > 0 && this._invoke(this._pos, dt);
        }
    } ]), ReusableInvoker;
}();

function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
    return function(iterator, dt) {
        try {
            fastPath(iterator, dt);
        } catch (e) {
            cc._throw(e);
            var array = iterator.array;
            for (ensureFlag && (array[iterator.i]._objFlags |= ensureFlag), ++iterator.i; iterator.i < array.length; ++iterator.i) try {
                singleInvoke(array[iterator.i], dt);
            } catch (e) {
                cc._throw(e), ensureFlag && (array[iterator.i]._objFlags |= ensureFlag);
            }
        }
    };
}

var invokeStart = createInvokeImpl((function(c) {
    c.start(), c._objFlags |= IsStartCalled$1;
}), (function(iterator) {
    var array = iterator.array;
    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var comp = array[iterator.i];
        comp.start(), comp._objFlags |= IsStartCalled$1;
    }
}), IsStartCalled$1), invokeUpdate = createInvokeImpl((function(c, dt) {
    c.update(dt);
}), (function(iterator, dt) {
    var array = iterator.array;
    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) array[iterator.i].update(dt);
})), invokeLateUpdate = createInvokeImpl((function(c, dt) {
    c.lateUpdate(dt);
}), (function(iterator, dt) {
    var array = iterator.array;
    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) array[iterator.i].lateUpdate(dt);
})), invokeOnEnable = function(iterator) {
    var compScheduler = cc.director._compScheduler, array = iterator.array;
    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var comp = array[iterator.i];
        if (comp._enabled) comp.onEnable(), !comp.node._activeInHierarchy || compScheduler._onEnabled(comp);
    }
}, ComponentScheduler = function() {
    function ComponentScheduler() {
        _classCallCheck(this, ComponentScheduler), this._deferredComps = [], this.unscheduleAll();
    }
    return _createClass(ComponentScheduler, [ {
        key: "unscheduleAll",
        value: function unscheduleAll() {
            this.startInvoker = new OneOffInvoker(invokeStart), this.updateInvoker = new ReusableInvoker(invokeUpdate), 
            this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate), this._updating = !1;
        }
    }, {
        key: "_onEnabled",
        value: function _onEnabled(comp) {
            cc.director.getScheduler().resumeTarget(comp), comp._objFlags |= IsOnEnableCalled$2, 
            this._updating ? this._deferredComps.push(comp) : this._scheduleImmediate(comp);
        }
    }, {
        key: "_onDisabled",
        value: function _onDisabled(comp) {
            cc.director.getScheduler().pauseTarget(comp), comp._objFlags &= ~IsOnEnableCalled$2;
            var index = this._deferredComps.indexOf(comp);
            index >= 0 ? fastRemoveAt$2(this._deferredComps, index) : (!comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.remove(comp), 
            comp.update && this.updateInvoker.remove(comp), comp.lateUpdate && this.lateUpdateInvoker.remove(comp));
        }
    }, {
        key: "enableComp",
        value: function enableComp(comp, invoker) {
            if (!(comp._objFlags & IsOnEnableCalled$2)) {
                if (comp.onEnable) {
                    if (invoker) return void invoker.add(comp);
                    if (comp.onEnable(), !comp.node._activeInHierarchy) return;
                }
                this._onEnabled(comp);
            }
        }
    }, {
        key: "disableComp",
        value: function disableComp(comp) {
            comp._objFlags & IsOnEnableCalled$2 && (comp.onDisable && comp.onDisable(), this._onDisabled(comp));
        }
    }, {
        key: "startPhase",
        value: function startPhase() {
            this._updating = !0, this.startInvoker.invoke(), this._startForNewComps();
        }
    }, {
        key: "updatePhase",
        value: function updatePhase(dt) {
            this.updateInvoker.invoke(dt);
        }
    }, {
        key: "lateUpdatePhase",
        value: function lateUpdatePhase(dt) {
            this.lateUpdateInvoker.invoke(dt), this._updating = !1, this._startForNewComps();
        }
    }, {
        key: "_startForNewComps",
        value: function _startForNewComps() {
            this._deferredComps.length > 0 && (this._deferredSchedule(), this.startInvoker.invoke());
        }
    }, {
        key: "_scheduleImmediate",
        value: function _scheduleImmediate(comp) {
            "function" != typeof comp.start || comp._objFlags & IsStartCalled$1 || this.startInvoker.add(comp), 
            "function" == typeof comp.update && this.updateInvoker.add(comp), "function" == typeof comp.lateUpdate && this.lateUpdateInvoker.add(comp);
        }
    }, {
        key: "_deferredSchedule",
        value: function _deferredSchedule() {
            for (var comps = this._deferredComps, i = 0, len = comps.length; i < len; i++) this._scheduleImmediate(comps[i]);
            comps.length = 0;
        }
    } ]), ComponentScheduler;
}(), IsPreloadStarted$1 = CCObject.Flags.IsPreloadStarted, IsOnLoadStarted$1 = CCObject.Flags.IsOnLoadStarted, IsOnLoadCalled$2 = CCObject.Flags.IsOnLoadCalled, Deactivating$2 = CCObject.Flags.Deactivating, UnsortedInvoker = function(_LifeCycleInvoker) {
    function UnsortedInvoker() {
        return _classCallCheck(this, UnsortedInvoker), _possibleConstructorReturn(this, _getPrototypeOf(UnsortedInvoker).apply(this, arguments));
    }
    return _inherits(UnsortedInvoker, LifeCycleInvoker), _createClass(UnsortedInvoker, [ {
        key: "add",
        value: function add(comp) {
            this._zero.array.push(comp);
        }
    }, {
        key: "remove",
        value: function remove(comp) {
            this._zero.fastRemove(comp);
        }
    }, {
        key: "cancelInactive",
        value: function cancelInactive(flagToClear) {
            LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
        }
    }, {
        key: "invoke",
        value: function invoke() {
            this._invoke(this._zero), this._zero.array.length = 0;
        }
    } ]), UnsortedInvoker;
}(), invokePreload = createInvokeImpl((function(c) {
    c.__preload();
}), (function(iterator) {
    var array = iterator.array;
    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) array[iterator.i].__preload();
})), invokeOnLoad = createInvokeImpl((function(c) {
    c.onLoad(), c._objFlags |= IsOnLoadCalled$2;
}), (function(iterator) {
    var array = iterator.array;
    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var comp = array[iterator.i];
        comp.onLoad(), comp._objFlags |= IsOnLoadCalled$2;
    }
}), IsOnLoadCalled$2), activateTasksPool = new Pool(4);

function _componentCorrupted(node, comp, index) {
    comp ? node._removeComponent(comp) : array.removeAt(node._components, index);
}

activateTasksPool.get = function getActivateTask() {
    var task = this._get() || {
        preload: new UnsortedInvoker(invokePreload),
        onLoad: new OneOffInvoker(invokeOnLoad),
        onEnable: new OneOffInvoker(invokeOnEnable)
    };
    task.preload._zero.i = -1;
    var invoker = task.onLoad;
    return invoker._zero.i = -1, invoker._neg.i = -1, invoker._pos.i = -1, (invoker = task.onEnable)._zero.i = -1, 
    invoker._neg.i = -1, invoker._pos.i = -1, task;
};

var _dec$A, _dec2$h, _dec3$8, _dec4$6, _dec5$5, _class$A, _class2$u, _descriptor$s, _descriptor2$k, _descriptor3$f, _descriptor4$9, _descriptor5$7, _descriptor6$3, _descriptor7$3, _dec6$5, _dec7$4, _class4$3, _class5$3, _descriptor8$3, _descriptor9$3, _descriptor10$3, _descriptor11$1, _dec8$2, _dec9$2, _dec10$2, _dec11$2, _dec12$1, _dec13$1, _class7$1, _class8$1, _descriptor12$1, _descriptor13$1, _descriptor14$1, _descriptor15, _descriptor16, _descriptor17, _dec14$1, _dec15$1, _dec16$1, _dec17, _dec18, _dec19, _dec20, _dec21, _class10$1, _class11$1, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _dec22, _dec23, _dec24, _class13, _class14, _descriptor26, _descriptor27, _descriptor28, RenderFlowType, NodeActivator = function() {
    function NodeActivator() {
        _classCallCheck(this, NodeActivator), this.resetComp = void 0, this.reset();
    }
    return _createClass(NodeActivator, [ {
        key: "reset",
        value: function reset() {
            this._activatingStack = [];
        }
    }, {
        key: "activateNode",
        value: function activateNode(node, active) {
            if (active) {
                var task = activateTasksPool.get();
                this._activatingStack.push(task), this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable), 
                task.preload.invoke(), task.onLoad.invoke(), task.onEnable.invoke(), this._activatingStack.pop(), 
                activateTasksPool.put(task);
            } else {
                this._deactivateNodeRecursively(node);
                for (var _step, _iterator = _createForOfIteratorHelperLoose(this._activatingStack); !(_step = _iterator()).done; ) {
                    var lastTask = _step.value;
                    lastTask.preload.cancelInactive(IsPreloadStarted$1), lastTask.onLoad.cancelInactive(IsOnLoadStarted$1), 
                    lastTask.onEnable.cancelInactive();
                }
            }
            node.emit("active-in-hierarchy-changed", node);
        }
    }, {
        key: "activateComp",
        value: function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
            if (comp._objFlags & IsPreloadStarted$1 || (comp._objFlags |= IsPreloadStarted$1, 
            comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload())), 
            comp._objFlags & IsOnLoadStarted$1 || (comp._objFlags |= IsOnLoadStarted$1, comp.onLoad ? onLoadInvoker ? onLoadInvoker.add(comp) : (comp.onLoad(), 
            comp._objFlags |= IsOnLoadCalled$2) : comp._objFlags |= IsOnLoadCalled$2), comp._enabled) {
                if (!comp.node._activeInHierarchy) return;
                cc.director._compScheduler.enableComp(comp, onEnableInvoker);
            }
        }
    }, {
        key: "destroyComp",
        value: function destroyComp(comp) {
            cc.director._compScheduler.disableComp(comp), comp.onDestroy && comp._objFlags & IsOnLoadCalled$2 && comp.onDestroy();
        }
    }, {
        key: "_activateNodeRecursively",
        value: function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
            if (node._objFlags & Deactivating$2) cc.errorID(3816, node.name); else {
                node._activeInHierarchy = !0;
                for (var originCount = node._components.length, i = 0; i < originCount; ++i) {
                    var component = node._components[i];
                    component instanceof cc.Component ? this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker) : (_componentCorrupted(node, component, i), 
                    --i, --originCount);
                }
                node._childArrivalOrder = node._children.length;
                for (var _i = 0, len = node._children.length; _i < len; ++_i) {
                    var child = node._children[_i];
                    child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                }
                node._onPostActivated(!0);
            }
        }
    }, {
        key: "_deactivateNodeRecursively",
        value: function _deactivateNodeRecursively(node) {
            node._objFlags |= Deactivating$2, node._activeInHierarchy = !1;
            for (var originCount = node._components.length, c = 0; c < originCount; ++c) {
                var component = node._components[c];
                if (component._enabled && (cc.director._compScheduler.disableComp(component), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
            }
            for (var i = 0, len = node._children.length; i < len; ++i) {
                var child = node._children[i];
                if (child._activeInHierarchy && (this._deactivateNodeRecursively(child), node._activeInHierarchy)) return void (node._objFlags &= ~Deactivating$2);
            }
            node._onPostActivated(!1), node._objFlags &= ~Deactivating$2;
        }
    } ]), NodeActivator;
}();

exports.replaceProperty(BaseNode.prototype, "BaseNode", [ {
    name: "childrenCount",
    newName: "children.length",
    customGetter: function customGetter() {
        return this.children.length;
    }
} ]), exports.removeProperty(Node$1.prototype, "Node.prototype", [ {
    name: "addLayer"
}, {
    name: "removeLayer"
} ]), exports.removeProperty(Layers, "Layers", [ {
    name: "All"
}, {
    name: "RaycastMask"
}, {
    name: "check"
} ]), exports.replaceProperty(Layers, "Layers", [ {
    name: "Default",
    newName: "DEFAULT",
    target: Layers.Enum,
    targetName: "Layers.Enum"
}, {
    name: "Always",
    newName: "ALWAYS",
    target: Layers.Enum,
    targetName: "Layers.Enum"
}, {
    name: "IgnoreRaycast",
    newName: "IGNORE_RAYCAST",
    target: Layers.Enum,
    targetName: "Layers.Enum"
}, {
    name: "Gizmos",
    newName: "GIZMOS",
    target: Layers.Enum,
    targetName: "Layers.Enum"
}, {
    name: "Editor",
    newName: "EDITOR",
    target: Layers.Enum,
    targetName: "Layers.Enum"
}, {
    name: "UI",
    newName: "UI_3D",
    target: Layers.Enum,
    targetName: "Layers.Enum"
}, {
    name: "UI2D",
    newName: "UI_2D",
    target: Layers.Enum,
    targetName: "Layers.Enum"
}, {
    name: "SceneGizmo",
    newName: "SCENE_GIZMO",
    target: Layers.Enum,
    targetName: "Layers.Enum"
}, {
    name: "makeInclusiveMask",
    newName: "makeMaskInclude",
    target: Layers,
    targetName: "Layers"
}, {
    name: "makeExclusiveMask",
    newName: "makeMaskExclude",
    target: Layers,
    targetName: "Layers"
} ]), exports.removeProperty(Layers.Enum, "Layers.Enum", [ {
    name: "ALWAYS"
} ]), exports.removeProperty(Layers.BitMask, "Layers.BitMask", [ {
    name: "ALWAYS"
} ]), ccenum(exports.GFXTextureType), ccenum(exports.GFXTextureViewType), ccenum(exports.GFXTextureUsageBit), 
ccenum(exports.GFXStoreOp), ccenum(exports.GFXLoadOp), ccenum(exports.GFXTextureLayout), 
function(RenderFlowType) {
    RenderFlowType[RenderFlowType.SCENE = 0] = "SCENE", RenderFlowType[RenderFlowType.POSTPROCESS = 1] = "POSTPROCESS", 
    RenderFlowType[RenderFlowType.UI = 2] = "UI";
}(RenderFlowType || (RenderFlowType = {})), ccenum(RenderFlowType);

var RenderTextureDesc = (_dec$A = ccclass("RenderTextureDesc"), _dec2$h = property({
    type: exports.GFXTextureType
}), _dec3$8 = property({
    type: exports.GFXTextureViewType
}), _dec4$6 = property({
    type: exports.GFXTextureUsageBit
}), _dec5$5 = property({
    type: exports.GFXFormat
}), _dec$A((_descriptor$s = _applyDecoratedDescriptor((_class2$u = function RenderTextureDesc() {
    _classCallCheck(this, RenderTextureDesc), _initializerDefineProperty(this, "name", _descriptor$s, this), 
    _initializerDefineProperty(this, "type", _descriptor2$k, this), _initializerDefineProperty(this, "viewType", _descriptor3$f, this), 
    _initializerDefineProperty(this, "usage", _descriptor4$9, this), _initializerDefineProperty(this, "format", _descriptor5$7, this), 
    _initializerDefineProperty(this, "width", _descriptor6$3, this), _initializerDefineProperty(this, "height", _descriptor7$3, this);
}).prototype, "name", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor2$k = _applyDecoratedDescriptor(_class2$u.prototype, "type", [ _dec2$h ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXTextureType.TEX2D;
    }
}), _descriptor3$f = _applyDecoratedDescriptor(_class2$u.prototype, "viewType", [ _dec3$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXTextureViewType.TV2D;
    }
}), _descriptor4$9 = _applyDecoratedDescriptor(_class2$u.prototype, "usage", [ _dec4$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXTextureUsageBit.COLOR_ATTACHMENT;
    }
}), _descriptor5$7 = _applyDecoratedDescriptor(_class2$u.prototype, "format", [ _dec5$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXFormat.UNKNOWN;
    }
}), _descriptor6$3 = _applyDecoratedDescriptor(_class2$u.prototype, "width", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _descriptor7$3 = _applyDecoratedDescriptor(_class2$u.prototype, "height", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _class$A = _class2$u)) || _class$A), FrameBufferDesc = (_dec6$5 = ccclass("FrameBufferDesc"), 
_dec7$4 = property({
    type: [ CCString ]
}), _dec6$5((_descriptor8$3 = _applyDecoratedDescriptor((_class5$3 = function FrameBufferDesc() {
    _classCallCheck(this, FrameBufferDesc), _initializerDefineProperty(this, "name", _descriptor8$3, this), 
    _initializerDefineProperty(this, "renderPass", _descriptor9$3, this), _initializerDefineProperty(this, "colorViews", _descriptor10$3, this), 
    _initializerDefineProperty(this, "depthStencilView", _descriptor11$1, this);
}).prototype, "name", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor9$3 = _applyDecoratedDescriptor(_class5$3.prototype, "renderPass", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor10$3 = _applyDecoratedDescriptor(_class5$3.prototype, "colorViews", [ _dec7$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor11$1 = _applyDecoratedDescriptor(_class5$3.prototype, "depthStencilView", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class4$3 = _class5$3)) || _class4$3), ColorDesc = (_dec8$2 = ccclass("ColorDesc"), 
_dec9$2 = property({
    type: exports.GFXFormat
}), _dec10$2 = property({
    type: exports.GFXLoadOp
}), _dec11$2 = property({
    type: exports.GFXStoreOp
}), _dec12$1 = property({
    type: exports.GFXTextureLayout
}), _dec13$1 = property({
    type: exports.GFXTextureLayout
}), _dec8$2((_descriptor12$1 = _applyDecoratedDescriptor((_class8$1 = function ColorDesc() {
    _classCallCheck(this, ColorDesc), _initializerDefineProperty(this, "format", _descriptor12$1, this), 
    _initializerDefineProperty(this, "loadOp", _descriptor13$1, this), _initializerDefineProperty(this, "storeOp", _descriptor14$1, this), 
    _initializerDefineProperty(this, "sampleCount", _descriptor15, this), _initializerDefineProperty(this, "beginLayout", _descriptor16, this), 
    _initializerDefineProperty(this, "endLayout", _descriptor17, this);
}).prototype, "format", [ _dec9$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXFormat.UNKNOWN;
    }
}), _descriptor13$1 = _applyDecoratedDescriptor(_class8$1.prototype, "loadOp", [ _dec10$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXLoadOp.CLEAR;
    }
}), _descriptor14$1 = _applyDecoratedDescriptor(_class8$1.prototype, "storeOp", [ _dec11$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXStoreOp.STORE;
    }
}), _descriptor15 = _applyDecoratedDescriptor(_class8$1.prototype, "sampleCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor16 = _applyDecoratedDescriptor(_class8$1.prototype, "beginLayout", [ _dec12$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
    }
}), _descriptor17 = _applyDecoratedDescriptor(_class8$1.prototype, "endLayout", [ _dec13$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
    }
}), _class7$1 = _class8$1)) || _class7$1), DepthStencilDesc = (_dec14$1 = ccclass("DepthStencilDesc"), 
_dec15$1 = property({
    type: exports.GFXFormat
}), _dec16$1 = property({
    type: exports.GFXLoadOp
}), _dec17 = property({
    type: exports.GFXStoreOp
}), _dec18 = property({
    type: exports.GFXLoadOp
}), _dec19 = property({
    type: exports.GFXStoreOp
}), _dec20 = property({
    type: exports.GFXTextureLayout
}), _dec21 = property({
    type: exports.GFXTextureLayout
}), _dec14$1((_descriptor18 = _applyDecoratedDescriptor((_class11$1 = function DepthStencilDesc() {
    _classCallCheck(this, DepthStencilDesc), _initializerDefineProperty(this, "format", _descriptor18, this), 
    _initializerDefineProperty(this, "depthLoadOp", _descriptor19, this), _initializerDefineProperty(this, "depthStoreOp", _descriptor20, this), 
    _initializerDefineProperty(this, "stencilLoadOp", _descriptor21, this), _initializerDefineProperty(this, "stencilStoreOp", _descriptor22, this), 
    _initializerDefineProperty(this, "sampleCount", _descriptor23, this), _initializerDefineProperty(this, "beginLayout", _descriptor24, this), 
    _initializerDefineProperty(this, "endLayout", _descriptor25, this);
}).prototype, "format", [ _dec15$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXFormat.UNKNOWN;
    }
}), _descriptor19 = _applyDecoratedDescriptor(_class11$1.prototype, "depthLoadOp", [ _dec16$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXLoadOp.CLEAR;
    }
}), _descriptor20 = _applyDecoratedDescriptor(_class11$1.prototype, "depthStoreOp", [ _dec17 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXStoreOp.STORE;
    }
}), _descriptor21 = _applyDecoratedDescriptor(_class11$1.prototype, "stencilLoadOp", [ _dec18 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXLoadOp.CLEAR;
    }
}), _descriptor22 = _applyDecoratedDescriptor(_class11$1.prototype, "stencilStoreOp", [ _dec19 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXStoreOp.STORE;
    }
}), _descriptor23 = _applyDecoratedDescriptor(_class11$1.prototype, "sampleCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor24 = _applyDecoratedDescriptor(_class11$1.prototype, "beginLayout", [ _dec20 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
    }
}), _descriptor25 = _applyDecoratedDescriptor(_class11$1.prototype, "endLayout", [ _dec21 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
    }
}), _class10$1 = _class11$1)) || _class10$1), RenderPassDesc = (_dec22 = ccclass("RenderPassDesc"), 
_dec23 = property({
    type: [ ColorDesc ]
}), _dec24 = property({
    type: DepthStencilDesc
}), _dec22((_descriptor26 = _applyDecoratedDescriptor((_class14 = function RenderPassDesc() {
    _classCallCheck(this, RenderPassDesc), _initializerDefineProperty(this, "index", _descriptor26, this), 
    _initializerDefineProperty(this, "colorAttachments", _descriptor27, this), _initializerDefineProperty(this, "depthStencilAttachment", _descriptor28, this);
}).prototype, "index", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _descriptor27 = _applyDecoratedDescriptor(_class14.prototype, "colorAttachments", [ _dec23 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor28 = _applyDecoratedDescriptor(_class14.prototype, "depthStencilAttachment", [ _dec24 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new DepthStencilDesc;
    }
}), _class13 = _class14)) || _class13);

function opaqueCompareFn(a, b) {
    return a.hash - b.hash || a.depth - b.depth || a.shaderId - b.shaderId;
}

function transparentCompareFn(a, b) {
    return a.hash - b.hash || b.depth - a.depth || a.shaderId - b.shaderId;
}

var _dec$B, _dec2$i, _dec3$9, _class$B, _class2$v, _descriptor$t, _descriptor2$l, _descriptor3$g, _dec4$7, _dec5$6, _dec6$6, _dec7$5, _dec8$3, _class4$4, _class5$4, _descriptor4$a, _descriptor5$8, _descriptor6$4, _descriptor7$4, RenderQueueSortMode, RenderQueue = function() {
    function RenderQueue(desc) {
        _classCallCheck(this, RenderQueue), this.queue = void 0, this.cmdBuffs = void 0, 
        this.cmdBuffCount = 0, this._passDesc = void 0, this._passPool = void 0, this._passDesc = desc, 
        this._passPool = new RecyclePool((function() {
            return {
                hash: 0,
                depth: 0,
                shaderId: 0,
                subModel: null,
                cmdBuff: null
            };
        }), 64), this.cmdBuffs = new CachedArray(64), this.queue = new CachedArray(64, this._passDesc.sortFunc);
    }
    return _createClass(RenderQueue, [ {
        key: "clear",
        value: function clear() {
            this.queue.clear(), this._passPool.reset(), this.cmdBuffCount = 0;
        }
    }, {
        key: "insertRenderPass",
        value: function insertRenderPass(renderObj, modelIdx, passIdx) {
            var subModel = renderObj.model.getSubModel(modelIdx), pass = subModel.passes[passIdx], pso = subModel.psos[passIdx];
            if (pso.blendState.targets[0].blend !== this._passDesc.isTransparent || !(pass.phase & this._passDesc.phases)) return !1;
            var hash = 0 | pass.priority << 16 | subModel.priority << 8 | passIdx, rp = this._passPool.add();
            return rp.hash = hash, rp.depth = renderObj.depth, rp.shaderId = pso.shader.id, 
            rp.subModel = subModel, rp.cmdBuff = subModel.commandBuffers[passIdx], this.queue.push(rp), 
            !0;
        }
    }, {
        key: "sort",
        value: function sort() {
            this.queue.sort(), this.cmdBuffCount = this.queue.length;
            for (var i = 0; i < this.queue.length; ++i) this.cmdBuffs.array[i] = this.queue.array[i].cmdBuff;
        }
    } ]), RenderQueue;
}(), _colors = [ {
    r: 0,
    g: 0,
    b: 0,
    a: 1
} ], bufs = [];

!function(RenderQueueSortMode) {
    RenderQueueSortMode[RenderQueueSortMode.FRONT_TO_BACK = 0] = "FRONT_TO_BACK", RenderQueueSortMode[RenderQueueSortMode.BACK_TO_FRONT = 1] = "BACK_TO_FRONT";
}(RenderQueueSortMode || (RenderQueueSortMode = {})), ccenum(RenderQueueSortMode);

var _dec$C, _dec2$j, _dec3$a, _dec4$8, _dec5$7, _dec6$7, _class$C, _class2$w, _descriptor$u, _descriptor2$m, _descriptor3$h, _descriptor4$b, _descriptor5$9, RenderQueueDesc = (_dec$B = ccclass("RenderQueueDesc"), 
_dec2$i = property({
    type: RenderQueueSortMode
}), _dec3$9 = property({
    type: [ CCString ]
}), _dec$B((_descriptor$t = _applyDecoratedDescriptor((_class2$v = function RenderQueueDesc() {
    _classCallCheck(this, RenderQueueDesc), _initializerDefineProperty(this, "isTransparent", _descriptor$t, this), 
    _initializerDefineProperty(this, "sortMode", _descriptor2$l, this), _initializerDefineProperty(this, "stages", _descriptor3$g, this);
}).prototype, "isTransparent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$l = _applyDecoratedDescriptor(_class2$v.prototype, "sortMode", [ _dec2$i ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return RenderQueueSortMode.FRONT_TO_BACK;
    }
}), _descriptor3$g = _applyDecoratedDescriptor(_class2$v.prototype, "stages", [ _dec3$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$B = _class2$v)) || _class$B), RenderStage = (_dec4$7 = ccclass("RenderStage"), 
_dec5$6 = property({
    displayOrder: 0,
    visible: !0
}), _dec6$6 = property({
    displayOrder: 1,
    visible: !0
}), _dec7$5 = property({
    displayOrder: 2,
    visible: !0
}), _dec8$3 = property({
    type: [ RenderQueueDesc ],
    displayOrder: 3,
    visible: !0
}), _dec4$7((_descriptor4$a = _applyDecoratedDescriptor((_class5$4 = function() {
    function RenderStage() {
        _classCallCheck(this, RenderStage), _initializerDefineProperty(this, "_name", _descriptor4$a, this), 
        _initializerDefineProperty(this, "_priority", _descriptor5$8, this), _initializerDefineProperty(this, "frameBuffer", _descriptor6$4, this), 
        _initializerDefineProperty(this, "renderQueues", _descriptor7$4, this), this._renderQueues = [], 
        this._flow = null, this._pipeline = null, this._device = null, this._framebuffer = null, 
        this._cmdBuff = null, this._clearColors = null, this._clearDepth = 1, this._clearStencil = 0, 
        this._renderArea = null, this._pass = null, this._pso = null;
    }
    return _createClass(RenderStage, [ {
        key: "initialize",
        value: function initialize(info) {
            return void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
            info.framebuffer && (this.frameBuffer = info.framebuffer), info.renderQueues && (this.renderQueues = info.renderQueues), 
            !0;
        }
    }, {
        key: "activate",
        value: function activate(flow) {
            if (this._flow = flow, this._pipeline = flow.pipeline, this._device = flow.device, 
            !this._flow.pipeline.root.device) throw new Error("");
            this._device = this._flow.pipeline.root.device, this._clearColors = [ {
                r: .3,
                g: .6,
                b: .9,
                a: 1
            } ], this._renderArea = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            for (var i = 0; i < this.renderQueues.length; i++) {
                for (var phase = 0, j = 0; j < this.renderQueues[i].stages.length; j++) phase |= getPhaseID(this.renderQueues[i].stages[j]);
                var sortFunc = opaqueCompareFn;
                switch (this.renderQueues[i].sortMode) {
                  case RenderQueueSortMode.BACK_TO_FRONT:
                    sortFunc = transparentCompareFn;
                    break;

                  case RenderQueueSortMode.FRONT_TO_BACK:
                    sortFunc = opaqueCompareFn;
                }
                this._renderQueues[i] = new RenderQueue({
                    isTransparent: this.renderQueues[i].isTransparent,
                    phases: phase,
                    sortFunc: sortFunc
                });
            }
            "window" === this.frameBuffer ? this._framebuffer = this._flow.pipeline.root.mainWindow.framebuffer : this._framebuffer = this._flow.pipeline.getFrameBuffer(this.frameBuffer);
        }
    }, {
        key: "setClearColor",
        value: function setClearColor(color) {
            this._clearColors.length > 0 ? this._clearColors[0] = color : this._clearColors.push(color);
        }
    }, {
        key: "setClearColors",
        value: function setClearColors(colors) {
            this._clearColors = colors;
        }
    }, {
        key: "setClearDepth",
        value: function setClearDepth(depth) {
            this._clearDepth = depth;
        }
    }, {
        key: "setClearStencil",
        value: function setClearStencil(stencil) {
            this._clearStencil = stencil;
        }
    }, {
        key: "setRenderArea",
        value: function setRenderArea(width, height) {
            this._renderArea.width = width, this._renderArea.height = height;
        }
    }, {
        key: "sortRenderQueue",
        value: function sortRenderQueue() {
            this._renderQueues.forEach(this.renderQueueClearFunc);
            for (var renderObjects = this._pipeline.renderObjects, i = 0; i < renderObjects.length; ++i) for (var ro = renderObjects[i], l = 0; l < ro.model.subModelNum; l++) for (var j = 0; j < ro.model.getSubModel(l).passes.length; j++) for (var k = 0; k < this._renderQueues.length; k++) this._renderQueues[k].insertRenderPass(ro, l, j);
            this._renderQueues.forEach(this.renderQueueSortFunc);
        }
    }, {
        key: "executeCommandBuffer",
        value: function executeCommandBuffer(view) {
            var camera = view.camera, cmdBuff = this._cmdBuff, vp = camera.viewport;
            this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
            this._renderArea.width = vp.width * camera.width * this.pipeline.shadingScale, this._renderArea.height = vp.height * camera.height * this.pipeline.shadingScale, 
            camera.clearFlag & exports.GFXClearFlag.COLOR && (_colors[0].a = camera.clearColor.a, 
            _colors[0].r = camera.clearColor.r, _colors[0].g = camera.clearColor.g, _colors[0].b = camera.clearColor.b), 
            this._framebuffer || (this._framebuffer = view.window.framebuffer), cmdBuff.begin(), 
            cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, camera.clearFlag, _colors, camera.clearDepth, camera.clearStencil);
            for (var i = 0; i < this._renderQueues.length; i++) cmdBuff.execute(this._renderQueues[i].cmdBuffs.array, this._renderQueues[i].cmdBuffCount);
            cmdBuff.endRenderPass(), cmdBuff.end(), bufs[0] = cmdBuff, this._device.queue.submit(bufs);
        }
    }, {
        key: "createCmdBuffer",
        value: function createCmdBuffer() {
            this._cmdBuff = this._device.createCommandBuffer({
                allocator: this._device.commandAllocator,
                type: exports.GFXCommandBufferType.PRIMARY
            });
        }
    }, {
        key: "renderQueueClearFunc",
        value: function renderQueueClearFunc(rq) {
            rq.clear();
        }
    }, {
        key: "renderQueueSortFunc",
        value: function renderQueueSortFunc(rq) {
            rq.sort();
        }
    }, {
        key: "flow",
        get: function get() {
            return this._flow;
        }
    }, {
        key: "pipeline",
        get: function get() {
            return this._pipeline;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        }
    }, {
        key: "framebuffer",
        get: function get() {
            return this._framebuffer;
        }
    } ]), RenderStage;
}()).prototype, "_name", [ _dec5$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor5$8 = _applyDecoratedDescriptor(_class5$4.prototype, "_priority", [ _dec6$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$4 = _applyDecoratedDescriptor(_class5$4.prototype, "frameBuffer", [ _dec7$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor7$4 = _applyDecoratedDescriptor(_class5$4.prototype, "renderQueues", [ _dec8$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class4$4 = _class5$4)) || _class4$4);

cc.RenderStage = RenderStage;

var _dec$D, _dec2$k, _dec3$b, _dec4$9, _dec5$8, _class$D, _class2$x, _descriptor$v, _descriptor2$n, _descriptor3$i, _descriptor4$c, RenderFlow = (_dec$C = ccclass("RenderFlow"), 
_dec2$j = property({
    displayOrder: 0,
    visible: !0
}), _dec3$a = property({
    displayOrder: 1,
    visible: !0
}), _dec4$8 = property({
    type: cc.Material,
    displayOrder: 2,
    visible: !0
}), _dec5$7 = property({
    type: RenderFlowType,
    displayOrder: 3,
    visible: !0
}), _dec6$7 = property({
    type: [ RenderStage ],
    displayOrder: 4,
    visible: !0
}), _dec$C((_descriptor$u = _applyDecoratedDescriptor((_class2$w = function() {
    function RenderFlow() {
        _classCallCheck(this, RenderFlow), this._device = null, this._pipeline = null, _initializerDefineProperty(this, "_name", _descriptor$u, this), 
        _initializerDefineProperty(this, "_priority", _descriptor2$m, this), _initializerDefineProperty(this, "_material", _descriptor3$h, this), 
        _initializerDefineProperty(this, "_type", _descriptor4$b, this), _initializerDefineProperty(this, "_stages", _descriptor5$9, this);
    }
    return _createClass(RenderFlow, [ {
        key: "initialize",
        value: function initialize(info) {
            void 0 !== info.name && (this._name = info.name), this._priority = info.priority, 
            info.material && (this._material = info.material), info.type && (this._type = info.type);
        }
    }, {
        key: "activate",
        value: function activate(pipeline) {
            this._device = pipeline.device, this._pipeline = pipeline, this._activateStages();
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            for (var i = 0; i < this._stages.length; i++) this._stages[i].resize(width, height);
        }
    }, {
        key: "render",
        value: function render(view) {
            for (var i = 0; i < this._stages.length; i++) this._stages[i].render(view);
        }
    }, {
        key: "destroyStages",
        value: function destroyStages() {
            for (var i = 0; i < this._stages.length; i++) this._stages[i].destroy();
            this._stages = [];
        }
    }, {
        key: "_activateStages",
        value: function _activateStages() {
            for (var i = 0; i < this._stages.length; i++) this._stages[i].activate(this);
            this._stages.sort((function(a, b) {
                return a.priority - b.priority;
            }));
        }
    }, {
        key: "device",
        get: function get() {
            return this._device;
        }
    }, {
        key: "pipeline",
        get: function get() {
            return this._pipeline;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        }
    }, {
        key: "stages",
        get: function get() {
            return this._stages;
        }
    }, {
        key: "material",
        get: function get() {
            return this._material;
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ]), RenderFlow;
}()).prototype, "_name", [ _dec2$j ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor2$m = _applyDecoratedDescriptor(_class2$w.prototype, "_priority", [ _dec3$a ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor3$h = _applyDecoratedDescriptor(_class2$w.prototype, "_material", [ _dec4$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor4$b = _applyDecoratedDescriptor(_class2$w.prototype, "_type", [ _dec5$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return RenderFlowType.SCENE;
    }
}), _descriptor5$9 = _applyDecoratedDescriptor(_class2$w.prototype, "_stages", [ _dec6$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$C = _class2$w)) || _class$C);

cc.RenderFlow = RenderFlow;

var _dec$E, _dec2$l, _class$E, _class2$y, _descriptor$w, v3_1$5 = new Vec3, RenderPipeline = (_dec$D = ccclass("RenderPipeline"), 
_dec2$k = property({
    type: [ RenderFlow ],
    visible: !0
}), _dec3$b = property({
    type: [ RenderTextureDesc ]
}), _dec4$9 = property({
    type: [ FrameBufferDesc ]
}), _dec5$8 = property({
    type: [ RenderPassDesc ]
}), _dec$D((_descriptor$v = _applyDecoratedDescriptor((_class2$x = function() {
    function RenderPipeline() {
        _classCallCheck(this, RenderPipeline), this._root = null, this._device = null, this._renderObjects = [], 
        _initializerDefineProperty(this, "_flows", _descriptor$v, this), this._activeFlows = [], 
        this._isHDRSupported = !1, this._isHDR = !1, this._lightMeterScale = 1e4, this._fboCount = 0, 
        this._colorFmt = exports.GFXFormat.UNKNOWN, this._depthStencilFmt = exports.GFXFormat.UNKNOWN, 
        this._shadingWidth = 0, this._shadingHeight = 0, this._shadingScale = 1, this._curIdx = "shading", 
        this._prevIdx = "shading1", this._usePostProcess = !1, this._useMSAA = !1, this._useSMAA = !1, 
        this._quadVB = null, this._quadIB = null, this._quadIA = null, this._uboGlobal = new UBOGlobal, 
        this._globalBindings = new Map, this._defaultTex = null, this._defaultTexView = null, 
        this._fpScale = 1 / 1024, this._fpScaleInv = 1024, this._macros = {}, this._useDynamicBatching = !1, 
        _initializerDefineProperty(this, "renderTextures", _descriptor2$n, this), _initializerDefineProperty(this, "framebuffers", _descriptor3$i, this), 
        _initializerDefineProperty(this, "renderPasses", _descriptor4$c, this), this._renderTextures = new Map, 
        this._textureViews = new Map, this._frameBuffers = new Map, this._renderPasses = new Map;
    }
    return _createClass(RenderPipeline, [ {
        key: "getTextureView",
        value: function getTextureView(name) {
            return this._textureViews.get(name);
        }
    }, {
        key: "getRenderTexture",
        value: function getRenderTexture(name) {
            return this._renderTextures.get(name);
        }
    }, {
        key: "getFrameBuffer",
        value: function getFrameBuffer(name) {
            return this._frameBuffers.get(name);
        }
    }, {
        key: "initialize",
        value: function initialize(info) {
            this._usePostProcess = void 0 !== info.enablePostProcess && info.enablePostProcess, 
            this._isHDR = void 0 !== info.enableHDR && info.enableHDR, this._useSMAA = void 0 !== info.enableSMAA && info.enableSMAA, 
            this._useMSAA = void 0 !== info.enableMSAA && info.enableMSAA, info.renderTextures && (this.renderTextures = info.renderTextures), 
            info.framebuffers && (this.framebuffers = info.framebuffers), info.renderPasses && (this.renderPasses = info.renderPasses);
        }
    }, {
        key: "activate",
        value: function activate(root) {
            if (this._root = root, this._device = root.device, !this._initRenderResource()) return console.error("RenderPipeline:" + this.name + " startup failed!"), 
            !1;
            for (var i = 0; i < this._flows.length; i++) {
                var flow = this._flows[i];
                flow.type === RenderFlowType.SCENE && (flow.activate(this), this.activateFlow(flow));
            }
            return !0;
        }
    }, {
        key: "render",
        value: function render(view) {
            for (var i = 0; i < view.flows.length; i++) view.flows[i].render(view);
        }
    }, {
        key: "rebuild",
        value: function rebuild() {
            this.updateMacros();
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            var w = Math.floor(width * this._shadingScale), h = Math.floor(height * this._shadingScale);
            (w > this._shadingWidth || h > this._shadingHeight) && this.resizeFBOs(w, h);
            for (var i = 0; i < this._flows.length; i++) this._flows[i].resize(width, height);
        }
    }, {
        key: "swapFBOs",
        value: function swapFBOs() {
            var temp = this._curIdx;
            this._curIdx = this._prevIdx, this._prevIdx = temp;
        }
    }, {
        key: "addRenderPass",
        value: function addRenderPass(stage, renderPass) {
            renderPass && this._renderPasses.set(stage, renderPass);
        }
    }, {
        key: "getRenderPass",
        value: function getRenderPass(stage) {
            var renderPass = this._renderPasses.get(stage);
            return renderPass || null;
        }
    }, {
        key: "removeRenderPass",
        value: function removeRenderPass(stage) {
            this._renderPasses.delete(stage);
        }
    }, {
        key: "clearRenderPasses",
        value: function clearRenderPasses() {
            this._renderPasses.clear();
        }
    }, {
        key: "destroyFlows",
        value: function destroyFlows() {
            for (var i = 0; i < this._flows.length; i++) this._flows[i].destroy();
            this._flows = [];
        }
    }, {
        key: "getFlow",
        value: function getFlow(name) {
            for (var i = 0; i < this._flows.length; i++) if (this._flows[i].name === name) return this._flows[i];
            return null;
        }
    }, {
        key: "updateMacros",
        value: function updateMacros() {
            programLib.destroyShaderByDefines(this._macros), this._macros.CC_USE_HDR = this._isHDR, 
            this._macros.CC_SUPPORT_FLOAT_TEXTURE = this.device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT);
            for (var i = 0; i < this._root.scenes.length; i++) this._root.scenes[i].onGlobalPipelineStateChanged();
        }
    }, {
        key: "updateUBOs",
        value: function updateUBOs(view) {
            var camera = view.camera, scene = camera.scene, device = this._root.device, mainLight = scene.mainLight, ambient = scene.ambient, fv = this._uboGlobal.view;
            fv[UBOGlobal.TIME_OFFSET] = this._root.cumulativeTime, fv[UBOGlobal.TIME_OFFSET + 1] = this._root.frameTime, 
            fv[UBOGlobal.TIME_OFFSET + 2] = cc.director.getTotalFrames(), fv[UBOGlobal.SCREEN_SIZE_OFFSET] = device.width, 
            fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1] = device.height, fv[UBOGlobal.SCREEN_SIZE_OFFSET + 2] = 1 / fv[UBOGlobal.SCREEN_SIZE_OFFSET], 
            fv[UBOGlobal.SCREEN_SIZE_OFFSET + 3] = 1 / fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1], 
            fv[UBOGlobal.SCREEN_SCALE_OFFSET] = camera.width / this._shadingWidth * this._shadingScale, 
            fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1] = camera.height / this._shadingHeight * this._shadingScale, 
            fv[UBOGlobal.SCREEN_SCALE_OFFSET + 2] = 1 / fv[UBOGlobal.SCREEN_SCALE_OFFSET], fv[UBOGlobal.SCREEN_SCALE_OFFSET + 3] = 1 / fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1], 
            fv[UBOGlobal.NATIVE_SIZE_OFFSET] = this._shadingWidth, fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1] = this._shadingHeight, 
            fv[UBOGlobal.NATIVE_SIZE_OFFSET + 2] = 1 / fv[UBOGlobal.NATIVE_SIZE_OFFSET], fv[UBOGlobal.NATIVE_SIZE_OFFSET + 3] = 1 / fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1], 
            Mat4.toArray(fv, camera.matView, UBOGlobal.MAT_VIEW_OFFSET), Mat4.toArray(fv, camera.node.worldMatrix, UBOGlobal.MAT_VIEW_INV_OFFSET), 
            Mat4.toArray(fv, camera.matProj, UBOGlobal.MAT_PROJ_OFFSET), Mat4.toArray(fv, camera.matProjInv, UBOGlobal.MAT_PROJ_INV_OFFSET), 
            Mat4.toArray(fv, camera.matViewProj, UBOGlobal.MAT_VIEW_PROJ_OFFSET), Mat4.toArray(fv, camera.matViewProjInv, UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET), 
            Vec3.toArray(fv, camera.position, UBOGlobal.CAMERA_POS_OFFSET);
            var exposure = camera.exposure;
            if (fv[UBOGlobal.EXPOSURE_OFFSET] = exposure, fv[UBOGlobal.EXPOSURE_OFFSET + 1] = 1 / exposure, 
            fv[UBOGlobal.EXPOSURE_OFFSET + 2] = this._isHDR ? 1 : 0, fv[UBOGlobal.EXPOSURE_OFFSET + 3] = this._fpScale / exposure, 
            mainLight) {
                if (Vec3.toArray(fv, mainLight.direction, UBOGlobal.MAIN_LIT_DIR_OFFSET), Vec3.toArray(fv, mainLight.color, UBOGlobal.MAIN_LIT_COLOR_OFFSET), 
                mainLight.useColorTemperature) {
                    var colorTempRGB = mainLight.colorTemperatureRGB;
                    fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET] *= colorTempRGB.x, fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 1] *= colorTempRGB.y, 
                    fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 2] *= colorTempRGB.z;
                }
                this._isHDR ? fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * this._fpScale : fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * exposure;
            } else Vec3.toArray(fv, Vec3.UNIT_Z, UBOGlobal.MAIN_LIT_DIR_OFFSET), Vec4.toArray(fv, Vec4.ZERO, UBOGlobal.MAIN_LIT_COLOR_OFFSET);
            var skyColor = ambient.skyColor;
            this._isHDR ? skyColor[3] = ambient.skyIllum * this._fpScale : skyColor[3] = ambient.skyIllum * exposure, 
            this._uboGlobal.view.set(skyColor, UBOGlobal.AMBIENT_SKY_OFFSET), this._uboGlobal.view.set(ambient.groundAlbedo, UBOGlobal.AMBIENT_GROUND_OFFSET), 
            this._globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this._uboGlobal.view);
        }
    }, {
        key: "sceneCulling",
        value: function sceneCulling(view) {
            var camera = view.camera, scene = camera.scene;
            this._renderObjects.length = 0;
            var mainLight = scene.mainLight, planarShadows = scene.planarShadows;
            mainLight && (mainLight.update(), planarShadows.enabled && mainLight.node.hasChangedFlags && planarShadows.updateDirLight(mainLight)), 
            scene.skybox.enabled && camera.clearFlag & SKYBOX_FLAG && this.addVisibleModel(scene.skybox, camera);
            for (var models = scene.models, stamp = cc.director.getTotalFrames(), i = 0; i < models.length; i++) {
                var model = models[i];
                if (model.enabled) if (view.visibility & Layers.BitMask.UI_2D) (model.node && view.visibility === model.node.layer || view.visibility === model.visFlags) && (model.updateTransform(stamp), 
                model.updateUBOs(stamp), this.addVisibleModel(model, camera)); else if (model.node && (view.visibility & model.node.layer) === model.node.layer || view.visibility & model.visFlags) {
                    if (model.updateTransform(stamp), model.worldBounds && !intersect.aabb_frustum(model.worldBounds, camera.frustum)) continue;
                    model.updateUBOs(stamp), this.addVisibleModel(model, camera);
                }
            }
            planarShadows.enabled && planarShadows.updateCommandBuffers(camera.frustum, stamp);
        }
    }, {
        key: "_initRenderResource",
        value: function _initRenderResource() {
            this._usePostProcess && ((this._device.hasFeature(exports.GFXFeature.FORMAT_R11G11B10F) || this._device.hasFeature(exports.GFXFeature.TEXTURE_HALF_FLOAT) || this._device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT)) && (this._isHDRSupported = !0), 
            this._fboCount = 1, this._useMSAA && (this._useMSAA = this.device.hasFeature(exports.GFXFeature.MSAA))), 
            this._isHDR && this._isHDRSupported && (this._device.hasFeature(exports.GFXFeature.COLOR_HALF_FLOAT) && this._device.hasFeature(exports.GFXFeature.TEXTURE_HALF_FLOAT_LINEAR) ? this._device.hasFeature(exports.GFXFeature.FORMAT_R11G11B10F) ? (this._colorFmt = exports.GFXFormat.R11G11B10F, 
            this._isHDR = !0) : this._device.hasFeature(exports.GFXFeature.TEXTURE_HALF_FLOAT) && (this._colorFmt = exports.GFXFormat.RGBA16F, 
            this._isHDR = !0) : this._device.hasFeature(exports.GFXFeature.COLOR_FLOAT) && this._device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT_LINEAR) && this._device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT) && (this._colorFmt = exports.GFXFormat.RGBA32F, 
            this._isHDR = !0)), this._isHDR || (this._colorFmt = exports.GFXFormat.RGBA8), 24 === this._device.depthBits ? 8 === this._device.stencilBits ? this._depthStencilFmt = exports.GFXFormat.D24S8 : this._depthStencilFmt = exports.GFXFormat.D24 : this._depthStencilFmt = exports.GFXFormat.D16, 
            this._shadingScale = 1, this._shadingWidth = Math.floor(this._device.width), this._shadingHeight = Math.floor(this._device.height), 
            console.info("USE_POST_PROCESS: " + this._usePostProcess), this._usePostProcess && (console.info("USE_MSAA: " + this._useMSAA), 
            console.info("USE_SMAA: " + this._useSMAA), console.info("USE_HDR: " + this._isHDR)), 
            console.info("SHADING_SIZE: " + this._shadingWidth + " x " + this._shadingHeight), 
            console.info("SHADING_SCALE: " + this._shadingScale.toFixed(4)), console.info("SHADING_COLOR_FORMAT: " + GFXFormatInfos[this._colorFmt].name), 
            console.info("SHADING_DEPTH_FORMAT: " + GFXFormatInfos[this._depthStencilFmt].name);
            for (var i = 0; i < this.renderTextures.length; i++) {
                var rtd = this.renderTextures[i];
                this._renderTextures.set(rtd.name, this._device.createTexture({
                    type: rtd.type,
                    usage: rtd.usage,
                    format: this._getTextureFormat(rtd.format, rtd.usage),
                    width: -1 === rtd.width ? this._shadingWidth : rtd.width,
                    height: -1 === rtd.height ? this._shadingHeight : rtd.height
                }));
                var rt = this._renderTextures.get(rtd.name);
                if (null == rt) return console.error("RenderTexture:" + rtd.name + " not found!"), 
                !1;
                this._textureViews.set(rtd.name, this._device.createTextureView({
                    texture: rt,
                    type: rtd.viewType,
                    format: this._getTextureFormat(rtd.format, rtd.usage)
                }));
            }
            for (var _i = 0; _i < this.renderPasses.length; _i++) {
                var rpd = this.renderPasses[_i];
                this._renderPasses.set(rpd.index, this._device.createRenderPass({
                    colorAttachments: rpd.colorAttachments,
                    depthStencilAttachment: rpd.depthStencilAttachment
                }));
            }
            for (var _i2 = 0; _i2 < this.framebuffers.length; _i2++) {
                var fbd = this.framebuffers[_i2], rp = this._renderPasses.get(fbd.renderPass);
                if (null == rp) return console.error("RenderPass:" + fbd.renderPass + " not found!"), 
                !1;
                for (var tvs = [], j = 0; j < fbd.colorViews.length; j++) {
                    var tv = this._textureViews.get(fbd.colorViews[j]);
                    if (null == tv) return console.error("TextureView:" + fbd.colorViews[j] + " not found!"), 
                    !1;
                    tvs.push(tv);
                }
                var dsv = this._textureViews.get(fbd.depthStencilView);
                this._frameBuffers.set(fbd.name, this._device.createFramebuffer({
                    renderPass: rp,
                    colorViews: tvs,
                    depthStencilView: dsv
                }));
            }
            if (!this.createQuadInputAssembler()) return !1;
            if (!this.createUBOs()) return !1;
            var mainWindow = this._root.mainWindow, windowPass = null;
            return mainWindow && (windowPass = mainWindow.renderPass), windowPass ? (this.addRenderPass(RenderPassStage.DEFAULT, windowPass), 
            this.updateMacros(), !0) : (console.error("RenderPass of main window is null."), 
            !1);
        }
    }, {
        key: "_destroy",
        value: function _destroy() {
            this.destroyFlows(), this.clearRenderPasses(), this.destroyQuadInputAssembler(), 
            this.destroyUBOs();
            for (var rtIter = this._renderTextures.values(), rtRes = rtIter.next(); !rtRes.done; ) rtRes.value.destroy(), 
            rtRes = rtIter.next();
            for (var tvIter = this._textureViews.values(), tvRes = tvIter.next(); !tvRes.done; ) tvRes.value.destroy(), 
            tvRes = tvIter.next();
            for (var rpIter = this._renderPasses.values(), rpRes = rpIter.next(); !rpRes.done; ) rpRes.value.destroy(), 
            rpRes = rpIter.next();
            for (var fbIter = this._frameBuffers.values(), fbRes = fbIter.next(); !fbRes.done; ) fbRes.value.destroy(), 
            fbRes = fbIter.next();
        }
    }, {
        key: "resizeFBOs",
        value: function resizeFBOs(width, height) {
            var _this = this;
            this._shadingWidth = width, this._shadingHeight = height;
            for (var i = 0; i < this.renderTextures.length; i++) {
                var rt = this.renderTextures[i];
                this._renderTextures.get(rt.name).resize(width, height), this._textureViews.get(rt.name).destroy(), 
                this._textureViews.get(rt.name).initialize({
                    texture: this._renderTextures.get(rt.name),
                    type: rt.viewType,
                    format: this._getTextureFormat(rt.format, rt.usage)
                });
            }
            for (var _i3 = 0; _i3 < this.framebuffers.length; _i3++) {
                var fb = this.framebuffers[_i3];
                this._frameBuffers.get(fb.name).destroy(), this._frameBuffers.get(fb.name).initialize({
                    renderPass: this._renderPasses.get(fb.renderPass),
                    colorViews: fb.colorViews.map((function(value) {
                        return _this._textureViews.get(value);
                    }), this),
                    depthStencilView: this._textureViews.get(fb.depthStencilView)
                });
            }
            console.info("Resizing shading fbos: " + this._shadingWidth + "x" + this._shadingHeight);
        }
    }, {
        key: "createQuadInputAssembler",
        value: function createQuadInputAssembler() {
            var vbStride = 4 * Float32Array.BYTES_PER_ELEMENT, vbSize = 4 * vbStride;
            if (this._quadVB = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: vbSize,
                stride: vbStride
            }), !this._quadVB) return !1;
            var verts = new Float32Array(16), n = 0;
            verts[n++] = -1, verts[n++] = -1, verts[n++] = 0, verts[n++] = 0, verts[n++] = 1, 
            verts[n++] = -1, verts[n++] = 1, verts[n++] = 0, verts[n++] = -1, verts[n++] = 1, 
            verts[n++] = 0, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, verts[n++] = 1, 
            verts[n++] = 1, this._quadVB.update(verts);
            var ibStride = Uint8Array.BYTES_PER_ELEMENT, ibSize = 6 * ibStride;
            if (this._quadIB = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: ibSize,
                stride: ibStride
            }), !this._quadIB) return !1;
            var indices = new Uint8Array(6);
            indices[0] = 0, indices[1] = 1, indices[2] = 2, indices[3] = 1, indices[4] = 3, 
            indices[5] = 2, this._quadIB.update(indices);
            var attributes = [ {
                name: "a_position",
                format: exports.GFXFormat.RG32F
            }, {
                name: "a_texCoord",
                format: exports.GFXFormat.RG32F
            } ];
            return this._quadIA = this._device.createInputAssembler({
                attributes: attributes,
                vertexBuffers: [ this._quadVB ],
                indexBuffer: this._quadIB
            }), !0;
        }
    }, {
        key: "destroyQuadInputAssembler",
        value: function destroyQuadInputAssembler() {
            this._quadVB && (this._quadVB.destroy(), this._quadVB = null), this._quadIB && (this._quadIB.destroy(), 
            this._quadIB = null), this._quadIA && (this._quadIA.destroy(), this._quadIA = null);
        }
    }, {
        key: "createUBOs",
        value: function createUBOs() {
            if (!this._globalBindings.get(UBOGlobal.BLOCK.name)) {
                var globalUBO = this._root.device.createBuffer({
                    usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: UBOGlobal.SIZE
                });
                this._globalBindings.set(UBOGlobal.BLOCK.name, {
                    type: exports.GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOGlobal.BLOCK,
                    buffer: globalUBO
                });
            }
            if (!this._globalBindings.get(UBOShadow.BLOCK.name)) {
                var shadowUBO = this._root.device.createBuffer({
                    usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: UBOShadow.SIZE
                });
                this._globalBindings.set(UBOShadow.BLOCK.name, {
                    type: exports.GFXBindingType.UNIFORM_BUFFER,
                    blockInfo: UBOShadow.BLOCK,
                    buffer: shadowUBO
                });
            }
            return this._globalBindings.get(UNIFORM_ENVIRONMENT.name) || this._globalBindings.set(UNIFORM_ENVIRONMENT.name, {
                type: exports.GFXBindingType.SAMPLER,
                samplerInfo: UNIFORM_ENVIRONMENT
            }), !0;
        }
    }, {
        key: "destroyUBOs",
        value: function destroyUBOs() {
            var globalUBO = this._globalBindings.get(UBOGlobal.BLOCK.name);
            globalUBO && (globalUBO.buffer.destroy(), this._globalBindings.delete(UBOGlobal.BLOCK.name));
            var shadowUBO = this._globalBindings.get(UBOShadow.BLOCK.name);
            shadowUBO && (shadowUBO.buffer.destroy(), this._globalBindings.delete(UBOShadow.BLOCK.name));
        }
    }, {
        key: "addVisibleModel",
        value: function addVisibleModel(model, camera) {
            var depth = 0;
            model.node && (Vec3.subtract(v3_1$5, model.node.worldPosition, camera.position), 
            depth = Vec3.dot(v3_1$5, camera.forward)), this._renderObjects.push({
                model: model,
                depth: depth
            });
        }
    }, {
        key: "activateFlow",
        value: function activateFlow(flow) {
            this._activeFlows.push(flow), this._activeFlows.sort((function(a, b) {
                return a.priority - b.priority;
            }));
        }
    }, {
        key: "_getTextureFormat",
        value: function _getTextureFormat(format, usage) {
            return format === exports.GFXFormat.UNKNOWN ? usage & exports.GFXTextureUsageBit.COLOR_ATTACHMENT ? this._colorFmt : usage & exports.GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT ? this._depthStencilFmt : exports.GFXFormat.UNKNOWN : format;
        }
    }, {
        key: "root",
        get: function get() {
            return this._root;
        }
    }, {
        key: "device",
        get: function get() {
            return this._device;
        }
    }, {
        key: "name",
        get: function get() {
            return js.getClassName(this.constructor);
        }
    }, {
        key: "renderObjects",
        get: function get() {
            return this._renderObjects;
        }
    }, {
        key: "flows",
        get: function get() {
            return this._flows;
        }
    }, {
        key: "activeFlows",
        get: function get() {
            return this._activeFlows;
        }
    }, {
        key: "usePostProcess",
        get: function get() {
            return this._usePostProcess;
        }
    }, {
        key: "isHDRSupported",
        get: function get() {
            return this._isHDRSupported;
        }
    }, {
        key: "isHDR",
        get: function get() {
            return this._isHDR;
        }
    }, {
        key: "shadingScale",
        get: function get() {
            return this._shadingScale;
        }
    }, {
        key: "lightMeterScale",
        set: function set(scale) {
            this._lightMeterScale = scale;
        },
        get: function get() {
            return this._lightMeterScale;
        }
    }, {
        key: "useMSAA",
        get: function get() {
            return this._useMSAA;
        }
    }, {
        key: "useSMAA",
        get: function get() {
            return this._useSMAA;
        }
    }, {
        key: "quadIA",
        get: function get() {
            return this._quadIA;
        }
    }, {
        key: "globalBindings",
        get: function get() {
            return this._globalBindings;
        }
    }, {
        key: "defaultTexture",
        get: function get() {
            return this._defaultTex;
        }
    }, {
        key: "fpScale",
        get: function get() {
            return this._fpScale;
        }
    }, {
        key: "fpScaleInv",
        get: function get() {
            return this._fpScaleInv;
        }
    }, {
        key: "macros",
        get: function get() {
            return this._macros;
        }
    }, {
        key: "defaultGlobalUBOData",
        get: function get() {
            return this._uboGlobal.view;
        }
    }, {
        key: "currShading",
        get: function get() {
            return this._curIdx;
        }
    }, {
        key: "prevShading",
        get: function get() {
            return this._prevIdx;
        }
    }, {
        key: "useDynamicBatching",
        get: function get() {
            return this._useDynamicBatching;
        }
    } ]), RenderPipeline;
}()).prototype, "_flows", [ _dec2$k ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$n = _applyDecoratedDescriptor(_class2$x.prototype, "renderTextures", [ _dec3$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$i = _applyDecoratedDescriptor(_class2$x.prototype, "framebuffers", [ _dec4$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor4$c = _applyDecoratedDescriptor(_class2$x.prototype, "renderPasses", [ _dec5$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class$D = _class2$x)) || _class$D);

cc.RenderPipeline = RenderPipeline;

var RenderPipelineAsset = (_dec$E = ccclass("cc.RenderPipelineAsset"), _dec2$l = property({
    type: RenderPipeline
}), _dec$E((_descriptor$w = _applyDecoratedDescriptor((_class2$y = function(_Asset) {
    function RenderPipelineAsset() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, RenderPipelineAsset);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderPipelineAsset)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "renderPipeline", _descriptor$w, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(RenderPipelineAsset, Asset), RenderPipelineAsset;
}()).prototype, "renderPipeline", [ _dec2$l ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$E = _class2$y)) || _class$E);

cc.RenderPipelineAsset = RenderPipelineAsset, exports.replaceProperty(Mesh.prototype, "Mesh.prototype", [ {
    name: "renderingMesh",
    newName: "renderingSubMeshes"
} ]), exports.removeProperty(Mesh.prototype, "Mesh.prototype", [ {
    name: "hasFlatBuffers"
}, {
    name: "destroyFlatBuffers"
} ]), cc.textureUtil = textureUtil;

var RenderViewPriority, visibleRect = {
    topLeft: cc.v2(0, 0),
    topRight: cc.v2(0, 0),
    top: cc.v2(0, 0),
    bottomLeft: cc.v2(0, 0),
    bottomRight: cc.v2(0, 0),
    bottom: cc.v2(0, 0),
    center: cc.v2(0, 0),
    left: cc.v2(0, 0),
    right: cc.v2(0, 0),
    width: 0,
    height: 0,
    init: function init(visibleRect_) {
        var w = this.width = visibleRect_.width, h = this.height = visibleRect_.height, l = visibleRect_.x, b = visibleRect_.y, t = b + h, r = l + w;
        this.topLeft.x = l, this.topLeft.y = t, this.topRight.x = r, this.topRight.y = t, 
        this.top.x = l + w / 2, this.top.y = t, this.bottomLeft.x = l, this.bottomLeft.y = b, 
        this.bottomRight.x = r, this.bottomRight.y = b, this.bottom.x = l + w / 2, this.bottom.y = b, 
        this.center.x = l + w / 2, this.center.y = b + h / 2, this.left.x = l, this.left.y = b + h / 2, 
        this.right.x = r, this.right.y = b + h / 2;
    }
};

cc.visibleRect = visibleRect, function(RenderViewPriority) {
    RenderViewPriority[RenderViewPriority.GENERAL = 100] = "GENERAL";
}(RenderViewPriority || (RenderViewPriority = {}));

var LightType, RenderView = function() {
    function RenderView(root, camera) {
        _classCallCheck(this, RenderView), this._root = void 0, this._name = "", this._window = null, 
        this._priority = 0, this._visibility = CAMERA_DEFAULT_MASK, this._camera = void 0, 
        this._isEnable = !1, this._flows = [], this._root = root, this._camera = camera;
    }
    return _createClass(RenderView, [ {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "window",
        get: function get() {
            return this._window;
        },
        set: function set(val) {
            this._window = val;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        },
        set: function set(val) {
            this._priority = val, cc.director.root && cc.director.root.sortViews();
        }
    }, {
        key: "visibility",
        set: function set(vis) {
            this._visibility = vis;
        },
        get: function get() {
            return this._visibility;
        }
    }, {
        key: "camera",
        get: function get() {
            return this._camera;
        }
    }, {
        key: "isEnable",
        get: function get() {
            return this._isEnable;
        }
    }, {
        key: "flows",
        get: function get() {
            return this._flows;
        }
    } ], [ {
        key: "registerCreateFunc",
        value: function registerCreateFunc(root) {
            root._createViewFun = function(_root, _camera) {
                return new RenderView(_root, _camera);
            };
        }
    } ]), _createClass(RenderView, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._name = info.name, this.priority = info.priority, this.setExecuteFlows(info.flows), 
            !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._window = null, this._priority = 0;
        }
    }, {
        key: "enable",
        value: function enable(isEnable) {
            this._isEnable = isEnable;
        }
    }, {
        key: "setExecuteFlows",
        value: function setExecuteFlows(flows) {
            if (this.flows.length = 0, flows && 1 === flows.length && "UIFlow" === flows[0]) this._flows.push(cc.director.root.pipeline.getFlow("UIFlow")); else for (var pipelineFlows = cc.director.root.pipeline.activeFlows, i = 0; i < pipelineFlows.length; ++i) {
                var f = pipelineFlows[i];
                (f.type === RenderFlowType.SCENE || flows && -1 !== flows.indexOf(f.name)) && this.flows.push(f);
            }
        }
    } ]), RenderView;
}();

function ColorTemperatureToRGB(rgb, kelvin) {
    kelvin < 1e3 ? kelvin = 1e3 : kelvin > 15e3 && (kelvin = 15e3);
    var kSqr = kelvin * kelvin, u = (.860117757 + .000154118254 * kelvin + 1.28641212e-7 * kSqr) / (1 + .000842420235 * kelvin + 7.08145163e-7 * kSqr), v = (.317398726 + 422806245e-13 * kelvin + 4.20481691e-8 * kSqr) / (1 - 289741816e-13 * kelvin + 1.61456053e-7 * kSqr), d = 2 * u - 8 * v + 4, x = 3 * u / d, y = 2 * v / d, X = 1 / y * x, Z = 1 / y * (1 - x - y);
    rgb.x = 3.2404542 * X - 1.5371385 + -.4985314 * Z, rgb.y = -.969266 * X + 1.8760108 + .041556 * Z, 
    rgb.z = .0556434 * X - .2040259 + 1.0572252 * Z;
}

!function(LightType) {
    LightType[LightType.DIRECTIONAL = 0] = "DIRECTIONAL", LightType[LightType.SPHERE = 1] = "SPHERE", 
    LightType[LightType.SPOT = 2] = "SPOT", LightType[LightType.UNKNOWN = 3] = "UNKNOWN";
}(LightType || (LightType = {}));

var nt2lm = function nt2lm(size) {
    return 4 * Math.PI * Math.PI * size * size;
}, Light = function() {
    function Light() {
        _classCallCheck(this, Light), this._color = new Vec3(1, 1, 1), this._useColorTemp = !1, 
        this._colorTemp = 6550, this._colorTempRGB = new Vec3(1, 1, 1), this._scene = null, 
        this._node = null, this._type = void 0, this._name = null, this._type = LightType.UNKNOWN;
    }
    return _createClass(Light, [ {
        key: "color",
        set: function set(color) {
            this._color.set(color);
        },
        get: function get() {
            return this._color;
        }
    }, {
        key: "useColorTemperature",
        set: function set(enable) {
            this._useColorTemp = enable;
        },
        get: function get() {
            return this._useColorTemp;
        }
    }, {
        key: "colorTemperature",
        set: function set(val) {
            this._colorTemp = val, ColorTemperatureToRGB(this._colorTempRGB, this._colorTemp);
        },
        get: function get() {
            return this._colorTemp;
        }
    }, {
        key: "colorTemperatureRGB",
        get: function get() {
            return this._colorTempRGB;
        }
    }, {
        key: "node",
        set: function set(n) {
            this._node = n, this._node && (this._node.hasChangedFlags |= TransformBit.ROTATION);
        },
        get: function get() {
            return this._node;
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "scene",
        get: function get() {
            return this._scene;
        }
    } ]), _createClass(Light, [ {
        key: "initialize",
        value: function initialize(name, node) {
            this._name = name, this._type = LightType.UNKNOWN, this._node = node;
        }
    }, {
        key: "attachToScene",
        value: function attachToScene(scene) {
            this._scene = scene;
        }
    }, {
        key: "detachFromScene",
        value: function detachFromScene() {
            this._scene = null;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._name = null, this._type = LightType.UNKNOWN, this._node = null;
        }
    }, {
        key: "update",
        value: function update() {}
    } ]), Light;
}();

function cullSphereLight(light, model) {
    return !(!model.worldBounds || intersect.aabb_aabb(model.worldBounds, light.aabb));
}

function cullSpotLight(light, model) {
    return !(!model.worldBounds || intersect.aabb_aabb(model.worldBounds, light.aabb) && intersect.aabb_frustum(model.worldBounds, light.frustum));
}

(lightFrustum = new frustum).accurate = !0;

var lightFrustum, ForwardStagePriority, ForwardFlowPriority, calcDirectionalLightCullFrustum = function() {
    var lightPos = new Vec3, lightViewCenter = new Vec3, lightRot = new Quat, camFrustum = new frustum;
    camFrustum.accurate = !0;
    var lightViewMat = new Mat4, lightVeiwMatInv = new Mat4, minBoxCorner = new Vec3, maxBoxCorner = new Vec3;
    return function(out, sceneCamera, light, near, far, nearBias) {
        Mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), sceneCamera.node.getWorldPosition(lightPos)), 
        Mat4.invert(lightVeiwMatInv, lightViewMat), sceneCamera.getSplitFrustum(camFrustum, near, far), 
        camFrustum.transform(lightVeiwMatInv), Vec3.set(minBoxCorner, camFrustum.vertices[0].x, camFrustum.vertices[0].y, camFrustum.vertices[0].z), 
        Vec3.copy(maxBoxCorner, minBoxCorner);
        for (var i = 1; i < camFrustum.vertices.length; i++) minBoxCorner.x = Math.min(minBoxCorner.x, camFrustum.vertices[i].x), 
        minBoxCorner.y = Math.min(minBoxCorner.y, camFrustum.vertices[i].y), minBoxCorner.z = Math.min(minBoxCorner.z, camFrustum.vertices[i].z), 
        maxBoxCorner.x = Math.max(maxBoxCorner.x, camFrustum.vertices[i].x), maxBoxCorner.y = Math.max(maxBoxCorner.y, camFrustum.vertices[i].y), 
        maxBoxCorner.z = Math.max(maxBoxCorner.z, camFrustum.vertices[i].z);
        Vec3.set(lightViewCenter, (minBoxCorner.x + maxBoxCorner.x) / 2, (minBoxCorner.y + maxBoxCorner.y) / 2, maxBoxCorner.z), 
        lightViewCenter.z += nearBias, Vec3.transformMat4(lightPos, lightViewCenter, lightViewMat), 
        Mat4.fromRT(lightViewMat, light.node.getWorldRotation(lightRot), lightPos), frustum.createOrtho(out, maxBoxCorner.x - minBoxCorner.x, maxBoxCorner.y - minBoxCorner.y, 0, minBoxCorner.z - nearBias - maxBoxCorner.z, lightViewMat);
    };
}();

!function(ForwardStagePriority) {
    ForwardStagePriority[ForwardStagePriority.FORWARD = 0] = "FORWARD";
}(ForwardStagePriority || (ForwardStagePriority = {})), function(ForwardFlowPriority) {
    ForwardFlowPriority[ForwardFlowPriority.FORWARD = 0] = "FORWARD", ForwardFlowPriority[ForwardFlowPriority.UI = 10] = "UI";
}(ForwardFlowPriority || (ForwardFlowPriority = {}));

var bufs$1 = [], colors = [], UIStage = function(_RenderStage) {
    function UIStage() {
        return _classCallCheck(this, UIStage), _possibleConstructorReturn(this, _getPrototypeOf(UIStage).apply(this, arguments));
    }
    return _inherits(UIStage, RenderStage), _createClass(UIStage, [ {
        key: "activate",
        value: function activate(flow) {
            _get(_getPrototypeOf(UIStage.prototype), "activate", this).call(this, flow), this._cmdBuff = this._device.createCommandBuffer({
                allocator: this._device.commandAllocator,
                type: exports.GFXCommandBufferType.PRIMARY
            });
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {}
    }, {
        key: "rebuild",
        value: function rebuild() {}
    }, {
        key: "render",
        value: function render(view) {
            this._renderQueues[0].clear();
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._pipeline.renderObjects); !(_step = _iterator()).done; ) for (var ro = _step.value, i = 0; i < ro.model.subModelNum; i++) for (var j = 0; j < ro.model.getSubModel(i).passes.length; j++) this._renderQueues[0].insertRenderPass(ro, i, j);
            this._renderQueues[0].sort();
            var framebuffer = view.window.framebuffer, cmdBuff = this._cmdBuff, camera = view.camera, vp = camera.viewport;
            this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
            this._renderArea.width = vp.width * camera.width, this._renderArea.height = vp.height * camera.height, 
            colors[0] = camera.clearColor, cmdBuff.begin(), cmdBuff.beginRenderPass(framebuffer, this._renderArea, camera.clearFlag, [ camera.clearColor ], camera.clearDepth, camera.clearStencil), 
            cmdBuff.execute(this._renderQueues[0].cmdBuffs.array, this._renderQueues[0].cmdBuffCount), 
            cmdBuff.endRenderPass(), cmdBuff.end(), bufs$1[0] = cmdBuff, this._device.queue.submit(bufs$1);
        }
    } ]), UIStage;
}();

UIStage.initInfo = {
    name: "UIStage",
    priority: 0,
    renderQueues: [ {
        isTransparent: !0,
        stages: [ "default" ],
        sortMode: RenderQueueSortMode.BACK_TO_FRONT
    } ],
    framebuffer: "window"
};

var UIFlow = function(_RenderFlow) {
    function UIFlow() {
        return _classCallCheck(this, UIFlow), _possibleConstructorReturn(this, _getPrototypeOf(UIFlow).apply(this, arguments));
    }
    return _inherits(UIFlow, RenderFlow), _createClass(UIFlow, [ {
        key: "initialize",
        value: function initialize(info) {
            _get(_getPrototypeOf(UIFlow.prototype), "initialize", this).call(this, info);
            var uiStage = new UIStage;
            return uiStage.initialize(UIStage.initInfo), this._stages.push(uiStage), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.destroyStages();
        }
    }, {
        key: "rebuild",
        value: function rebuild() {}
    }, {
        key: "render",
        value: function render(view) {
            view.camera.update(), this.pipeline.sceneCulling(view), this.pipeline.updateUBOs(view);
            var isHDR = this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2];
            this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = 0, this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData), 
            _get(_getPrototypeOf(UIFlow.prototype), "render", this).call(this, view), this.pipeline.defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = isHDR, 
            this.pipeline.globalBindings.get(UBOGlobal.BLOCK.name).buffer.update(this.pipeline.defaultGlobalUBOData);
        }
    } ]), UIFlow;
}();

UIFlow.initInfo = {
    name: "UIFlow",
    priority: ForwardFlowPriority.UI,
    type: RenderFlowType.UI
};

var _class$F, _class2$z, _temp$B, _class$G, _class2$A, _temp$C, _class$H, _class2$B, _temp$D, _class$I, _class2$C, _temp$E, _class$J, _class2$D, _temp$F, RenderBatchedQueue = function() {
    function RenderBatchedQueue() {
        _classCallCheck(this, RenderBatchedQueue), this.queue = new Set;
    }
    return _createClass(RenderBatchedQueue, [ {
        key: "clear",
        value: function clear() {
            for (var it = this.queue.values(), res = it.next(); !res.done; ) res.value.clear(), 
            res = it.next();
            this.queue.clear();
        }
    }, {
        key: "recordCommandBuffer",
        value: function recordCommandBuffer(cmdBuff) {
            for (var it = this.queue.values(), res = it.next(); !res.done; ) {
                for (var boundPSO = !1, b = 0; b < res.value.batches.length; ++b) {
                    var batch = res.value.batches[b];
                    if (batch.mergeCount) {
                        for (var v = 0; v < batch.vbs.length; ++v) batch.vbs[v].update(batch.vbDatas[v]);
                        batch.vbIdx.update(batch.vbIdxData.buffer), batch.ubo.update(batch.uboData.view), 
                        boundPSO || (cmdBuff.bindPipelineState(batch.pso), boundPSO = !0), cmdBuff.bindBindingLayout(batch.pso.pipelineLayout.layouts[0]), 
                        cmdBuff.bindInputAssembler(batch.ia), cmdBuff.draw(batch.ia);
                    }
                }
                res = it.next();
            }
        }
    } ]), RenderBatchedQueue;
}(), RenderInstancedQueue = function() {
    function RenderInstancedQueue() {
        _classCallCheck(this, RenderInstancedQueue), this.queue = new Set;
    }
    return _createClass(RenderInstancedQueue, [ {
        key: "clear",
        value: function clear() {
            for (var it = this.queue.values(), res = it.next(); !res.done; ) res.value.clear(), 
            res = it.next();
            this.queue.clear();
        }
    }, {
        key: "recordCommandBuffer",
        value: function recordCommandBuffer(cmdBuff) {
            for (var it = this.queue.values(), res = it.next(); !res.done; ) {
                var instances = res.value.instances;
                if (instances.length > 0) {
                    res.value.uploadBuffers();
                    for (var b = 0; b < instances.length; ++b) {
                        var instance = instances[b];
                        instance.count && (cmdBuff.bindPipelineState(instance.pso), cmdBuff.bindBindingLayout(instance.pso.pipelineLayout.layouts[0]), 
                        cmdBuff.bindInputAssembler(instance.ia), cmdBuff.draw(instance.ia));
                    }
                }
                res = it.next();
            }
        }
    } ]), RenderInstancedQueue;
}(), colors$1 = [ {
    r: 0,
    g: 0,
    b: 0,
    a: 1
} ], bufs$2 = [], ForwardStage = ccclass("ForwardStage")((_temp$B = _class2$z = function(_RenderStage) {
    function ForwardStage() {
        var _this;
        return _classCallCheck(this, ForwardStage), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardStage).call(this)))._opaqueBatchedQueue = void 0, 
        _this._opaqueInstancedQueue = void 0, _this._opaqueBatchedQueue = new RenderBatchedQueue, 
        _this._opaqueInstancedQueue = new RenderInstancedQueue, _this;
    }
    return _inherits(ForwardStage, RenderStage), _createClass(ForwardStage, [ {
        key: "activate",
        value: function activate(flow) {
            _get(_getPrototypeOf(ForwardStage.prototype), "activate", this).call(this, flow), 
            this.createCmdBuffer();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {}
    }, {
        key: "rebuild",
        value: function rebuild() {}
    }, {
        key: "render",
        value: function render(view) {
            this._opaqueInstancedQueue.clear(), this._opaqueBatchedQueue.clear(), this._renderQueues.forEach(this.renderQueueClearFunc);
            for (var renderObjects = this._pipeline.renderObjects, i = 0; i < renderObjects.length; ++i) {
                var ro = renderObjects[i];
                if (ro.model.isDynamicBatching) for (var subModels = ro.model.subModels, m = 0; m < subModels.length; ++m) for (var subModel = subModels[m], passes = subModel.passes, p = 0; p < passes.length; ++p) {
                    var pass = passes[p], pso = subModel.psos[p];
                    if (pass.instancedBuffer) pass.instancedBuffer.merge(subModel, ro.model.instancedAttributes, pso), 
                    this._opaqueInstancedQueue.queue.add(pass.instancedBuffer); else if (pass.batchedBuffer) pass.batchedBuffer.merge(subModel, ro, pso), 
                    this._opaqueBatchedQueue.queue.add(pass.batchedBuffer); else for (var k = 0; k < this._renderQueues.length; k++) this._renderQueues[k].insertRenderPass(ro, m, p);
                } else for (var _m = 0; _m < ro.model.subModelNum; _m++) for (var _p = 0; _p < ro.model.getSubModel(_m).passes.length; _p++) for (var _k = 0; _k < this._renderQueues.length; _k++) this._renderQueues[_k].insertRenderPass(ro, _m, _p);
            }
            this._renderQueues.forEach(this.renderQueueSortFunc);
            var camera = view.camera, cmdBuff = this._cmdBuff, vp = camera.viewport;
            if (this._renderArea.x = vp.x * camera.width, this._renderArea.y = vp.y * camera.height, 
            this._renderArea.width = vp.width * camera.width * this.pipeline.shadingScale, this._renderArea.height = vp.height * camera.height * this.pipeline.shadingScale, 
            camera.clearFlag & exports.GFXClearFlag.COLOR) if (this._pipeline.isHDR) {
                !function SRGBToLinear(out, gamma) {
                    out.r = gamma.r * gamma.r, out.g = gamma.g * gamma.g, out.b = gamma.b * gamma.b;
                }(colors$1[0], camera.clearColor);
                var scale = this._pipeline.fpScale / camera.exposure;
                colors$1[0].r *= scale, colors$1[0].g *= scale, colors$1[0].b *= scale;
            } else colors$1[0].r = camera.clearColor.r, colors$1[0].g = camera.clearColor.g, 
            colors$1[0].b = camera.clearColor.b;
            colors$1[0].a = camera.clearColor.a, this._pipeline.usePostProcess ? this._pipeline.useMSAA ? this._framebuffer = this._pipeline.getFrameBuffer("msaa") : this._framebuffer = this._pipeline.getFrameBuffer(this._pipeline.currShading) : this._framebuffer = view.window.framebuffer;
            var planarShadow = camera.scene.planarShadows;
            cmdBuff.begin(), cmdBuff.beginRenderPass(this._framebuffer, this._renderArea, camera.clearFlag, colors$1, camera.clearDepth, camera.clearStencil), 
            cmdBuff.execute(this._renderQueues[0].cmdBuffs.array, this._renderQueues[0].cmdBuffCount), 
            this._opaqueInstancedQueue.recordCommandBuffer(cmdBuff), this._opaqueBatchedQueue.recordCommandBuffer(cmdBuff), 
            camera.visibility & Layers.BitMask.DEFAULT && planarShadow.recordCommandBuffer(cmdBuff), 
            cmdBuff.execute(this._renderQueues[1].cmdBuffs.array, this._renderQueues[1].cmdBuffCount), 
            cmdBuff.endRenderPass(), cmdBuff.end(), bufs$2[0] = cmdBuff, this._device.queue.submit(bufs$2), 
            this._pipeline.useMSAA && this._device.blitFramebuffer(this._framebuffer, this._pipeline.getFrameBuffer(this._pipeline.currShading), this._renderArea, this._renderArea, exports.GFXFilter.POINT);
        }
    } ]), ForwardStage;
}(), _class2$z.initInfo = {
    name: "ForwardStage",
    priority: ForwardStagePriority.FORWARD,
    renderQueues: [ {
        isTransparent: !1,
        sortMode: RenderQueueSortMode.FRONT_TO_BACK,
        stages: [ "default" ]
    }, {
        isTransparent: !0,
        sortMode: RenderQueueSortMode.BACK_TO_FRONT,
        stages: [ "default", "planarShadow" ]
    } ]
}, _class$F = _temp$B)) || _class$F, ForwardFlow = ccclass("ForwardFlow")((_temp$C = _class2$A = function(_RenderFlow) {
    function ForwardFlow() {
        return _classCallCheck(this, ForwardFlow), _possibleConstructorReturn(this, _getPrototypeOf(ForwardFlow).apply(this, arguments));
    }
    return _inherits(ForwardFlow, RenderFlow), _createClass(ForwardFlow, [ {
        key: "initialize",
        value: function initialize(info) {
            _get(_getPrototypeOf(ForwardFlow.prototype), "initialize", this).call(this, info);
            var forwardStage = new ForwardStage;
            forwardStage.initialize(ForwardStage.initInfo), this._stages.push(forwardStage);
        }
    }, {
        key: "render",
        value: function render(view) {
            view.camera.update(), this.pipeline.sceneCulling(view), this.pipeline.updateUBOs(view), 
            _get(_getPrototypeOf(ForwardFlow.prototype), "render", this).call(this, view);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.destroyStages();
        }
    }, {
        key: "rebuild",
        value: function rebuild() {}
    } ]), ForwardFlow;
}(), _class2$A.initInfo = {
    name: "ForwardFlow",
    priority: ForwardFlowPriority.FORWARD
}, _class$G = _temp$C)) || _class$G, bufs$3 = [], ToneMapStage = ccclass("ToneMapStage")((_temp$D = _class2$B = function(_RenderStage) {
    function ToneMapStage() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ToneMapStage);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToneMapStage)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._hTexSampler = 0, 
        _this._hBlendTexSampler = 0, _this._bindingLayout = null, _this;
    }
    return _inherits(ToneMapStage, RenderStage), _createClass(ToneMapStage, [ {
        key: "activate",
        value: function activate(flow) {
            _get(_getPrototypeOf(ToneMapStage.prototype), "activate", this).call(this, flow), 
            this._createCmdBuffer(), this.rebuild();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._cmdBuff && (this._cmdBuff.destroy(), this._cmdBuff = null);
        }
    }, {
        key: "resize",
        value: function resize(width, height) {}
    }, {
        key: "rebuild",
        value: function rebuild() {
            this._pass = this._flow.material.passes[0], this._hTexSampler = this._pass.getBinding("u_texSampler");
            var globalUBO = this._pipeline.globalBindings.get(UBOGlobal.BLOCK.name);
            this._pso = this._pass.createPipelineState(), this._bindingLayout = this._pso.pipelineLayout.layouts[0], 
            this._pass.bindBuffer(UBOGlobal.BLOCK.binding, globalUBO.buffer), this._pass.bindTextureView(this._hTexSampler, this._pipeline.getTextureView(this._pipeline.currShading)), 
            this._pipeline.useSMAA && (this._hBlendTexSampler = this._pass.getBinding("u_blendTexSampler"), 
            this._pass.bindTextureView(this._hBlendTexSampler, this._pipeline.getTextureView("smaaBlend"))), 
            this._pass.update(), this._bindingLayout.update();
        }
    }, {
        key: "render",
        value: function render(view) {
            var camera = view.camera;
            if (this._cmdBuff) {
                this._renderArea.width = camera.width, this._renderArea.height = camera.height;
                var framebuffer = view.window.framebuffer;
                this._cmdBuff.begin(), this._cmdBuff.beginRenderPass(framebuffer, this._renderArea, exports.GFXClearFlag.ALL, [ {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                } ], 1, 0), this._cmdBuff.bindPipelineState(this._pso), this._cmdBuff.bindBindingLayout(this._pso.pipelineLayout.layouts[0]), 
                this._cmdBuff.bindInputAssembler(this._pipeline.quadIA), this._cmdBuff.draw(this._pipeline.quadIA), 
                this._cmdBuff.endRenderPass(), this._cmdBuff.end();
            }
            bufs$3[0] = this._cmdBuff, this._device.queue.submit(bufs$3);
        }
    }, {
        key: "_createCmdBuffer",
        value: function _createCmdBuffer() {
            this._cmdBuff = this._device.createCommandBuffer({
                allocator: this._device.commandAllocator,
                type: exports.GFXCommandBufferType.PRIMARY
            });
        }
    } ]), ToneMapStage;
}(), _class2$B.initInfo = {
    name: "ToneMapStage",
    priority: 0,
    framebuffer: "window"
}, _class$H = _temp$D)) || _class$H, ToneMapFlow = ccclass("ToneMapFlow")((_temp$E = _class2$C = function(_RenderFlow) {
    function ToneMapFlow() {
        return _classCallCheck(this, ToneMapFlow), _possibleConstructorReturn(this, _getPrototypeOf(ToneMapFlow).apply(this, arguments));
    }
    return _inherits(ToneMapFlow, RenderFlow), _createClass(ToneMapFlow, [ {
        key: "initialize",
        value: function initialize(info) {
            _get(_getPrototypeOf(ToneMapFlow.prototype), "initialize", this).call(this, info), 
            this._material.recompileShaders({
                CC_USE_SMAA: this._pipeline.useSMAA
            });
            var toneStage = new ToneMapStage;
            return toneStage.initialize(ToneMapStage.initInfo), this._stages.push(toneStage), 
            !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._material && this._material.destroy(), this.destroyStages();
        }
    }, {
        key: "rebuild",
        value: function rebuild() {
            this._material && this._material.recompileShaders({
                CC_USE_SMAA: this._pipeline.useSMAA
            });
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._stages); !(_step = _iterator()).done; ) {
                _step.value.rebuild();
            }
        }
    } ]), ToneMapFlow;
}(), _class2$C.initInfo = {
    name: "ToneMapFlow",
    priority: ForwardFlowPriority.FORWARD + 1
}, _class$I = _temp$E)) || _class$I, _vec4Array = new Float32Array(4), _sphere = sphere.create(0, 0, 0, 1), _tempLightIndex = [], _tempLightDist = [], _tempVec3 = new Vec3, ForwardPipeline = ccclass("ForwardPipeline")((_temp$F = _class2$D = function(_RenderPipeline) {
    function ForwardPipeline() {
        var _this;
        return _classCallCheck(this, ForwardPipeline), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardPipeline).call(this)))._uboLights = new UBOForwardLight, 
        _this._lightsUBO = null, _this._validLights = void 0, _this._lightIndexOffset = void 0, 
        _this._lightIndices = void 0, _this._validLights = [], _this._lightIndexOffset = [], 
        _this._lightIndices = [], _this;
    }
    return _inherits(ForwardPipeline, RenderPipeline), _createClass(ForwardPipeline, [ {
        key: "lightsUBO",
        get: function get() {
            return this._lightsUBO;
        }
    } ]), _createClass(ForwardPipeline, [ {
        key: "initialize",
        value: function initialize(info) {
            _get(_getPrototypeOf(ForwardPipeline.prototype), "initialize", this).call(this, info);
            var forwardFlow = new ForwardFlow;
            forwardFlow.initialize(ForwardFlow.initInfo), this._flows.push(forwardFlow);
        }
    }, {
        key: "activate",
        value: function activate(root) {
            if (!_get(_getPrototypeOf(ForwardPipeline.prototype), "activate", this).call(this, root)) return !1;
            if (this._usePostProcess) {
                this._useSMAA;
                var tonemapFlow = new ToneMapFlow;
                tonemapFlow.initialize(ForwardFlow.initInfo), this._flows.push(tonemapFlow), tonemapFlow.activate(this);
            }
            var uiFlow = new UIFlow;
            return uiFlow.initialize(UIFlow.initInfo), this._flows.push(uiFlow), uiFlow.activate(this), 
            !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._destroy();
        }
    }, {
        key: "rebuild",
        value: function rebuild() {
            _get(_getPrototypeOf(ForwardPipeline.prototype), "rebuild", this).call(this);
            for (var i = 0; i < this._flows.length; i++) this._flows[i].rebuild();
        }
    }, {
        key: "updateUBOs",
        value: function updateUBOs(view) {
            _get(_getPrototypeOf(ForwardPipeline.prototype), "updateUBOs", this).call(this, view);
            for (var exposure = view.camera.exposure, i = 0; i < this._renderObjects.length; i++) {
                this._uboLights.view.fill(0);
                var nextLightIndex = i + 1 < this._renderObjects.length ? this._lightIndexOffset[i + 1] : this._lightIndices.length;
                if (this._renderObjects[i].model.lightBuffer && !this._renderObjects[i].model.isDynamicBatching) {
                    for (var sphereNum = 0, spotNum = 0, l = this._lightIndexOffset[i]; l < nextLightIndex; l++) {
                        var light = this._validLights[this._lightIndices[l]];
                        if (light) switch (light.type) {
                          case LightType.SPHERE:
                            if (sphereNum >= UBOForwardLight.MAX_SPHERE_LIGHTS) continue;
                            var sphereLit = light;
                            if (Vec3.toArray(_vec4Array, sphereLit.position), this._uboLights.view.set(_vec4Array, UBOForwardLight.SPHERE_LIGHT_POS_OFFSET + 4 * sphereNum), 
                            _vec4Array[0] = sphereLit.size, _vec4Array[1] = sphereLit.range, _vec4Array[2] = 0, 
                            this._uboLights.view.set(_vec4Array, UBOForwardLight.SPHERE_LIGHT_SIZE_RANGE_OFFSET + 4 * sphereNum), 
                            Vec3.toArray(_vec4Array, light.color), light.useColorTemperature) {
                                var tempRGB = light.colorTemperatureRGB;
                                _vec4Array[0] *= tempRGB.x, _vec4Array[1] *= tempRGB.y, _vec4Array[2] *= tempRGB.z;
                            }
                            this._isHDR ? _vec4Array[3] = sphereLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array[3] = sphereLit.luminance * exposure * this._lightMeterScale, 
                            this._uboLights.view.set(_vec4Array, UBOForwardLight.SPHERE_LIGHT_COLOR_OFFSET + 4 * sphereNum), 
                            sphereNum++;
                            break;

                          case LightType.SPOT:
                            if (spotNum >= UBOForwardLight.MAX_SPOT_LIGHTS) continue;
                            var spotLit = light;
                            if (Vec3.toArray(_vec4Array, spotLit.position), _vec4Array[3] = spotLit.size, this._uboLights.view.set(_vec4Array, UBOForwardLight.SPOT_LIGHT_POS_OFFSET + 4 * spotNum), 
                            _vec4Array[0] = spotLit.size, _vec4Array[1] = spotLit.range, _vec4Array[2] = spotLit.spotAngle, 
                            this._uboLights.view.set(_vec4Array, UBOForwardLight.SPOT_LIGHT_SIZE_RANGE_ANGLE_OFFSET + 4 * spotNum), 
                            Vec3.toArray(_vec4Array, spotLit.direction), this._uboLights.view.set(_vec4Array, UBOForwardLight.SPOT_LIGHT_DIR_OFFSET + 4 * spotNum), 
                            Vec3.toArray(_vec4Array, light.color), light.useColorTemperature) {
                                var _tempRGB = light.colorTemperatureRGB;
                                _vec4Array[0] *= _tempRGB.x, _vec4Array[1] *= _tempRGB.y, _vec4Array[2] *= _tempRGB.z;
                            }
                            this._isHDR ? _vec4Array[3] = spotLit.luminance * this._fpScale * this._lightMeterScale : _vec4Array[3] = spotLit.luminance * exposure * this._lightMeterScale, 
                            this._uboLights.view.set(_vec4Array, UBOForwardLight.SPOT_LIGHT_COLOR_OFFSET + 4 * spotNum), 
                            spotNum++;
                        }
                    }
                    this._renderObjects[i].model.lightBuffer.update(this._uboLights.view);
                }
            }
        }
    }, {
        key: "sceneCulling",
        value: function sceneCulling(view) {
            _get(_getPrototypeOf(ForwardPipeline.prototype), "sceneCulling", this).call(this, view), 
            this._validLights.length = 0;
            for (var sphereLights = view.camera.scene.sphereLights, i = 0; i < sphereLights.length; i++) {
                var light = sphereLights[i];
                light.update(), sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range), 
                intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(light);
            }
            for (var spotLights = view.camera.scene.spotLights, _i = 0; _i < spotLights.length; _i++) {
                var _light = spotLights[_i];
                _light.update(), sphere.set(_sphere, _light.position.x, _light.position.y, _light.position.z, _light.range), 
                intersect.sphere_frustum(_sphere, view.camera.frustum) && this._validLights.push(_light);
            }
            if (this._lightIndexOffset.length = this._lightIndices.length = 0, this._validLights.length) for (var _i2 = 0; _i2 < this._renderObjects.length; _i2++) this._lightIndexOffset[_i2] = this._lightIndices.length, 
            this._renderObjects[_i2].model.lightBuffer && this.cullLightPerModel(this._renderObjects[_i2].model);
        }
    }, {
        key: "cullLightPerModel",
        value: function cullLightPerModel(model) {
            _tempLightIndex.length = 0;
            for (var i = 0; i < this._validLights.length; i++) {
                var isCulled = !1;
                switch (this._validLights[i].type) {
                  case LightType.DIRECTIONAL:
                    this._validLights[i], isCulled = !1;
                    break;

                  case LightType.SPHERE:
                    isCulled = cullSphereLight(this._validLights[i], model);
                    break;

                  case LightType.SPOT:
                    isCulled = cullSpotLight(this._validLights[i], model);
                }
                isCulled || (_tempLightIndex.push(i), this._validLights[i].type === LightType.DIRECTIONAL ? _tempLightDist[i] = 0 : _tempLightDist[i] = Vec3.distance(this._validLights[i].position, model.node.getWorldPosition(_tempVec3)));
            }
            _tempLightIndex.sort(this.sortLight), Array.prototype.push.apply(this._lightIndices, _tempLightIndex);
        }
    }, {
        key: "sortLight",
        value: function sortLight(a, b) {
            return _tempLightDist[a] - _tempLightDist[b];
        }
    } ]), ForwardPipeline;
}(), _class2$D.initInfo = {}, _class$J = _temp$F)) || _class$J, pipeline = pipelineDefine, _vec2$1 = new Vec2, Touch = function() {
    function Touch(x, y) {
        var id = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        _classCallCheck(this, Touch), this._point = new Vec2, this._prevPoint = new Vec2, 
        this._lastModified = 0, this._id = 0, this._startPoint = new Vec2, this._startPointCaptured = !1, 
        this.setTouchInfo(id, x, y);
    }
    return _createClass(Touch, [ {
        key: "lastModified",
        get: function get() {
            return this._lastModified;
        }
    } ]), _createClass(Touch, [ {
        key: "getLocation",
        value: function getLocation(out) {
            return out || (out = new Vec2), out.set(this._point.x, this._point.y), out;
        }
    }, {
        key: "getLocationX",
        value: function getLocationX() {
            return this._point.x;
        }
    }, {
        key: "getLocationY",
        value: function getLocationY() {
            return this._point.y;
        }
    }, {
        key: "getUILocation",
        value: function getUILocation(out) {
            return out || (out = new Vec2), out.set(this._point.x, this._point.y), cc.view._convertPointWithScale(out), 
            out;
        }
    }, {
        key: "getUILocationX",
        value: function getUILocationX() {
            var viewport = cc.view.getViewportRect();
            return (this._point.x - viewport.x) / cc.view.getScaleX();
        }
    }, {
        key: "getUILocationY",
        value: function getUILocationY() {
            var viewport = cc.view.getViewportRect();
            return (this._point.y - viewport.y) / cc.view.getScaleY();
        }
    }, {
        key: "getPreviousLocation",
        value: function getPreviousLocation(out) {
            return out || (out = new Vec2), out.set(this._prevPoint.x, this._prevPoint.y), out;
        }
    }, {
        key: "getUIPreviousLocation",
        value: function getUIPreviousLocation(out) {
            return out || (out = new Vec2), out.set(this._prevPoint.x, this._prevPoint.y), cc.view._convertPointWithScale(out), 
            out;
        }
    }, {
        key: "getStartLocation",
        value: function getStartLocation(out) {
            return out || (out = new Vec2), out.set(this._startPoint.x, this._startPoint.y), 
            out;
        }
    }, {
        key: "getUIStartLocation",
        value: function getUIStartLocation(out) {
            return out || (out = new Vec2), out.set(this._startPoint.x, this._startPoint.y), 
            cc.view._convertPointWithScale(out), out;
        }
    }, {
        key: "getDelta",
        value: function getDelta(out) {
            return out || (out = new Vec2), out.set(this._point), out.subtract(this._prevPoint), 
            out;
        }
    }, {
        key: "getUIDelta",
        value: function getUIDelta(out) {
            return out || (out = new Vec2), _vec2$1.set(this._point), _vec2$1.subtract(this._prevPoint), 
            out.set(cc.view.getScaleX(), cc.view.getScaleY()), Vec2.divide(out, _vec2$1, out), 
            out;
        }
    }, {
        key: "getLocationInView",
        value: function getLocationInView(out) {
            return out || (out = new Vec2), out.set(this._point.x, cc.view._designResolutionSize.height - this._point.y), 
            out;
        }
    }, {
        key: "getPreviousLocationInView",
        value: function getPreviousLocationInView(out) {
            return out || (out = new Vec2), out.set(this._prevPoint.x, cc.view._designResolutionSize.height - this._prevPoint.y), 
            out;
        }
    }, {
        key: "getStartLocationInView",
        value: function getStartLocationInView(out) {
            return out || (out = new Vec2), out.set(this._startPoint.x, cc.view._designResolutionSize.height - this._startPoint.y), 
            out;
        }
    }, {
        key: "getID",
        value: function getID() {
            return this._id;
        }
    }, {
        key: "setTouchInfo",
        value: function setTouchInfo() {
            var id = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, x = arguments.length > 1 ? arguments[1] : void 0, y = arguments.length > 2 ? arguments[2] : void 0;
            this._prevPoint = this._point, this._point = new Vec2(x || 0, y || 0), this._id = id, 
            this._startPointCaptured || (this._startPoint = new Vec2(this._point), this._startPointCaptured = !0);
        }
    }, {
        key: "setPoint",
        value: function setPoint(x, y) {
            "object" === _typeof(x) ? (this._point.x = x.x, this._point.y = x.y) : (this._point.x = x || 0, 
            this._point.y = y || 0), this._lastModified = cc.director.getCurrentTime();
        }
    }, {
        key: "setPrevPoint",
        value: function setPrevPoint(x, y) {
            "object" === _typeof(x) ? this._prevPoint = new Vec2(x.x, x.y) : this._prevPoint = new Vec2(x || 0, y || 0), 
            this._lastModified = cc.director.getCurrentTime();
        }
    } ]), Touch;
}();

cc.Touch = Touch;

var _didAccelerateFun, TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT, _vec2$2 = new Vec2, _preLocation = new Vec2, Acceleration$1 = function Acceleration() {
    var x = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, y = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, z = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, timestamp = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    _classCallCheck(this, Acceleration), this.x = void 0, this.y = void 0, this.z = void 0, 
    this.timestamp = void 0, this.x = x, this.y = y, this.z = z, this.timestamp = timestamp;
};

cc.internal.Acceleration = Acceleration$1;

var inputManager = new (function() {
    function InputManager() {
        _classCallCheck(this, InputManager), this._mousePressed = !1, this._isRegisterEvent = !1, 
        this._preTouchPoint = new Vec2, this._prevMousePoint = new Vec2, this._preTouchPool = [], 
        this._preTouchPoolPointer = 0, this._touches = [], this._touchesIntegerDict = {}, 
        this._indexBitsUsed = 0, this._maxTouches = 8, this._accelEnabled = !1, this._accelInterval = .2, 
        this._accelMinus = 1, this._accelCurTime = 0, this._acceleration = null, this._accelDeviceEvent = null, 
        this._glView = null, this._pointLocked = !1;
    }
    return _createClass(InputManager, [ {
        key: "handleTouchesBegin",
        value: function handleTouchesBegin(touches) {
            for (var handleTouches = [], locTouchIntDict = this._touchesIntegerDict, i = 0; i < touches.length; ++i) {
                var touch = touches[i], touchID = touch.getID();
                if (null !== touchID) if (void 0 === locTouchIntDict[touchID]) {
                    var unusedIndex = this._getUnUsedIndex();
                    if (-1 === unusedIndex) {
                        cc.logID(2300, unusedIndex);
                        continue;
                    }
                    touch.getLocation(_vec2$2);
                    var curTouch = new Touch(_vec2$2.x, _vec2$2.y, touchID);
                    this._touches[unusedIndex] = curTouch, touch.getPreviousLocation(_vec2$2), curTouch.setPrevPoint(_vec2$2), 
                    locTouchIntDict[touchID] = unusedIndex, handleTouches.push(curTouch);
                }
            }
            if (handleTouches.length > 0) {
                var touchEvent = new EventTouch(handleTouches, !1, EventTouch.BEGAN);
                eventManager.dispatchEvent(touchEvent);
            }
        }
    }, {
        key: "handleTouchesMove",
        value: function handleTouchesMove(touches) {
            for (var handleTouches = [], locTouches = this._touches, i = 0; i < touches.length; ++i) {
                var touch = touches[i], touchID = touch.getID();
                if (null !== touchID) {
                    var _index2 = this._touchesIntegerDict[touchID];
                    void 0 !== _index2 && locTouches[_index2] && (touch.getLocation(_vec2$2), locTouches[_index2].setPoint(_vec2$2), 
                    touch.getPreviousLocation(_vec2$2), locTouches[_index2].setPrevPoint(_vec2$2), handleTouches.push(locTouches[_index2]));
                }
            }
            if (handleTouches.length > 0) {
                var touchEvent = new EventTouch(handleTouches, !1, EventTouch.MOVED);
                eventManager.dispatchEvent(touchEvent);
            }
        }
    }, {
        key: "handleTouchesEnd",
        value: function handleTouchesEnd(touches) {
            var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
            if (handleTouches.length > 0) {
                var touchEvent = new EventTouch(handleTouches, !1, EventTouch.ENDED);
                eventManager.dispatchEvent(touchEvent);
            }
            this._preTouchPool.length = 0;
        }
    }, {
        key: "handleTouchesCancel",
        value: function handleTouchesCancel(touches) {
            var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
            if (handleTouches.length > 0) {
                var touchEvent = new EventTouch(handleTouches, !1, EventTouch.CANCELLED);
                eventManager.dispatchEvent(touchEvent);
            }
            this._preTouchPool.length = 0;
        }
    }, {
        key: "getSetOfTouchesEndOrCancel",
        value: function getSetOfTouchesEndOrCancel(touches) {
            for (var handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict, i = 0; i < touches.length; ++i) {
                var touch = touches[i], touchID = touch.getID();
                if (null !== touchID) {
                    var _index3 = locTouchesIntDict[touchID];
                    void 0 !== _index3 && locTouches[_index3] && (touch.getLocation(_vec2$2), locTouches[_index3].setPoint(_vec2$2), 
                    touch.getPreviousLocation(_vec2$2), locTouches[_index3].setPrevPoint(_vec2$2), handleTouches.push(locTouches[_index3]), 
                    this._removeUsedIndexBit(_index3), delete locTouchesIntDict[touchID]);
                }
            }
            return handleTouches;
        }
    }, {
        key: "getHTMLElementPosition",
        value: function getHTMLElementPosition(element) {
            if (sys.platform === sys.WECHAT_GAME) return {
                left: 0,
                top: 0,
                width: window.innerWidth,
                height: window.innerHeight
            };
            var docElem = document.documentElement, leftOffset = sys.os === sys.OS_IOS && sys.isBrowser ? window.screenLeft : window.pageXOffset;
            leftOffset -= docElem.clientLeft;
            var topOffset = sys.os === sys.OS_IOS && sys.isBrowser ? window.screenTop : window.pageYOffset;
            if (topOffset -= docElem.clientTop, element.getBoundingClientRect) {
                var box = element.getBoundingClientRect();
                return {
                    left: box.left + leftOffset,
                    top: box.top + topOffset,
                    width: box.width,
                    height: box.height
                };
            }
            return element instanceof HTMLCanvasElement ? {
                left: leftOffset,
                top: topOffset,
                width: element.width,
                height: element.height
            } : {
                left: leftOffset,
                top: topOffset,
                width: parseInt(element.style.width || "0", void 0),
                height: parseInt(element.style.height || "0", void 0)
            };
        }
    }, {
        key: "getPreTouch",
        value: function getPreTouch(touch) {
            for (var preTouch = null, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
                preTouch = locPreTouchPool[i];
                break;
            }
            return preTouch || (preTouch = touch), preTouch;
        }
    }, {
        key: "setPreTouch",
        value: function setPreTouch(touch) {
            for (var find = !1, locPreTouchPool = this._preTouchPool, id = touch.getID(), i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
                locPreTouchPool[i] = touch, find = !0;
                break;
            }
            find || (locPreTouchPool.length <= 50 ? locPreTouchPool.push(touch) : (locPreTouchPool[this._preTouchPoolPointer] = touch, 
            this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50));
        }
    }, {
        key: "getTouchByXY",
        value: function getTouchByXY(event, tx, ty, pos) {
            var locPreTouch = this._preTouchPoint, location = this._glView.convertToLocationInView(tx, ty, pos);
            this._pointLocked && (location.x = locPreTouch.x + event.movementX, location.y = locPreTouch.y - event.movementY);
            var touch = new Touch(location.x, location.y, 0);
            return touch.setPrevPoint(locPreTouch.x, locPreTouch.y), locPreTouch.x = location.x, 
            locPreTouch.y = location.y, touch;
        }
    }, {
        key: "getMouseEvent",
        value: function getMouseEvent(location, pos, eventType) {
            var locPreMouse = this._prevMousePoint, mouseEvent = new EventMouse(eventType, !1, locPreMouse);
            return locPreMouse.x = location.x, locPreMouse.y = location.y, this._glView._convertMouseToLocation(locPreMouse, pos), 
            mouseEvent.setLocation(locPreMouse.x, locPreMouse.y), mouseEvent;
        }
    }, {
        key: "getPointByEvent",
        value: function getPointByEvent(event, pos) {
            return null != event.pageX ? {
                x: event.pageX,
                y: event.pageY
            } : (sys.platform === sys.WECHAT_GAME ? (pos.left = 0, pos.top = 0) : (pos.left -= document.body.scrollLeft, 
            pos.top -= document.body.scrollTop), {
                x: event.clientX,
                y: event.clientY
            });
        }
    }, {
        key: "getTouchesByEvent",
        value: function getTouchesByEvent(event, position) {
            for (var touches = [], locView = this._glView, locPreTouch = this._preTouchPoint, length = event.changedTouches.length, i = 0; i < length; i++) {
                var changedTouch = event.changedTouches[i];
                if (changedTouch) {
                    var _location = void 0;
                    _location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(changedTouch.pageX, changedTouch.pageY, position, _vec2$2) : locView.convertToLocationInView(changedTouch.clientX, changedTouch.clientY, position, _vec2$2);
                    var touch = void 0;
                    null != changedTouch.identifier ? (touch = new Touch(_location.x, _location.y, changedTouch.identifier), 
                    this.getPreTouch(touch).getLocation(_preLocation), touch.setPrevPoint(_preLocation.x, _preLocation.y), 
                    this.setPreTouch(touch)) : (touch = new Touch(_location.x, _location.y)).setPrevPoint(locPreTouch.x, locPreTouch.y), 
                    locPreTouch.x = _location.x, locPreTouch.y = _location.y, touches.push(touch);
                }
            }
            return touches;
        }
    }, {
        key: "registerSystemEvent",
        value: function registerSystemEvent(element) {
            if (!this._isRegisterEvent && element) {
                this._glView = cc.view;
                var prohibition = sys.isMobile, supportMouse = "mouse" in sys.capabilities, supportTouches = "touches" in sys.capabilities;
                sys.platform === sys.WECHAT_GAME && (prohibition = !1, supportTouches = !0, supportMouse = !1), 
                supportMouse && this._registerMouseEvents(element, prohibition), window.navigator.msPointerEnabled && this._registerMousePointerEvents(element), 
                supportTouches && this._registerTouchEvents(element), this._registerKeyboardEvent(), 
                this._isRegisterEvent = !0;
            }
        }
    }, {
        key: "setAccelerometerEnabled",
        value: function setAccelerometerEnabled(isEnable) {
            if (this._accelEnabled !== isEnable) {
                this._accelEnabled = isEnable;
                var scheduler = cc.director.getScheduler();
                scheduler.enableForTarget(this), this._accelEnabled ? (this._registerAccelerometerEvent(), 
                this._accelCurTime = 0, scheduler.scheduleUpdate(this)) : (this._unregisterAccelerometerEvent(), 
                this._accelCurTime = 0, scheduler.unscheduleUpdate(this));
            }
        }
    }, {
        key: "didAccelerate",
        value: function didAccelerate(eventData) {
            if (this._accelEnabled) {
                var mAcceleration = this._acceleration, x = 0, y = 0, z = 0;
                if (this._accelDeviceEvent === window.DeviceMotionEvent) {
                    var eventAcceleration = eventData.accelerationIncludingGravity;
                    eventAcceleration && (x = this._accelMinus * (eventAcceleration.x || 0) * .1, y = this._accelMinus * (eventAcceleration.y || 0) * .1, 
                    z = .1 * (eventAcceleration.z || 0));
                } else {
                    var deviceOrientationEvent = eventData;
                    x = (deviceOrientationEvent.gamma || 0) / 90 * .981, y = -(deviceOrientationEvent.beta || 0) / 90 * .981, 
                    z = (deviceOrientationEvent.alpha || 0) / 90 * .981;
                }
                if (cc.view._isRotated) {
                    var tmp = x;
                    x = -y, y = tmp;
                }
                mAcceleration.x = x, mAcceleration.y = y, mAcceleration.z = z, mAcceleration.timestamp = eventData.timeStamp || Date.now();
                var tmpX = mAcceleration.x;
                90 === window.orientation ? (mAcceleration.x = -mAcceleration.y, mAcceleration.y = tmpX) : -90 === window.orientation ? (mAcceleration.x = mAcceleration.y, 
                mAcceleration.y = -tmpX) : 180 === window.orientation && (mAcceleration.x = -mAcceleration.x, 
                mAcceleration.y = -mAcceleration.y), cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ && (mAcceleration.x = -mAcceleration.x, 
                mAcceleration.y = -mAcceleration.y);
            }
        }
    }, {
        key: "update",
        value: function update(dt) {
            this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, 
            eventManager.dispatchEvent(new EventAcceleration(this._acceleration))), this._accelCurTime += dt;
        }
    }, {
        key: "setAccelerometerInterval",
        value: function setAccelerometerInterval(interval) {
            this._accelInterval !== interval && (this._accelInterval = interval);
        }
    }, {
        key: "_getUnUsedIndex",
        value: function _getUnUsedIndex() {
            for (var temp = this._indexBitsUsed, now = cc.director.getCurrentTime(), i = 0; i < this._maxTouches; i++) {
                if (!(1 & temp)) return this._indexBitsUsed |= 1 << i, i;
                var touch = this._touches[i];
                if (now - touch.lastModified > TOUCH_TIMEOUT) {
                    this._removeUsedIndexBit(i);
                    var touchID = touch.getID();
                    return null !== touchID && delete this._touchesIntegerDict[touchID], i;
                }
                temp >>= 1;
            }
            return -1;
        }
    }, {
        key: "_removeUsedIndexBit",
        value: function _removeUsedIndexBit(index) {
            if (!(index < 0 || index >= this._maxTouches)) {
                var temp = 1 << index;
                temp = ~temp, this._indexBitsUsed &= temp;
            }
        }
    }, {
        key: "_registerMouseEvents",
        value: function _registerMouseEvents(element, prohibition) {
            this._registerPointerLockEvent(), prohibition || this._registerWindowMouseEvents(element), 
            this._registerElementMouseEvents(element, prohibition);
        }
    }, {
        key: "_registerPointerLockEvent",
        value: function _registerPointerLockEvent() {
            var _this = this, lockChangeAlert = function lockChangeAlert() {
                var canvas = cc.game.canvas;
                document.pointerLockElement === canvas || document.mozPointerLockElement === canvas ? _this._pointLocked = !0 : _this._pointLocked = !1;
            };
            "onpointerlockchange" in document ? document.addEventListener("pointerlockchange", lockChangeAlert, !1) : "onmozpointerlockchange" in document && document.addEventListener("mozpointerlockchange", lockChangeAlert, !1);
        }
    }, {
        key: "_registerWindowMouseEvents",
        value: function _registerWindowMouseEvents(element) {
            var _this2 = this;
            window.addEventListener("mousedown", (function() {
                _this2._mousePressed = !0;
            }), !1), window.addEventListener("mouseup", (function(event) {
                if (_this2._mousePressed) {
                    _this2._mousePressed = !1;
                    var position = _this2.getHTMLElementPosition(element), location = _this2.getPointByEvent(event, position);
                    if (!rect(position.left, position.top, position.width, position.height).contains(new Vec2(location.x, location.y))) {
                        _this2.handleTouchesEnd([ _this2.getTouchByXY(event, location.x, location.y, position) ]);
                        var _mouseEvent = _this2.getMouseEvent(location, position, EventMouse.UP);
                        _mouseEvent.setButton(event.button), eventManager.dispatchEvent(_mouseEvent);
                    }
                }
            }), !1);
        }
    }, {
        key: "_registerElementMouseEvents",
        value: function _registerElementMouseEvents(element, prohibition) {
            var _this3 = this, listenDOMMouseEvent = function listenDOMMouseEvent(eventName, type, handler) {
                element.addEventListener(eventName, (function(event) {
                    var pos = _this3.getHTMLElementPosition(element), location = _this3.getPointByEvent(event, pos), mouseEvent = _this3.getMouseEvent(location, pos, type);
                    mouseEvent.setButton(event.button), handler(event, mouseEvent, location, pos), eventManager.dispatchEvent(mouseEvent), 
                    event.stopPropagation(), event.preventDefault();
                }));
            };
            prohibition || (listenDOMMouseEvent("mousedown", EventMouse.DOWN, (function(event, mouseEvent, location, pos) {
                _this3._mousePressed = !0, _this3.handleTouchesBegin([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                element.focus();
            })), listenDOMMouseEvent("mouseup", EventMouse.UP, (function(event, mouseEvent, location, pos) {
                _this3._mousePressed = !1, _this3.handleTouchesEnd([ _this3.getTouchByXY(event, location.x, location.y, pos) ]);
            })), listenDOMMouseEvent("mousemove", EventMouse.MOVE, (function(event, mouseEvent, location, pos) {
                _this3.handleTouchesMove([ _this3.getTouchByXY(event, location.x, location.y, pos) ]), 
                _this3._mousePressed || mouseEvent.setButton(EventMouse.BUTTON_MISSING), void 0 !== event.movementX && void 0 !== event.movementY && (mouseEvent.movementX = event.movementX, 
                mouseEvent.movementY = event.movementY);
            }))), listenDOMMouseEvent("mousewheel", EventMouse.SCROLL, (function(event, mouseEvent, location, pos) {
                mouseEvent.setScrollData(0, event.wheelDelta);
            })), listenDOMMouseEvent("DOMMouseScroll", EventMouse.SCROLL, (function(event, mouseEvent, location, pos) {
                mouseEvent.setScrollData(0, -120 * event.detail);
            }));
        }
    }, {
        key: "_registerMousePointerEvents",
        value: function _registerMousePointerEvents(element) {
            var _this4 = this, _pointerEventsMap = {
                MSPointerDown: this.handleTouchesBegin,
                MSPointerMove: this.handleTouchesMove,
                MSPointerUp: this.handleTouchesEnd,
                MSPointerCancel: this.handleTouchesCancel
            }, _loop = function _loop(eventName) {
                var touchEvent = _pointerEventsMap[eventName];
                element.addEventListener(eventName, (function(event) {
                    var pos = _this4.getHTMLElementPosition(element);
                    pos.left -= document.documentElement.scrollLeft, pos.top -= document.documentElement.scrollTop, 
                    touchEvent.call(_this4, [ _this4.getTouchByXY(event, event.clientX, event.clientY, pos) ]), 
                    event.stopPropagation();
                }), !1);
            };
            for (var eventName in _pointerEventsMap) _loop(eventName);
        }
    }, {
        key: "_registerTouchEvents",
        value: function _registerTouchEvents(element) {
            var _this5 = this, makeTouchListener = function makeTouchListener(touchesHandler) {
                return function(event) {
                    if (event.changedTouches) {
                        var pos = _this5.getHTMLElementPosition(element), body = document.body;
                        pos.left -= body.scrollLeft || 0, pos.top -= body.scrollTop || 0, touchesHandler(_this5.getTouchesByEvent(event, pos)), 
                        event.stopPropagation(), event.preventDefault();
                    }
                };
            };
            element.addEventListener("touchstart", makeTouchListener((function(touchesToHandle) {
                _this5.handleTouchesBegin(touchesToHandle), sys.platform !== sys.WECHAT_GAME && element.focus();
            })), !1), element.addEventListener("touchmove", makeTouchListener((function(touchesToHandle) {
                _this5.handleTouchesMove(touchesToHandle);
            })), !1), element.addEventListener("touchend", makeTouchListener((function(touchesToHandle) {
                _this5.handleTouchesEnd(touchesToHandle);
            })), !1), element.addEventListener("touchcancel", makeTouchListener((function(touchesToHandle) {
                _this5.handleTouchesCancel(touchesToHandle);
            })), !1);
        }
    }, {
        key: "_registerKeyboardEvent",
        value: function _registerKeyboardEvent() {
            var canvas = cc.game.canvas;
            canvas.addEventListener("keydown", (function(event) {
                eventManager.dispatchEvent(new EventKeyboard(event, !0)), event.stopPropagation(), 
                event.preventDefault();
            }), !1), canvas.addEventListener("keyup", (function(event) {
                eventManager.dispatchEvent(new EventKeyboard(event, !1)), event.stopPropagation(), 
                event.preventDefault();
            }), !1);
        }
    }, {
        key: "_registerAccelerometerEvent",
        value: function _registerAccelerometerEvent() {
            var _this6 = this;
            this._acceleration = new Acceleration$1, this._accelDeviceEvent = window.DeviceMotionEvent || window.DeviceOrientationEvent, 
            cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
            var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
            _didAccelerateFun = function _didAccelerateFun() {
                return _this6.didAccelerate.apply(_this6, arguments);
            }, window.addEventListener(_deviceEventType, _didAccelerateFun, !1);
        }
    }, {
        key: "_unregisterAccelerometerEvent",
        value: function _unregisterAccelerometerEvent() {
            var _deviceEventType = this._accelDeviceEvent === window.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
            _didAccelerateFun && window.removeEventListener(_deviceEventType, _didAccelerateFun, !1);
        }
    } ]), InputManager;
}());

cc.internal.inputManager = inputManager;

var Game = function(_EventTarget) {
    function Game() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, Game);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Game)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).frame = null, 
        _this.container = null, _this.canvas = null, _this.renderType = -1, _this.eventTargetOn = _get(_getPrototypeOf(Game.prototype), "on", _assertThisInitialized(_this)), 
        _this.eventTargetOnce = _get(_getPrototypeOf(Game.prototype), "once", _assertThisInitialized(_this)), 
        _this.config = {}, _this.onStart = null, _this._persistRootNodes = {}, _this._paused = !0, 
        _this._configLoaded = !1, _this._isCloning = !1, _this._inited = !1, _this._rendererInitialized = !1, 
        _this._gfxDevice = null, _this._intervalId = null, _this._lastTime = null, _this._frameTime = null, 
        _this._sceneInfos = [], _this.collisionMatrix = [], _this.groupList = [], _this;
    }
    return _inherits(Game, EventTarget), _createClass(Game, [ {
        key: "setFrameRate",
        value: function setFrameRate(frameRate) {
            var config = this.config;
            "number" != typeof frameRate && (frameRate = parseInt(frameRate), isNaN(frameRate) && (frameRate = 60)), 
            config.frameRate = frameRate, this._paused = !0, this._setAnimFrame(), this._runMainLoop();
        }
    }, {
        key: "getFrameRate",
        value: function getFrameRate() {
            return this.config.frameRate || 0;
        }
    }, {
        key: "step",
        value: function step() {
            cc.director.mainLoop();
        }
    }, {
        key: "pause",
        value: function pause() {
            this._paused || (this._paused = !0, this._intervalId && (window.cAF(this._intervalId), 
            this._intervalId = 0));
        }
    }, {
        key: "resume",
        value: function resume() {
            this._paused && (this._paused = !1, this._runMainLoop());
        }
    }, {
        key: "isPaused",
        value: function isPaused() {
            return this._paused;
        }
    }, {
        key: "restart",
        value: function restart() {
            cc.director.once(cc.Director.EVENT_AFTER_DRAW, (function() {
                for (var id in cc.game._persistRootNodes) cc.game.removePersistRootNode(cc.game._persistRootNodes[id]);
                cc.director.getScene().destroy(), cc.Object._deferredDestroy(), cc.director.reset(), 
                cc.game.onStart(), cc.game._safeEmit(cc.Game.EVENT_RESTART);
            }));
        }
    }, {
        key: "end",
        value: function end() {
            this._gfxDevice && (this._gfxDevice.destroy(), this._gfxDevice = null), close();
        }
    }, {
        key: "on",
        value: function on(type, callback, target, once) {
            this._inited && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOn(type, callback, target, once);
        }
    }, {
        key: "once",
        value: function once(type, callback, target) {
            this._inited && type === Game.EVENT_ENGINE_INITED ? callback.call(target) : this.eventTargetOnce(type, callback, target);
        }
    }, {
        key: "init",
        value: function init(config) {
            return this._initConfig(config), this.config.assetOptions && AssetLibrary.init(this.config.assetOptions), 
            this._initEngine(), cc.internal.SplashScreenWebgl && this.canvas && cc.internal.SplashScreenWebgl.instance.main(this.canvas), 
            cc.director.root.dataPoolManager.jointTexturePool.registerCustomTextureLayouts(config.customJointTextureLayouts), 
            this._inited;
        }
    }, {
        key: "run",
        value: function run(onStart, legacyOnStart) {
            var _this2 = this;
            if (this._initEvents(), "function" != typeof onStart && legacyOnStart) {
                var config = this.onStart;
                this.init(config), this.onStart = legacyOnStart;
            } else this.onStart = onStart;
            this._setAnimFrame(), this._runMainLoop(), game.config.registerSystemEvent && inputManager.registerSystemEvent(game.canvas);
            var splashScreen = cc.internal.SplashScreenWebgl && cc.internal.SplashScreenWebgl.instance, useSplash = splashScreen;
            useSplash && splashScreen.setOnFinish((function() {
                _this2.onStart && _this2.onStart();
            }));
            var renderPipeline = this.config.renderPipeline;
            renderPipeline ? cc.loader.load({
                uuid: renderPipeline
            }, (function(err, asset) {
                !err && asset instanceof RenderPipeline ? _this2.setRenderPipeline(asset) : (console.warn("Failed load renderpipeline: ".concat(renderPipeline, ", engine failed to initialize, all process stopped")), 
                console.warn(err)), _this2._safeEmit(Game.EVENT_GAME_INITED), useSplash ? splashScreen.loadFinish = !0 : _this2.onStart && _this2.onStart();
            })) : (this._safeEmit(Game.EVENT_GAME_INITED), useSplash ? splashScreen.loadFinish = !0 : this.onStart && this.onStart());
        }
    }, {
        key: "addPersistRootNode",
        value: function addPersistRootNode(node) {
            if (cc.Node.isNode(node) && node.uuid) {
                var id = node.uuid;
                if (!this._persistRootNodes[id]) {
                    var scene = cc.director._scene;
                    if (cc.isValid(scene)) if (node.parent) {
                        if (!(node.parent instanceof cc.Scene)) return void warnID(3801);
                        if (node.parent !== scene) return void warnID(3802);
                    } else node.parent = scene;
                    this._persistRootNodes[id] = node, node._persistNode = !0;
                }
            } else warnID(3800);
        }
    }, {
        key: "removePersistRootNode",
        value: function removePersistRootNode(node) {
            var id = node.uuid || "";
            node === this._persistRootNodes[id] && (delete this._persistRootNodes[id], node._persistNode = !1);
        }
    }, {
        key: "isPersistRootNode",
        value: function isPersistRootNode(node) {
            return node._persistNode;
        }
    }, {
        key: "_initEngine",
        value: function _initEngine() {
            this._initDevice(), cc.director._init(), this.setRenderPipeline(), console.log("Cocos Creator 3D v" + cc.ENGINE_VERSION), 
            this._safeEmit(Game.EVENT_ENGINE_INITED), this._inited = !0;
        }
    }, {
        key: "_setAnimFrame",
        value: function _setAnimFrame() {
            this._lastTime = new Date;
            var frameRate = cc.game.config.frameRate;
            this._frameTime = 1e3 / frameRate, this._intervalId && (window.cAF(this._intervalId), 
            this._intervalId = 0), 60 !== frameRate && 30 !== frameRate ? (window.rAF = this._stTime, 
            window.cAF = this._ctTime) : (window.rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, 
            window.cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame || this._ctTime);
        }
    }, {
        key: "_stTime",
        value: function _stTime(callback) {
            var currTime = (new Date).getTime(), timeToCall = Math.max(0, cc.game._frameTime - (currTime - cc.game._lastTime)), id = window.setTimeout(callback, timeToCall);
            return cc.game._lastTime = currTime + timeToCall, id;
        }
    }, {
        key: "_ctTime",
        value: function _ctTime(id) {
            window.clearTimeout(id);
        }
    }, {
        key: "_runMainLoop",
        value: function _runMainLoop() {
            var _callback, _this3 = this, config = this.config, director = cc.director, skip = !0, frameRate = config.frameRate;
            setDisplayStats(!!config.showFPS), director.startAnimation(), _callback = function callback(time) {
                _this3._paused || (_this3._intervalId = window.rAF(_callback), 30 === frameRate && (skip = !skip) || director.mainLoop(time));
            }, this._intervalId && (window.cAF(this._intervalId), this._intervalId = 0), this._intervalId = window.rAF(_callback), 
            this._paused = !1;
        }
    }, {
        key: "_initConfig",
        value: function _initConfig(config) {
            "number" != typeof config.debugMode && (config.debugMode = 0), config.exposeClassName = !!config.exposeClassName, 
            "number" != typeof config.frameRate && (config.frameRate = 60);
            var renderMode = config.renderMode;
            ("number" != typeof renderMode || renderMode > 2 || renderMode < 0) && (config.renderMode = 0), 
            "boolean" != typeof config.registerSystemEvent && (config.registerSystemEvent = !0), 
            config.showFPS = !!config.showFPS, this._sceneInfos = config.scenes || [], this.collisionMatrix = config.collisionMatrix || [], 
            this.groupList = config.groupList || [], _resetDebugSetting(config.debugMode), this.config = config, 
            this._configLoaded = !0;
        }
    }, {
        key: "_determineRenderType",
        value: function _determineRenderType() {
            var config = this.config, userRenderMode = parseInt(config.renderMode);
            this.renderType = Game.RENDER_TYPE_CANVAS;
            var supportRender = !1;
            if (0 === userRenderMode ? cc.sys.capabilities.opengl ? (this.renderType = Game.RENDER_TYPE_WEBGL, 
            supportRender = !0) : cc.sys.capabilities.canvas && (this.renderType = Game.RENDER_TYPE_CANVAS, 
            supportRender = !0) : 1 === userRenderMode && cc.sys.capabilities.canvas ? (this.renderType = Game.RENDER_TYPE_CANVAS, 
            supportRender = !0) : 2 === userRenderMode && cc.sys.capabilities.opengl && (this.renderType = Game.RENDER_TYPE_WEBGL, 
            supportRender = !0), !supportRender) throw new Error(getError(3820, userRenderMode));
        }
    }, {
        key: "_initDevice",
        value: function _initDevice() {
            if (!this._rendererInitialized) {
                if (this.canvas = this.config.adapter.canvas, this.frame = this.config.adapter.frame, 
                this.container = this.config.adapter.container, this._determineRenderType(), this.renderType === Game.RENDER_TYPE_WEBGL) {
                    var useWebGL2 = !!window.WebGL2RenderingContext, userAgent = window.navigator.userAgent.toLowerCase();
                    (-1 !== userAgent.indexOf("safari") && -1 === userAgent.indexOf("chrome") || sys.browserType === sys.BROWSER_TYPE_UC) && (useWebGL2 = !1), 
                    useWebGL2 && cc.WebGL2GFXDevice ? this._gfxDevice = new cc.WebGL2GFXDevice : cc.WebGLGFXDevice && (this._gfxDevice = new cc.WebGLGFXDevice);
                    var opts = {
                        canvasElm: this.canvas,
                        debug: !0,
                        isAntialias: macro.ENABLE_WEBGL_ANTIALIAS,
                        devicePixelRatio: window.devicePixelRatio,
                        nativeWidth: Math.floor(screen.width * window.devicePixelRatio),
                        nativeHeight: Math.floor(screen.height * window.devicePixelRatio)
                    };
                    !this._gfxDevice.initialize(opts) && useWebGL2 && (this._gfxDevice = new cc.WebGLGFXDevice, 
                    this._gfxDevice.initialize(opts));
                }
                if (!this._gfxDevice) return console.error("can not support canvas rendering in 3D"), 
                void (this.renderType = Game.RENDER_TYPE_CANVAS);
                this.canvas.oncontextmenu = function() {
                    if (!cc._isContextMenuEnable) return !1;
                };
            }
        }
    }, {
        key: "_initEvents",
        value: function _initEvents() {
            var hiddenPropName, win = window;
            void 0 !== document.hidden ? hiddenPropName = "hidden" : void 0 !== document.mozHidden ? hiddenPropName = "mozHidden" : void 0 !== document.msHidden ? hiddenPropName = "msHidden" : void 0 !== document.webkitHidden && (hiddenPropName = "webkitHidden");
            var hidden = !1;
            function onHidden() {
                hidden || (hidden = !0, cc.game.emit(Game.EVENT_HIDE));
            }
            function onShown() {
                hidden && (hidden = !1, cc.game.emit(Game.EVENT_SHOW));
            }
            if (hiddenPropName) for (var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ], i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], (function(event) {
                var visible = document[hiddenPropName];
                (visible = visible || event.hidden) ? onHidden() : onShown();
            })); else win.addEventListener("blur", onHidden), win.addEventListener("focus", onShown);
            window.navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = onShown), 
            "onpageshow" in window && "onpagehide" in window && (win.addEventListener("pagehide", onHidden), 
            win.addEventListener("pageshow", onShown), document.addEventListener("pagehide", onHidden), 
            document.addEventListener("pageshow", onShown)), this.on(Game.EVENT_HIDE, (function() {
                cc.game.pause();
            })), this.on(Game.EVENT_SHOW, (function() {
                cc.game.resume();
            }));
        }
    }, {
        key: "setRenderPipeline",
        value: function setRenderPipeline(rppl) {
            rppl || (rppl = new ForwardPipeline).initialize(ForwardPipeline.initInfo), cc.director.root.setRenderPipeline(rppl) || this.setRenderPipeline(), 
            this._rendererInitialized = !0, this._safeEmit(Game.EVENT_RENDERER_INITED);
        }
    }, {
        key: "_safeEmit",
        value: function _safeEmit(event) {
            this.emit(event);
        }
    }, {
        key: "inited",
        get: function get() {
            return this._inited;
        }
    } ]), Game;
}();

Game.EVENT_HIDE = "game_on_hide", Game.EVENT_SHOW = "game_on_show", Game.EVENT_GAME_INITED = "game_inited", 
Game.EVENT_ENGINE_INITED = "engine_inited", Game.EVENT_RENDERER_INITED = "renderer_inited", 
Game.EVENT_RESTART = "game_on_restart", Game.RENDER_TYPE_CANVAS = 0, Game.RENDER_TYPE_WEBGL = 1, 
Game.RENDER_TYPE_OPENGL = 2, cc.Game = Game;

var game = cc.game = new Game, __BrowserGetter = new (function() {
    function BrowserGetter() {
        _classCallCheck(this, BrowserGetter), this.html = void 0, this.meta = {
            width: "device-width"
        }, this.adaptationType = cc.sys.browserType;
    }
    return _createClass(BrowserGetter, [ {
        key: "init",
        value: function init() {}
    }, {
        key: "availWidth",
        value: function availWidth(frame) {
            return cc.sys.isMobile || !frame || frame === this.html ? window.innerWidth : frame.clientWidth;
        }
    }, {
        key: "availHeight",
        value: function availHeight(frame) {
            return cc.sys.isMobile || !frame || frame === this.html ? window.innerHeight : frame.clientHeight;
        }
    } ]), BrowserGetter;
}());

cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI), 
__BrowserGetter.availWidth = function() {
    return window.innerWidth;
}, __BrowserGetter.availHeight = function() {
    return window.innerHeight;
};

var View = function(_EventTarget) {
    function View() {
        var _this;
        _classCallCheck(this, View), (_this = _possibleConstructorReturn(this, _getPrototypeOf(View).call(this)))._resizeWithBrowserSize = void 0, 
        _this._designResolutionSize = void 0, _this._originalDesignResolutionSize = void 0, 
        _this._frameSize = void 0, _this._scaleX = void 0, _this._scaleY = void 0, _this._viewportRect = void 0, 
        _this._visibleRect = void 0, _this._autoFullScreen = void 0, _this._devicePixelRatio = void 0, 
        _this._maxPixelRatio = void 0, _this._retinaEnabled = void 0, _this._resizeCallback = void 0, 
        _this._resizing = void 0, _this._orientationChanging = void 0, _this._isRotated = void 0, 
        _this._orientation = void 0, _this._isAdjustViewport = void 0, _this._antiAliasEnabled = void 0, 
        _this._resolutionPolicy = void 0, _this._rpExactFit = void 0, _this._rpShowAll = void 0, 
        _this._rpNoBorder = void 0, _this._rpFixedHeight = void 0, _this._rpFixedWidth = void 0;
        _assertThisInitialized(_this);
        var _strategyer = ContainerStrategy, _strategy = ContentStrategy;
        return _this._frameSize = new Size(0, 0), _this._designResolutionSize = new Size(0, 0), 
        _this._originalDesignResolutionSize = new Size(0, 0), _this._scaleX = 1, _this._scaleY = 1, 
        _this._viewportRect = new Rect(0, 0, 0, 0), _this._visibleRect = new Rect(0, 0, 0, 0), 
        _this._autoFullScreen = !1, _this._devicePixelRatio = 1, _this._maxPixelRatio = 2, 
        _this._retinaEnabled = !1, _this._resizeCallback = null, _this._resizing = !1, _this._resizeWithBrowserSize = !1, 
        _this._orientationChanging = !0, _this._isRotated = !1, _this._orientation = cc.macro.ORIENTATION_AUTO, 
        _this._isAdjustViewport = !0, _this._antiAliasEnabled = !1, _this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT), 
        _this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL), 
        _this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER), 
        _this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT), 
        _this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH), 
        _this._resolutionPolicy = _this._rpShowAll, cc.game.once(cc.Game.EVENT_ENGINE_INITED, _this.init, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(View, EventTarget), _createClass(View, [ {
        key: "init",
        value: function init() {
            __BrowserGetter.init(), this._initFrameSize(), this.enableAntiAlias(!0);
            var w = cc.game.canvas.width, h = cc.game.canvas.height;
            this._designResolutionSize.width = w, this._designResolutionSize.height = h, this._originalDesignResolutionSize.width = w, 
            this._originalDesignResolutionSize.height = h, this._viewportRect.width = w, this._viewportRect.height = h, 
            this._visibleRect.width = w, this._visibleRect.height = h, cc.winSize.width = this._visibleRect.width, 
            cc.winSize.height = this._visibleRect.height, cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        }
    }, {
        key: "resizeWithBrowserSize",
        value: function resizeWithBrowserSize(enabled) {
            enabled ? this._resizeWithBrowserSize || (this._resizeWithBrowserSize = !0, window.addEventListener("resize", this._resizeEvent), 
            window.addEventListener("orientationchange", this._orientationChange)) : this._resizeWithBrowserSize && (this._resizeWithBrowserSize = !1, 
            window.removeEventListener("resize", this._resizeEvent), window.removeEventListener("orientationchange", this._orientationChange));
        }
    }, {
        key: "setResizeCallback",
        value: function setResizeCallback(callback) {
            "function" != typeof callback && null != callback || (this._resizeCallback = callback);
        }
    }, {
        key: "setOrientation",
        value: function setOrientation(orientation) {
            (orientation &= cc.macro.ORIENTATION_AUTO) && this._orientation !== orientation && (this._orientation = orientation);
        }
    }, {
        key: "adjustViewportMeta",
        value: function adjustViewportMeta(enabled) {
            this._isAdjustViewport = enabled;
        }
    }, {
        key: "enableRetina",
        value: function enableRetina(enabled) {
            this._retinaEnabled = !!enabled;
        }
    }, {
        key: "isRetinaEnabled",
        value: function isRetinaEnabled() {
            return this._retinaEnabled;
        }
    }, {
        key: "enableAntiAlias",
        value: function enableAntiAlias(enabled) {
            if (this._antiAliasEnabled !== enabled) if (this._antiAliasEnabled = enabled, cc.game.renderType === cc.Game.RENDER_TYPE_WEBGL) {
                var cache = cc.loader._cache;
                for (var key in cache) {
                    var item = cache[key], tex = item && item.content instanceof cc.Texture2D ? item.content : null;
                    if (tex) {
                        var Filter = cc.Texture2D.Filter;
                        enabled ? tex.setFilters(Filter.LINEAR, Filter.LINEAR) : tex.setFilters(Filter.NEAREST, Filter.NEAREST);
                    }
                }
            } else if (cc.game.renderType === cc.Game.RENDER_TYPE_CANVAS) {
                var ctx = cc.game.canvas.getContext("2d");
                ctx.imageSmoothingEnabled = enabled, ctx.mozImageSmoothingEnabled = enabled;
            }
        }
    }, {
        key: "isAntiAliasEnabled",
        value: function isAntiAliasEnabled() {
            return this._antiAliasEnabled;
        }
    }, {
        key: "enableAutoFullScreen",
        value: function enableAutoFullScreen(enabled) {
            enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT ? (this._autoFullScreen = !0, 
            cc.screen.autoFullScreen(cc.game.frame)) : this._autoFullScreen = !1;
        }
    }, {
        key: "isAutoFullScreenEnabled",
        value: function isAutoFullScreenEnabled() {
            return this._autoFullScreen;
        }
    }, {
        key: "setCanvasSize",
        value: function setCanvasSize(width, height) {
            var canvas = cc.game.canvas, container = cc.game.container;
            this._devicePixelRatio = window.devicePixelRatio, canvas.width = width * this._devicePixelRatio, 
            canvas.height = height * this._devicePixelRatio, canvas.style.width = width + "px", 
            canvas.style.height = height + "px", container.style.width = width + "px", container.style.height = height + "px", 
            this._resizeEvent();
        }
    }, {
        key: "getCanvasSize",
        value: function getCanvasSize() {
            return new Size(cc.game.canvas.width, cc.game.canvas.height);
        }
    }, {
        key: "getFrameSize",
        value: function getFrameSize() {
            return new Size(this._frameSize.width, this._frameSize.height);
        }
    }, {
        key: "setFrameSize",
        value: function setFrameSize(width, height) {
            this._frameSize.width = width, this._frameSize.height = height, cc.frame.style.width = width + "px", 
            cc.frame.style.height = height + "px", this._resizeEvent();
        }
    }, {
        key: "getVisibleSize",
        value: function getVisibleSize() {
            return new Size(this._visibleRect.width, this._visibleRect.height);
        }
    }, {
        key: "getVisibleSizeInPixel",
        value: function getVisibleSizeInPixel() {
            return new Size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
        }
    }, {
        key: "getVisibleOrigin",
        value: function getVisibleOrigin() {
            return new Vec2(this._visibleRect.x, this._visibleRect.y);
        }
    }, {
        key: "getVisibleOriginInPixel",
        value: function getVisibleOriginInPixel() {
            return new Vec2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
        }
    }, {
        key: "getResolutionPolicy",
        value: function getResolutionPolicy() {
            return this._resolutionPolicy;
        }
    }, {
        key: "setResolutionPolicy",
        value: function setResolutionPolicy(resolutionPolicy) {
            var _t = this;
            if (resolutionPolicy instanceof ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
                var _locPolicy = ResolutionPolicy;
                resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit), 
                resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll), 
                resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder), 
                resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight), 
                resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
            }
        }
    }, {
        key: "setDesignResolutionSize",
        value: function setDesignResolutionSize(width, height, resolutionPolicy) {
            if (width > 0 || height > 0) {
                this.setResolutionPolicy(resolutionPolicy);
                var policy = this._resolutionPolicy;
                if (policy && policy.preApply(this), cc.sys.isMobile && this._adjustViewportMeta(), 
                this._orientationChanging = !0, this._resizing || this._initFrameSize(), policy) {
                    this._originalDesignResolutionSize.width = this._designResolutionSize.width = width, 
                    this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
                    var result = policy.apply(this, this._designResolutionSize);
                    if (result.scale && 2 === result.scale.length && (this._scaleX = result.scale[0], 
                    this._scaleY = result.scale[1]), result.viewport) {
                        var vp = this._viewportRect, vb = this._visibleRect, rv = result.viewport;
                        vp.x = rv.x, vp.y = rv.y, vp.width = rv.width, vp.height = rv.height, vb.x = 0, 
                        vb.y = 0, vb.width = rv.width / this._scaleX, vb.height = rv.height / this._scaleY;
                    }
                    policy.postApply(this), cc.winSize.width = this._visibleRect.width, cc.winSize.height = this._visibleRect.height, 
                    visibleRect && visibleRect.init(this._visibleRect), this.emit("design-resolution-changed");
                } else cc.logID(2201);
            } else cc.logID(2200);
        }
    }, {
        key: "getDesignResolutionSize",
        value: function getDesignResolutionSize() {
            return new Size(this._designResolutionSize.width, this._designResolutionSize.height);
        }
    }, {
        key: "setRealPixelResolution",
        value: function setRealPixelResolution(width, height, resolutionPolicy) {
            this.setDesignResolutionSize(width, height, resolutionPolicy);
        }
    }, {
        key: "getViewportRect",
        value: function getViewportRect() {
            return this._viewportRect;
        }
    }, {
        key: "getScaleX",
        value: function getScaleX() {
            return this._scaleX;
        }
    }, {
        key: "getScaleY",
        value: function getScaleY() {
            return this._scaleY;
        }
    }, {
        key: "getDevicePixelRatio",
        value: function getDevicePixelRatio() {
            return this._devicePixelRatio;
        }
    }, {
        key: "convertToLocationInView",
        value: function convertToLocationInView(tx, ty, relatedPos, out) {
            var result = out || new Vec2, x = this._devicePixelRatio * (tx - relatedPos.left), y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
            return this._isRotated ? (result.x = cc.game.canvas.width - y, result.y = x) : (result.x = x, 
            result.y = y), result;
        }
    }, {
        key: "_convertPointWithScale",
        value: function _convertPointWithScale(point) {
            var viewport = this._viewportRect;
            point.x = (point.x - viewport.x) / this._scaleX, point.y = (point.y - viewport.y) / this._scaleY;
        }
    }, {
        key: "_resizeEvent",
        value: function _resizeEvent() {
            var _view = cc.view, prevFrameW = _view._frameSize.width, prevFrameH = _view._frameSize.height, prevRotated = _view._isRotated;
            if (cc.sys.isMobile) {
                var containerStyle = cc.game.container.style, margin = containerStyle.margin;
                containerStyle.margin = "0", containerStyle.display = "none", _view._initFrameSize(), 
                containerStyle.margin = margin, containerStyle.display = "block";
            } else _view._initFrameSize();
            if (_view._orientationChanging || _view._isRotated !== prevRotated || _view._frameSize.width !== prevFrameW || _view._frameSize.height !== prevFrameH) {
                var width = _view._originalDesignResolutionSize.width, height = _view._originalDesignResolutionSize.height;
                _view._resizing = !0, width > 0 && _view.setDesignResolutionSize(width, height, _view._resolutionPolicy), 
                _view._resizing = !1, _view._resizeCallback && _view._resizeCallback.call();
            }
        }
    }, {
        key: "_orientationChange",
        value: function _orientationChange() {
            cc.view._orientationChanging = !0, cc.view._resizeEvent();
        }
    }, {
        key: "_initFrameSize",
        value: function _initFrameSize() {
            var locFrameSize = this._frameSize, w = __BrowserGetter.availWidth(cc.game.frame), h = __BrowserGetter.availHeight(cc.game.frame), isLandscape = w >= h;
            !cc.sys.isMobile || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT ? (locFrameSize.width = w, 
            locFrameSize.height = h, cc.game.container.style["-webkit-transform"] = "rotate(0deg)", 
            cc.game.container.style.transform = "rotate(0deg)", this._isRotated = !1) : (locFrameSize.width = h, 
            locFrameSize.height = w, cc.game.container.style["-webkit-transform"] = "rotate(90deg)", 
            cc.game.container.style.transform = "rotate(90deg)", cc.game.container.style["-webkit-transform-origin"] = "0px 0px 0px", 
            cc.game.container.style.transformOrigin = "0px 0px 0px", this._isRotated = !0, cc.game.canvas.style["-webkit-transform"] = "translateZ(0px)", 
            cc.game.canvas.style.transform = "translateZ(0px)"), this._orientationChanging && setTimeout((function() {
                cc.view._orientationChanging = !1;
            }), 1e3);
        }
    }, {
        key: "_adjustSizeKeepCanvasSize",
        value: function _adjustSizeKeepCanvasSize() {
            var designWidth = this._originalDesignResolutionSize.width, designHeight = this._originalDesignResolutionSize.height;
            designWidth > 0 && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
        }
    }, {
        key: "_setViewportMeta",
        value: function _setViewportMeta(metas, overwrite) {
            var vp = document.getElementById("cocosMetaElement");
            vp && overwrite && document.head.removeChild(vp);
            var content, key, pattern, elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null;
            for (key in content = currentVP ? currentVP.content : "", (vp = vp || document.createElement("meta")).id = "cocosMetaElement", 
            vp.name = "viewport", vp.content = "", metas) -1 === content.indexOf(key) ? content += "," + key + "=" + metas[key] : overwrite && (pattern = new RegExp(key + "s*=s*[^,]+"), 
            content.replace(pattern, key + "=" + metas[key]));
            /^,/.test(content) && (content = content.substr(1)), vp.content = content, currentVP && (currentVP.content = content), 
            document.head.appendChild(vp);
        }
    }, {
        key: "_adjustViewportMeta",
        value: function _adjustViewportMeta() {
            this._isAdjustViewport, 0;
        }
    }, {
        key: "_convertMouseToLocation",
        value: function _convertMouseToLocation(in_out_point, relatedPos) {
            in_out_point.x = this._devicePixelRatio * (in_out_point.x - relatedPos.left), in_out_point.y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y);
        }
    }, {
        key: "_convertTouchWidthScale",
        value: function _convertTouchWidthScale(selTouch) {
            var viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY;
            selTouch._point.x = (selTouch._point.x - viewport.x) / scaleX, selTouch._point.y = (selTouch._point.y - viewport.y) / scaleY, 
            selTouch._prevPoint.x = (selTouch._prevPoint.x - viewport.x) / scaleX, selTouch._prevPoint.y = (selTouch._prevPoint.y - viewport.y) / scaleY;
        }
    }, {
        key: "_convertTouchesWithScale",
        value: function _convertTouchesWithScale(touches) {
            for (var selPoint, selPrePoint, viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY, i = 0; i < touches.length; i++) {
                var selTouch = touches[i];
                selPoint = selTouch._point, selPrePoint = selTouch._prevPoint, selPoint.x = (selPoint.x - viewport.x) / scaleX, 
                selPoint.y = (selPoint.y - viewport.y) / scaleY, selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX, 
                selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
            }
        }
    } ]), View;
}();

View.instance = void 0;

var ContainerStrategy = function() {
    function ContainerStrategy() {
        _classCallCheck(this, ContainerStrategy), this.name = "ContainerStrategy";
    }
    return _createClass(ContainerStrategy, [ {
        key: "preApply",
        value: function preApply(_view) {}
    }, {
        key: "apply",
        value: function apply(_view, designedResolution) {}
    }, {
        key: "postApply",
        value: function postApply(_view) {}
    }, {
        key: "_setupContainer",
        value: function _setupContainer(_view, w, h) {
            var locCanvas = cc.game.canvas, locContainer = cc.game.container;
            cc.sys.platform !== cc.sys.WECHAT_GAME && (cc.sys.os === cc.sys.OS_ANDROID && (document.body.style.width = (_view._isRotated ? h : w) + "px", 
            document.body.style.height = (_view._isRotated ? w : h) + "px"), locContainer.style.width = locCanvas.style.width = w + "px", 
            locContainer.style.height = locCanvas.style.height = h + "px");
            var devicePixelRatio = _view._devicePixelRatio = 1;
            _view.isRetinaEnabled() && (devicePixelRatio = _view._devicePixelRatio = Math.min(_view._maxPixelRatio, window.devicePixelRatio || 1)), 
            locCanvas.width = w * devicePixelRatio, locCanvas.height = h * devicePixelRatio;
        }
    }, {
        key: "_fixContainer",
        value: function _fixContainer() {
            document.body.insertBefore(cc.game.container, document.body.firstChild);
            var bs = document.body.style;
            bs.width = window.innerWidth + "px", bs.height = window.innerHeight + "px", bs.overflow = "hidden";
            var contStyle = cc.game.container.style;
            contStyle.position = "fixed", contStyle.left = contStyle.top = "0px", document.body.scrollTop = 0;
        }
    } ]), ContainerStrategy;
}();

ContainerStrategy.EQUAL_TO_FRAME = void 0, ContainerStrategy.PROPORTION_TO_FRAME = void 0;

var ContentStrategy = function() {
    function ContentStrategy() {
        _classCallCheck(this, ContentStrategy), this.name = "ContentStrategy", this._result = void 0, 
        this._result = {
            scale: [ 1, 1 ],
            viewport: null
        };
    }
    return _createClass(ContentStrategy, [ {
        key: "preApply",
        value: function preApply(_view) {}
    }, {
        key: "apply",
        value: function apply(_view, designedResolution) {
            return {
                scale: [ 1, 1 ]
            };
        }
    }, {
        key: "postApply",
        value: function postApply(_view) {}
    }, {
        key: "_buildResult",
        value: function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
            Math.abs(containerW - contentW) < 2 && (contentW = containerW), Math.abs(containerH - contentH) < 2 && (contentH = containerH);
            var viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
            return this._result.scale = [ scaleX, scaleY ], this._result.viewport = viewport, 
            this._result;
        }
    } ]), ContentStrategy;
}();

ContentStrategy.EXACT_FIT = void 0, ContentStrategy.SHOW_ALL = void 0, ContentStrategy.NO_BORDER = void 0, 
ContentStrategy.FIXED_HEIGHT = void 0, ContentStrategy.FIXED_WIDTH = void 0, function() {
    var EqualToFrame = function(_ContainerStrategy) {
        function EqualToFrame() {
            var _getPrototypeOf2, _this2;
            _classCallCheck(this, EqualToFrame);
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EqualToFrame)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).name = "EqualToFrame", 
            _this2;
        }
        return _inherits(EqualToFrame, ContainerStrategy), _createClass(EqualToFrame, [ {
            key: "apply",
            value: function apply(_view) {
                var frameH = _view._frameSize.height, containerStyle = cc.game.container.style;
                this._setupContainer(_view, _view._frameSize.width, _view._frameSize.height), _view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                containerStyle.padding = "0px";
            }
        } ]), EqualToFrame;
    }(), ProportionalToFrame = function(_ContainerStrategy2) {
        function ProportionalToFrame() {
            var _getPrototypeOf3, _this3;
            _classCallCheck(this, ProportionalToFrame);
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
            return (_this3 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(ProportionalToFrame)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).name = "ProportionalToFrame", 
            _this3;
        }
        return _inherits(ProportionalToFrame, ContainerStrategy), _createClass(ProportionalToFrame, [ {
            key: "apply",
            value: function apply(_view, designedResolution) {
                var containerW, containerH, frameW = _view._frameSize.width, frameH = _view._frameSize.height, containerStyle = cc.game.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH;
                scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
                containerH = frameH);
                var offx = Math.round((frameW - containerW) / 2), offy = Math.round((frameH - containerH) / 2);
                containerW = frameW - 2 * offx, containerH = frameH - 2 * offy, this._setupContainer(_view, containerW, containerH), 
                _view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px", 
                containerStyle.paddingLeft = offx + "px", containerStyle.paddingRight = offx + "px", 
                containerStyle.paddingTop = offy + "px", containerStyle.paddingBottom = offy + "px";
            }
        } ]), ProportionalToFrame;
    }(), globalAdapter = ("undefined" == typeof window ? global : window).__globalAdapter;
    globalAdapter && (globalAdapter.adaptContainerStrategy && globalAdapter.adaptContainerStrategy(ContainerStrategy.prototype), 
    globalAdapter.adaptView && globalAdapter.adaptView(View.prototype)), ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame, 
    ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame;
    var ExactFit = function(_ContentStrategy) {
        function ExactFit() {
            var _getPrototypeOf4, _this4;
            _classCallCheck(this, ExactFit);
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
            return (_this4 = _possibleConstructorReturn(this, (_getPrototypeOf4 = _getPrototypeOf(ExactFit)).call.apply(_getPrototypeOf4, [ this ].concat(args)))).name = "ExactFit", 
            _this4;
        }
        return _inherits(ExactFit, ContentStrategy), _createClass(ExactFit, [ {
            key: "apply",
            value: function apply(_view, designedResolution) {
                var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
                return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
            }
        } ]), ExactFit;
    }(), ShowAll = function(_ContentStrategy2) {
        function ShowAll() {
            var _getPrototypeOf5, _this5;
            _classCallCheck(this, ShowAll);
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
            return (_this5 = _possibleConstructorReturn(this, (_getPrototypeOf5 = _getPrototypeOf(ShowAll)).call.apply(_getPrototypeOf5, [ this ].concat(args)))).name = "ShowAll", 
            _this5;
        }
        return _inherits(ShowAll, ContentStrategy), _createClass(ShowAll, [ {
            key: "apply",
            value: function apply(_view, designedResolution) {
                var contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0;
                return scaleX < scaleY ? (contentW = containerW, contentH = designH * (scale = scaleX)) : (contentW = designW * (scale = scaleY), 
                contentH = containerH), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
            }
        } ]), ShowAll;
    }(), NoBorder = function(_ContentStrategy3) {
        function NoBorder() {
            var _getPrototypeOf6, _this6;
            _classCallCheck(this, NoBorder);
            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
            return (_this6 = _possibleConstructorReturn(this, (_getPrototypeOf6 = _getPrototypeOf(NoBorder)).call.apply(_getPrototypeOf6, [ this ].concat(args)))).name = "NoBorder", 
            _this6;
        }
        return _inherits(NoBorder, ContentStrategy), _createClass(NoBorder, [ {
            key: "apply",
            value: function apply(_view, designedResolution) {
                var scale, contentW, contentH, containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH;
                return scaleX < scaleY ? (contentW = designW * (scale = scaleY), contentH = containerH) : (contentW = containerW, 
                contentH = designH * (scale = scaleX)), this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
            }
        } ]), NoBorder;
    }(), FixedHeight = function(_ContentStrategy4) {
        function FixedHeight() {
            var _getPrototypeOf7, _this7;
            _classCallCheck(this, FixedHeight);
            for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) args[_key6] = arguments[_key6];
            return (_this7 = _possibleConstructorReturn(this, (_getPrototypeOf7 = _getPrototypeOf(FixedHeight)).call.apply(_getPrototypeOf7, [ this ].concat(args)))).name = "FixedHeight", 
            _this7;
        }
        return _inherits(FixedHeight, ContentStrategy), _createClass(FixedHeight, [ {
            key: "apply",
            value: function apply(_view, designedResolution) {
                var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerH / designedResolution.height, contentW = containerW, contentH = containerH;
                return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
            }
        } ]), FixedHeight;
    }(), FixedWidth = function(_ContentStrategy5) {
        function FixedWidth() {
            var _getPrototypeOf8, _this8;
            _classCallCheck(this, FixedWidth);
            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) args[_key7] = arguments[_key7];
            return (_this8 = _possibleConstructorReturn(this, (_getPrototypeOf8 = _getPrototypeOf(FixedWidth)).call.apply(_getPrototypeOf8, [ this ].concat(args)))).name = "FixedWidth", 
            _this8;
        }
        return _inherits(FixedWidth, ContentStrategy), _createClass(FixedWidth, [ {
            key: "apply",
            value: function apply(_view, designedResolution) {
                var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scale = containerW / designedResolution.width, contentW = containerW, contentH = containerH;
                return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
            }
        } ]), FixedWidth;
    }();
    ContentStrategy.EXACT_FIT = new ExactFit, ContentStrategy.SHOW_ALL = new ShowAll, 
    ContentStrategy.NO_BORDER = new NoBorder, ContentStrategy.FIXED_HEIGHT = new FixedHeight, 
    ContentStrategy.FIXED_WIDTH = new FixedWidth;
}();

var ResolutionPolicy = function() {
    function ResolutionPolicy(containerStg, contentStg) {
        _classCallCheck(this, ResolutionPolicy), this.name = "ResolutionPolicy", this._containerStrategy = void 0, 
        this._contentStrategy = void 0, this._containerStrategy = null, this._contentStrategy = null, 
        this.setContainerStrategy(containerStg), this.setContentStrategy(contentStg);
    }
    return _createClass(ResolutionPolicy, [ {
        key: "preApply",
        value: function preApply(_view) {
            this._containerStrategy.preApply(_view), this._contentStrategy.preApply(_view);
        }
    }, {
        key: "apply",
        value: function apply(_view, designedResolution) {
            return this._containerStrategy.apply(_view, designedResolution), this._contentStrategy.apply(_view, designedResolution);
        }
    }, {
        key: "postApply",
        value: function postApply(_view) {
            this._containerStrategy.postApply(_view), this._contentStrategy.postApply(_view);
        }
    }, {
        key: "setContainerStrategy",
        value: function setContainerStrategy(containerStg) {
            containerStg instanceof ContainerStrategy && (this._containerStrategy = containerStg);
        }
    }, {
        key: "setContentStrategy",
        value: function setContentStrategy(contentStg) {
            contentStg instanceof ContentStrategy && (this._contentStrategy = contentStg);
        }
    }, {
        key: "canvasSize",
        get: function get() {
            return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
        }
    } ]), ResolutionPolicy;
}();

ResolutionPolicy.EXACT_FIT = 0, ResolutionPolicy.NO_BORDER = 1, ResolutionPolicy.SHOW_ALL = 2, 
ResolutionPolicy.FIXED_HEIGHT = 3, ResolutionPolicy.FIXED_WIDTH = 4, ResolutionPolicy.UNKNOWN = 5, 
ResolutionPolicy.ContainerStrategy = ContainerStrategy, ResolutionPolicy.ContentStrategy = ContentStrategy, 
cc.ResolutionPolicy = ResolutionPolicy;

var view = View.instance = cc.view = new View;

cc.winSize = new Vec2;

var keyboardListener = null, accelerationListener = null, touchListener = null, mouseListener = null, SystemEvent = function(_EventTarget) {
    function SystemEvent() {
        return _classCallCheck(this, SystemEvent), _possibleConstructorReturn(this, _getPrototypeOf(SystemEvent).call(this));
    }
    return _inherits(SystemEvent, EventTarget), _createClass(SystemEvent, [ {
        key: "setAccelerometerEnabled",
        value: function setAccelerometerEnabled(isEnabled) {
            isEnabled && window.DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceMotionEvent.requestPermission().then((function(response) {
                console.log("Device Motion Event request permission: ".concat(response)), inputManager.setAccelerometerEnabled("granted" === response);
            })) : inputManager.setAccelerometerEnabled(isEnabled);
        }
    }, {
        key: "setAccelerometerInterval",
        value: function setAccelerometerInterval(interval) {
            inputManager.setAccelerometerInterval(interval);
        }
    }, {
        key: "on",
        value: function on(type, callback, target, once) {
            return _get(_getPrototypeOf(SystemEvent.prototype), "on", this).call(this, type, callback, target, once), 
            type !== exports.SystemEventType.KEY_DOWN && type !== exports.SystemEventType.KEY_UP || keyboardListener || (keyboardListener = EventListener.create({
                event: EventListener.KEYBOARD,
                onKeyPressed: function onKeyPressed(keyCode, event) {
                    event.type = exports.SystemEventType.KEY_DOWN, systemEvent.emit(event.type, event);
                },
                onKeyReleased: function onKeyReleased(keyCode, event) {
                    event.type = exports.SystemEventType.KEY_UP, systemEvent.emit(event.type, event);
                }
            }), eventManager.addListener(keyboardListener, 256)), type === exports.SystemEventType.DEVICEMOTION && (accelerationListener || (accelerationListener = EventListener.create({
                event: EventListener.ACCELERATION,
                callback: function callback(acc, event) {
                    event.type = exports.SystemEventType.DEVICEMOTION, cc.systemEvent.emit(event.type, event);
                }
            }), eventManager.addListener(accelerationListener, 256))), type !== exports.SystemEventType.TOUCH_START && type !== exports.SystemEventType.TOUCH_MOVE && type !== exports.SystemEventType.TOUCH_END && type !== exports.SystemEventType.TOUCH_CANCEL || touchListener || (touchListener = EventListener.create({
                event: EventListener.TOUCH_ONE_BY_ONE,
                onTouchBegan: function onTouchBegan(touch, event) {
                    return event.type = exports.SystemEventType.TOUCH_START, cc.systemEvent.emit(event.type, touch, event), 
                    !0;
                },
                onTouchMoved: function onTouchMoved(touch, event) {
                    event.type = exports.SystemEventType.TOUCH_MOVE, cc.systemEvent.emit(event.type, touch, event);
                },
                onTouchEnded: function onTouchEnded(touch, event) {
                    event.type = exports.SystemEventType.TOUCH_END, cc.systemEvent.emit(event.type, touch, event);
                },
                onTouchCancelled: function onTouchCancelled(touch, event) {
                    event.type = exports.SystemEventType.TOUCH_CANCEL, cc.systemEvent.emit(event.type, touch, event);
                }
            }), eventManager.addListener(touchListener, 256)), type !== exports.SystemEventType.MOUSE_DOWN && type !== exports.SystemEventType.MOUSE_MOVE && type !== exports.SystemEventType.MOUSE_UP && type !== exports.SystemEventType.MOUSE_WHEEL || mouseListener || (mouseListener = EventListener.create({
                event: EventListener.MOUSE,
                onMouseDown: function onMouseDown(event) {
                    event.type = exports.SystemEventType.MOUSE_DOWN, cc.systemEvent.emit(event.type, event);
                },
                onMouseMove: function onMouseMove(event) {
                    event.type = exports.SystemEventType.MOUSE_MOVE, cc.systemEvent.emit(event.type, event);
                },
                onMouseUp: function onMouseUp(event) {
                    event.type = exports.SystemEventType.MOUSE_UP, cc.systemEvent.emit(event.type, event);
                },
                onMouseScroll: function onMouseScroll(event) {
                    event.type = exports.SystemEventType.MOUSE_WHEEL, cc.systemEvent.emit(event.type, event);
                }
            }), eventManager.addListener(mouseListener, 256)), callback;
        }
    }, {
        key: "off",
        value: function off(type, callback, target) {
            if (_get(_getPrototypeOf(SystemEvent.prototype), "off", this).call(this, type, callback, target), 
            keyboardListener && (type === exports.SystemEventType.KEY_DOWN || type === exports.SystemEventType.KEY_UP)) {
                var hasKeyDownEventListener = this.hasEventListener(exports.SystemEventType.KEY_DOWN), hasKeyUpEventListener = this.hasEventListener(exports.SystemEventType.KEY_UP);
                hasKeyDownEventListener || hasKeyUpEventListener || (eventManager.removeListener(keyboardListener), 
                keyboardListener = null);
            }
            if (accelerationListener && type === exports.SystemEventType.DEVICEMOTION && (eventManager.removeListener(accelerationListener), 
            accelerationListener = null), touchListener && (type === exports.SystemEventType.TOUCH_START || type === exports.SystemEventType.TOUCH_MOVE || type === exports.SystemEventType.TOUCH_END || type === exports.SystemEventType.TOUCH_CANCEL)) {
                var hasTouchStart = this.hasEventListener(exports.SystemEventType.TOUCH_START), hasTouchMove = this.hasEventListener(exports.SystemEventType.TOUCH_MOVE), hasTouchEnd = this.hasEventListener(exports.SystemEventType.TOUCH_END), hasTouchCancel = this.hasEventListener(exports.SystemEventType.TOUCH_CANCEL);
                hasTouchStart || hasTouchMove || hasTouchEnd || hasTouchCancel || (eventManager.removeListener(touchListener), 
                touchListener = null);
            }
            if (mouseListener && (type === exports.SystemEventType.MOUSE_DOWN || type === exports.SystemEventType.MOUSE_MOVE || type === exports.SystemEventType.MOUSE_UP || type === exports.SystemEventType.MOUSE_WHEEL)) {
                var hasMouseDown = this.hasEventListener(exports.SystemEventType.MOUSE_DOWN), hasMouseMove = this.hasEventListener(exports.SystemEventType.MOUSE_MOVE), hasMouseUp = this.hasEventListener(exports.SystemEventType.MOUSE_UP), hasMouseWheel = this.hasEventListener(exports.SystemEventType.MOUSE_WHEEL);
                hasMouseDown || hasMouseMove || hasMouseUp || hasMouseWheel || (eventManager.removeListener(mouseListener), 
                mouseListener = null);
            }
        }
    } ]), SystemEvent;
}();

SystemEvent.EventType = exports.SystemEventType, cc.SystemEvent = SystemEvent;

var systemEvent = new SystemEvent;

cc.systemEvent = systemEvent, exports.replaceProperty(exports.SystemEventType, "Node.EventType", [ {
    name: "POSITION_PART",
    newName: "TRANSFORM_CHANGED"
}, {
    name: "ROTATION_PART",
    newName: "TRANSFORM_CHANGED"
}, {
    name: "SCALE_PART",
    newName: "TRANSFORM_CHANGED"
} ]);

var screen$1 = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
    init: function init() {
        this._fn = {};
        var i, l, val, valL, map = this._fnMap;
        for (i = 0, l = map.length; i < l; i++) if ((val = map[i]) && void 0 !== document[val[1]]) {
            for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
            break;
        }
        this._supportsFullScreen = void 0 !== this._fn.requestFullscreen, this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
    },
    fullScreen: function fullScreen() {
        return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]);
    },
    requestFullScreen: function requestFullScreen(element, onFullScreenChange) {
        if (this._supportsFullScreen) {
            if (element = element || document.documentElement, onFullScreenChange) {
                var eventName = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(eventName, this._preOnFullScreenChange), 
                this._preOnFullScreenChange = onFullScreenChange, document.addEventListener(eventName, onFullScreenChange, !1);
            }
            return element[this._fn.requestFullscreen]();
        }
    },
    exitFullScreen: function exitFullScreen() {
        return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
    },
    autoFullScreen: function autoFullScreen(element, onFullScreenChange) {
        element = element || document.body;
        var touchTarget = cc.game.canvas || element, theScreen = this;
        this.requestFullScreen(element, onFullScreenChange), touchTarget.addEventListener(this._touchEvent, (function callback() {
            touchTarget.removeEventListener(theScreen._touchEvent, callback), theScreen.requestFullScreen(element, onFullScreenChange);
        }));
    }
};

screen$1.init(), cc.screen = screen$1;

var RenderQueue$1, PassStage, _stageOffset = 0, _name2stageID = {}, config_addStage = function addStage(name) {
    if (void 0 === _name2stageID[name]) {
        var stageID = 1 << _stageOffset;
        _name2stageID[name] = stageID, _stageOffset += 1;
    }
};

function nearestPOT(num) {
    return --num, num |= num >> 16, num |= num >> 8, num |= num >> 4, num |= num >> 2, 
    num |= num >> 1, ++num;
}

function roundUp(n, alignment) {
    return Math.ceil(n / alignment) * alignment;
}

!function(RenderQueue) {
    RenderQueue[RenderQueue.OPAQUE = 0] = "OPAQUE", RenderQueue[RenderQueue.TRANSPARENT = 1] = "TRANSPARENT", 
    RenderQueue[RenderQueue.OVERLAY = 2] = "OVERLAY";
}(RenderQueue$1 || (RenderQueue$1 = {})), function(PassStage) {
    PassStage[PassStage.DEFAULT = 1] = "DEFAULT", PassStage[PassStage.FORWARD = 2] = "FORWARD", 
    PassStage[PassStage.SHADOWCAST = 4] = "SHADOWCAST";
}(PassStage || (PassStage = {}));

var _class$K, _class2$E, _descriptor$x, _class4$5, _class5$5, _descriptor2$o, TextureBufferPool = function() {
    function TextureBufferPool(device) {
        _classCallCheck(this, TextureBufferPool), this._device = void 0, this._format = exports.GFXFormat.UNKNOWN, 
        this._formatSize = 0, this._chunks = [], this._chunkCount = 0, this._handles = [], 
        this._region0 = new GFXBufferTextureCopy, this._region1 = new GFXBufferTextureCopy, 
        this._region2 = new GFXBufferTextureCopy, this._roundUpFn = null, this._bufferViewCtor = Uint8Array, 
        this._channels = 4, this._alignment = 1, this._device = device;
    }
    return _createClass(TextureBufferPool, [ {
        key: "initialize",
        value: function initialize(info) {
            var formatInfo = GFXFormatInfos[info.format];
            this._format = info.format, this._formatSize = formatInfo.size, this._channels = formatInfo.count, 
            this._bufferViewCtor = getTypedArrayConstructor(formatInfo), this._roundUpFn = info.roundUpFn || null, 
            this._alignment = info.alignment || 1, info.inOrderFree && (this.alloc = this._McDonaldAlloc);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            for (var i = 0; i < this._chunkCount; ++i) {
                var chunk = this._chunks[i];
                chunk.texView.destroy(), chunk.texture.destroy();
            }
            this._chunks.length = 0, this._handles.length = 0;
        }
    }, {
        key: "alloc",
        value: function alloc(size, chunkIdx) {
            size = roundUp(size, this._alignment);
            var index = -1, start = -1;
            if (void 0 !== chunkIdx && (index = chunkIdx, start = this._findAvailableSpace(size, index)), 
            start < 0) for (var i = 0; i < this._chunkCount && (index = i, !((start = this._findAvailableSpace(size, index)) >= 0)); ++i) ;
            if (start >= 0) {
                var chunk = this._chunks[index];
                chunk.start += size;
                var handle = {
                    chunkIdx: index,
                    start: start,
                    end: start + size,
                    texture: chunk.texture,
                    texView: chunk.texView
                };
                return this._handles.push(handle), handle;
            }
            var targetSize = Math.sqrt(size / this._formatSize), texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize)), newChunk = this._chunks[this.createChunk(texLength)];
            newChunk.start += size;
            var texHandle = {
                chunkIdx: this._chunkCount - 1,
                start: 0,
                end: size,
                texture: newChunk.texture,
                texView: newChunk.texView
            };
            return this._handles.push(texHandle), texHandle;
        }
    }, {
        key: "free",
        value: function free(handle) {
            for (var i = 0; i < this._handles.length; ++i) if (this._handles[i] === handle) return this._chunks[handle.chunkIdx].end = handle.end, 
            void this._handles.splice(i, 1);
        }
    }, {
        key: "createChunk",
        value: function createChunk(length) {
            var texSize = length * length * this._formatSize;
            console.info("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + texSize + ", format: " + this._format);
            var texture = this._device.createTexture({
                type: exports.GFXTextureType.TEX2D,
                usage: exports.GFXTextureUsageBit.SAMPLED,
                format: this._format,
                width: length,
                height: length,
                mipLevel: 1
            }), chunk = {
                texture: texture,
                texView: this._device.createTextureView({
                    texture: texture,
                    type: exports.GFXTextureViewType.TV2D,
                    format: this._format
                }),
                size: texSize,
                start: 0,
                end: texSize
            };
            return this._chunks[this._chunkCount] = chunk, this._chunkCount++;
        }
    }, {
        key: "update",
        value: function update(handle, buffer) {
            var buffers = [], regions = [], start = handle.start / this._formatSize, remainSize = buffer.byteLength / this._formatSize, offsetX = start % handle.texture.width, offsetY = Math.floor(start / handle.texture.width), copySize = Math.min(handle.texture.width - offsetX, remainSize), begin = 0;
            offsetX > 0 && (this._region0.texOffset.x = offsetX, this._region0.texOffset.y = offsetY, 
            this._region0.texExtent.width = copySize, this._region0.texExtent.height = 1, buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels)), 
            regions.push(this._region0), offsetX = 0, offsetY += 1, remainSize -= copySize, 
            begin += copySize), remainSize > 0 && (this._region1.texOffset.x = offsetX, this._region1.texOffset.y = offsetY, 
            remainSize > handle.texture.width ? (this._region1.texExtent.width = handle.texture.width, 
            this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width), 
            copySize = this._region1.texExtent.width * this._region1.texExtent.height) : (copySize = remainSize, 
            this._region1.texExtent.width = copySize, this._region1.texExtent.height = 1), buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels)), 
            regions.push(this._region1), offsetX = 0, offsetY += this._region1.texExtent.height, 
            remainSize -= copySize, begin += copySize), remainSize > 0 && (this._region2.texOffset.x = offsetX, 
            this._region2.texOffset.y = offsetY, this._region2.texExtent.width = remainSize, 
            this._region2.texExtent.height = 1, buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels)), 
            regions.push(this._region2)), this._device.copyBuffersToTexture(buffers, handle.texture, regions);
        }
    }, {
        key: "_findAvailableSpace",
        value: function _findAvailableSpace(size, chunkIdx) {
            var chunk = this._chunks[chunkIdx], isFound = !1, start = chunk.start;
            if (start + size <= chunk.size) isFound = !0; else {
                start = 0;
                for (var handles = this._handles.filter((function(h) {
                    return h.chunkIdx === chunkIdx;
                })).sort((function(a, b) {
                    return a.start - b.start;
                })), i = 0; i < handles.length; i++) {
                    var handle = handles[i];
                    if (start + size <= handle.start) {
                        isFound = !0;
                        break;
                    }
                    start = handle.end;
                }
                !isFound && start + size <= chunk.size && (isFound = !0);
            }
            return isFound ? start : -1;
        }
    }, {
        key: "_McDonaldAlloc",
        value: function _McDonaldAlloc(size) {
            size = roundUp(size, this._alignment);
            for (var i = 0; i < this._chunkCount; ++i) {
                var chunk = this._chunks[i], isFound = !1, start = chunk.start;
                if (start + size <= chunk.end ? isFound = !0 : start > chunk.end ? start + size <= chunk.size ? isFound = !0 : size <= chunk.end && (chunk.start = start = 0, 
                isFound = !0) : start === chunk.end && (chunk.start = start = 0, chunk.end = chunk.size, 
                size <= chunk.end && (isFound = !0)), isFound) {
                    chunk.start += size;
                    var handle = {
                        chunkIdx: i,
                        start: start,
                        end: start + size,
                        texture: chunk.texture,
                        texView: chunk.texView
                    };
                    return this._handles.push(handle), handle;
                }
            }
            var targetSize = Math.sqrt(size / this._formatSize), texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize)), newChunk = this._chunks[this.createChunk(texLength)];
            newChunk.start += size;
            var texHandle = {
                chunkIdx: this._chunkCount,
                start: 0,
                end: size,
                texture: newChunk.texture,
                texView: newChunk.texView
            };
            return this._handles.push(texHandle), texHandle;
        }
    } ]), TextureBufferPool;
}();

function isPropertyPath(path) {
    return "string" == typeof path || "number" == typeof path;
}

function isCustomPath(path, constructor) {
    return path instanceof constructor;
}

var HierarchyPath = ccclass("cc.animation.HierarchyPath")((_descriptor$x = _applyDecoratedDescriptor((_class2$E = function() {
    function HierarchyPath(path) {
        _classCallCheck(this, HierarchyPath), _initializerDefineProperty(this, "path", _descriptor$x, this), 
        this.path = path || "";
    }
    return _createClass(HierarchyPath, [ {
        key: "get",
        value: function get(target) {
            if (!(target instanceof Node$1)) return warn("Target of hierarchy path should be of type Node."), 
            null;
            var result = target.getChildByPath(this.path);
            return result || (warn('Node "'.concat(target.name, '" has no path "').concat(this.path, '"')), 
            null);
        }
    } ]), HierarchyPath;
}()).prototype, "path", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$K = _class2$E)) || _class$K, ComponentPath = ccclass("cc.animation.ComponentPath")((_descriptor2$o = _applyDecoratedDescriptor((_class5$5 = function() {
    function ComponentPath(component) {
        _classCallCheck(this, ComponentPath), _initializerDefineProperty(this, "component", _descriptor2$o, this), 
        this.component = component || "";
    }
    return _createClass(ComponentPath, [ {
        key: "get",
        value: function get(target) {
            if (!(target instanceof Node$1)) return warn("Target of component path should be of type Node."), 
            null;
            var result = target.getComponent(this.component);
            return result || (warn('Node "'.concat(target.name, '" has no component "').concat(this.component, '"')), 
            null);
        }
    } ]), ComponentPath;
}()).prototype, "component", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class4$5 = _class5$5)) || _class4$5;

function evaluatePath(root) {
    for (var result = root, iPath = 0; iPath < (arguments.length <= 1 ? 0 : arguments.length - 1); ++iPath) {
        var path = iPath + 1 < 1 || arguments.length <= iPath + 1 ? void 0 : arguments[iPath + 1];
        if (isPropertyPath(path)) {
            if (!(path in result)) return warn('Target object has no property "'.concat(path, '"')), 
            null;
            result = result[path];
        } else result = path.get(result);
        if (null === result) break;
    }
    return result;
}

var SkelAnimDataHub = function() {
    function SkelAnimDataHub() {
        _classCallCheck(this, SkelAnimDataHub);
    }
    return _createClass(SkelAnimDataHub, null, [ {
        key: "getOrExtract",
        value: function getOrExtract(clip) {
            var data = SkelAnimDataHub.pool.get(clip);
            return data && data.info.sample === clip.sample || (data && cc.director.root.dataPoolManager.releaseAnimationClip(clip), 
            data = function convertToSkeletalCurves(clip) {
                var data = {};
                clip.curves.forEach((function(curve) {
                    if (!curve.valueAdapter && isCustomPath(curve.modifiers[0], HierarchyPath) && isPropertyPath(curve.modifiers[1])) {
                        var path = curve.modifiers[0].path, cs = data[path];
                        cs || (cs = data[path] = {}), cs[curve.modifiers[1]] = {
                            values: curve.data.values,
                            keys: curve.data.keys
                        };
                    }
                }));
                for (var frames = Math.ceil(clip.sample * clip.duration) + 1, _loop = function _loop() {
                    var path = _Object$keys[_i], props = data[path];
                    if (!props) return "continue";
                    Object.defineProperty(props, "worldMatrix", {
                        get: function get() {
                            if (!props._worldMatrix) {
                                var position = props.position, rotation = props.rotation, scale = props.scale;
                                convertToUniformSample(clip, position, frames), convertToUniformSample(clip, rotation, frames), 
                                convertToUniformSample(clip, scale, frames), function convertToWorldSpace(convertedProps, path, props) {
                                    var oPos = props.position.values, oRot = props.rotation.values, oScale = props.scale.values, matrix = oPos.map((function() {
                                        return new Mat4;
                                    })), idx = path.lastIndexOf("/"), pMatrix = null;
                                    if (idx > 0) {
                                        var name = path.substring(0, idx), data = convertedProps[name];
                                        if (!data) return void console.warn("no data for parent bone?");
                                        pMatrix = data.worldMatrix.values;
                                    }
                                    for (var i = 0; i < oPos.length; i++) {
                                        var oT = oPos[i], oR = oRot[i], oS = oScale[i], m = matrix[i];
                                        Mat4.fromRTS(m, oR, oT, oS), pMatrix && Mat4.multiply(m, pMatrix[i], m);
                                    }
                                    Object.keys(props).forEach((function(k) {
                                        return delete props[k];
                                    })), props._worldMatrix = {
                                        keys: 0,
                                        interpolate: !1,
                                        values: matrix
                                    };
                                }(data, path, props);
                            }
                            return props._worldMatrix;
                        }
                    });
                }, _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) _loop();
                return {
                    info: {
                        frames: frames,
                        sample: clip.sample
                    },
                    data: data
                };
            }(clip), SkelAnimDataHub.pool.set(clip, data)), data;
        }
    }, {
        key: "destroy",
        value: function destroy(clip) {
            SkelAnimDataHub.pool.delete(clip);
        }
    } ]), SkelAnimDataHub;
}();

function convertToUniformSample(clip, curve, frames) {
    var keys = clip.keys[curve.keys], values = [];
    if (keys && 1 !== keys.length) for (var isQuat = curve.values[0] instanceof Quat, _i2 = 0, idx = 0; _i2 < frames; _i2++) {
        for (var time = _i2 / clip.sample; keys[idx] <= time; ) idx++;
        idx > keys.length - 1 ? time = keys[idx = keys.length - 1] : 0 === idx && (idx = 1);
        var from = curve.values[idx - 1].clone(), denom = keys[idx] - keys[idx - 1], ratio = denom ? clamp01((time - keys[idx - 1]) / denom) : 1;
        isQuat ? from.slerp(curve.values[idx], ratio) : from.lerp(curve.values[idx], ratio), 
        values[_i2] = from;
    } else for (var i = 0; i < frames; i++) values[i] = curve.values[0].clone();
    curve.values = values;
}

SkelAnimDataHub.pool = new Map;

var m4_1$2 = new Mat4;

function getWorldTransformUntilRoot(target, root, outMatrix) {
    for (Mat4.identity(outMatrix); target !== root; ) Mat4.fromRTS(m4_1$2, target.rotation, target.position, target.scale), 
    Mat4.multiply(outMatrix, m4_1$2, outMatrix), target = target.parent;
    return outMatrix;
}

var uploadJointData = function uploadJointDataLBS(out, base, mat, firstBone) {
    out[base + 0] = mat.m00, out[base + 1] = mat.m01, out[base + 2] = mat.m02, out[base + 3] = mat.m12, 
    out[base + 4] = mat.m04, out[base + 5] = mat.m05, out[base + 6] = mat.m06, out[base + 7] = mat.m13, 
    out[base + 8] = mat.m08, out[base + 9] = mat.m09, out[base + 10] = mat.m10, out[base + 11] = mat.m14;
};

function selectJointsMediumFormat(device) {
    return device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT) ? exports.GFXFormat.RGBA32F : exports.GFXFormat.RGBA8;
}

new Quat, new Quat, new Vec3, new Quat, new Vec3;

function roundUpTextureSize(targetLength, formatSize) {
    var formatScale = 4 / Math.sqrt(formatSize);
    return 12 * Math.ceil(Math.max(480 * formatScale, targetLength) / 12);
}

var jointTextureSamplerHash = genSamplerHash([ exports.GFXFilter.POINT, exports.GFXFilter.POINT, exports.GFXFilter.NONE, exports.GFXAddress.CLAMP, exports.GFXAddress.CLAMP, exports.GFXAddress.CLAMP ]), v3_3 = new Vec3, v3_4 = new Vec3, v3_min = new Vec3, v3_max = new Vec3, m4_1$3 = new Mat4, m4_2 = new Mat4, ab_1 = new aabb, Inf = Number.MAX_SAFE_INTEGER, JointTexturePool = function() {
    function JointTexturePool(device) {
        _classCallCheck(this, JointTexturePool), this._device = void 0, this._pool = void 0, 
        this._textureBuffers = new Map, this._formatSize = void 0, this._pixelsPerJoint = void 0, 
        this._customPool = void 0, this._chunkIdxMap = new Map, this._device = device;
        var format = selectJointsMediumFormat(this._device);
        this._formatSize = GFXFormatInfos[format].size, this._pixelsPerJoint = 48 / this._formatSize, 
        this._pool = new TextureBufferPool(device), this._pool.initialize({
            format: format,
            roundUpFn: roundUpTextureSize
        }), this._customPool = new TextureBufferPool(device), this._customPool.initialize({
            format: format,
            roundUpFn: roundUpTextureSize
        });
    }
    return _createClass(JointTexturePool, [ {
        key: "pixelsPerJoint",
        get: function get() {
            return this._pixelsPerJoint;
        }
    } ]), _createClass(JointTexturePool, [ {
        key: "clear",
        value: function clear() {
            this._pool.destroy(), this._textureBuffers.clear();
        }
    }, {
        key: "registerCustomTextureLayouts",
        value: function registerCustomTextureLayouts(layouts) {
            for (var i = 0; i < layouts.length; i++) for (var layout = layouts[i], chunkIdx = this._customPool.createChunk(layout.textureLength), j = 0; j < layout.contents.length; j++) {
                var content = layout.contents[j], skeleton = content.skeleton;
                this._chunkIdxMap.set(skeleton, chunkIdx);
                for (var k = 0; k < content.clips.length; k++) {
                    var clip = content.clips[k];
                    this._chunkIdxMap.set(skeleton ^ clip, chunkIdx);
                }
            }
        }
    }, {
        key: "getDefaultPoseTexture",
        value: function getDefaultPoseTexture(skeleton, mesh, skinningRoot) {
            var hash = 0 ^ skeleton.hash, texture = this._textureBuffers.get(hash) || null;
            if (texture && texture.bounds.has(mesh.hash)) return texture.refCount++, texture;
            var joints = skeleton.joints, bindposes = skeleton.bindposes, textureBuffer = null, buildTexture = !1, jointCount = joints.length;
            if (texture) texture.refCount++; else {
                var bufSize = 12 * jointCount, customChunkIdx = this._chunkIdxMap.get(hash), handle = void 0 !== customChunkIdx ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);
                if (!handle) return texture;
                texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map,
                    skeletonHash: skeleton.hash,
                    clipHash: 0,
                    readyToBeDeleted: !1,
                    handle: handle
                }, textureBuffer = new Float32Array(bufSize), buildTexture = !0;
            }
            Vec3.set(v3_min, Inf, Inf, Inf), Vec3.set(v3_max, -Inf, -Inf, -Inf);
            for (var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton), j = 0, offset = 0; j < jointCount; j++, 
            offset += 12) {
                var node = skinningRoot.getChildByPath(joints[j]), mat = node ? getWorldTransformUntilRoot(node, skinningRoot, m4_1$3) : skeleton.inverseBindposes[j], bound = boneSpaceBounds[j];
                bound && (aabb.transform(ab_1, bound, mat), ab_1.getBoundary(v3_3, v3_4), Vec3.min(v3_min, v3_min, v3_3), 
                Vec3.max(v3_max, v3_max, v3_4)), buildTexture && (node && Mat4.multiply(mat, mat, bindposes[j]), 
                uploadJointData(textureBuffer, offset, node ? mat : Mat4.IDENTITY));
            }
            var bounds = [ new aabb ];
            return texture.bounds.set(mesh.hash, bounds), aabb.fromPoints(bounds[0], v3_min, v3_max), 
            buildTexture && (this._pool.update(texture.handle, textureBuffer.buffer), this._textureBuffers.set(hash, texture)), 
            texture;
        }
    }, {
        key: "getSequencePoseTexture",
        value: function getSequencePoseTexture(skeleton, clip, mesh, skinningRoot) {
            var hash = skeleton.hash ^ clip.hash, texture = this._textureBuffers.get(hash) || null;
            if (texture && texture.bounds.has(mesh.hash)) return texture.refCount++, texture;
            var joints = skeleton.joints, bindposes = skeleton.bindposes, frames = SkelAnimDataHub.getOrExtract(clip).info.frames, textureBuffer = null, buildTexture = !1, jointCount = joints.length;
            if (texture) texture.refCount++; else {
                var bufSize = 12 * jointCount * frames, customChunkIdx = this._chunkIdxMap.get(hash), handle = void 0 !== customChunkIdx ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);
                if (!handle) return null;
                var animInfos = this._createAnimInfos(skeleton, clip, skinningRoot);
                texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map,
                    skeletonHash: skeleton.hash,
                    clipHash: clip.hash,
                    readyToBeDeleted: !1,
                    handle: handle,
                    animInfos: animInfos
                }, textureBuffer = new Float32Array(bufSize), buildTexture = !0;
            }
            var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton), bounds = [];
            texture.bounds.set(mesh.hash, bounds);
            for (var f = 0; f < frames; f++) bounds.push(new aabb(Inf, Inf, Inf, -Inf, -Inf, -Inf));
            for (var _f = 0, offset = 0; _f < frames; _f++) {
                for (var bound = bounds[_f], j = 0; j < jointCount; j++, offset += 12) {
                    var _j = texture.animInfos[j], curveData = _j.curveData, downstream = _j.downstream, bindposeIdx = _j.bindposeIdx, bindposeCorrection = _j.bindposeCorrection, mat = void 0, transformValid = !0;
                    curveData && downstream ? mat = Mat4.multiply(m4_1$3, curveData[_f], downstream) : curveData ? mat = curveData[_f] : downstream ? mat = downstream : (mat = skeleton.inverseBindposes[bindposeIdx], 
                    transformValid = !1);
                    var boneSpaceBound = boneSpaceBounds[j];
                    if (boneSpaceBound) {
                        var transform = bindposeCorrection ? Mat4.multiply(m4_2, mat, bindposeCorrection) : mat;
                        aabb.transform(ab_1, boneSpaceBound, transform), ab_1.getBoundary(v3_3, v3_4), Vec3.min(bound.center, bound.center, v3_3), 
                        Vec3.max(bound.halfExtents, bound.halfExtents, v3_4);
                    }
                    buildTexture && (transformValid && Mat4.multiply(m4_1$3, mat, bindposes[bindposeIdx]), 
                    uploadJointData(textureBuffer, offset, transformValid ? m4_1$3 : Mat4.IDENTITY));
                }
                aabb.fromPoints(bound, bound.center, bound.halfExtents);
            }
            return buildTexture && (this._pool.update(texture.handle, textureBuffer.buffer), 
            this._textureBuffers.set(hash, texture)), texture;
        }
    }, {
        key: "releaseHandle",
        value: function releaseHandle(handle) {
            if (handle.refCount > 0 && handle.refCount--, !handle.refCount && handle.readyToBeDeleted) {
                var hash = handle.skeletonHash ^ handle.clipHash;
                (void 0 !== this._chunkIdxMap.get(hash) ? this._customPool : this._pool).free(handle.handle), 
                this._textureBuffers.get(hash) === handle && this._textureBuffers.delete(hash);
            }
        }
    }, {
        key: "releaseSkeleton",
        value: function releaseSkeleton(skeleton) {
            for (var it = this._textureBuffers.values(), res = it.next(); !res.done; ) {
                var handle = res.value;
                handle.skeletonHash === skeleton.hash && (handle.readyToBeDeleted = !0, handle.refCount ? this._textureBuffers.delete(handle.skeletonHash ^ handle.clipHash) : this.releaseHandle(handle)), 
                res = it.next();
            }
        }
    }, {
        key: "releaseAnimationClip",
        value: function releaseAnimationClip(clip) {
            for (var it = this._textureBuffers.values(), res = it.next(); !res.done; ) {
                var handle = res.value;
                handle.clipHash === clip.hash && (handle.readyToBeDeleted = !0, handle.refCount ? this._textureBuffers.delete(handle.skeletonHash ^ handle.clipHash) : this.releaseHandle(handle)), 
                res = it.next();
            }
        }
    }, {
        key: "_createAnimInfos",
        value: function _createAnimInfos(skeleton, clip, skinningRoot) {
            for (var animInfos = [], joints = skeleton.joints, bindposes = skeleton.bindposes, jointCount = joints.length, clipData = SkelAnimDataHub.getOrExtract(clip), j = 0; j < jointCount; j++) {
                for (var animPath = joints[j], source = clipData.data[animPath], animNode = skinningRoot.getChildByPath(animPath), downstream = void 0, correctionPath = void 0; !source; ) {
                    var idx = animPath.lastIndexOf("/");
                    if (animPath = animPath.substring(0, idx), source = clipData.data[animPath], animNode ? (downstream || (downstream = new Mat4), 
                    Mat4.fromRTS(m4_1$3, animNode.rotation, animNode.position, animNode.scale), Mat4.multiply(downstream, m4_1$3, downstream), 
                    animNode = animNode.parent) : correctionPath = animPath, idx < 0) break;
                }
                var bindposeIdx = j, bindposeCorrection = void 0;
                if (void 0 !== correctionPath && source) {
                    bindposeIdx = j - 1;
                    for (var t = 0; t < jointCount; t++) if (joints[t] === correctionPath) {
                        bindposeIdx = t, bindposeCorrection = new Mat4, Mat4.multiply(bindposeCorrection, bindposes[t], skeleton.inverseBindposes[j]);
                        break;
                    }
                }
                animInfos.push({
                    curveData: source && source.worldMatrix.values,
                    downstream: downstream,
                    bindposeIdx: bindposeIdx,
                    bindposeCorrection: bindposeCorrection
                });
            }
            return animInfos;
        }
    } ]), JointTexturePool;
}(), JointAnimationInfo = function() {
    function JointAnimationInfo(device) {
        _classCallCheck(this, JointAnimationInfo), this._pool = new Map, this._device = void 0, 
        this._device = device;
    }
    return _createClass(JointAnimationInfo, [ {
        key: "getData",
        value: function getData() {
            var nodeID = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "-1", res = this._pool.get(nodeID);
            if (res) return res;
            var buffer = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: UBOSkinningAnimation.SIZE,
                stride: UBOSkinningAnimation.SIZE
            }), data = new Float32Array([ 0, 0, 0, 0 ]);
            buffer.update(data);
            var info = {
                buffer: buffer,
                data: data,
                dirty: !1
            };
            return this._pool.set(nodeID, info), info;
        }
    }, {
        key: "destroy",
        value: function destroy(nodeID) {
            var info = this._pool.get(nodeID);
            info && (info.buffer.destroy(), this._pool.delete(nodeID));
        }
    }, {
        key: "switchClip",
        value: function switchClip(info, clip) {
            return info.data[0] = 0, info.buffer.update(info.data), info.dirty = !1, info;
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._pool.values()); !(_step = _iterator()).done; ) {
                _step.value.buffer.destroy();
            }
            this._pool.clear();
        }
    } ]), JointAnimationInfo;
}(), stack = [], pool = new Map, myPatches = [ {
    name: "CC_USE_SKINNING",
    value: !0
} ];

function getWorldMatrix(transform, stamp) {
    for (var i = 0, res = Mat4.IDENTITY; transform; ) {
        if (transform.stamp === stamp || transform.stamp + 1 === stamp && !transform.node.hasChangedFlags) {
            res = transform.world, transform.stamp = stamp;
            break;
        }
        transform.stamp = stamp, stack[i++] = transform, transform = transform.parent;
    }
    for (;i > 0; ) {
        var node = (transform = stack[--i]).node;
        Mat4.fromRTS(transform.local, node.rotation, node.position, node.scale), res = Mat4.multiply(transform.world, res, transform.local);
    }
    return res;
}

function getTransform(node, root) {
    for (var child, joint = null, i = 0; node !== root; ) {
        var id = node.uuid;
        if (pool.has(id)) {
            joint = pool.get(id);
            break;
        }
        joint = {
            node: node,
            local: new Mat4,
            world: new Mat4,
            stamp: -1,
            parent: null
        }, pool.set(id, joint), stack[i++] = joint, node = node.parent, joint = null;
    }
    for (;i > 0; ) (child = stack[--i]).parent = joint, joint = child;
    return joint;
}

function deleteTransform(node) {
    for (var transform = pool.get(node.uuid) || null; transform; ) pool.delete(transform.node.uuid), 
    transform = transform.parent;
}

function getRelevantBuffers(outIndices, outBuffers, jointMaps, targetJoint) {
    for (var i = 0; i < jointMaps.length; i++) {
        for (var idxMap = jointMaps[i], index = -1, j = 0; j < idxMap.length; j++) if (idxMap[j] === targetJoint) {
            index = j;
            break;
        }
        index >= 0 && (outBuffers.push(i), outIndices.push(index));
    }
}

var _keyMap, v3_min$1 = new Vec3, v3_max$1 = new Vec3, v3_1$7 = new Vec3, v3_2$4 = new Vec3, m4_1$4 = new Mat4, ab_1$1 = new aabb, SkinningModel = function(_MorphModel) {
    function SkinningModel() {
        var _this;
        return _classCallCheck(this, SkinningModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SkinningModel).call(this))).uploadAnimation = null, 
        _this._buffers = [], _this._dataArray = [], _this._joints = [], _this._bufferIndices = null, 
        _this.type = ModelType.SKINNING, _this;
    }
    return _inherits(SkinningModel, MorphModel), _createClass(SkinningModel, [ {
        key: "destroy",
        value: function destroy() {
            if (this.bindSkeleton(), this._buffers.length) {
                for (var i = 0; i < this._buffers.length; i++) this._buffers[i].destroy();
                this._buffers.length = 0;
            }
            _get(_getPrototypeOf(SkinningModel.prototype), "destroy", this).call(this);
        }
    }, {
        key: "bindSkeleton",
        value: function bindSkeleton() {
            for (var skeleton = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, skinningRoot = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, mesh = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, i = 0; i < this._joints.length; i++) deleteTransform(this._joints[i].target);
            if (this._bufferIndices = null, this._joints.length = 0, skeleton && skinningRoot && mesh) {
                this.transform = skinningRoot;
                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton), jointMaps = mesh.struct.jointMaps;
                this._ensureEnoughBuffers(jointMaps && jointMaps.length || 1), this._bufferIndices = mesh.jointBufferIndices;
                for (var index = 0; index < skeleton.joints.length; index++) {
                    var bound = boneSpaceBounds[index], target = skinningRoot.getChildByPath(skeleton.joints[index]);
                    if (bound && target) {
                        var transform = getTransform(target, skinningRoot), bindpose = skeleton.bindposes[index], indices = [], buffers = [];
                        jointMaps ? getRelevantBuffers(indices, buffers, jointMaps, index) : (indices.push(index), 
                        buffers.push(0)), this._joints.push({
                            indices: indices,
                            buffers: buffers,
                            bound: bound,
                            target: target,
                            bindpose: bindpose,
                            transform: transform
                        });
                    }
                }
            }
        }
    }, {
        key: "updateTransform",
        value: function updateTransform(stamp) {
            var root = this.transform;
            (root.hasChangedFlags || root._dirtyFlags) && (root.updateWorldTransform(), this._transformUpdated = !0), 
            Vec3.set(v3_min$1, 1 / 0, 1 / 0, 1 / 0), Vec3.set(v3_max$1, -1 / 0, -1 / 0, -1 / 0);
            for (var i = 0; i < this._joints.length; i++) {
                var _this$_joints$i = this._joints[i], bound = _this$_joints$i.bound, worldMatrix = getWorldMatrix(_this$_joints$i.transform, stamp);
                aabb.transform(ab_1$1, bound, worldMatrix), ab_1$1.getBoundary(v3_1$7, v3_2$4), 
                Vec3.min(v3_min$1, v3_min$1, v3_1$7), Vec3.max(v3_max$1, v3_max$1, v3_2$4);
            }
            this._modelBounds && this._worldBounds && (aabb.fromPoints(this._modelBounds, v3_min$1, v3_max$1), 
            this._modelBounds.transform(root._mat, root._pos, root._rot, root._scale, this._worldBounds));
        }
    }, {
        key: "updateUBOs",
        value: function updateUBOs(stamp) {
            _get(_getPrototypeOf(SkinningModel.prototype), "updateUBOs", this).call(this, stamp);
            for (var i = 0; i < this._joints.length; i++) {
                var _this$_joints$i2 = this._joints[i], indices = _this$_joints$i2.indices, buffers = _this$_joints$i2.buffers, transform = _this$_joints$i2.transform, bindpose = _this$_joints$i2.bindpose;
                Mat4.multiply(m4_1$4, transform.world, bindpose);
                for (var b = 0; b < buffers.length; b++) uploadJointData(this._dataArray[buffers[b]], 12 * indices[b], m4_1$4);
            }
            for (var _b = 0; _b < this._buffers.length; _b++) this._buffers[_b].update(this._dataArray[_b]);
            return !0;
        }
    }, {
        key: "initSubModel",
        value: function initSubModel(idx, subMeshData, mat) {
            var original = subMeshData.vertexBuffers;
            subMeshData.vertexBuffers = subMeshData.jointMappedBuffers, _get(_getPrototypeOf(SkinningModel.prototype), "initSubModel", this).call(this, idx, subMeshData, mat), 
            subMeshData.vertexBuffers = original;
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState(pass, subModelIdx, patches) {
            var _patches$concat, pso = _get(_getPrototypeOf(SkinningModel.prototype), "createPipelineState", this).call(this, pass, subModelIdx, null !== (_patches$concat = null == patches ? void 0 : patches.concat(myPatches)) && void 0 !== _patches$concat ? _patches$concat : myPatches), bindingLayout = pso.pipelineLayout.layouts[0], buffer = this._buffers[this._bufferIndices[subModelIdx]];
            return buffer && bindingLayout.bindBuffer(UBOSkinning.BLOCK.binding, buffer), pso;
        }
    }, {
        key: "_ensureEnoughBuffers",
        value: function _ensureEnoughBuffers(count) {
            for (var i = 0; i < count; i++) this._buffers[i] || (this._buffers[i] = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: UBOSkinning.SIZE,
                stride: UBOSkinning.SIZE
            })), this._dataArray[i] || (this._dataArray[i] = new Float32Array(UBOSkinning.COUNT));
        }
    } ]), SkinningModel;
}(), myPatches$1 = [ {
    name: "CC_USE_SKINNING",
    value: !0
}, {
    name: "CC_USE_BAKED_ANIMATION",
    value: !0
} ], BakedSkinningModel = function(_MorphModel) {
    function BakedSkinningModel() {
        var _this;
        _classCallCheck(this, BakedSkinningModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(BakedSkinningModel).call(this))).uploadedAnim = void 0, 
        _this._jointsMedium = void 0, _this._skeleton = null, _this._mesh = null, _this._dataPoolManager = void 0, 
        _this._instAnimInfoIdx = -1, _this.type = ModelType.BAKED_SKINNING, _this._dataPoolManager = cc.director.root.dataPoolManager;
        var jointTextureInfo = new Float32Array(4), animInfo = _this._dataPoolManager.jointAnimationInfo.getData();
        return _this._jointsMedium = {
            buffer: null,
            jointTextureInfo: jointTextureInfo,
            animInfo: animInfo,
            texture: null,
            boundsInfo: null
        }, _this;
    }
    return _inherits(BakedSkinningModel, MorphModel), _createClass(BakedSkinningModel, [ {
        key: "destroy",
        value: function destroy() {
            this.uploadedAnim = void 0, this._jointsMedium.boundsInfo = null, this._jointsMedium.buffer && (this._jointsMedium.buffer.destroy(), 
            this._jointsMedium.buffer = null), this._applyJointTexture(), _get(_getPrototypeOf(BakedSkinningModel.prototype), "destroy", this).call(this);
        }
    }, {
        key: "bindSkeleton",
        value: function bindSkeleton() {
            var skeleton = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, skinningRoot = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, mesh = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            if (this._skeleton = skeleton, this._mesh = mesh, skeleton && skinningRoot && mesh) {
                this.transform = skinningRoot;
                var resMgr = this._dataPoolManager;
                this._jointsMedium.animInfo = resMgr.jointAnimationInfo.getData(skinningRoot.uuid), 
                this._jointsMedium.buffer || (this._jointsMedium.buffer = this._device.createBuffer({
                    usage: exports.GFXBufferUsageBit.UNIFORM | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: UBOSkinningTexture.SIZE,
                    stride: UBOSkinningTexture.SIZE
                }));
            }
        }
    }, {
        key: "updateTransform",
        value: function updateTransform(stamp) {
            if (_get(_getPrototypeOf(BakedSkinningModel.prototype), "updateTransform", this).call(this, stamp), 
            this.uploadedAnim) {
                var _this$_jointsMedium = this._jointsMedium, animInfo = _this$_jointsMedium.animInfo, skelBound = _this$_jointsMedium.boundsInfo[animInfo.data[0]], node = this.transform;
                this._worldBounds && skelBound && skelBound.transform(node._mat, node._pos, node._rot, node._scale, this._worldBounds);
            }
        }
    }, {
        key: "updateUBOs",
        value: function updateUBOs(stamp) {
            _get(_getPrototypeOf(BakedSkinningModel.prototype), "updateUBOs", this).call(this, stamp);
            var info = this._jointsMedium.animInfo, idx = this._instAnimInfoIdx;
            idx >= 0 ? this.instancedAttributes.list[idx].view[0] = info.data[0] : info.dirty && (info.buffer.update(info.data), 
            info.dirty = !1);
            return !0;
        }
    }, {
        key: "createBoundingShape",
        value: function createBoundingShape(minPos, maxPos) {
            minPos && maxPos && (this._worldBounds = new aabb);
        }
    }, {
        key: "uploadAnimation",
        value: function uploadAnimation(anim) {
            if (this._skeleton && this._mesh && this.uploadedAnim !== anim) {
                this.uploadedAnim = anim;
                var resMgr = this._dataPoolManager, texture = null;
                anim ? (texture = resMgr.jointTexturePool.getSequencePoseTexture(this._skeleton, anim, this._mesh, this.transform), 
                this._jointsMedium.boundsInfo = texture && texture.bounds.get(this._mesh.hash), 
                this._modelBounds = null) : (texture = resMgr.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform), 
                this._jointsMedium.boundsInfo = null, this._modelBounds = texture && texture.bounds.get(this._mesh.hash)[0]), 
                this._applyJointTexture(texture);
            }
        }
    }, {
        key: "_applyJointTexture",
        value: function _applyJointTexture() {
            var texture = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, oldTex = this._jointsMedium.texture;
            if (oldTex && oldTex !== texture && this._dataPoolManager.jointTexturePool.releaseHandle(oldTex), 
            this._jointsMedium.texture = texture, texture) {
                var _this$_jointsMedium2 = this._jointsMedium, buffer = _this$_jointsMedium2.buffer, jointTextureInfo = _this$_jointsMedium2.jointTextureInfo;
                jointTextureInfo[0] = texture.handle.texture.width, jointTextureInfo[1] = this._skeleton.joints.length, 
                jointTextureInfo[2] = texture.pixelOffset + .1, jointTextureInfo[3] = 1 / jointTextureInfo[0], 
                this.updateInstancedJointTextureInfo(), buffer && buffer.update(jointTextureInfo);
                for (var tv = texture.handle.texView, it = this._matPSORecord.values(), res = it.next(); !res.done; ) {
                    for (var psos = res.value, i = 0; i < psos.length; i++) {
                        var bindingLayout = psos[i].pipelineLayout.layouts[0];
                        bindingLayout.bindTextureView(UniformJointTexture.binding, tv);
                    }
                    res = it.next();
                }
                for (var _i = 0; _i < this._implantPSOs.length; _i++) {
                    var _bindingLayout = this._implantPSOs[_i].pipelineLayout.layouts[0];
                    _bindingLayout.bindTextureView(UniformJointTexture.binding, tv), _bindingLayout.update();
                }
            }
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState(pass, subModelIdx, patches) {
            var _patches$concat, pso = _get(_getPrototypeOf(BakedSkinningModel.prototype), "createPipelineState", this).call(this, pass, subModelIdx, null !== (_patches$concat = null == patches ? void 0 : patches.concat(myPatches$1)) && void 0 !== _patches$concat ? _patches$concat : myPatches$1), _this$_jointsMedium3 = this._jointsMedium, buffer = _this$_jointsMedium3.buffer, texture = _this$_jointsMedium3.texture, animInfo = _this$_jointsMedium3.animInfo, bindingLayout = pso.pipelineLayout.layouts[0];
            bindingLayout.bindBuffer(UBOSkinningTexture.BLOCK.binding, buffer), bindingLayout.bindBuffer(UBOSkinningAnimation.BLOCK.binding, animInfo.buffer);
            var sampler = samplerLib.getSampler(this._device, jointTextureSamplerHash);
            return texture && (bindingLayout.bindTextureView(UniformJointTexture.binding, texture.handle.texView), 
            bindingLayout.bindSampler(UniformJointTexture.binding, sampler)), pso;
        }
    }, {
        key: "updateInstancedAttributeList",
        value: function updateInstancedAttributeList(pso, pass) {
            _get(_getPrototypeOf(BakedSkinningModel.prototype), "updateInstancedAttributeList", this).call(this, pso, pass), 
            this._instAnimInfoIdx = this.getInstancedAttributeIndex("a_jointAnimInfo"), this.updateInstancedJointTextureInfo();
        }
    }, {
        key: "updateInstancedJointTextureInfo",
        value: function updateInstancedJointTextureInfo() {
            var _this$_jointsMedium4 = this._jointsMedium, jointTextureInfo = _this$_jointsMedium4.jointTextureInfo, animInfo = _this$_jointsMedium4.animInfo, idx = this._instAnimInfoIdx;
            if (idx >= 0) {
                var view = this.instancedAttributes.list[idx].view;
                view[0] = animInfo.data[0], view[1] = jointTextureInfo[1], view[2] = jointTextureInfo[2];
            }
        }
    } ]), BakedSkinningModel;
}(), _forward = new Vec3(0, 0, -1), _v3$1 = new Vec3, _ab = new aabb, _qt$1 = new Quat, PlanarShadows = function() {
    function PlanarShadows(scene) {
        _classCallCheck(this, PlanarShadows), this._scene = void 0, this._enabled = !1, 
        this._normal = new Vec3(0, 1, 0), this._distance = 0, this._matLight = new Mat4, 
        this._data = Float32Array.from([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, .3 ]), 
        this._globalBindings = void 0, this._record = new Map, this._pendingModels = [], 
        this._material = void 0, this._instancingMaterial = void 0, this._scene = scene, 
        this._globalBindings = scene.root.pipeline.globalBindings.get(UBOShadow.BLOCK.name), 
        this._material = new Material, this._material.initialize({
            effectName: "pipeline/planar-shadow"
        }), this._instancingMaterial = new Material, this._instancingMaterial.initialize({
            effectName: "pipeline/planar-shadow",
            defines: {
                USE_INSTANCING: !0
            }
        });
    }
    return _createClass(PlanarShadows, [ {
        key: "enabled",
        set: function set(enable) {
            this._enabled = enable, this._scene.mainLight && this.updateDirLight(this._scene.mainLight);
        },
        get: function get() {
            return this._enabled;
        }
    }, {
        key: "normal",
        set: function set(val) {
            Vec3.copy(this._normal, val), this._scene.mainLight && this.updateDirLight(this._scene.mainLight);
        },
        get: function get() {
            return this._normal;
        }
    }, {
        key: "distance",
        set: function set(val) {
            this._distance = val, this._scene.mainLight && this.updateDirLight(this._scene.mainLight);
        },
        get: function get() {
            return this._distance;
        }
    }, {
        key: "shadowColor",
        set: function set(color) {
            Color.toArray(this._data, color, UBOShadow.SHADOW_COLOR_OFFSET), this._globalBindings.buffer.update(this.data);
        }
    }, {
        key: "matLight",
        get: function get() {
            return this._matLight;
        }
    }, {
        key: "data",
        get: function get() {
            return this._data;
        }
    } ]), _createClass(PlanarShadows, [ {
        key: "updateSphereLight",
        value: function updateSphereLight(light) {
            light.node.getWorldPosition(_v3$1);
            var n = this._normal, d = this._distance + .001, NdL = Vec3.dot(n, _v3$1), lx = _v3$1.x, ly = _v3$1.y, lz = _v3$1.z, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
            m.m00 = NdL - d - lx * nx, m.m01 = -ly * nx, m.m02 = -lz * nx, m.m03 = -nx, m.m04 = -lx * ny, 
            m.m05 = NdL - d - ly * ny, m.m06 = -lz * ny, m.m07 = -ny, m.m08 = -lx * nz, m.m09 = -ly * nz, 
            m.m10 = NdL - d - lz * nz, m.m11 = -nz, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
            m.m15 = NdL, Mat4.toArray(this.data, this._matLight), this._globalBindings.buffer.update(this.data);
        }
    }, {
        key: "updateDirLight",
        value: function updateDirLight(light) {
            light.node.getWorldRotation(_qt$1), Vec3.transformQuat(_v3$1, _forward, _qt$1);
            var n = this._normal, d = this._distance + .001, scale = 1 / Vec3.dot(n, _v3$1), lx = _v3$1.x * scale, ly = _v3$1.y * scale, lz = _v3$1.z * scale, nx = n.x, ny = n.y, nz = n.z, m = this._matLight;
            m.m00 = 1 - nx * lx, m.m01 = -nx * ly, m.m02 = -nx * lz, m.m03 = 0, m.m04 = -ny * lx, 
            m.m05 = 1 - ny * ly, m.m06 = -ny * lz, m.m07 = 0, m.m08 = -nz * lx, m.m09 = -nz * ly, 
            m.m10 = 1 - nz * lz, m.m11 = 0, m.m12 = lx * d, m.m13 = ly * d, m.m14 = lz * d, 
            m.m15 = 1, Mat4.toArray(this.data, this._matLight, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET), 
            this._globalBindings.buffer.update(this.data);
        }
    }, {
        key: "updateCommandBuffers",
        value: function updateCommandBuffers(frstm, stamp) {
            if (this._pendingModels.length = 0, this._scene.mainLight) for (var models = this._scene.models, i = 0; i < models.length; i++) {
                var model = models[i];
                if (model.enabled && model.node && model.castShadow && (!model.worldBounds || (aabb.transform(_ab, model.worldBounds, this._matLight), 
                intersect.aabb_frustum(_ab, frstm)))) {
                    var data = this._record.get(model);
                    data && !!data.instancedBuffer !== model.isInstancingEnabled && (this.destroyShadowData(model), 
                    data = void 0), data || (data = this.createShadowData(model), this._record.set(model, data)), 
                    model.updateStamp !== stamp && model.updateUBOs(stamp), this._pendingModels.push(data);
                }
            }
        }
    }, {
        key: "recordCommandBuffer",
        value: function recordCommandBuffer(cmdBuff) {
            var models = this._pendingModels, modelLen = models.length, buffer = this._instancingMaterial.passes[0].instancedBuffer;
            buffer && buffer.clear();
            for (var i = 0; i < modelLen; i++) for (var _models$i = models[i], model = _models$i.model, psos = _models$i.psos, instancedBuffer = _models$i.instancedBuffer, j = 0; j < psos.length; j++) {
                var submodel = model.getSubModel(j), pso = psos[j];
                if (instancedBuffer) instancedBuffer.merge(submodel, model.instancedAttributes, pso); else {
                    var ia = submodel.inputAssembler;
                    cmdBuff.bindPipelineState(pso), cmdBuff.bindBindingLayout(pso.pipelineLayout.layouts[0]), 
                    cmdBuff.bindInputAssembler(ia), cmdBuff.draw(ia);
                }
            }
            if (buffer && buffer.instances.length > 0) {
                buffer.uploadBuffers();
                for (var b = 0; b < buffer.instances.length; ++b) {
                    var instance = buffer.instances[b];
                    instance.count && (cmdBuff.bindPipelineState(instance.pso), cmdBuff.bindBindingLayout(instance.pso.pipelineLayout.layouts[0]), 
                    cmdBuff.bindInputAssembler(instance.ia), cmdBuff.draw(instance.ia));
                }
            }
        }
    }, {
        key: "createShadowData",
        value: function createShadowData(model) {
            for (var psos = [], material = model.isInstancingEnabled ? this._instancingMaterial : this._material, i = 0; i < model.subModelNum; i++) {
                var pso = model.createPipelineState(material.passes[0], i);
                model.insertImplantPSO(pso), pso.pipelineLayout.layouts[0].update(), psos.push(pso);
            }
            return {
                model: model,
                psos: psos,
                instancedBuffer: material.passes[0].instancedBuffer
            };
        }
    }, {
        key: "destroyShadowData",
        value: function destroyShadowData(model) {
            var data = this._record.get(model);
            if (data) {
                for (var material = data.instancedBuffer ? this._instancingMaterial : this._material, i = 0; i < data.psos.length; i++) {
                    var pso = data.psos[i];
                    model.removeImplantPSO(pso), material.passes[0].destroyPipelineState(pso);
                }
                this._record.delete(model);
            }
        }
    }, {
        key: "onGlobalPipelineStateChanged",
        value: function onGlobalPipelineStateChanged() {
            for (var it = this._record.keys(), res = it.next(); !res.done; ) this.destroyShadowData(res.value), 
            res = it.next();
            this._record.clear();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.onGlobalPipelineStateChanged(), this._material.destroy();
        }
    } ]), PlanarShadows;
}();

!function(_keyMap) {
    _keyMap[_keyMap.positions = exports.GFXAttributeName.ATTR_POSITION] = "positions", 
    _keyMap[_keyMap.normals = exports.GFXAttributeName.ATTR_NORMAL] = "normals", _keyMap[_keyMap.uvs = exports.GFXAttributeName.ATTR_TEX_COORD] = "uvs", 
    _keyMap[_keyMap.colors = exports.GFXAttributeName.ATTR_COLOR] = "colors";
}(_keyMap || (_keyMap = {}));

var _defAttrs = [ {
    name: exports.GFXAttributeName.ATTR_POSITION,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_NORMAL,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD,
    format: exports.GFXFormat.RG32F
}, {
    name: exports.GFXAttributeName.ATTR_COLOR,
    format: exports.GFXFormat.RGBA32F
} ], v3_1$8 = new Vec3;

function createMesh(geometry, out, options) {
    options = options || {};
    var attr, attributes = [], stride = 0, channels = [], vertCount = 0;
    if (geometry.positions.length > 0) {
        if (attr = null, geometry.attributes) for (var _step, _iterator = _createForOfIteratorHelperLoose(geometry.attributes); !(_step = _iterator()).done; ) {
            var att = _step.value;
            if (att.name === exports.GFXAttributeName.ATTR_POSITION) {
                attr = att;
                break;
            }
        }
        attr || (attr = _defAttrs[0]);
        var info = GFXFormatInfos[attr.format];
        attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.positions.length / info.count)), 
        channels.push({
            offset: stride,
            data: geometry.positions,
            attribute: attr
        }), stride += info.size;
    }
    if (geometry.normals && geometry.normals.length > 0) {
        if (attr = null, geometry.attributes) for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(geometry.attributes); !(_step2 = _iterator2()).done; ) {
            var _att = _step2.value;
            if (_att.name === exports.GFXAttributeName.ATTR_NORMAL) {
                attr = _att;
                break;
            }
        }
        attr || (attr = _defAttrs[1]);
        var _info = GFXFormatInfos[attr.format];
        attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count)), 
        channels.push({
            offset: stride,
            data: geometry.normals,
            attribute: attr
        }), stride += _info.size;
    }
    if (geometry.uvs && geometry.uvs.length > 0) {
        if (attr = null, geometry.attributes) for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(geometry.attributes); !(_step3 = _iterator3()).done; ) {
            var _att2 = _step3.value;
            if (_att2.name === exports.GFXAttributeName.ATTR_TEX_COORD) {
                attr = _att2;
                break;
            }
        }
        attr || (attr = _defAttrs[2]);
        var _info2 = GFXFormatInfos[attr.format];
        attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count)), 
        channels.push({
            offset: stride,
            data: geometry.uvs,
            attribute: attr
        }), stride += _info2.size;
    }
    if (geometry.colors && geometry.colors.length > 0) {
        if (attr = null, geometry.attributes) for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(geometry.attributes); !(_step4 = _iterator4()).done; ) {
            var _att3 = _step4.value;
            if (_att3.name === exports.GFXAttributeName.ATTR_COLOR) {
                attr = _att3;
                break;
            }
        }
        attr || (attr = _defAttrs[3]);
        var _info3 = GFXFormatInfos[attr.format];
        attributes.push(attr), vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info3.count)), 
        channels.push({
            offset: stride,
            data: geometry.colors,
            attribute: attr
        }), stride += _info3.size;
    }
    if (geometry.customAttributes) for (var _step5, _iterator5 = _createForOfIteratorHelperLoose(geometry.customAttributes); !(_step5 = _iterator5()).done; ) {
        var ca = _step5.value, _info4 = GFXFormatInfos[ca.attr.format];
        attributes.push(ca.attr), vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info4.count)), 
        channels.push({
            offset: stride,
            data: ca.values,
            attribute: ca.attr
        }), stride += _info4.size;
    }
    for (var bufferBlob = new BufferBlob, vertexBuffer = new ArrayBuffer(vertCount * stride), vertexBufferView = new DataView(vertexBuffer), _i = 0, _channels = channels; _i < _channels.length; _i++) {
        var channel = _channels[_i];
        writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
    }
    bufferBlob.setNextAlignment(0);
    var vertexBundle = {
        attributes: attributes,
        view: {
            offset: bufferBlob.getLength(),
            length: vertexBuffer.byteLength,
            count: vertCount,
            stride: stride
        }
    };
    bufferBlob.addBuffer(vertexBuffer);
    var indexBuffer = null, idxCount = 0;
    if (geometry.indices) {
        var indices = geometry.indices;
        idxCount = indices.length, indexBuffer = new ArrayBuffer(2 * idxCount), writeBuffer(new DataView(indexBuffer), indices, exports.GFXFormat.R16UI);
    }
    var primitive = {
        primitiveMode: geometry.primitiveMode || exports.GFXPrimitiveMode.TRIANGLE_LIST,
        vertexBundelIndices: [ 0 ]
    };
    indexBuffer && (bufferBlob.setNextAlignment(2), primitive.indexView = {
        offset: bufferBlob.getLength(),
        length: indexBuffer.byteLength,
        count: idxCount,
        stride: 2
    }, bufferBlob.addBuffer(indexBuffer));
    var minPosition = geometry.minPos;
    if (!minPosition && options.calculateBounds) {
        minPosition = Vec3.set(new Vec3, 1 / 0, 1 / 0, 1 / 0);
        for (var iVertex = 0; iVertex < vertCount; ++iVertex) Vec3.set(v3_1$8, geometry.positions[3 * iVertex + 0], geometry.positions[3 * iVertex + 1], geometry.positions[3 * iVertex + 2]), 
        Vec3.min(minPosition, minPosition, v3_1$8);
    }
    var maxPosition = geometry.maxPos;
    if (!maxPosition && options.calculateBounds) {
        maxPosition = Vec3.set(new Vec3, -1 / 0, -1 / 0, -1 / 0);
        for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) Vec3.set(v3_1$8, geometry.positions[3 * _iVertex + 0], geometry.positions[3 * _iVertex + 1], geometry.positions[3 * _iVertex + 2]), 
        Vec3.max(maxPosition, maxPosition, v3_1$8);
    }
    var meshStruct = {
        vertexBundles: [ vertexBundle ],
        primitives: [ primitive ]
    };
    return minPosition && (meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z)), 
    maxPosition && (meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z)), 
    out || (out = new Mesh), out.reset({
        struct: meshStruct,
        data: new Uint8Array(bufferBlob.getCombined())
    }), out;
}

var utils = Object.freeze({
    __proto__: null,
    find: find,
    toPPM: function toPPM(buffer, w, h) {
        return "P3 ".concat(w, " ").concat(h, " 255\n").concat(buffer.filter((function(e, i) {
            return i % 4 < 3;
        })).toString(), "\n");
    },
    readMesh: function readMesh(mesh) {
        for (var _step, iPrimitive = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, out = {
            positions: []
        }, dataView = new DataView(mesh._nativeAsset), struct = mesh.struct, primitive = struct.primitives[iPrimitive], _iterator = _createForOfIteratorHelperLoose(primitive.vertexBundelIndices); !(_step = _iterator()).done; ) for (var _step2, idx = _step.value, bundle = struct.vertexBundles[idx], offset = bundle.view.offset, _bundle$view = bundle.view, length = _bundle$view.length, stride = _bundle$view.stride, _iterator2 = _createForOfIteratorHelperLoose(bundle.attributes); !(_step2 = _iterator2()).done; ) {
            var attr = _step2.value, name = _keyMap[attr.name];
            name && (out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride))), 
            offset += GFXFormatInfos[attr.format].size;
        }
        var view = primitive.indexView;
        return out.indices = readBuffer(dataView, exports.GFXFormat["R".concat(8 * view.stride, "UI")], view.offset, view.length), 
        out;
    },
    createMesh: createMesh,
    readBuffer: readBuffer,
    writeBuffer: writeBuffer,
    mapBuffer: mapBuffer
});

function applyDefaultGeometryOptions(options) {
    return void 0 === (options = options || {}).includeNormal && (options.includeNormal = !0), 
    void 0 === options.includeUV && (options.includeUV = !0), options;
}

function box(options) {
    var ws = (options = options || {}).widthSegments || 1, hs = options.heightSegments || 1, ls = options.lengthSegments || 1, hw = (options.width || 1) / 2, hh = (options.height || 1) / 2, hl = (options.length || 1) / 2, corners = [ Vec3.set(c0, -hw, -hh, hl), Vec3.set(c1, hw, -hh, hl), Vec3.set(c2, hw, hh, hl), Vec3.set(c3, -hw, hh, hl), Vec3.set(c4, hw, -hh, -hl), Vec3.set(c5, -hw, -hh, -hl), Vec3.set(c6, -hw, hh, -hl), Vec3.set(c7, hw, hh, -hl) ], faceAxes = [ [ 2, 3, 1 ], [ 4, 5, 7 ], [ 7, 6, 2 ], [ 1, 0, 4 ], [ 1, 4, 2 ], [ 5, 0, 6 ] ], faceNormals = [ [ 0, 0, 1 ], [ 0, 0, -1 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 1, 0, 0 ], [ -1, 0, 0 ] ], positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-hw, -hh, -hl), maxPos = new Vec3(hw, hh, hl), boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);
    function _buildPlane(side, uSegments, vSegments) {
        var u, v, ix, iy, offset = positions.length / 3, faceAxe = faceAxes[side], faceNormal = faceNormals[side];
        for (iy = 0; iy <= vSegments; iy++) for (ix = 0; ix <= uSegments; ix++) if (u = ix / uSegments, 
        v = iy / vSegments, Vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u), 
        Vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v), Vec3.subtract(temp3, temp2, corners[faceAxe[0]]), 
        Vec3.add(r, temp1, temp3), positions.push(r.x, r.y, r.z), normals.push(faceNormal[0], faceNormal[1], faceNormal[2]), 
        uvs.push(u, v), ix < uSegments && iy < vSegments) {
            var useg1 = uSegments + 1, a = ix + iy * useg1, b = ix + (iy + 1) * useg1, c = ix + 1 + (iy + 1) * useg1, d = ix + 1 + iy * useg1;
            indices.push(offset + a, offset + d, offset + b), indices.push(offset + b, offset + d, offset + c);
        }
    }
    return _buildPlane(0, ws, hs), _buildPlane(4, ls, hs), _buildPlane(1, ws, hs), _buildPlane(5, ls, hs), 
    _buildPlane(3, ws, ls), _buildPlane(2, ws, ls), {
        positions: positions,
        normals: normals,
        uvs: uvs,
        indices: indices,
        minPos: minPos,
        maxPos: maxPos,
        boundingRadius: boundingRadius
    };
}

var temp1 = new Vec3, temp2 = new Vec3, temp3 = new Vec3, r = new Vec3, c0 = new Vec3, c1 = new Vec3, c2 = new Vec3, c3 = new Vec3, c4 = new Vec3, c5 = new Vec3, c6 = new Vec3, c7 = new Vec3, temp1$1 = new Vec3(0, 0, 0), temp2$1 = new Vec3(0, 0, 0);

function cylinder() {
    var radiusTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5, height = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, opts = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, halfHeight = .5 * height, radialSegments = opts.radialSegments || 32, heightSegments = opts.heightSegments || 1, capped = void 0 === opts.capped || opts.capped, arc = opts.arc || 2 * Math.PI, cntCap = 0;
    capped || (radiusTop > 0 && cntCap++, radiusBottom > 0 && cntCap++);
    var vertCount = (radialSegments + 1) * (heightSegments + 1);
    capped && (vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap);
    var indexCount = radialSegments * heightSegments * 2 * 3;
    capped && (indexCount += radialSegments * cntCap * 3);
    var indices = new Array(indexCount), positions = new Array(3 * vertCount), normals = new Array(3 * vertCount), uvs = new Array(2 * vertCount), maxRadius = Math.max(radiusTop, radiusBottom), minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius), maxPos = new Vec3(maxRadius, halfHeight, maxRadius), boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight), index = 0, indexOffset = 0;
    return generateTorso(), capped && (radiusBottom > 0 && generateCap(!1), radiusTop > 0 && generateCap(!0)), 
    {
        positions: positions,
        normals: normals,
        uvs: uvs,
        indices: indices,
        minPos: minPos,
        maxPos: maxPos,
        boundingRadius: boundingRadius
    };
    function generateTorso() {
        for (var indexArray = [], r = radiusTop - radiusBottom, slope = r * r / height * Math.sign(r), y = 0; y <= heightSegments; y++) {
            for (var indexRow = [], v = y / heightSegments, radius = v * r + radiusBottom, x = 0; x <= radialSegments; ++x) {
                var u = x / radialSegments, theta = u * arc, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = v * height - halfHeight, 
                positions[3 * index + 2] = radius * cosTheta, Vec3.normalize(temp1$1, Vec3.set(temp2$1, sinTheta, -slope, cosTheta)), 
                normals[3 * index] = temp1$1.x, normals[3 * index + 1] = temp1$1.y, normals[3 * index + 2] = temp1$1.z, 
                uvs[2 * index] = 2 * (1 - u) % 1, uvs[2 * index + 1] = v, indexRow.push(index), 
                ++index;
            }
            indexArray.push(indexRow);
        }
        for (var _y = 0; _y < heightSegments; ++_y) for (var _x = 0; _x < radialSegments; ++_x) {
            var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
            indices[indexOffset] = i1, ++indexOffset, indices[indexOffset] = i4, ++indexOffset, 
            indices[indexOffset] = i2, ++indexOffset, indices[indexOffset] = i4, ++indexOffset, 
            indices[indexOffset] = i3, ++indexOffset, indices[indexOffset] = i2, ++indexOffset;
        }
    }
    function generateCap(top) {
        for (var radius = top ? radiusTop : radiusBottom, sign = top ? 1 : -1, centerIndexStart = index, x = 1; x <= radialSegments; ++x) positions[3 * index] = 0, 
        positions[3 * index + 1] = halfHeight * sign, positions[3 * index + 2] = 0, normals[3 * index] = 0, 
        normals[3 * index + 1] = sign, normals[3 * index + 2] = 0, uvs[2 * index] = .5, 
        uvs[2 * index + 1] = .5, ++index;
        for (var centerIndexEnd = index, _x2 = 0; _x2 <= radialSegments; ++_x2) {
            var theta = _x2 / radialSegments * arc, cosTheta = Math.cos(theta), sinTheta = Math.sin(theta);
            positions[3 * index] = radius * sinTheta, positions[3 * index + 1] = halfHeight * sign, 
            positions[3 * index + 2] = radius * cosTheta, normals[3 * index] = 0, normals[3 * index + 1] = sign, 
            normals[3 * index + 2] = 0, uvs[2 * index] = .5 - .5 * sinTheta * sign, uvs[2 * index + 1] = .5 + .5 * cosTheta, 
            ++index;
        }
        for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
            var c = centerIndexStart + _x3, i = centerIndexEnd + _x3;
            top ? (indices[indexOffset] = i + 1, ++indexOffset, indices[indexOffset] = c, ++indexOffset, 
            indices[indexOffset] = i, ++indexOffset) : (indices[indexOffset] = c, ++indexOffset, 
            indices[indexOffset] = i + 1, ++indexOffset, indices[indexOffset] = i, ++indexOffset);
        }
    }
}

var temp1$2 = new Vec3(0, 0, 0), temp2$2 = new Vec3(0, 0, 0), temp3$1 = new Vec3(0, 0, 0), r$1 = new Vec3(0, 0, 0), c00 = new Vec3(0, 0, 0), c10 = new Vec3(0, 0, 0), c01 = new Vec3(0, 0, 0);

var temp1$3 = new Vec3(0, 0, 0), temp2$3 = new Vec3(0, 0, 0);

var primitives = Object.freeze({
    __proto__: null,
    box: box,
    cone: function cone() {
        var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, height = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, opts = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return cylinder(0, radius, height, opts);
    },
    cylinder: cylinder,
    plane: function plane$1(options) {
        var normalizedOptions = function applyDefaultPlaneOptions(options) {
            return (options = applyDefaultGeometryOptions(options)).width = options.width || 10, 
            options.length = options.length || 10, options.widthSegments = options.widthSegments || 10, 
            options.lengthSegments = options.lengthSegments || 10, options;
        }(options), width = normalizedOptions.width, length = normalizedOptions.length, uSegments = normalizedOptions.widthSegments, vSegments = normalizedOptions.lengthSegments, hw = .5 * width, hl = .5 * length, positions = [], uvs = [], indices = [], minPos = new Vec3(-hw, 0, -hl), maxPos = new Vec3(hw, 0, hl), boundingRadius = Math.sqrt(width * width + length * length);
        Vec3.set(c00, -hw, 0, hl), Vec3.set(c10, hw, 0, hl), Vec3.set(c01, -hw, 0, -hl);
        for (var y = 0; y <= vSegments; y++) for (var x = 0; x <= uSegments; x++) {
            var u = x / uSegments, v = y / vSegments;
            if (Vec3.lerp(temp1$2, c00, c10, u), Vec3.lerp(temp2$2, c00, c01, v), Vec3.subtract(temp3$1, temp2$2, c00), 
            Vec3.add(r$1, temp1$2, temp3$1), positions.push(r$1.x, r$1.y, r$1.z), normalizedOptions.includeUV && uvs.push(u, v), 
            x < uSegments && y < vSegments) {
                var useg1 = uSegments + 1, a = x + y * useg1, b = x + (y + 1) * useg1, c = x + 1 + (y + 1) * useg1, d = x + 1 + y * useg1;
                indices.push(a, d, b), indices.push(d, c, b);
            }
        }
        var result = {
            positions: positions,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
        if (normalizedOptions.includeNormal) {
            var nVertex = (vSegments + 1) * (uSegments + 1), normals = new Array(3 * nVertex);
            result.normals = normals;
            for (var i = 0; i < nVertex; ++i) normals[3 * i + 0] = 0, normals[3 * i + 1] = 1, 
            normals[3 * i + 2] = 0;
        }
        return normalizedOptions.includeUV && (result.uvs = uvs), result;
    },
    quad: function quad(options) {
        var normalizedOptions = applyDefaultGeometryOptions(options), result = {
            positions: [ -.5, -.5, 0, -.5, .5, 0, .5, .5, 0, .5, -.5, 0 ],
            indices: [ 0, 3, 1, 3, 2, 1 ],
            minPos: {
                x: -.5,
                y: -.5,
                z: 0
            },
            maxPos: {
                x: .5,
                y: .5,
                z: 0
            },
            boundingRadius: Math.sqrt(.5)
        };
        return !1 !== normalizedOptions.includeNormal && (result.normals = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ]), 
        !1 !== normalizedOptions.includeUV && (result.uvs = [ 0, 0, 0, 1, 1, 1, 1, 0 ]), 
        result;
    },
    sphere: function sphere$1() {
        for (var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, segments = void 0 !== opts.segments ? opts.segments : 32, positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-radius, -radius, -radius), maxPos = new Vec3(radius, radius, radius), boundingRadius = radius, lat = 0; lat <= segments; ++lat) for (var theta = lat * Math.PI / segments, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= segments; ++lon) {
            var phi = 2 * lon * Math.PI / segments - Math.PI / 2, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi), x = sinPhi * sinTheta, y = cosTheta, z = cosPhi * sinTheta, u = lon / segments, v = lat / segments;
            if (positions.push(x * radius, y * radius, z * radius), normals.push(x, y, z), uvs.push(u, v), 
            lat < segments && lon < segments) {
                var seg1 = segments + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                indices.push(a, d, b), indices.push(d, c, b);
            }
        }
        return {
            positions: positions,
            indices: indices,
            normals: normals,
            uvs: uvs,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
    },
    torus: function torus() {
        for (var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .4, tube = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .1, opts = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, radialSegments = opts.radialSegments || 32, tubularSegments = opts.tubularSegments || 32, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], minPos = new Vec3(-radius - tube, -tube, -radius - tube), maxPos = new Vec3(radius + tube, tube, radius + tube), boundingRadius = radius + tube, j = 0; j <= radialSegments; j++) for (var i = 0; i <= tubularSegments; i++) {
            var u = i / tubularSegments, v = j / radialSegments, u1 = u * arc, v1 = v * Math.PI * 2, x = (radius + tube * Math.cos(v1)) * Math.sin(u1), y = tube * Math.sin(v1), z = (radius + tube * Math.cos(v1)) * Math.cos(u1), nx = Math.sin(u1) * Math.cos(v1), ny = Math.sin(v1), nz = Math.cos(u1) * Math.cos(v1);
            if (positions.push(x, y, z), normals.push(nx, ny, nz), uvs.push(u, v), i < tubularSegments && j < radialSegments) {
                var seg1 = tubularSegments + 1, a = seg1 * j + i, b = seg1 * (j + 1) + i, c = seg1 * (j + 1) + i + 1, d = seg1 * j + i + 1;
                indices.push(a, d, b), indices.push(d, c, b);
            }
        }
        return {
            positions: positions,
            normals: normals,
            uvs: uvs,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
    },
    capsule: function capsule$1() {
        var radiusTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, radiusBottom = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .5, height = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, opts = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, torsoHeight = height - radiusTop - radiusBottom, sides = opts.sides || 32, heightSegments = opts.heightSegments || 32, bottomProp = radiusBottom / height, torProp = torsoHeight / height, topProp = radiusTop / height, bottomSegments = Math.floor(heightSegments * bottomProp), topSegments = Math.floor(heightSegments * topProp), torSegments = Math.floor(heightSegments * torProp), topOffset = torsoHeight + radiusBottom - height / 2, torOffset = radiusBottom - height / 2, bottomOffset = radiusBottom - height / 2, arc = opts.arc || 2 * Math.PI, positions = [], normals = [], uvs = [], indices = [], maxRadius = Math.max(radiusTop, radiusBottom), minPos = new Vec3(-maxRadius, -height / 2, -maxRadius), maxPos = new Vec3(maxRadius, height / 2, maxRadius), boundingRadius = height / 2, index = 0, indexArray = [];
        return generateBottom(), generateTorso(), generateTop(), {
            positions: positions,
            normals: normals,
            uvs: uvs,
            indices: indices,
            minPos: minPos,
            maxPos: maxPos,
            boundingRadius: boundingRadius
        };
        function generateTorso() {
            for (var slope = (radiusTop - radiusBottom) / torsoHeight, y = 0; y <= torSegments; y++) {
                for (var indexRow = [], lat = y / torSegments, radius = lat * (radiusTop - radiusBottom) + radiusBottom, x = 0; x <= sides; ++x) {
                    var u = x / sides, v = lat * torProp + bottomProp, theta = u * arc - arc / 4, sinTheta = Math.sin(theta), cosTheta = Math.cos(theta);
                    positions.push(radius * sinTheta), positions.push(lat * torsoHeight + torOffset), 
                    positions.push(radius * cosTheta), Vec3.normalize(temp1$3, Vec3.set(temp2$3, sinTheta, -slope, cosTheta)), 
                    normals.push(temp1$3.x), normals.push(temp1$3.y), normals.push(temp1$3.z), uvs.push(u, v), 
                    indexRow.push(index), ++index;
                }
                indexArray.push(indexRow);
            }
            for (var _y = 0; _y < torSegments; ++_y) for (var _x = 0; _x < sides; ++_x) {
                var i1 = indexArray[_y][_x], i2 = indexArray[_y + 1][_x], i3 = indexArray[_y + 1][_x + 1], i4 = indexArray[_y][_x + 1];
                indices.push(i1), indices.push(i4), indices.push(i2), indices.push(i4), indices.push(i3), 
                indices.push(i2);
            }
        }
        function generateBottom() {
            for (var lat = 0; lat <= bottomSegments; ++lat) for (var theta = lat * Math.PI / bottomSegments / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                var phi = 2 * lon * Math.PI / sides - Math.PI / 2, x = Math.sin(phi) * sinTheta, y = cosTheta, z = Math.cos(phi) * sinTheta, u = lon / sides, v = lat / heightSegments;
                if (positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom), 
                normals.push(x, y, z), uvs.push(u, v), lat < bottomSegments && lon < sides) {
                    var seg1 = sides + 1, a = seg1 * lat + lon, b = seg1 * (lat + 1) + lon, c = seg1 * (lat + 1) + lon + 1, d = seg1 * lat + lon + 1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
                ++index;
            }
        }
        function generateTop() {
            for (var lat = 0; lat <= topSegments; ++lat) for (var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2, sinTheta = Math.sin(theta), cosTheta = -Math.cos(theta), lon = 0; lon <= sides; ++lon) {
                var phi = 2 * lon * Math.PI / sides - Math.PI / 2, x = Math.sin(phi) * sinTheta, y = cosTheta, z = Math.cos(phi) * sinTheta, u = lon / sides, v = lat / heightSegments + (1 - topProp);
                if (positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop), normals.push(x, y, z), 
                uvs.push(u, v), lat < topSegments && lon < sides) {
                    var seg1 = sides + 1, a = seg1 * lat + lon + indexArray[torSegments][sides] + 1, b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1, c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1, d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                    indices.push(a, d, b), indices.push(d, c, b);
                }
            }
        }
    },
    circle: function circle(options) {
        var segments = function applyDefaultCircleOptions(options) {
            return (options = applyDefaultGeometryOptions(options)).segments = 64, options;
        }(options).segments, positions = new Array(3 * (segments + 1));
        positions[0] = 0, positions[1] = 0, positions[2] = 0;
        var indices = new Array(1 + 2 * segments);
        indices[0] = 0;
        for (var step = 2 * Math.PI / segments, iSegment = 0; iSegment < segments; ++iSegment) {
            var angle = step * iSegment, x = Math.cos(angle), y = Math.sin(angle), p = 3 * (iSegment + 1);
            positions[p + 0] = x, positions[p + 1] = y, positions[p + 2] = 0;
            var i = 2 * iSegment;
            indices[1 + i] = iSegment + 1, indices[1 + (i + 1)] = iSegment + 2;
        }
        return segments > 0 && (indices[indices.length - 1] = 1), {
            positions: positions,
            indices: indices,
            minPos: {
                x: 1,
                y: 1,
                z: 0
            },
            maxPos: {
                x: -1,
                y: -1,
                z: 0
            },
            boundingRadius: 1,
            primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_FAN
        };
    },
    translate: function translate(geometry, offset) {
        for (var x = offset.x || 0, y = offset.y || 0, z = offset.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
            var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
            geometry.positions[iX] = geometry.positions[iX] + x, geometry.positions[iY] = geometry.positions[iY] + y, 
            geometry.positions[iZ] = geometry.positions[iZ] + z;
        }
        return geometry.minPos && (geometry.minPos.x += x, geometry.minPos.y += y, geometry.minPos.z += z), 
        geometry.maxPos && (geometry.maxPos.x += x, geometry.maxPos.y += y, geometry.maxPos.z += z), 
        geometry;
    },
    scale: function scale(geometry, value) {
        for (var x = value.x || 0, y = value.y || 0, z = value.z || 0, nVertex = Math.floor(geometry.positions.length / 3), iVertex = 0; iVertex < nVertex; ++iVertex) {
            var iX = 3 * iVertex, iY = 3 * iVertex + 1, iZ = 3 * iVertex + 2;
            geometry.positions[iX] *= x, geometry.positions[iY] *= y, geometry.positions[iZ] *= z;
        }
        return geometry.minPos && (geometry.minPos.x *= x, geometry.minPos.y *= y, geometry.minPos.z *= z), 
        geometry.maxPos && (geometry.maxPos.x *= x, geometry.maxPos.y *= y, geometry.maxPos.z *= z), 
        geometry.boundingRadius = Math.max(Math.max(x, y), z), geometry;
    },
    wireframed: function wireframed(geometry) {
        var indices = geometry.indices;
        if (!indices) return geometry;
        if (geometry.primitiveMode && geometry.primitiveMode !== exports.GFXPrimitiveMode.TRIANGLE_LIST) return geometry;
        for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
            var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
            void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
        }
        return geometry.indices = lines, geometry.primitiveMode = exports.GFXPrimitiveMode.LINE_LIST, 
        geometry;
    },
    wireframe: function wireframe(indices) {
        for (var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ], lines = [], lineIDs = {}, i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
            var i1 = indices[i + offsets[k][0]], i2 = indices[i + offsets[k][1]], id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
            void 0 === lineIDs[id] && (lineIDs[id] = 0, lines.push(i1, i2));
        }
        return lines;
    },
    invWinding: function invWinding(indices) {
        for (var newIB = [], i = 0; i < indices.length; i += 3) newIB.push(indices[i], indices[i + 2], indices[i + 1]);
        return newIB;
    },
    toWavefrontOBJ: function toWavefrontOBJ(primitive) {
        var scale = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        if (!primitive.indices || !primitive.uvs || !primitive.normals || void 0 !== primitive.primitiveMode && primitive.primitiveMode !== exports.GFXPrimitiveMode.TRIANGLE_LIST) return "";
        for (var v = primitive.positions, t = primitive.uvs, n = primitive.normals, IB = primitive.indices, V = function V(i) {
            return "".concat(IB[i] + 1, "/").concat(IB[i] + 1, "/").concat(IB[i] + 1);
        }, content = "", i = 0; i < v.length; i += 3) content += "v ".concat(v[i] * scale, " ").concat(v[i + 1] * scale, " ").concat(v[i + 2] * scale, "\n");
        for (var _i = 0; _i < t.length; _i += 2) content += "vt ".concat(t[_i], " ").concat(t[_i + 1], "\n");
        for (var _i2 = 0; _i2 < n.length; _i2 += 3) content += "vn ".concat(n[_i2], " ").concat(n[_i2 + 1], " ").concat(n[_i2 + 2], "\n");
        for (var _i3 = 0; _i3 < IB.length; _i3 += 3) content += "f ".concat(V(_i3), " ").concat(V(_i3 + 1), " ").concat(V(_i3 + 2), "\n");
        return content;
    },
    normals: function normals(positions, nms) {
        for (var length = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, verts = new Array(2 * positions.length), i = 0; i < positions.length / 3; ++i) {
            var i3 = 3 * i, i6 = 6 * i;
            verts[i6 + 0] = positions[i3 + 0], verts[i6 + 1] = positions[i3 + 1], verts[i6 + 2] = positions[i3 + 2], 
            verts[i6 + 3] = positions[i3 + 0] + nms[i3 + 0] * length, verts[i6 + 4] = positions[i3 + 1] + nms[i3 + 1] * length, 
            verts[i6 + 5] = positions[i3 + 2] + nms[i3 + 2] * length;
        }
        return verts;
    },
    applyDefaultGeometryOptions: applyDefaultGeometryOptions
}), skybox_mesh = null, skybox_material = null, Skybox = function(_Model) {
    function Skybox(scene) {
        var _this;
        if (_classCallCheck(this, Skybox), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Skybox).call(this)))._default = builtinResMgr.get("default-cube-texture"), 
        _this._envmap = _this._default, _this._isRGBE = !1, _this._useIBL = !1, _this._globalBinding = void 0, 
        _this.scene = scene, _this._globalBinding = _this.scene.root.pipeline.globalBindings.get(UNIFORM_ENVIRONMENT.name), 
        !skybox_material) {
            var mat = new Material;
            mat.initialize({
                effectName: "pipeline/skybox",
                defines: {
                    USE_RGBE_CUBEMAP: _this._isRGBE
                }
            }), skybox_material = new MaterialInstance({
                parent: mat
            });
        }
        return skybox_mesh || (skybox_mesh = createMesh(box({
            width: 2,
            height: 2,
            length: 2
        }))), _this.initSubModel(0, skybox_mesh.renderingSubMeshes[0], skybox_material), 
        _this;
    }
    return _inherits(Skybox, Model), _createClass(Skybox, [ {
        key: "useIBL",
        set: function set(val) {
            this._useIBL = val, this._updatePipeline();
        },
        get: function get() {
            return this._useIBL;
        }
    }, {
        key: "isRGBE",
        set: function set(val) {
            this._isRGBE = val, skybox_material.recompileShaders({
                USE_RGBE_CUBEMAP: this._isRGBE
            }), this.setSubModelMaterial(0, skybox_material), this._updatePipeline();
        },
        get: function get() {
            return this._isRGBE;
        }
    }, {
        key: "envmap",
        set: function set(val) {
            var newEnvmap = val || this._default;
            this._envmap = newEnvmap, this.scene.ambient.groundAlbedo[3] = this._envmap.mipmapLevel, 
            this._updateGlobalBinding();
        },
        get: function get() {
            return this._envmap;
        }
    } ]), _createClass(Skybox, [ {
        key: "onGlobalPipelineStateChanged",
        value: function onGlobalPipelineStateChanged() {
            _get(_getPrototypeOf(Skybox.prototype), "onGlobalPipelineStateChanged", this).call(this), 
            this._updateGlobalBinding();
        }
    }, {
        key: "_updatePipeline",
        value: function _updatePipeline() {
            var value = this._useIBL ? this._isRGBE ? 2 : 1 : 0, pipeline = this.scene.root.pipeline;
            (pipeline.macros.CC_USE_IBL || 0) !== value && (pipeline.macros.CC_USE_IBL = value, 
            this.scene.onGlobalPipelineStateChanged());
        }
    }, {
        key: "_updateGlobalBinding",
        value: function _updateGlobalBinding() {
            var textureView = this._envmap.getGFXTextureView(), sampler = samplerLib.getSampler(this._device, this._envmap.getSamplerHash());
            this._globalBinding.sampler = sampler, this._globalBinding.textureView = textureView;
            var mat = skybox_material;
            mat.passes[0].bindSampler(UNIFORM_ENVIRONMENT.binding, sampler), mat.passes[0].bindTextureView(UNIFORM_ENVIRONMENT.binding, textureView);
            for (var psos = this._matPSORecord.get(mat), i = 0; i < psos.length; i++) psos[i].pipelineLayout.layouts[0].update();
        }
    } ]), Skybox;
}(), RenderScene = function() {
    function RenderScene(root) {
        _classCallCheck(this, RenderScene), this._root = void 0, this._name = "", this._cameras = [], 
        this._ambient = void 0, this._skybox = void 0, this._planarShadows = void 0, this._models = [], 
        this._directionalLights = [], this._sphereLights = [], this._spotLights = [], this._mainLight = null, 
        this._modelId = 0, this._root = root, this._ambient = new Ambient(this), this._skybox = new Skybox(this), 
        this._planarShadows = new PlanarShadows(this);
    }
    return _createClass(RenderScene, [ {
        key: "root",
        get: function get() {
            return this._root;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "cameras",
        get: function get() {
            return this._cameras;
        }
    }, {
        key: "ambient",
        get: function get() {
            return this._ambient;
        }
    }, {
        key: "skybox",
        get: function get() {
            return this._skybox;
        }
    }, {
        key: "planarShadows",
        get: function get() {
            return this._planarShadows;
        }
    }, {
        key: "mainLight",
        get: function get() {
            return this._mainLight;
        }
    }, {
        key: "sphereLights",
        get: function get() {
            return this._sphereLights;
        }
    }, {
        key: "spotLights",
        get: function get() {
            return this._spotLights;
        }
    }, {
        key: "models",
        get: function get() {
            return this._models;
        }
    }, {
        key: "rayResultCanvas",
        get: function get() {
            return resultCanvas;
        }
    }, {
        key: "rayResultModels",
        get: function get() {
            return resultModels;
        }
    }, {
        key: "rayResultAll",
        get: function get() {
            return resultAll;
        }
    }, {
        key: "rayResultSingleModel",
        get: function get() {
            return resultSingleModel;
        }
    } ], [ {
        key: "registerCreateFunc",
        value: function registerCreateFunc(root) {
            root._createSceneFun = function(_root) {
                return new RenderScene(_root);
            };
        }
    } ]), _createClass(RenderScene, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._name = info.name, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.removeCameras(), this.removeSphereLights(), this.removeSpotLights(), this.removeModels(), 
            this._skybox.destroy(), this._planarShadows.destroy();
        }
    }, {
        key: "addCamera",
        value: function addCamera(cam) {
            cam.attachToScene(this), this._cameras.push(cam);
        }
    }, {
        key: "removeCamera",
        value: function removeCamera(camera) {
            for (var i = 0; i < this._cameras.length; ++i) if (this._cameras[i] === camera) return this._cameras.splice(i, 1), 
            void camera.detachFromScene();
        }
    }, {
        key: "removeCameras",
        value: function removeCameras() {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._cameras); !(_step = _iterator()).done; ) {
                _step.value.detachFromScene();
            }
            this._cameras.splice(0);
        }
    }, {
        key: "setMainLight",
        value: function setMainLight(dl) {
            this._mainLight = dl;
        }
    }, {
        key: "unsetMainLight",
        value: function unsetMainLight(dl) {
            if (this._mainLight === dl) {
                var dlList = this._directionalLights;
                dlList.length ? (this._mainLight = dlList[dlList.length - 1], this._mainLight.node && (this._mainLight.node.hasChangedFlags |= TransformBit.ROTATION)) : this._mainLight = null;
            }
        }
    }, {
        key: "addDirectionalLight",
        value: function addDirectionalLight(dl) {
            dl.attachToScene(this), this._directionalLights.push(dl);
        }
    }, {
        key: "removeDirectionalLight",
        value: function removeDirectionalLight(dl) {
            for (var i = 0; i < this._directionalLights.length; ++i) if (this._directionalLights[i] === dl) return dl.detachFromScene(), 
            void this._directionalLights.splice(i, 1);
        }
    }, {
        key: "addSphereLight",
        value: function addSphereLight(pl) {
            pl.attachToScene(this), this._sphereLights.push(pl);
        }
    }, {
        key: "removeSphereLight",
        value: function removeSphereLight(pl) {
            for (var i = 0; i < this._sphereLights.length; ++i) if (this._sphereLights[i] === pl) return pl.detachFromScene(), 
            void this._sphereLights.splice(i, 1);
        }
    }, {
        key: "addSpotLight",
        value: function addSpotLight(sl) {
            sl.attachToScene(this), this._spotLights.push(sl);
        }
    }, {
        key: "removeSpotLight",
        value: function removeSpotLight(sl) {
            for (var i = 0; i < this._spotLights.length; ++i) if (this._spotLights[i] === sl) return sl.detachFromScene(), 
            void this._spotLights.splice(i, 1);
        }
    }, {
        key: "removeSphereLights",
        value: function removeSphereLights() {
            for (var i = 0; i < this._sphereLights.length; ++i) this._sphereLights[i].detachFromScene();
            this._sphereLights.length = 0;
        }
    }, {
        key: "removeSpotLights",
        value: function removeSpotLights() {
            for (var i = 0; i < this._spotLights.length; ++i) this._spotLights[i].detachFromScene();
            this._spotLights = [];
        }
    }, {
        key: "addModel",
        value: function addModel(m) {
            m.attachToScene(this), this._models.push(m);
        }
    }, {
        key: "removeModel",
        value: function removeModel(model) {
            for (var i = 0; i < this._models.length; ++i) if (this._models[i] === model) return this._planarShadows.destroyShadowData(model), 
            model.detachFromScene(), void this._models.splice(i, 1);
        }
    }, {
        key: "removeModels",
        value: function removeModels() {
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._models); !(_step2 = _iterator2()).done; ) {
                var m = _step2.value;
                this._planarShadows.destroyShadowData(m), m.detachFromScene();
            }
            this._models.length = 0;
        }
    }, {
        key: "onGlobalPipelineStateChanged",
        value: function onGlobalPipelineStateChanged() {
            for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._models); !(_step3 = _iterator3()).done; ) {
                _step3.value.onGlobalPipelineStateChanged();
            }
            this._skybox.onGlobalPipelineStateChanged(), this._planarShadows.onGlobalPipelineStateChanged();
        }
    }, {
        key: "generateModelId",
        value: function generateModelId() {
            return this._modelId++;
        }
    }, {
        key: "raycastAll",
        value: function raycastAll(worldRay) {
            var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.Enum.DEFAULT | Layers.Enum.UI_2D, distance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0, r_3d = this.raycastAllModels(worldRay, mask, distance), r_ui2d = this.raycastAllCanvas(worldRay, mask, distance), isHit = r_3d || r_ui2d;
            return resultAll.length = 0, isHit && (Array.prototype.push.apply(resultAll, resultModels), 
            Array.prototype.push.apply(resultAll, resultCanvas)), isHit;
        }
    }, {
        key: "raycastAllModels",
        value: function raycastAllModels(worldRay) {
            var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.Enum.DEFAULT, distance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0;
            pool$1.reset();
            for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._models); !(_step4 = _iterator4()).done; ) {
                var m = _step4.value, transform = m.transform;
                if (transform && m.enabled && m.node.layer & mask & ~Layers.Enum.IGNORE_RAYCAST && m.worldBounds) {
                    var d = intersect.ray_aabb(worldRay, m.worldBounds);
                    if (!(d <= 0 || d >= distance)) {
                        if (m.type === ModelType.DEFAULT) {
                            Mat4.invert(m4, transform.getWorldMatrix(m4)), Vec3.transformMat4(modelRay.o, worldRay.o, m4), 
                            Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4)), 
                            d = 1 / 0;
                            for (var i = 0; i < m.subModelNum; ++i) {
                                var subModel = m.getSubModel(i).subMeshData;
                                if (subModel && subModel.geometricInfo) {
                                    var _subModel$geometricIn = subModel.geometricInfo, vb = _subModel$geometricIn.positions, ib = _subModel$geometricIn.indices, sides = _subModel$geometricIn.doubleSided;
                                    narrowphase(vb, ib, subModel.primitiveMode, sides, distance), d = Math.min(d, narrowDis * Vec3.multiply(v3$1, modelRay.d, transform.worldScale).length());
                                }
                            }
                        }
                        if (d < distance) {
                            var r = pool$1.add();
                            r.node = m.node, r.distance = d, resultModels[pool$1.length - 1] = r;
                        }
                    }
                }
            }
            return resultModels.length = pool$1.length, resultModels.length > 0;
        }
    }, {
        key: "raycastSingleModel",
        value: function raycastSingleModel(worldRay, model) {
            var mask = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Layers.Enum.DEFAULT, distance = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
            pool$1.reset();
            var m = model, transform = m.transform;
            if (!(transform && m.enabled && m.node.layer & mask & ~Layers.Enum.IGNORE_RAYCAST && m.worldBounds)) return !1;
            var d = intersect.ray_aabb(worldRay, m.worldBounds);
            if (d <= 0 || d >= distance) return !1;
            if (m.type === ModelType.DEFAULT) {
                Mat4.invert(m4, transform.getWorldMatrix(m4)), Vec3.transformMat4(modelRay.o, worldRay.o, m4), 
                Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4)), 
                d = 1 / 0;
                for (var i = 0; i < m.subModelNum; ++i) {
                    var subModel = m.getSubModel(i).subMeshData;
                    if (subModel && subModel.geometricInfo) {
                        var _subModel$geometricIn2 = subModel.geometricInfo, vb = _subModel$geometricIn2.positions, ib = _subModel$geometricIn2.indices, sides = _subModel$geometricIn2.doubleSided;
                        narrowphase(vb, ib, subModel.primitiveMode, sides, distance), d = Math.min(d, narrowDis * Vec3.multiply(v3$1, modelRay.d, transform.worldScale).length());
                    }
                }
            }
            if (d < distance) {
                var r = pool$1.add();
                r.node = m.node, r.distance = d, resultSingleModel[pool$1.length - 1] = r;
            }
            return resultSingleModel.length = pool$1.length, resultSingleModel.length > 0;
        }
    }, {
        key: "raycastAllCanvas",
        value: function raycastAllCanvas(worldRay) {
            var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Layers.Enum.UI_2D, distance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1 / 0;
            poolUI.reset();
            var canvasComs = cc.director.getScene().getComponentsInChildren(cc.CanvasComponent);
            if (null != canvasComs && canvasComs.length > 0) for (var i = 0; i < canvasComs.length; i++) {
                var canvasNode = canvasComs[i].node;
                null != canvasNode && canvasNode.active && this._raycastUI2DNodeRecursiveChildren(worldRay, canvasNode, mask, distance);
            }
            return resultCanvas.length = poolUI.length, resultCanvas.length > 0;
        }
    }, {
        key: "_raycastUI2DNode",
        value: function _raycastUI2DNode(worldRay, ui2dNode) {
            var mask = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Layers.Enum.UI_2D, distance = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0, uiTransform = ui2dNode._uiProps.uiTransformComp;
            if (!(null == uiTransform || ui2dNode.layer & Layers.Enum.IGNORE_RAYCAST) && ui2dNode.layer & mask) {
                uiTransform.getComputeAABB(aabbUI);
                var d = intersect.ray_aabb(worldRay, aabbUI);
                if (!(d <= 0) && d < distance) {
                    var r = poolUI.add();
                    return r.node = ui2dNode, r.distance = d, r;
                }
            }
        }
    }, {
        key: "_raycastUI2DNodeRecursiveChildren",
        value: function _raycastUI2DNodeRecursiveChildren(worldRay, parent) {
            var mask = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Layers.Enum.UI_2D, distance = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0, result = this._raycastUI2DNode(worldRay, parent, mask, distance);
            null != result && (resultCanvas[poolUI.length - 1] = result);
            for (var _step5, _iterator5 = _createForOfIteratorHelperLoose(parent.children); !(_step5 = _iterator5()).done; ) {
                var node = _step5.value;
                null != node && node.active && this._raycastUI2DNodeRecursiveChildren(worldRay, node, mask, distance);
            }
        }
    } ]), RenderScene;
}(), modelRay = ray.create(), v3$1 = new Vec3, m4 = new Mat4, narrowDis = 1 / 0, tri = triangle.create(), pool$1 = new RecyclePool((function() {
    return {
        node: null,
        distance: 1 / 0
    };
}), 8), resultModels = [], aabbUI = new aabb, poolUI = new RecyclePool((function() {
    return {
        node: null,
        distance: 1 / 0
    };
}), 8), resultCanvas = [], resultAll = [], resultSingleModel = [], narrowphase = function narrowphase(vb, ib, pm, sides) {
    var distance = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1 / 0;
    if (narrowDis = distance, pm === exports.GFXPrimitiveMode.TRIANGLE_LIST) for (var cnt = ib.length, j = 0; j < cnt; j += 3) {
        var i0 = 3 * ib[j], i1 = 3 * ib[j + 1], i2 = 3 * ib[j + 2];
        Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]), Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]), 
        Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
        var dist = intersect.ray_triangle(modelRay, tri, sides);
        dist <= 0 || dist >= narrowDis || (narrowDis = dist);
    } else if (pm === exports.GFXPrimitiveMode.TRIANGLE_STRIP) for (var _cnt = ib.length - 2, rev = 0, _j = 0; _j < _cnt; _j += 1) {
        var _i = 3 * ib[_j - rev], _i2 = 3 * ib[_j + rev + 1], _i3 = 3 * ib[_j + 2];
        Vec3.set(tri.a, vb[_i], vb[_i + 1], vb[_i + 2]), Vec3.set(tri.b, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]), 
        Vec3.set(tri.c, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]), rev = ~rev;
        var _dist = intersect.ray_triangle(modelRay, tri, sides);
        _dist <= 0 || _dist >= narrowDis || (narrowDis = _dist);
    } else if (pm === exports.GFXPrimitiveMode.TRIANGLE_FAN) {
        var _cnt2 = ib.length - 1, _i4 = 3 * ib[0];
        Vec3.set(tri.a, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);
        for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
            var _i5 = 3 * ib[_j2], _i6 = 3 * ib[_j2 + 1];
            Vec3.set(tri.b, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]), Vec3.set(tri.c, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);
            var _dist2 = intersect.ray_triangle(modelRay, tri, sides);
            _dist2 <= 0 || _dist2 >= narrowDis || (narrowDis = _dist2);
        }
    }
};

exports.replaceProperty(RenderScene.prototype, "RenderScene.prototype", [ {
    name: "raycastUI",
    newName: "raycastAllCanvas"
}, {
    name: "raycastUI2D",
    newName: "raycastAllCanvas"
}, {
    name: "raycast",
    newName: "raycastAllModels"
}, {
    name: "raycastModels",
    newName: "raycastAllModels"
}, {
    name: "raycastModel",
    newName: "raycastSingleModel"
} ]), exports.removeProperty(RenderScene.prototype, "RenderScene.prototype", [ {
    name: "raycastUI2DNode"
}, {
    name: "raycastUINode"
} ]), exports.markAsWarning(RenderScene.prototype, "RenderScene.prototype", [ {
    name: "raycastAll",
    suggest: "using intersect in geometry"
}, {
    name: "raycastAllModels",
    suggest: "using intersect in geometry"
}, {
    name: "raycastSingleModel",
    suggest: "using intersect in geometry"
}, {
    name: "raycastAllCanvas",
    suggest: "using intersect in geometry"
}, {
    name: "rayResultCanvas"
}, {
    name: "rayResultModels"
}, {
    name: "rayResultAll"
}, {
    name: "rayResultSingleModel"
} ]);

var CameraVisFlags = {};

exports.removeProperty(CameraVisFlags, "CameraVisFlags", [ {
    name: "GENERAL"
} ]), exports.replaceProperty(CameraVisFlags, "CameraVisFlags", [ {
    name: "PROFILER",
    newName: "PROFILER",
    target: Layers.BitMask,
    targetName: "PROFILER"
}, {
    name: "GIZMOS",
    newName: "GIZMOS",
    target: Layers.BitMask,
    targetName: "GIZMOS"
}, {
    name: "EDITOR",
    newName: "EDITOR",
    target: Layers.BitMask,
    targetName: "EDITOR"
}, {
    name: "UI",
    newName: "UI",
    target: Layers.BitMask,
    targetName: "UI_3D"
}, {
    name: "UI2D",
    newName: "UI2D",
    target: Layers.BitMask,
    targetName: "UI_2D"
} ]), cc.CameraVisFlags = CameraVisFlags;

var VisibilityFlags = {};

exports.removeProperty(VisibilityFlags, "VisibilityFlags", [ {
    name: "GENERAL"
} ]), exports.replaceProperty(VisibilityFlags, "VisibilityFlags", [ {
    name: "ALWALS",
    newName: "ALWALS",
    target: Layers.Enum,
    targetName: "ALWALS"
}, {
    name: "PROFILER",
    newName: "PROFILER",
    target: Layers.Enum,
    targetName: "PROFILER"
}, {
    name: "GIZMOS",
    newName: "GIZMOS",
    target: Layers.Enum,
    targetName: "GIZMOS"
}, {
    name: "EDITOR",
    newName: "EDITOR",
    target: Layers.Enum,
    targetName: "EDITOR"
}, {
    name: "UI",
    newName: "UI",
    target: Layers.Enum,
    targetName: "UI_3D"
}, {
    name: "UI2D",
    newName: "UI2D",
    target: Layers.Enum,
    targetName: "UI_2D"
} ]), cc.VisibilityFlags = VisibilityFlags;

var _class$L, _dec$M, _dec2$o, _dec3$d, _dec4$a, _dec5$9, _class$M, _class2$F, _descriptor$y, _descriptor2$p, _descriptor3$j, _descriptor4$d, _class3$e, _temp$I, InstanceMaterialType, _forward$1 = new Vec3(0, 0, -1), _v3$2 = new Vec3, _qt$2 = new Quat, DirectionalLight = function(_Light) {
    function DirectionalLight() {
        var _this;
        return _classCallCheck(this, DirectionalLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLight).call(this)))._dir = new Vec3(1, -1, -1), 
        _this._illum = Ambient.SUN_ILLUM, _this._type = LightType.DIRECTIONAL, _this;
    }
    return _inherits(DirectionalLight, Light), _createClass(DirectionalLight, [ {
        key: "direction",
        set: function set(dir) {
            this._dir = dir, Vec3.normalize(this._dir, this._dir);
        },
        get: function get() {
            return this._dir;
        }
    }, {
        key: "illuminance",
        set: function set(illum) {
            this._illum = illum;
        },
        get: function get() {
            return this._illum;
        }
    } ]), _createClass(DirectionalLight, [ {
        key: "update",
        value: function update() {
            this._node && this._node.hasChangedFlags && (this._dir = Vec3.transformQuat(_v3$2, _forward$1, this._node.getWorldRotation(_qt$2)), 
            Vec3.normalize(this._dir, this._dir));
        }
    } ]), DirectionalLight;
}(), SphereLight = function(_Light) {
    function SphereLight() {
        var _this;
        return _classCallCheck(this, SphereLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereLight).call(this)))._needUpdate = !1, 
        _this._size = .15, _this._range = 1, _this._luminance = 1700 / nt2lm(_this._size), 
        _this._pos = void 0, _this._aabb = void 0, _this._type = LightType.SPHERE, _this._aabb = aabb.create(), 
        _this._pos = new Vec3, _this;
    }
    return _inherits(SphereLight, Light), _createClass(SphereLight, [ {
        key: "position",
        get: function get() {
            return this._pos;
        }
    }, {
        key: "size",
        set: function set(size) {
            this._size = size;
        },
        get: function get() {
            return this._size;
        }
    }, {
        key: "range",
        set: function set(range) {
            this._range = range, this._needUpdate = !0;
        },
        get: function get() {
            return this._range;
        }
    }, {
        key: "luminance",
        set: function set(lum) {
            this._luminance = lum;
        },
        get: function get() {
            return this._luminance;
        }
    }, {
        key: "aabb",
        get: function get() {
            return this._aabb;
        }
    } ]), _createClass(SphereLight, [ {
        key: "update",
        value: function update() {
            this._node && (this._node.hasChangedFlags || this._needUpdate) && (this._node.getWorldPosition(this._pos), 
            aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), 
            this._needUpdate = !1);
        }
    } ]), SphereLight;
}(), _forward$2 = new Vec3(0, 0, -1), _qt$3 = (new Vec3, new Quat), _matView = new Mat4, _matProj = new Mat4, _matViewProj = new Mat4, _matViewProjInv = new Mat4, SpotLight = function(_Light) {
    function SpotLight() {
        var _this;
        return _classCallCheck(this, SpotLight), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this)))._dir = new Vec3(1, -1, -1), 
        _this._size = .15, _this._range = 5, _this._luminance = 1700 / nt2lm(_this._size), 
        _this._spotAngle = Math.cos(Math.PI / 6), _this._pos = void 0, _this._aabb = void 0, 
        _this._frustum = void 0, _this._angle = 0, _this._needUpdate = !1, _this._type = LightType.SPOT, 
        _this._aabb = aabb.create(), _this._frustum = frustum.create(), _this._pos = new Vec3, 
        _this;
    }
    return _inherits(SpotLight, Light), _createClass(SpotLight, [ {
        key: "position",
        get: function get() {
            return this._pos;
        }
    }, {
        key: "size",
        set: function set(size) {
            this._size = size;
        },
        get: function get() {
            return this._size;
        }
    }, {
        key: "range",
        set: function set(range) {
            this._range = range, this._needUpdate = !0;
        },
        get: function get() {
            return this._range;
        }
    }, {
        key: "luminance",
        set: function set(lum) {
            this._luminance = lum;
        },
        get: function get() {
            return this._luminance;
        }
    }, {
        key: "direction",
        get: function get() {
            return this._dir;
        }
    }, {
        key: "spotAngle",
        get: function get() {
            return this._spotAngle;
        },
        set: function set(val) {
            this._angle = .5 * val, this._spotAngle = Math.cos(.5 * val), this._needUpdate = !0;
        }
    }, {
        key: "aabb",
        get: function get() {
            return this._aabb;
        }
    }, {
        key: "frustum",
        get: function get() {
            return this._frustum;
        }
    } ]), _createClass(SpotLight, [ {
        key: "update",
        value: function update() {
            this._node && (this._node.hasChangedFlags || this._needUpdate) && (this._node.getWorldPosition(this._pos), 
            Vec3.transformQuat(this._dir, _forward$2, this._node.getWorldRotation(_qt$3)), Vec3.normalize(this._dir, this._dir), 
            aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range), 
            this._node.getWorldRT(_matView), Mat4.invert(_matView, _matView), Mat4.perspective(_matProj, this._angle, 1, .001, this._range), 
            Mat4.multiply(_matViewProj, _matProj, _matView), this._frustum.update(_matViewProj, _matViewProjInv), 
            this._needUpdate = !1);
        }
    } ]), SpotLight;
}(), BaseRenderData = function BaseRenderData() {
    _classCallCheck(this, BaseRenderData), this.material = null, this.vertexCount = 0, 
    this.indiceCount = 0;
}, RenderData = function(_BaseRenderData) {
    function RenderData() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, RenderData);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderData)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).vData = null, 
        _this.uvDirty = !0, _this.vertDirty = !0, _this._datas = [], _this._indices = [], 
        _this._pivotX = 0, _this._pivotY = 0, _this._width = 0, _this._height = 0, _this;
    }
    return _inherits(RenderData, BaseRenderData), _createClass(RenderData, [ {
        key: "updateSizeNPivot",
        value: function updateSizeNPivot(width, height, pivotX, pivotY) {
            width === this._width && height === this._height && pivotX === this._pivotX && pivotY === this._pivotY || (this._width = width, 
            this._height = height, this._pivotX = pivotX, this._pivotY = pivotY, this.vertDirty = !0);
        }
    }, {
        key: "clear",
        value: function clear() {
            this._datas.length = 0, this._indices.length = 0, this._pivotX = 0, this._pivotY = 0, 
            this._width = 0, this._height = 0, this.uvDirty = !0, this.vertDirty = !0, this.material = null, 
            this.vertexCount = 0, this.indiceCount = 0;
        }
    }, {
        key: "dataLength",
        get: function get() {
            return this._datas.length;
        },
        set: function set(length) {
            var data = this._datas;
            if (data.length !== length) {
                var value = data.length, i = 0;
                for (i = length; i < value; i++) _dataPool.free(data[i]);
                for (i = value; i < length; i++) data[i] = _dataPool.alloc();
                data.length = length;
            }
        }
    }, {
        key: "datas",
        get: function get() {
            return this._datas;
        }
    } ], [ {
        key: "add",
        value: function add() {
            return _pool$1.add();
        }
    }, {
        key: "remove",
        value: function remove(data) {
            var idx = _pool$1.data.indexOf(data);
            -1 !== idx && (_pool$1.data[idx].clear(), _pool$1.removeAt(idx));
        }
    } ]), RenderData;
}(), MeshRenderData = function(_BaseRenderData2) {
    function MeshRenderData() {
        var _getPrototypeOf3, _this2;
        _classCallCheck(this, MeshRenderData);
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
        return (_this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(MeshRenderData)).call.apply(_getPrototypeOf3, [ this ].concat(args)))).vData = new Float32Array(2304 * Float32Array.BYTES_PER_ELEMENT), 
        _this2.iData = new Uint16Array(1536), _this2.vertexStart = 0, _this2.indiceStart = 0, 
        _this2.byteStart = 0, _this2.byteCount = 0, _this2._formatByte = 9 * Float32Array.BYTES_PER_ELEMENT, 
        _this2;
    }
    return _inherits(MeshRenderData, BaseRenderData), _createClass(MeshRenderData, [ {
        key: "request",
        value: function request(vertexCount, indiceCount) {
            var byteOffset = this.byteCount + vertexCount * this._formatByte, indiceOffset = this.indiceCount + indiceCount;
            if (vertexCount + this.vertexCount > 65535) return !1;
            var byteLength = this.vData.byteLength, indiceLength = this.iData.length, vCount = this.vData.length, iCount = this.iData.length;
            if (byteOffset > byteLength || indiceOffset > indiceLength) {
                for (;byteLength < byteOffset || indiceLength < indiceOffset; ) byteLength = 4 * (vCount *= 2), 
                indiceLength = iCount *= 2;
                var oldvData = new Float32Array(this.vData.buffer);
                this.vData = new Float32Array(vCount), this.vData.set(oldvData, 0);
                var oldiData = new Uint16Array(this.iData.buffer);
                this.iData = new Uint16Array(iCount), this.iData.set(oldiData, 0);
            }
            return this.vertexCount += vertexCount, this.indiceCount += indiceCount, this.byteCount = byteOffset, 
            !0;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.vertexCount = 0, this.indiceCount = 0, this.byteCount = 0, this.vertexStart = 0, 
            this.indiceStart = 0, this.byteStart = 0;
        }
    } ]), MeshRenderData;
}(), _dataPool = new Pool$1((function() {
    return {
        x: 0,
        y: 0,
        z: 0,
        u: 0,
        v: 0,
        color: Color.WHITE.clone()
    };
}), 128), _pool$1 = new RecyclePool((function() {
    return new RenderData;
}), 32), addStage = config_addStage, renderer = Object.freeze({
    __proto__: null,
    addStage: addStage,
    createIA: function createIA(device, data) {
        if (!data.positions) return console.error("The data must have positions field"), 
        null;
        for (var verts = [], vcount = data.positions.length / 3, i = 0; i < vcount; ++i) verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]), 
        data.normals && verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]), 
        data.uvs && verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]), data.colors && verts.push(data.colors[3 * i], data.uvs[3 * i + 1], data.colors[3 * i + 2]);
        var vfmt = [];
        vfmt.push({
            name: exports.GFXAttributeName.ATTR_POSITION,
            format: exports.GFXFormat.RGB32F
        }), data.normals && vfmt.push({
            name: exports.GFXAttributeName.ATTR_NORMAL,
            format: exports.GFXFormat.RGB32F
        }), data.uvs && vfmt.push({
            name: exports.GFXAttributeName.ATTR_TEX_COORD,
            format: exports.GFXFormat.RG32F
        }), data.colors && vfmt.push({
            name: exports.GFXAttributeName.ATTR_COLOR,
            format: exports.GFXFormat.RGB32F
        });
        var vb = device.createBuffer({
            usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
            memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
            size: 4 * verts.length,
            stride: 4 * verts.length / vcount
        });
        vb.update(new Float32Array(verts));
        var ib = device.createBuffer({
            usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
            memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
            size: 2 * data.indices.length,
            stride: 2
        });
        return ib.update(new Uint16Array(data.indices)), device.createInputAssembler({
            attributes: vfmt,
            vertexBuffers: [ vb ],
            indexBuffer: ib
        });
    },
    get RenderQueue() {
        return RenderQueue$1;
    },
    get PassStage() {
        return PassStage;
    },
    genHandle: genHandle,
    getBindingTypeFromHandle: getBindingTypeFromHandle,
    getTypeFromHandle: getTypeFromHandle,
    getBindingFromHandle: getBindingFromHandle,
    getOffsetFromHandle: getOffsetFromHandle,
    customizeType: customizeType,
    type2reader: type2reader,
    type2writer: type2writer,
    getDefaultFromType: getDefaultFromType,
    assignDefines: assignDefines,
    Pass: Pass,
    programLib: programLib,
    get SamplerInfoIndex() {
        return SamplerInfoIndex;
    },
    genSamplerHash: genSamplerHash,
    samplerLib: samplerLib,
    nearestPOT: nearestPOT,
    TextureBufferPool: TextureBufferPool,
    MaterialInstance: MaterialInstance,
    PassInstance: PassInstance,
    uploadJointData: uploadJointData,
    MINIMUM_JOINT_TEXTURE_SIZE: 480,
    selectJointsMediumFormat: selectJointsMediumFormat,
    jointTextureSamplerHash: jointTextureSamplerHash,
    JointTexturePool: JointTexturePool,
    JointAnimationInfo: JointAnimationInfo,
    getWorldMatrix: getWorldMatrix,
    getTransform: getTransform,
    deleteTransform: deleteTransform,
    SkinningModel: SkinningModel,
    BakedSkinningModel: BakedSkinningModel,
    Ambient: Ambient,
    get CameraFOVAxis() {
        return CameraFOVAxis;
    },
    get CameraProjection() {
        return CameraProjection;
    },
    get CameraAperture() {
        return CameraAperture;
    },
    get CameraISO() {
        return CameraISO;
    },
    get CameraShutter() {
        return CameraShutter;
    },
    SKYBOX_FLAG: SKYBOX_FLAG,
    Camera: Camera,
    CameraVisFlags: CameraVisFlags,
    VisibilityFlags: VisibilityFlags,
    DirectionalLight: DirectionalLight,
    ColorTemperatureToRGB: ColorTemperatureToRGB,
    get LightType() {
        return LightType;
    },
    nt2lm: nt2lm,
    Light: Light,
    get ModelType() {
        return ModelType;
    },
    Model: Model,
    PlanarShadows: PlanarShadows,
    RenderScene: RenderScene,
    Skybox: Skybox,
    SphereLight: SphereLight,
    SpotLight: SpotLight,
    SubModel: SubModel
}), UIComponent = ccclass("cc.UIComponent")(_class$L = requireComponent(UITransformComponent)(_class$L = executionOrder(110)(_class$L = disallowMultiple(_class$L = executeInEditMode(_class$L = function(_Component) {
    function UIComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UIComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._lastParent = null, 
        _this;
    }
    return _inherits(UIComponent, Component), _createClass(UIComponent, [ {
        key: "__preload",
        value: function __preload() {
            this.node._uiProps.uiComp = this;
        }
    }, {
        key: "onEnable",
        value: function onEnable() {}
    }, {
        key: "onDisable",
        value: function onDisable() {}
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.node._uiProps.uiComp === this && (this.node._uiProps.uiComp = null);
        }
    }, {
        key: "updateAssembler",
        value: function updateAssembler(render) {}
    }, {
        key: "postUpdateAssembler",
        value: function postUpdateAssembler(render) {}
    } ]), UIComponent;
}()) || _class$L) || _class$L) || _class$L) || _class$L) || _class$L;

ccenum(exports.GFXBlendFactor), (InstanceMaterialType = exports.InstanceMaterialType || (exports.InstanceMaterialType = {}))[InstanceMaterialType.ADDCOLOR = 0] = "ADDCOLOR", 
InstanceMaterialType[InstanceMaterialType.ADDCOLORANDTEXTURE = 1] = "ADDCOLORANDTEXTURE", 
InstanceMaterialType[InstanceMaterialType.GRAYSCALE = 2] = "GRAYSCALE";

var _dec$N, _dec2$p, _dec3$e, _dec4$b, _dec5$a, _dec6$8, _dec7$6, _dec8$4, _dec9$3, _dec10$3, _dec11$3, _dec12$2, _dec13$2, _class$N, _class2$G, _descriptor$z, _descriptor2$q, _descriptor3$k, _descriptor4$e, _descriptor5$a, _descriptor6$5, _descriptor7$5, _descriptor8$4, _descriptor9$4, _descriptor10$4, _class3$f, _temp$J, SpriteType, FillType, SizeMode, EventType, _matInsInfo$1 = {
    parent: null,
    owner: null,
    subModelIdx: 0
}, UIRenderComponent = (_dec$M = ccclass("cc.UIRenderComponent"), _dec2$o = property({
    type: exports.GFXBlendFactor,
    displayOrder: 0,
    tooltip: "原图混合模式"
}), _dec3$d = property({
    type: exports.GFXBlendFactor,
    displayOrder: 1,
    tooltip: "目标混合模式"
}), _dec4$a = property({
    displayOrder: 2,
    tooltip: "渲染颜色"
}), _dec5$9 = property({
    type: Material,
    displayOrder: 3,
    tooltip: "源材质",
    visible: !1
}), _dec$M((_temp$I = _class3$e = function(_UIComponent) {
    function UIRenderComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UIRenderComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIRenderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_srcBlendFactor", _descriptor$y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_dstBlendFactor", _descriptor2$p, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_color", _descriptor3$j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_sharedMaterial", _descriptor4$d, _assertThisInitialized(_this)), 
        _this._assembler = null, _this._postAssembler = null, _this._renderData = null, 
        _this._renderDataFlag = !0, _this._renderFlag = !0, _this._delegateSrc = null, _this._material = null, 
        _this._instanceMaterialType = exports.InstanceMaterialType.ADDCOLORANDTEXTURE, _this._blendTemplate = {
            blendState: {
                targets: [ {
                    blendSrc: exports.GFXBlendFactor.SRC_ALPHA,
                    blendDst: exports.GFXBlendFactor.ONE_MINUS_SRC_ALPHA
                } ]
            },
            depthStencilState: {},
            rasterizerState: {}
        }, _this;
    }
    return _inherits(UIRenderComponent, UIComponent), _createClass(UIRenderComponent, [ {
        key: "__preload",
        value: function __preload() {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "__preload", this).call(this), 
            this._instanceMaterial(), this._flushAssembler && this._flushAssembler();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "onEnable", this).call(this), 
            this.node.on(exports.SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), 
            this.node.on(exports.SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
            this._renderFlag = this._canRender();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "onDisable", this).call(this), 
            this.node.off(exports.SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this), 
            this.node.off(exports.SystemEventType.SIZE_CHANGED, this._nodeStateChange, this), 
            this._renderFlag = !1;
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "onDestroy", this).call(this), 
            this.destroyRenderData(), this._material && this._material.destroy(), this._updateMaterial(null), 
            this._renderData = null;
        }
    }, {
        key: "markForUpdateRenderData",
        value: function markForUpdateRenderData() {
            var enable = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            if (this._renderFlag = this._canRender(), enable && this._renderFlag) {
                var renderData = this._renderData;
                renderData && (renderData.vertDirty = !0), this._renderDataFlag = enable;
            } else enable || (this._renderDataFlag = enable);
        }
    }, {
        key: "requestRenderData",
        value: function requestRenderData() {
            var data = RenderData.add();
            return this._renderData = data, data;
        }
    }, {
        key: "destroyRenderData",
        value: function destroyRenderData() {
            this._renderData && (RenderData.remove(this._renderData), this._renderData = null);
        }
    }, {
        key: "updateAssembler",
        value: function updateAssembler(render) {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "updateAssembler", this).call(this, render), 
            this._renderFlag && (this._checkAndUpdateRenderData(), this._render(render));
        }
    }, {
        key: "postUpdateAssembler",
        value: function postUpdateAssembler(render) {
            _get(_getPrototypeOf(UIRenderComponent.prototype), "postUpdateAssembler", this).call(this, render), 
            this._renderFlag && this._postRender(render);
        }
    }, {
        key: "_render",
        value: function _render(render) {}
    }, {
        key: "_postRender",
        value: function _postRender(render) {}
    }, {
        key: "_checkAndUpdateRenderData",
        value: function _checkAndUpdateRenderData() {
            this._renderDataFlag && (this._assembler.updateRenderData(this), this._renderDataFlag = !1);
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            return null !== this.material && this.enabled && (this._delegateSrc ? this._delegateSrc.activeInHierarchy : this.enabledInHierarchy);
        }
    }, {
        key: "_postCanRender",
        value: function _postCanRender() {}
    }, {
        key: "_updateColor",
        value: function _updateColor() {
            this._assembler && this._assembler.updateColor && this._assembler.updateColor(this);
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial(material) {
            this._material = material, this._updateBlendFunc();
        }
    }, {
        key: "_updateBlendFunc",
        value: function _updateBlendFunc() {
            if (this._material) {
                var target = this._blendTemplate.blendState.targets[0];
                target.blendDst === this._dstBlendFactor && target.blendSrc === this._srcBlendFactor || (target.blendDst = this._dstBlendFactor, 
                target.blendSrc = this._srcBlendFactor, this._blendTemplate.depthStencilState = this._material.passes[0].depthStencilState, 
                this._blendTemplate.rasterizerState = this._material.passes[0].rasterizerState, 
                this._material.overridePipelineStates(this._blendTemplate, 0));
            }
        }
    }, {
        key: "_nodeStateChange",
        value: function _nodeStateChange(type) {
            this._renderData && this.markForUpdateRenderData();
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this.node.children); !(_step = _iterator()).done; ) {
                var renderComp = _step.value.getComponent(UIRenderComponent);
                renderComp && renderComp.markForUpdateRenderData();
            }
        }
    }, {
        key: "_instanceMaterial",
        value: function _instanceMaterial() {
            var mat = null;
            if (_matInsInfo$1.owner = new RenderableComponent, this._sharedMaterial) _matInsInfo$1.parent = this._sharedMaterial, 
            mat = new MaterialInstance(_matInsInfo$1); else switch (this._instanceMaterialType) {
              case exports.InstanceMaterialType.ADDCOLOR:
                _matInsInfo$1.parent = builtinResMgr.get("ui-base-material"), mat = new MaterialInstance(_matInsInfo$1);
                break;

              case exports.InstanceMaterialType.ADDCOLORANDTEXTURE:
                _matInsInfo$1.parent = builtinResMgr.get("ui-sprite-material"), mat = new MaterialInstance(_matInsInfo$1);
                break;

              case exports.InstanceMaterialType.GRAYSCALE:
                _matInsInfo$1.parent = builtinResMgr.get("ui-sprite-gray-material"), mat = new MaterialInstance(_matInsInfo$1);
            }
            this._updateMaterial(mat);
        }
    }, {
        key: "srcBlendFactor",
        get: function get() {
            return this._srcBlendFactor;
        },
        set: function set(value) {
            this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "dstBlendFactor",
        get: function get() {
            return this._dstBlendFactor;
        },
        set: function set(value) {
            this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(value) {
            this._color !== value && (this._color.set(value), this._updateColor(), this.markForUpdateRenderData());
        }
    }, {
        key: "sharedMaterial",
        get: function get() {
            return this._sharedMaterial;
        },
        set: function set(value) {
            this._sharedMaterial !== value && (this._sharedMaterial = value, this._instanceMaterial && this._instanceMaterial());
        }
    }, {
        key: "material",
        get: function get() {
            return this._material || this._instanceMaterial && this._instanceMaterial(), this._material;
        }
    }, {
        key: "renderData",
        get: function get() {
            return this._renderData;
        }
    }, {
        key: "delegateSrc",
        set: function set(value) {
            this._delegateSrc = value;
        }
    } ]), UIRenderComponent;
}(), _class3$e.BlendState = exports.GFXBlendFactor, _class3$e.Assembler = null, 
_class3$e.PostAssembler = null, _applyDecoratedDescriptor((_class2$F = _temp$I).prototype, "srcBlendFactor", [ _dec2$o ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "srcBlendFactor"), _class2$F.prototype), 
_applyDecoratedDescriptor(_class2$F.prototype, "dstBlendFactor", [ _dec3$d ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "dstBlendFactor"), _class2$F.prototype), 
_applyDecoratedDescriptor(_class2$F.prototype, "color", [ _dec4$a ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "color"), _class2$F.prototype), 
_applyDecoratedDescriptor(_class2$F.prototype, "sharedMaterial", [ _dec5$9 ], Object.getOwnPropertyDescriptor(_class2$F.prototype, "sharedMaterial"), _class2$F.prototype), 
_descriptor$y = _applyDecoratedDescriptor(_class2$F.prototype, "_srcBlendFactor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXBlendFactor.SRC_ALPHA;
    }
}), _descriptor2$p = _applyDecoratedDescriptor(_class2$F.prototype, "_dstBlendFactor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.GFXBlendFactor.ONE_MINUS_SRC_ALPHA;
    }
}), _descriptor3$j = _applyDecoratedDescriptor(_class2$F.prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor4$d = _applyDecoratedDescriptor(_class2$F.prototype, "_sharedMaterial", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$M = _class2$F)) || _class$M);

cc.UIRenderComponent = UIRenderComponent, function(SpriteType) {
    SpriteType[SpriteType.SIMPLE = 0] = "SIMPLE", SpriteType[SpriteType.SLICED = 1] = "SLICED", 
    SpriteType[SpriteType.TILED = 2] = "TILED", SpriteType[SpriteType.FILLED = 3] = "FILLED";
}(SpriteType || (SpriteType = {})), ccenum(SpriteType), function(FillType) {
    FillType[FillType.HORIZONTAL = 0] = "HORIZONTAL", FillType[FillType.VERTICAL = 1] = "VERTICAL", 
    FillType[FillType.RADIAL = 2] = "RADIAL";
}(FillType || (FillType = {})), ccenum(FillType), function(SizeMode) {
    SizeMode[SizeMode.CUSTOM = 0] = "CUSTOM", SizeMode[SizeMode.TRIMMED = 1] = "TRIMMED", 
    SizeMode[SizeMode.RAW = 2] = "RAW";
}(SizeMode || (SizeMode = {})), ccenum(SizeMode), function(EventType) {
    EventType.SPRITE_FRAME_CHANGED = "spriteframe-changed";
}(EventType || (EventType = {}));

var _dec$O, _dec2$q, _dec3$f, _dec4$c, _dec5$b, _dec6$9, _class$O, _class2$H, _descriptor$A, SpriteComponent = (_dec$N = ccclass("cc.SpriteComponent"), 
_dec2$p = help("i18n:cc.SpriteComponent"), _dec3$e = executionOrder(110), _dec4$b = menu("UI/Render/Sprite"), 
_dec5$a = property({
    type: SpriteAtlas,
    displayOrder: 4,
    tooltip: "图片资源所属的 Atlas 图集资源"
}), _dec6$8 = property({
    type: SpriteFrame,
    displayOrder: 5,
    tooltip: "渲染 Sprite 使用的 SpriteFrame 图片资源"
}), _dec7$6 = property({
    type: SpriteType,
    displayOrder: 6,
    tooltip: "渲染模式：\n- 普通（Simple）：修改尺寸会整体拉伸图像，适用于序列帧动画和普通图像 \n- 九宫格（Sliced）：修改尺寸时四个角的区域不会拉伸，适用于 UI 按钮和面板背景 \n- 填充（Filled）：设置一定的填充起始位置和方向，能够以一定比率剪裁显示图片"
}), _dec8$4 = property({
    type: FillType,
    tooltip: "填充方向，可以选择横向（Horizontal），纵向（Vertical）和扇形（Radial）三种方向"
}), _dec9$3 = property({
    tooltip: "扇形填充时，指定扇形的中心点，取值范围 0 ~ 1"
}), _dec10$3 = property({
    range: [ 0, 1, .1 ],
    tooltip: "填充起始位置，输入一个 0 ~ 1 之间的小数表示起始位置的百分比"
}), _dec11$3 = property({
    range: [ 0, 1, .1 ],
    tooltip: "填充总量，取值范围 0 ~ 1 指定显示图像范围的百分比"
}), _dec12$2 = property({
    displayOrder: 8,
    tooltip: "节点约束框内是否包括透明像素区域，勾选此项会去除节点约束框内的透明区域"
}), _dec13$2 = property({
    type: SizeMode,
    displayOrder: 7,
    tooltip: "指定 Sprite 所在节点的尺寸，CUSTOM 表示自定义尺寸，TRIMMED 表示取原始图片剪裁透明像素后的尺寸，RAW 表示取原始图片未剪裁的尺寸"
}), _dec$N(_class$N = _dec2$p(_class$N = _dec3$e(_class$N = _dec4$b((_temp$J = _class3$f = function(_UIRenderComponent) {
    function SpriteComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SpriteComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_spriteFrame", _descriptor$z, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_type", _descriptor2$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillType", _descriptor3$k, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_sizeMode", _descriptor4$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillCenter", _descriptor5$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillStart", _descriptor6$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillRange", _descriptor7$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isTrimmedMode", _descriptor8$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_useGrayscale", _descriptor9$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_atlas", _descriptor10$4, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SpriteComponent, UIRenderComponent), _createClass(SpriteComponent, [ {
        key: "__preload",
        value: function __preload() {
            this._useGrayscale && (this._instanceMaterialType = exports.InstanceMaterialType.GRAYSCALE), 
            _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this) && _get(_getPrototypeOf(SpriteComponent.prototype), "__preload", this).call(this), 
            this._spriteFrame && (this._spriteFrame.on("load", this._markForUpdateUvDirty, this), 
            this._markForUpdateUvDirty());
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(SpriteComponent.prototype), "onEnable", this).call(this), this._activateMaterial();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(SpriteComponent.prototype), "onDestroy", this).call(this), 
            this.destroyRenderData(), this._spriteFrame && this._spriteFrame.off("load");
        }
    }, {
        key: "changeSpriteFrameFromAtlas",
        value: function changeSpriteFrameFromAtlas(name) {
            if (this._atlas) {
                var sprite = this._atlas.getSpriteFrame(name);
                this.spriteFrame = sprite;
            } else console.warn("SpriteAtlas is null.");
        }
    }, {
        key: "_render",
        value: function _render(render) {
            render.commitComp(this, this._spriteFrame.getGFXTextureView(), this._assembler, this._spriteFrame.texture.getGFXSampler());
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            if (!_get(_getPrototypeOf(SpriteComponent.prototype), "_canRender", this).call(this)) return !1;
            var spriteFrame = this._spriteFrame;
            return !(!spriteFrame || !spriteFrame.textureLoaded());
        }
    }, {
        key: "_flushAssembler",
        value: function _flushAssembler() {
            var assembler = SpriteComponent.Assembler.getAssembler(this);
            this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
            this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
            this._renderData.material = this._material, this.markForUpdateRenderData(), this._updateColor());
        }
    }, {
        key: "_applySpriteSize",
        value: function _applySpriteSize() {
            if (this._spriteFrame) {
                if (SizeMode.RAW === this._sizeMode) {
                    var size = this._spriteFrame.originalSize;
                    this.node.setContentSize(size);
                } else if (SizeMode.TRIMMED === this._sizeMode) {
                    var rect = this._spriteFrame.getRect();
                    this.node.setContentSize(rect.width, rect.height);
                }
                this._activateMaterial();
            }
        }
    }, {
        key: "_resized",
        value: function _resized() {}
    }, {
        key: "_activateMaterial",
        value: function _activateMaterial() {
            var spriteFrame = this._spriteFrame, material = this._material;
            cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS ? (spriteFrame && material && this.markForUpdateRenderData(), 
            this._renderData && (this._renderData.material = material)) : this.markForUpdateRenderData();
        }
    }, {
        key: "_onTextureLoaded",
        value: function _onTextureLoaded() {
            this.isValid && this._applySpriteSize();
        }
    }, {
        key: "_applySpriteFrame",
        value: function _applySpriteFrame(oldFrame) {
            var spriteFrame = this._spriteFrame;
            this._renderData && (oldFrame && oldFrame.off("load", this._markForUpdateUvDirty), 
            spriteFrame && spriteFrame.on("load", this._markForUpdateUvDirty, this), this._renderData.uvDirty || (this._renderData.uvDirty = !oldFrame || !spriteFrame || oldFrame.uvHash !== spriteFrame.uvHash), 
            this._renderDataFlag = this._renderData.uvDirty), spriteFrame && (oldFrame && spriteFrame === oldFrame || (spriteFrame.loaded ? this._onTextureLoaded() : spriteFrame.once("load", this._onTextureLoaded, this)));
        }
    }, {
        key: "_markForUpdateUvDirty",
        value: function _markForUpdateUvDirty() {
            this._renderData && (this._renderData.uvDirty = !0, this._renderDataFlag = !0);
        }
    }, {
        key: "spriteAtlas",
        get: function get() {
            return this._atlas;
        },
        set: function set(value) {
            this._atlas !== value && (this._atlas = value);
        }
    }, {
        key: "spriteFrame",
        get: function get() {
            return this._spriteFrame;
        },
        set: function set(value) {
            if (this._spriteFrame !== value) {
                var lastSprite = this._spriteFrame;
                this._spriteFrame = value, this.markForUpdateRenderData(!1), this._applySpriteFrame(lastSprite);
            }
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        },
        set: function set(value) {
            this._type !== value && (this._type = value, this._flushAssembler());
        }
    }, {
        key: "fillType",
        get: function get() {
            return this._fillType;
        },
        set: function set(value) {
            this._fillType !== value && (value === FillType.RADIAL || this._fillType === FillType.RADIAL ? (this.destroyRenderData(), 
            this._renderData = null) : this._renderData && this.markForUpdateRenderData(!0)), 
            this._fillType = value, this._flushAssembler();
        }
    }, {
        key: "fillCenter",
        get: function get() {
            return this._fillCenter;
        },
        set: function set(value) {
            this._fillCenter.x = value.x, this._fillCenter.y = value.y, this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData();
        }
    }, {
        key: "fillStart",
        get: function get() {
            return this._fillStart;
        },
        set: function set(value) {
            this._fillStart = clamp(value, -1, 1), this._type === SpriteType.FILLED && this._renderData && (this.markForUpdateRenderData(), 
            this._renderData.uvDirty = !0);
        }
    }, {
        key: "fillRange",
        get: function get() {
            return this._fillRange;
        },
        set: function set(value) {
            this._fillRange = clamp(value, 0, 1), this._type === SpriteType.FILLED && this._renderData && (this.markForUpdateRenderData(), 
            this._renderData.uvDirty = !0);
        }
    }, {
        key: "trim",
        get: function get() {
            return this._isTrimmedMode;
        },
        set: function set(value) {
            this._isTrimmedMode !== value && (this._isTrimmedMode = value, this._type === SpriteType.SIMPLE && this._renderData && this.markForUpdateRenderData(!0));
        }
    }, {
        key: "grayscale",
        get: function get() {
            return this._useGrayscale;
        },
        set: function set(value) {
            this._useGrayscale !== value && (this._useGrayscale = value, this._instanceMaterialType = !0 === value ? exports.InstanceMaterialType.GRAYSCALE : exports.InstanceMaterialType.ADDCOLORANDTEXTURE, 
            this._instanceMaterial());
        }
    }, {
        key: "sizeMode",
        get: function get() {
            return this._sizeMode;
        },
        set: function set(value) {
            this._sizeMode !== value && (this._sizeMode = value, value !== SizeMode.CUSTOM && this._applySpriteSize());
        }
    } ]), SpriteComponent;
}(), _class3$f.FillType = FillType, _class3$f.Type = SpriteType, _class3$f.SizeMode = SizeMode, 
_class3$f.EventType = EventType, _applyDecoratedDescriptor((_class2$G = _temp$J).prototype, "spriteAtlas", [ _dec5$a ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "spriteAtlas"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "spriteFrame", [ _dec6$8 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "spriteFrame"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "type", [ _dec7$6 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "type"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "fillType", [ _dec8$4 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "fillType"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "fillCenter", [ _dec9$3 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "fillCenter"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "fillStart", [ _dec10$3 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "fillStart"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "fillRange", [ _dec11$3 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "fillRange"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "trim", [ _dec12$2 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "trim"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "grayscale", [ property ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "grayscale"), _class2$G.prototype), 
_applyDecoratedDescriptor(_class2$G.prototype, "sizeMode", [ _dec13$2 ], Object.getOwnPropertyDescriptor(_class2$G.prototype, "sizeMode"), _class2$G.prototype), 
_descriptor$z = _applyDecoratedDescriptor(_class2$G.prototype, "_spriteFrame", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$q = _applyDecoratedDescriptor(_class2$G.prototype, "_type", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return SpriteType.SIMPLE;
    }
}), _descriptor3$k = _applyDecoratedDescriptor(_class2$G.prototype, "_fillType", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return FillType.HORIZONTAL;
    }
}), _descriptor4$e = _applyDecoratedDescriptor(_class2$G.prototype, "_sizeMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return SizeMode.TRIMMED;
    }
}), _descriptor5$a = _applyDecoratedDescriptor(_class2$G.prototype, "_fillCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(0, 0);
    }
}), _descriptor6$5 = _applyDecoratedDescriptor(_class2$G.prototype, "_fillStart", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$5 = _applyDecoratedDescriptor(_class2$G.prototype, "_fillRange", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$4 = _applyDecoratedDescriptor(_class2$G.prototype, "_isTrimmedMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor9$4 = _applyDecoratedDescriptor(_class2$G.prototype, "_useGrayscale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor10$4 = _applyDecoratedDescriptor(_class2$G.prototype, "_atlas", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$N = _class2$G)) || _class$N) || _class$N) || _class$N) || _class$N);

cc.SpriteComponent = SpriteComponent;

var SubContextView = (_dec$O = ccclass("cc.SubContextView"), _dec2$q = help("i18n:cc.SubContextView"), 
_dec3$f = executionOrder(110), _dec4$c = requireComponent(UITransformComponent), 
_dec5$b = menu("Components/SubContextView"), _dec6$9 = property({
    tooltip: "帧数"
}), _dec$O(_class$O = _dec2$q(_class$O = _dec3$f(_class$O = _dec4$c(_class$O = _dec5$b((_applyDecoratedDescriptor((_class2$H = function(_Component) {
    function SubContextView() {
        var _this;
        return _classCallCheck(this, SubContextView), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SubContextView).call(this)), "_fps", _descriptor$A, _assertThisInitialized(_this)), 
        _this._sprite = void 0, _this._imageAsset = void 0, _this._context = void 0, _this._updatedTime = 0, 
        _this._updateInterval = 0, _this._firstlyEnabled = !0, _this._sprite = null, _this._imageAsset = new ImageAsset, 
        _this._context = null, _this._updatedTime = performance.now(), _this;
    }
    return _inherits(SubContextView, Component), _createClass(SubContextView, [ {
        key: "fps",
        get: function get() {
            return this._fps;
        },
        set: function set(value) {
            this._fps !== value && (this._fps = value, this._updateInterval = 1 / value, this._updateSubContextFrameRate());
        }
    } ]), _createClass(SubContextView, [ {
        key: "onLoad",
        value: function onLoad() {
            if (window.__globalAdapter && __globalAdapter.getOpenDataContext) {
                this._updateInterval = 1e3 / this._fps, this._context = __globalAdapter.getOpenDataContext(), 
                this.reset();
                var image = this._imageAsset, sharedCanvas = this._context.canvas;
                if (image.reset(sharedCanvas), image._texture.create(sharedCanvas.width, sharedCanvas.height), 
                this._sprite = this.node.getComponent(SpriteComponent), this._sprite || (this._sprite = this.node.addComponent(SpriteComponent)), 
                this._sprite.spriteFrame) this._sprite.spriteFrame.texture = this._imageAsset._texture; else {
                    var sp = new SpriteFrame;
                    sp.texture = this._imageAsset._texture, this._sprite.spriteFrame = sp;
                }
            } else this.enabled = !1;
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._firstlyEnabled && this._context ? (this._context.postMessage({
                fromEngine: !0,
                event: "boot"
            }), this._firstlyEnabled = !1) : this._runSubContextMainLoop(), this._registerNodeEvent(), 
            this._updateSubContextFrameRate(), this.updateSubContextViewport();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._unregisterNodeEvent(), this._stopSubContextMainLoop();
        }
    }, {
        key: "update",
        value: function update(dt) {
            if (void 0 === dt) return this._context && this._context.postMessage({
                fromEngine: !0,
                event: "step"
            }), void this._updateSubContextTexture();
            performance.now() - this._updatedTime >= this._updateInterval && (this._updatedTime += this._updateInterval, 
            this._updateSubContextTexture());
        }
    }, {
        key: "reset",
        value: function reset() {
            if (this._context) {
                this.updateSubContextViewport();
                var sharedCanvas = this._context.canvas, transformComp = this.node.getComponent(UITransformComponent);
                sharedCanvas && (sharedCanvas.width = transformComp.width, sharedCanvas.height = transformComp.height);
            }
        }
    }, {
        key: "updateSubContextViewport",
        value: function updateSubContextViewport() {
            if (this._context) {
                var box = this.node.getComponent(UITransformComponent).getBoundingBoxToWorld(), sx = view.getScaleX(), sy = view.getScaleY(), rect = view.getViewportRect();
                this._context.postMessage({
                    fromEngine: !0,
                    event: "viewport",
                    x: box.x * sx + rect.x,
                    y: box.y * sy + rect.y,
                    width: box.width * sx,
                    height: box.height * sy
                });
            }
        }
    }, {
        key: "_updateSubContextTexture",
        value: function _updateSubContextTexture() {
            var img = this._imageAsset;
            if (img && this._context && !(img.width <= 0 || img.height <= 0)) {
                var canvas = this._context.canvas;
                img.reset(canvas), (canvas.width > img.width || canvas.height > img.height) && this._imageAsset._texture.create(canvas.width, canvas.height), 
                this._imageAsset._texture.uploadData(canvas);
            }
        }
    }, {
        key: "_registerNodeEvent",
        value: function _registerNodeEvent() {
            this.node.on(Node$1.EventType.TRANSFORM_CHANGED, this.updateSubContextViewport, this), 
            this.node.on(Node$1.EventType.SIZE_CHANGED, this.updateSubContextViewport, this);
        }
    }, {
        key: "_unregisterNodeEvent",
        value: function _unregisterNodeEvent() {
            this.node.off(Node$1.EventType.TRANSFORM_CHANGED, this.updateSubContextViewport, this), 
            this.node.off(Node$1.EventType.SIZE_CHANGED, this.updateSubContextViewport, this);
        }
    }, {
        key: "_runSubContextMainLoop",
        value: function _runSubContextMainLoop() {
            this._context && this._context.postMessage({
                fromEngine: !0,
                event: "mainLoop",
                value: !0
            });
        }
    }, {
        key: "_stopSubContextMainLoop",
        value: function _stopSubContextMainLoop() {
            this._context && this._context.postMessage({
                fromEngine: !0,
                event: "mainLoop",
                value: !1
            });
        }
    }, {
        key: "_updateSubContextFrameRate",
        value: function _updateSubContextFrameRate() {
            this._context && this._context.postMessage({
                fromEngine: !0,
                event: "frameRate",
                value: this._fps
            });
        }
    } ]), SubContextView;
}()).prototype, "fps", [ _dec6$9 ], Object.getOwnPropertyDescriptor(_class2$H.prototype, "fps"), _class2$H.prototype), 
_descriptor$A = _applyDecoratedDescriptor(_class2$H.prototype, "_fps", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 60;
    }
}), _class$O = _class2$H)) || _class$O) || _class$O) || _class$O) || _class$O) || _class$O);

cc.SubContextView = SubContextView;

var System = function() {
    function System() {
        _classCallCheck(this, System), this._id = "", this._priority = 0, this._executeInEditMode = !1;
    }
    return _createClass(System, [ {
        key: "init",
        value: function init() {}
    }, {
        key: "update",
        value: function update(dt) {}
    }, {
        key: "postUpdate",
        value: function postUpdate(dt) {}
    }, {
        key: "priority",
        set: function set(value) {
            this._priority = value;
        },
        get: function get() {
            return this._priority;
        }
    }, {
        key: "id",
        set: function set(id) {
            this._id = id;
        },
        get: function get() {
            return this._id;
        }
    } ], [ {
        key: "sortByPriority",
        value: function sortByPriority(a, b) {
            return a._priority < b._priority ? 1 : a._priority > b.priority ? -1 : 0;
        }
    } ]), System;
}(), idGenerator$3 = new IDGenerator("Scheduler"), ListEntry = function ListEntry(target, priority, paused, markedForDeletion) {
    _classCallCheck(this, ListEntry), this.target = void 0, this.priority = void 0, 
    this.paused = void 0, this.markedForDeletion = void 0, this.target = target, this.priority = priority, 
    this.paused = paused, this.markedForDeletion = markedForDeletion;
};

ListEntry.get = function(target, priority, paused, markedForDeletion) {
    var result = ListEntry._listEntries.pop();
    return result ? (result.target = target, result.priority = priority, result.paused = paused, 
    result.markedForDeletion = markedForDeletion) : result = new ListEntry(target, priority, paused, markedForDeletion), 
    result;
}, ListEntry.put = function(entry) {
    ListEntry._listEntries.length < 20 && (entry.target = null, ListEntry._listEntries.push(entry));
}, ListEntry._listEntries = [];

var HashUpdateEntry = function HashUpdateEntry(list, entry, target, callback) {
    _classCallCheck(this, HashUpdateEntry), this.list = void 0, this.entry = void 0, 
    this.target = void 0, this.callback = void 0, this.list = list, this.entry = entry, 
    this.target = target, this.callback = callback;
};

HashUpdateEntry.get = function(list, entry, target, callback) {
    var result = HashUpdateEntry._hashUpdateEntries.pop();
    return result ? (result.list = list, result.entry = entry, result.target = target, 
    result.callback = callback) : result = new HashUpdateEntry(list, entry, target, callback), 
    result;
}, HashUpdateEntry.put = function(entry) {
    HashUpdateEntry._hashUpdateEntries.length < 20 && (entry.list = entry.entry = entry.target = entry.callback = null, 
    HashUpdateEntry._hashUpdateEntries.push(entry));
}, HashUpdateEntry._hashUpdateEntries = [];

var HashTimerEntry = function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
    _classCallCheck(this, HashTimerEntry), this.timers = void 0, this.target = void 0, 
    this.timerIndex = void 0, this.currentTimer = void 0, this.currentTimerSalvaged = void 0, 
    this.paused = void 0, this.timers = timers, this.target = target, this.timerIndex = timerIndex, 
    this.currentTimer = currentTimer, this.currentTimerSalvaged = currentTimerSalvaged, 
    this.paused = paused;
};

HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
    var result = HashTimerEntry._hashTimerEntries.pop();
    return result ? (result.timers = timers, result.target = target, result.timerIndex = timerIndex, 
    result.currentTimer = currentTimer, result.currentTimerSalvaged = currentTimerSalvaged, 
    result.paused = paused) : result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused), 
    result;
}, HashTimerEntry.put = function(entry) {
    HashTimerEntry._hashTimerEntries.length < 20 && (entry.timers = entry.target = entry.currentTimer = null, 
    HashTimerEntry._hashTimerEntries.push(entry));
}, HashTimerEntry._hashTimerEntries = [];

var CallbackTimer = function() {
    function CallbackTimer() {
        _classCallCheck(this, CallbackTimer), this._lock = void 0, this._scheduler = void 0, 
        this._elapsed = void 0, this._runForever = void 0, this._useDelay = void 0, this._timesExecuted = void 0, 
        this._repeat = void 0, this._delay = void 0, this._interval = void 0, this._target = void 0, 
        this._callback = void 0, this._lock = !1, this._scheduler = null, this._elapsed = -1, 
        this._runForever = !1, this._useDelay = !1, this._timesExecuted = 0, this._repeat = 0, 
        this._delay = 0, this._interval = 0, this._target = null, this._callback = null;
    }
    return _createClass(CallbackTimer, [ {
        key: "initWithCallback",
        value: function initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
            return this._lock = !1, this._scheduler = scheduler, this._target = target, this._callback = callback, 
            this._elapsed = -1, this._interval = seconds, this._delay = delay, this._useDelay = this._delay > 0, 
            this._repeat = repeat, this._runForever = this._repeat === cc.macro.REPEAT_FOREVER, 
            !0;
        }
    }, {
        key: "getInterval",
        value: function getInterval() {
            return this._interval;
        }
    }, {
        key: "setInterval",
        value: function setInterval(interval) {
            this._interval = interval;
        }
    }, {
        key: "update",
        value: function update(dt) {
            -1 === this._elapsed ? (this._elapsed = 0, this._timesExecuted = 0) : (this._elapsed += dt, 
            this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), 
            this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), 
            this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), 
            this._elapsed = 0, this._timesExecuted += 1), this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel()));
        }
    }, {
        key: "getCallback",
        value: function getCallback() {
            return this._callback;
        }
    }, {
        key: "trigger",
        value: function trigger() {
            this._target && this._callback && (this._lock = !0, this._callback.call(this._target, this._elapsed), 
            this._lock = !1);
        }
    }, {
        key: "cancel",
        value: function cancel() {
            this._scheduler.unschedule(this._callback, this._target);
        }
    } ]), CallbackTimer;
}();

CallbackTimer._timers = [], CallbackTimer.get = function() {
    return CallbackTimer._timers.pop() || new CallbackTimer;
}, CallbackTimer.put = function(timer) {
    CallbackTimer._timers.length < 20 && !timer._lock && (timer._scheduler = timer._target = timer._callback = null, 
    CallbackTimer._timers.push(timer));
};

var Scheduler = function(_System) {
    function Scheduler() {
        var _this;
        return _classCallCheck(this, Scheduler), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Scheduler).call(this)))._timeScale = void 0, 
        _this._updatesNegList = void 0, _this._updates0List = void 0, _this._updatesPosList = void 0, 
        _this._hashForUpdates = void 0, _this._hashForTimers = void 0, _this._currentTarget = void 0, 
        _this._currentTargetSalvaged = void 0, _this._updateHashLocked = void 0, _this._arrayForTimers = void 0, 
        _this._timeScale = 1, _this._updatesNegList = [], _this._updates0List = [], _this._updatesPosList = [], 
        _this._hashForUpdates = createMap(!0), _this._hashForTimers = createMap(!0), _this._currentTarget = null, 
        _this._currentTargetSalvaged = !1, _this._updateHashLocked = !1, _this._arrayForTimers = [], 
        _this;
    }
    return _inherits(Scheduler, System), _createClass(Scheduler, null, [ {
        key: "enableForTarget",
        value: function enableForTarget(target) {
            var found = !1;
            (target.uuid || target.id) && (found = !0), found || (target.__instanceId ? cc.warnID(1513) : target.id = idGenerator$3.getNewId());
        }
    } ]), _createClass(Scheduler, [ {
        key: "setTimeScale",
        value: function setTimeScale(timeScale) {
            this._timeScale = timeScale;
        }
    }, {
        key: "getTimeScale",
        value: function getTimeScale() {
            return this._timeScale;
        }
    }, {
        key: "update",
        value: function update(dt) {
            var i, list, len, entry, elt;
            for (this._updateHashLocked = !0, 1 !== this._timeScale && (dt *= this._timeScale), 
            i = 0, len = (list = this._updatesNegList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
            for (i = 0, len = (list = this._updates0List).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
            for (i = 0, len = (list = this._updatesPosList).length; i < len; i++) (entry = list[i]).paused || entry.markedForDeletion || entry.target.update(dt);
            var arr = this._arrayForTimers;
            for (i = 0; i < arr.length; i++) {
                if (elt = arr[i], this._currentTarget = elt, this._currentTargetSalvaged = !1, !elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) elt.currentTimer = elt.timers[elt.timerIndex], 
                elt.currentTimerSalvaged = !1, elt.currentTimer.update(dt), elt.currentTimer = null;
                this._currentTargetSalvaged && 0 === this._currentTarget.timers.length && (this._removeHashElement(this._currentTarget), 
                --i);
            }
            for (i = 0, list = this._updatesNegList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
            for (i = 0, list = this._updates0List; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
            for (i = 0, list = this._updatesPosList; i < list.length; ) (entry = list[i]).markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
            this._updateHashLocked = !1, this._currentTarget = null;
        }
    }, {
        key: "schedule",
        value: function schedule(callback, target, interval, repeat, delay, paused) {
            if ("function" != typeof callback) {
                var tmp = callback;
                callback = target, target = tmp;
            }
            3 !== arguments.length && 4 !== arguments.length && 5 !== arguments.length || (paused = !!repeat, 
            repeat = cc.macro.REPEAT_FOREVER, delay = 0), cc.assertID(target, 1502);
            var targetId = target.uuid || target.id;
            if (targetId) {
                var timer, i, element = this._hashForTimers[targetId];
                if (element ? element.paused !== paused && cc.warnID(1511) : (element = HashTimerEntry.get(null, target, 0, null, null, paused), 
                this._arrayForTimers.push(element), this._hashForTimers[targetId] = element), null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) if ((timer = element.timers[i]) && callback === timer._callback) return cc.logID(1507, timer.getInterval(), interval), 
                void (timer._interval = interval);
                (timer = CallbackTimer.get()).initWithCallback(this, callback, target, interval, repeat, delay), 
                element.timers.push(timer), this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = !1);
            } else cc.errorID(1510);
        }
    }, {
        key: "scheduleUpdate",
        value: function scheduleUpdate(target, priority, paused) {
            var targetId = target.uuid || target.id;
            if (targetId) {
                var hashElement = this._hashForUpdates[targetId];
                if (hashElement && hashElement.entry) {
                    if (hashElement.entry.priority === priority) return hashElement.entry.markedForDeletion = !1, 
                    void (hashElement.entry.paused = paused);
                    if (this._updateHashLocked) return cc.logID(1506), hashElement.entry.markedForDeletion = !1, 
                    void (hashElement.entry.paused = paused);
                    this.unscheduleUpdate(target);
                }
                var ppList, listElement = ListEntry.get(target, priority, paused, !1);
                0 === priority ? (ppList = this._updates0List, this._appendIn(ppList, listElement)) : (ppList = priority < 0 ? this._updatesNegList : this._updatesPosList, 
                this._priorityIn(ppList, listElement, priority)), this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
            } else cc.errorID(1510);
        }
    }, {
        key: "unschedule",
        value: function unschedule(callback, target) {
            if (target && callback) {
                var targetId = target.uuid || target.id;
                if (targetId) {
                    var element = this._hashForTimers[targetId];
                    if (element) for (var timers = element.timers, i = 0, li = timers.length; i < li; i++) {
                        var timer = timers[i];
                        if (callback === timer._callback) return timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = !0), 
                        timers.splice(i, 1), CallbackTimer.put(timer), element.timerIndex >= i && element.timerIndex--, 
                        void (0 === timers.length && (this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element)));
                    }
                } else cc.errorID(1510);
            }
        }
    }, {
        key: "unscheduleUpdate",
        value: function unscheduleUpdate(target) {
            if (target) {
                var targetId = target.uuid || target.id;
                if (targetId) {
                    var element = this._hashForUpdates[targetId];
                    element && (this._updateHashLocked ? element.entry.markedForDeletion = !0 : this._removeUpdateFromHash(element.entry));
                } else cc.errorID(1510);
            }
        }
    }, {
        key: "unscheduleAllForTarget",
        value: function unscheduleAllForTarget(target) {
            if (target) {
                var targetId = target.uuid || target.id;
                if (targetId) {
                    var element = this._hashForTimers[targetId];
                    if (element) {
                        var timers = element.timers;
                        timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = !0);
                        for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
                        timers.length = 0, this._currentTarget === element ? this._currentTargetSalvaged = !0 : this._removeHashElement(element);
                    }
                    this.unscheduleUpdate(target);
                } else cc.errorID(1510);
            }
        }
    }, {
        key: "unscheduleAll",
        value: function unscheduleAll() {
            this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
        }
    }, {
        key: "unscheduleAllWithMinPriority",
        value: function unscheduleAllWithMinPriority(minPriority) {
            var i, element, entry, arr = this._arrayForTimers;
            for (i = arr.length - 1; i >= 0; i--) element = arr[i], this.unscheduleAllForTarget(element.target);
            var temp_length = 0;
            if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) temp_length = this._updatesNegList.length, 
            (entry = this._updatesNegList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
            temp_length === this._updatesNegList.length && i++;
            if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) temp_length = this._updates0List.length, 
            (entry = this._updates0List[i]) && this.unscheduleUpdate(entry.target), temp_length === this._updates0List.length && i++;
            for (i = 0; i < this._updatesPosList.length; ) temp_length = this._updatesPosList.length, 
            (entry = this._updatesPosList[i]) && entry.priority >= minPriority && this.unscheduleUpdate(entry.target), 
            temp_length === this._updatesPosList.length && i++;
        }
    }, {
        key: "isScheduled",
        value: function isScheduled(callback, target) {
            cc.assertID(callback, 1508), cc.assertID(target, 1509);
            var targetId = target.uuid || target.id;
            if (targetId) {
                var element = this._hashForTimers[targetId];
                if (!element) return !1;
                if (null == element.timers) return !1;
                for (var timers = element.timers, i = 0; i < timers.length; ++i) {
                    if (callback === timers[i]._callback) return !0;
                }
                return !1;
            }
            cc.errorID(1510);
        }
    }, {
        key: "pauseAllTargets",
        value: function pauseAllTargets() {
            return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
        }
    }, {
        key: "pauseAllTargetsWithMinPriority",
        value: function pauseAllTargetsWithMinPriority(minPriority) {
            var element, i, li, entry, idsWithSelectors = [], locArrayForTimers = this._arrayForTimers;
            for (i = 0, li = locArrayForTimers.length; i < li; i++) (element = locArrayForTimers[i]) && (element.paused = !0, 
            idsWithSelectors.push(element.target));
            if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) (entry = this._updatesNegList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
            idsWithSelectors.push(entry.target));
            if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) (entry = this._updates0List[i]) && (entry.paused = !0, 
            idsWithSelectors.push(entry.target));
            for (i = 0; i < this._updatesPosList.length; i++) (entry = this._updatesPosList[i]) && entry.priority >= minPriority && (entry.paused = !0, 
            idsWithSelectors.push(entry.target));
            return idsWithSelectors;
        }
    }, {
        key: "resumeTargets",
        value: function resumeTargets(targetsToResume) {
            if (targetsToResume) for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
        }
    }, {
        key: "pauseTarget",
        value: function pauseTarget(target) {
            cc.assertID(target, 1503);
            var targetId = target.uuid || target.id;
            if (targetId) {
                var element = this._hashForTimers[targetId];
                element && (element.paused = !0);
                var elementUpdate = this._hashForUpdates[targetId];
                elementUpdate && (elementUpdate.entry.paused = !0);
            } else cc.errorID(1510);
        }
    }, {
        key: "resumeTarget",
        value: function resumeTarget(target) {
            cc.assertID(target, 1504);
            var targetId = target.uuid || target.id;
            if (targetId) {
                var element = this._hashForTimers[targetId];
                element && (element.paused = !1);
                var elementUpdate = this._hashForUpdates[targetId];
                elementUpdate && (elementUpdate.entry.paused = !1);
            } else cc.errorID(1510);
        }
    }, {
        key: "isTargetPaused",
        value: function isTargetPaused(target) {
            cc.assertID(target, 1505);
            var targetId = target.uuid || target.id;
            if (!targetId) return cc.errorID(1510), !1;
            var element = this._hashForTimers[targetId];
            if (element) return element.paused;
            var elementUpdate = this._hashForUpdates[targetId];
            return !!elementUpdate && elementUpdate.entry.paused;
        }
    }, {
        key: "_removeHashElement",
        value: function _removeHashElement(element) {
            var targetId = element.target.uuid || element.target.id;
            delete this._hashForTimers[targetId];
            for (var arr = this._arrayForTimers, i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
                arr.splice(i, 1);
                break;
            }
            HashTimerEntry.put(element);
        }
    }, {
        key: "_removeUpdateFromHash",
        value: function _removeUpdateFromHash(entry) {
            var targetId = entry.target.uuid || entry.target.id, element = this._hashForUpdates[targetId];
            if (element) {
                for (var list = element.list, listEntry = element.entry, i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
                    list.splice(i, 1);
                    break;
                }
                delete this._hashForUpdates[targetId], ListEntry.put(listEntry), HashUpdateEntry.put(element);
            }
        }
    }, {
        key: "_priorityIn",
        value: function _priorityIn(ppList, listElement, priority) {
            for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) return void ppList.splice(i, 0, listElement);
            ppList.push(listElement);
        }
    }, {
        key: "_appendIn",
        value: function _appendIn(ppList, listElement) {
            ppList.push(listElement);
        }
    } ]), Scheduler;
}();

Scheduler.PRIORITY_SYSTEM = 1 << 31, Scheduler.PRIORITY_NON_SYSTEM = Scheduler.PRIORITY_SYSTEM + 1, 
Scheduler.ID = "scheduler", cc.Scheduler = Scheduler;

var Stage, DataPoolManager = function() {
    function DataPoolManager(device) {
        _classCallCheck(this, DataPoolManager), this.jointTexturePool = void 0, this.jointAnimationInfo = void 0, 
        this.jointTexturePool = new JointTexturePool(device), this.jointAnimationInfo = new JointAnimationInfo(device);
    }
    return _createClass(DataPoolManager, [ {
        key: "releaseSkeleton",
        value: function releaseSkeleton(skeleton) {
            this.jointTexturePool.releaseSkeleton(skeleton);
        }
    }, {
        key: "releaseAnimationClip",
        value: function releaseAnimationClip(clip) {
            this.jointTexturePool.releaseAnimationClip(clip);
        }
    }, {
        key: "clear",
        value: function clear() {
            this.jointTexturePool.clear(), this.jointAnimationInfo.clear();
        }
    } ]), DataPoolManager;
}(), MeshBuffer = function() {
    function MeshBuffer(batcher) {
        _classCallCheck(this, MeshBuffer), this.batcher = void 0, this.vData = null, this.iData = null, 
        this.vb = null, this.ib = null, this.ia = null, this.byteStart = 0, this.byteOffset = 0, 
        this.indiceStart = 0, this.indiceOffset = 0, this.vertexStart = 0, this.vertexOffset = 0, 
        this.lastByteOffset = 1, this.dirty = !1, this._vertexFormatBytes = 9 * Float32Array.BYTES_PER_ELEMENT, 
        this._initVDataCount = 256 * this._vertexFormatBytes, this._initIDataCount = 1536, 
        this._outofCallback = null, this.batcher = batcher;
    }
    return _createClass(MeshBuffer, [ {
        key: "initialize",
        value: function initialize(attrs, outofCallback) {
            this._outofCallback = outofCallback;
            var vbStride = 9 * Float32Array.BYTES_PER_ELEMENT;
            this.vb = this.vb || this.batcher.device.createBuffer({
                usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 0,
                stride: vbStride
            });
            var ibStride = Uint16Array.BYTES_PER_ELEMENT;
            this.ib = this.ib || this.batcher.device.createBuffer({
                usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 0,
                stride: ibStride
            }), this.ia = this.ia || this.batcher.device.createInputAssembler({
                attributes: attrs,
                vertexBuffers: [ this.vb ],
                indexBuffer: this.ib
            }), this._reallocBuffer();
        }
    }, {
        key: "request",
        value: function request() {
            var vertexCount = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 4, indiceCount = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 6;
            this.lastByteOffset = this.byteOffset;
            var byteOffset = this.byteOffset + vertexCount * this._vertexFormatBytes, indiceOffset = this.indiceOffset + indiceCount;
            if (vertexCount + this.vertexOffset > 65535) return this.batcher.autoMergeBatches(), 
            this._outofCallback && this._outofCallback.call(this.batcher, vertexCount, indiceCount), 
            !1;
            var byteLength = this.vData.byteLength, indiceLength = this.iData.length;
            if (byteOffset > byteLength || indiceOffset > indiceLength) {
                for (;byteLength < byteOffset || indiceLength < indiceOffset; ) this._initVDataCount *= 2, 
                this._initIDataCount *= 2, byteLength = 4 * this._initVDataCount, indiceLength = this._initIDataCount;
                this._reallocBuffer();
            }
            return this.vertexOffset += vertexCount, this.indiceOffset += indiceCount, this.byteOffset = byteOffset, 
            this.dirty = !0, !0;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.byteStart = 0, this.byteOffset = 0, this.indiceStart = 0, this.indiceOffset = 0, 
            this.vertexStart = 0, this.vertexOffset = 0, this.lastByteOffset = 0, this.dirty = !1;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.ib.destroy(), this.vb.destroy(), this.ia.destroy(), this.ib = null, this.vb = null, 
            this.ia = null;
        }
    }, {
        key: "uploadData",
        value: function uploadData() {
            if (0 !== this.byteOffset && this.dirty) {
                var verticesData = new Float32Array(this.vData.buffer, 0, this.byteOffset >> 2), indicesData = new Uint16Array(this.iData.buffer, 0, this.indiceOffset);
                this.byteOffset > this.vb.size && this.vb.resize(this.byteOffset), this.vb.update(verticesData), 
                2 * this.indiceOffset > this.ib.size && this.ib.resize(2 * this.indiceOffset), this.ib.update(indicesData);
            }
        }
    }, {
        key: "_reallocBuffer",
        value: function _reallocBuffer() {
            this._reallocVData(!0), this._reallocIData(!0);
        }
    }, {
        key: "_reallocVData",
        value: function _reallocVData(copyOldData) {
            var oldVData;
            if (this.vData && (oldVData = new Uint8Array(this.vData.buffer)), this.vData = new Float32Array(this._initVDataCount), 
            oldVData && copyOldData) for (var newData = new Uint8Array(this.vData.buffer), i = 0, l = oldVData.length; i < l; i++) newData[i] = oldVData[i];
        }
    }, {
        key: "_reallocIData",
        value: function _reallocIData(copyOldData) {
            var oldIData = this.iData;
            if (this.iData = new Uint16Array(this._initIDataCount), oldIData && copyOldData) for (var iData = this.iData, i = 0, l = oldIData.length; i < l; i++) iData[i] = oldIData[i];
        }
    } ]), MeshBuffer;
}();

MeshBuffer.OPACITY_OFFSET = 8, function(Stage) {
    Stage[Stage.DISABLED = 0] = "DISABLED", Stage[Stage.CLEAR = 1] = "CLEAR", Stage[Stage.ENTER_LEVEL = 2] = "ENTER_LEVEL", 
    Stage[Stage.ENABLED = 3] = "ENABLED", Stage[Stage.EXIT_LEVEL = 4] = "EXIT_LEVEL";
}(Stage || (Stage = {}));

var StencilManager = function() {
    function StencilManager() {
        _classCallCheck(this, StencilManager), this.stage = Stage.DISABLED, this._maskStack = [], 
        this._stencilPattern = {
            stencilTest: !0,
            func: exports.GFXComparisonFunc.ALWAYS,
            stencilMask: 65535,
            writeMask: 65535,
            failOp: exports.GFXStencilOp.KEEP,
            zFailOp: exports.GFXStencilOp.KEEP,
            passOp: exports.GFXStencilOp.KEEP,
            ref: 1
        }, this._defaultPipelineState = {
            depthStencilState: {},
            rasterizerState: {},
            blendState: {}
        };
    }
    return _createClass(StencilManager, [ {
        key: "pushMask",
        value: function pushMask(mask) {
            this._maskStack.push(mask);
        }
    }, {
        key: "clear",
        value: function clear() {
            this.stage = Stage.CLEAR;
        }
    }, {
        key: "enterLevel",
        value: function enterLevel() {
            this.stage = Stage.ENTER_LEVEL;
        }
    }, {
        key: "enableMask",
        value: function enableMask() {
            this.stage = Stage.ENABLED;
        }
    }, {
        key: "exitMask",
        value: function exitMask() {
            0 !== this._maskStack.length && (this._maskStack.pop(), 0 === this._maskStack.length ? this.stage = Stage.DISABLED : this.stage = Stage.ENABLED);
        }
    }, {
        key: "handleMaterial",
        value: function handleMaterial(mat) {
            var pattern = this._stencilPattern;
            if (this.stage === Stage.DISABLED) pattern.stencilTest = !1, pattern.func = exports.GFXComparisonFunc.ALWAYS, 
            pattern.failOp = exports.GFXStencilOp.KEEP, pattern.stencilMask = pattern.writeMask = 65535, 
            pattern.ref = 1; else if (pattern.stencilTest = !0, this.stage === Stage.ENABLED) pattern.func = exports.GFXComparisonFunc.EQUAL, 
            pattern.failOp = exports.GFXStencilOp.KEEP, pattern.stencilMask = pattern.ref = this.getStencilRef(), 
            pattern.writeMask = this.getWriteMask(); else if (this.stage === Stage.CLEAR) {
                var mask = this._maskStack[this._maskStack.length - 1];
                pattern.func = exports.GFXComparisonFunc.NEVER, pattern.failOp = mask.inverted ? exports.GFXStencilOp.REPLACE : exports.GFXStencilOp.ZERO, 
                pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            } else if (this.stage === Stage.ENTER_LEVEL) {
                var _mask = this._maskStack[this._maskStack.length - 1];
                pattern.func = exports.GFXComparisonFunc.NEVER, pattern.failOp = _mask.inverted ? exports.GFXStencilOp.ZERO : exports.GFXStencilOp.REPLACE, 
                pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
            }
            var pass = mat.passes[0];
            if (this._changed(pass)) {
                var state = this._stencilPattern;
                return this._defaultPipelineState.depthStencilState = {
                    stencilTestFront: state.stencilTest,
                    stencilFuncFront: state.func,
                    stencilReadMaskFront: state.stencilMask,
                    stencilWriteMaskFront: state.writeMask,
                    stencilFailOpFront: state.failOp,
                    stencilZFailOpFront: state.zFailOp,
                    stencilPassOpFront: state.passOp,
                    stencilRefFront: state.ref,
                    stencilTestBack: state.stencilTest,
                    stencilFuncBack: state.func,
                    stencilReadMaskBack: state.stencilMask,
                    stencilWriteMaskBack: state.writeMask,
                    stencilFailOpBack: state.failOp,
                    stencilZFailOpBack: state.zFailOp,
                    stencilPassOpBack: state.passOp,
                    stencilRefBack: state.ref
                }, this._defaultPipelineState.blendState = pass.blendState, this._defaultPipelineState.rasterizerState = pass.rasterizerState, 
                mat.overridePipelineStates(this._defaultPipelineState), !0;
            }
            return !1;
        }
    }, {
        key: "getWriteMask",
        value: function getWriteMask() {
            return 1 << this._maskStack.length - 1;
        }
    }, {
        key: "getExitWriteMask",
        value: function getExitWriteMask() {
            return 1 << this._maskStack.length;
        }
    }, {
        key: "getStencilRef",
        value: function getStencilRef() {
            for (var result = 0, i = 0; i < this._maskStack.length; ++i) result += 1 << i;
            return result;
        }
    }, {
        key: "reset",
        value: function reset() {
            this._maskStack.length = 0, this.stage = Stage.DISABLED;
        }
    }, {
        key: "_changed",
        value: function _changed(pass) {
            var stencilState = pass.depthStencilState, pattern = this._stencilPattern;
            return pattern.stencilTest !== stencilState.stencilTestFront || pattern.func !== stencilState.stencilFuncFront || pattern.failOp !== stencilState.stencilFailOpFront || pattern.zFailOp !== stencilState.stencilZFailOpFront || pattern.passOp !== stencilState.stencilPassOpFront || pattern.stencilMask !== stencilState.stencilReadMaskFront || pattern.writeMask !== stencilState.stencilWriteMaskFront || pattern.ref !== stencilState.stencilRefFront;
        }
    } ]), StencilManager;
}();

StencilManager.sharedManager = null, StencilManager.sharedManager = new StencilManager;

var UIBatchModel = function(_Model) {
    function UIBatchModel() {
        var _this;
        return _classCallCheck(this, UIBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(UIBatchModel).call(this)))._subModel = void 0, 
        _this.type = ModelType.UI_BATCH, _this._subModel = new UISubModel, _this;
    }
    return _inherits(UIBatchModel, Model), _createClass(UIBatchModel, [ {
        key: "updateTransform",
        value: function updateTransform() {}
    }, {
        key: "updateUBOs",
        value: function updateUBOs() {
            return !1;
        }
    }, {
        key: "directInitialize",
        value: function directInitialize(ia, batch) {
            this._subModel.directInitialize(ia, batch.material, batch.pipelineState), this._subModels[0] = this._subModel;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._subModel.destroy();
        }
    } ]), UIBatchModel;
}(), UISubModel = function(_SubModel) {
    function UISubModel() {
        var _this2;
        return _classCallCheck(this, UISubModel), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(UISubModel).call(this)))._psos = [], 
        _this2;
    }
    return _inherits(UISubModel, SubModel), _createClass(UISubModel, [ {
        key: "directInitialize",
        value: function directInitialize(ia, mat, pso) {
            this._inputAssembler = ia, this._psos[0] = pso, this.material = mat;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.commandBuffers.length > 0 && this.commandBuffers[0].destroy();
        }
    } ]), UISubModel;
}(), UIDrawBatch = function() {
    function UIDrawBatch() {
        _classCallCheck(this, UIDrawBatch), this.camera = null, this.bufferBatch = null, 
        this.model = null, this.material = null, this.texView = null, this.sampler = null, 
        this.firstIdx = 0, this.idxCount = 0, this.pipelineState = null, this.bindingLayout = null, 
        this.useLocalData = null, this.isStatic = !1;
    }
    return _createClass(UIDrawBatch, [ {
        key: "destroy",
        value: function destroy(ui) {
            this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
            this.pipelineState = null), this.bindingLayout && (this.bindingLayout = null);
        }
    }, {
        key: "clear",
        value: function clear(ui) {
            this.pipelineState && (ui._getUIMaterial(this.material).revertPipelineState(this.pipelineState), 
            this.pipelineState = null), this.camera = null, this.bufferBatch = null, this.material = null, 
            this.texView = null, this.sampler = null, this.firstIdx = 0, this.idxCount = 0, 
            this.model = null, this.isStatic = !1;
        }
    } ]), UIDrawBatch;
}(), UIMaterial = function() {
    function UIMaterial() {
        _classCallCheck(this, UIMaterial), this._material = null, this._pass = null, this._psos = void 0, 
        this._refCount = 0, this._psos = null;
    }
    return _createClass(UIMaterial, [ {
        key: "material",
        get: function get() {
            return this._material;
        }
    }, {
        key: "pass",
        get: function get() {
            return this._pass;
        }
    } ]), _createClass(UIMaterial, [ {
        key: "initialize",
        value: function initialize(info) {
            var _this = this;
            return !!info.material && (this._material = new Material, this._material.copy(info.material), 
            this._pass = info.material.passes[0], this._pass.update(), this._psos = new Pool$1((function() {
                return _this._pass.createPipelineState();
            }), 1), !0);
        }
    }, {
        key: "increase",
        value: function increase() {
            return this._refCount++, this._refCount;
        }
    }, {
        key: "decrease",
        value: function decrease() {
            return this._refCount--, 0 === this._refCount && this.destroy(), this._refCount;
        }
    }, {
        key: "getPipelineState",
        value: function getPipelineState() {
            return this._psos.alloc();
        }
    }, {
        key: "revertPipelineState",
        value: function revertPipelineState(pso) {
            this._psos.free(pso);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var _this2 = this;
            this._psos && this._psos.clear((function(obj) {
                _this2._pass.destroyPipelineState(obj);
            })), this._material && (this._material.destroy(), this._material = null), this._refCount = 0;
        }
    } ]), UIMaterial;
}(), vfmt = [ {
    name: exports.GFXAttributeName.ATTR_POSITION,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD,
    format: exports.GFXFormat.RG32F
}, {
    name: exports.GFXAttributeName.ATTR_COLOR,
    format: exports.GFXFormat.RGBA32F
} ], UIVertexFormat = Object.freeze({
    __proto__: null,
    vfmt: vfmt
}), UI = function() {
    function UI(_root) {
        var _this = this;
        _classCallCheck(this, UI), this.device = void 0, this._screens = [], this._bufferBatchPool = new RecyclePool((function() {
            return new MeshBuffer(_this);
        }), 128), this._drawBatchPool = new Pool$1((function() {
            return new UIDrawBatch;
        }), 128), this._cmdBuff = null, this._scene = void 0, this._attributes = [], this._meshBuffers = [], 
        this._meshBufferUseCount = 0, this._uiMaterials = new Map, this._canvasMaterials = new Map, 
        this._batches = void 0, this._uiModelPool = null, this._modelInUse = void 0, this._emptyMaterial = new Material, 
        this._currMaterial = this._emptyMaterial, this._currTexView = null, this._currSampler = null, 
        this._currCanvas = null, this._currMeshBuffer = null, this._currStaticRoot = null, 
        this._parentOpacity = 1, this._root = _root, this.device = _root.device, this._scene = this._root.createScene({
            name: "GUIScene"
        }), this._uiModelPool = new Pool$1((function() {
            var model = cc.director.root.createModel(UIBatchModel);
            return model.enabled = !0, model.visFlags |= Layers.Enum.UI_3D, model;
        }), 2), this._modelInUse = new CachedArray(10), this._batches = new CachedArray(64), 
        cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.update, this);
    }
    return _createClass(UI, [ {
        key: "renderScene",
        get: function get() {
            return this._scene;
        }
    }, {
        key: "currBufferBatch",
        get: function get() {
            return this._currMeshBuffer;
        },
        set: function set(value) {
            value && (this._currMeshBuffer = value);
        }
    }, {
        key: "currStaticRoot",
        set: function set(value) {
            this._currStaticRoot = value;
        }
    } ]), _createClass(UI, [ {
        key: "initialize",
        value: function initialize() {
            return this._attributes = vfmt, this._requireBufferBatch(), this._cmdBuff = this.device.createCommandBuffer({
                allocator: this.device.commandAllocator,
                type: exports.GFXCommandBufferType.PRIMARY
            }), !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            for (var i = 0; i < this._batches.array.length; i++) this._batches.array[i].destroy(this);
            for (var _i = 0; _i < this._meshBuffers.length; _i++) this._meshBuffers[_i].destroy();
            this._meshBuffers.splice(0), this._destroyUIMaterials(), this._cmdBuff && (this._cmdBuff.destroy(), 
            this._cmdBuff = null);
        }
    }, {
        key: "getRenderSceneGetter",
        value: function getRenderSceneGetter() {
            return Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this), "renderScene").get.bind(this);
        }
    }, {
        key: "_getUIMaterial",
        value: function _getUIMaterial(mat) {
            if (this._uiMaterials.has(mat.hash)) return this._uiMaterials.get(mat.hash);
            var uiMat = new UIMaterial;
            return uiMat.initialize({
                material: mat
            }), this._uiMaterials.set(mat.hash, uiMat), uiMat;
        }
    }, {
        key: "_removeUIMaterial",
        value: function _removeUIMaterial(hash) {
            this._uiMaterials.has(hash) && 0 === this._uiMaterials.get(hash).decrease() && this._uiMaterials.delete(hash);
        }
    }, {
        key: "addScreen",
        value: function addScreen(comp) {
            for (var screens = this._screens, i = 0; i < screens.length; i++) {
                var screen = screens[i];
                if (screen.camera) {
                    var visibility = screen.camera.view.visibility, matRecord = this._canvasMaterials.get(visibility);
                    if (matRecord) {
                        for (var matHashInter = matRecord.keys(), matHash = matHashInter.next(); !matHash.done; ) this._removeUIMaterial(matHash.value), 
                        matHash = matHashInter.next();
                        matRecord.clear();
                    }
                }
            }
            this._screens.push(comp), this._screens.sort(this._screenSort);
            for (var _i2 = 0; _i2 < screens.length; _i2++) {
                var element = screens[_i2];
                element.camera && (element.camera.view.visibility = Layers.BitMask.UI_2D | _i2 + 1, 
                this._canvasMaterials.has(element.camera.view.visibility) || this._canvasMaterials.set(element.camera.view.visibility, new Map));
            }
        }
    }, {
        key: "getScreen",
        value: function getScreen(visibility) {
            for (var screens = this._screens, i = 0; i < screens.length; ++i) {
                var screen = screens[i];
                if (screen.camera && screen.camera.view.visibility === visibility) return screen;
            }
            return null;
        }
    }, {
        key: "removeScreen",
        value: function removeScreen(comp) {
            var _this2 = this, idx = this._screens.indexOf(comp);
            if (-1 !== idx) {
                if (this._screens.splice(idx, 1), comp.camera) {
                    for (var matRecord = this._canvasMaterials.get(comp.camera.view.visibility), matHashInter = matRecord.keys(), matHash = matHashInter.next(); !matHash.done; ) this._removeUIMaterial(matHash.value), 
                    matHash = matHashInter.next();
                    matRecord.clear();
                }
                for (var camera, i = idx; i < this._screens.length; i++) (camera = this._screens[i].camera) && function() {
                    var matRecord = _this2._canvasMaterials.get(camera.view.visibility);
                    camera.view.visibility = Layers.BitMask.UI_2D | i + 1;
                    var newMatRecord = _this2._canvasMaterials.get(camera.view.visibility);
                    matRecord.forEach((function(value, key) {
                        newMatRecord.set(key, value);
                    })), matRecord.clear();
                }();
            }
        }
    }, {
        key: "update",
        value: function update(dt) {
            if (this._renderScreens(), this._batches.length > 0) for (var buffers = this._meshBuffers, i = 0; i < buffers.length; ++i) {
                var bufferBatch = buffers[i];
                bufferBatch.uploadData(), bufferBatch.reset();
            }
            this.render(), this._reset();
        }
    }, {
        key: "sortScreens",
        value: function sortScreens() {
            this._screens.sort(this._screenSort);
        }
    }, {
        key: "render",
        value: function render() {
            for (var batchPriority = 0, i = 0; i < this._modelInUse.length; i++) this._scene.removeModel(this._modelInUse.get(i)), 
            this._uiModelPool.free(this._modelInUse.get(i));
            if (this._modelInUse.clear(), this._batches.length) for (var _i3 = 0; _i3 < this._batches.length; ++_i3) {
                var batch = this._batches.array[_i3];
                if (batch.model) {
                    if (batch.camera) {
                        var visFlags = batch.camera.view.visibility;
                        batch.model.visFlags = visFlags, batch.model.node.layer = visFlags;
                    }
                    for (var j = 0; j < batch.model.subModelNum; j++) batch.model.getSubModel(j).priority = batchPriority++;
                } else {
                    var bindingLayout = batch.bindingLayout;
                    bindingLayout.bindTextureView(UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT, batch.texView), 
                    bindingLayout.bindSampler(UniformBinding.CUSTOM_SAMPLER_BINDING_START_POINT, batch.sampler), 
                    bindingLayout.update();
                    var ia = batch.bufferBatch.ia;
                    ia.firstIndex = batch.firstIdx, ia.indexCount = batch.idxCount;
                    var uiModel = this._uiModelPool.alloc();
                    uiModel.directInitialize(ia, batch), this._scene.addModel(uiModel), uiModel.getSubModel(0).priority = batchPriority++, 
                    batch.camera && (uiModel.visFlags = batch.camera.view.visibility, null == this._canvasMaterials.get(batch.camera.view.visibility).get(batch.material.hash) && (this._uiMaterials.get(batch.material.hash).increase(), 
                    this._canvasMaterials.get(batch.camera.view.visibility).set(batch.material.hash, 1))), 
                    this._modelInUse.push(uiModel);
                }
            }
        }
    }, {
        key: "commitComp",
        value: function commitComp(comp) {
            var frame = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, assembler = arguments.length > 2 ? arguments[2] : void 0, sampler = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, renderComp = comp, texView = frame, samp = sampler;
            this._currMaterial.hash === renderComp.material.hash && this._currTexView === texView && this._currSampler === samp || (this.autoMergeBatches(), 
            this._currMaterial = renderComp.material, this._currTexView = texView, this._currSampler = samp), 
            assembler && (assembler.fillBuffers(renderComp, this), this._applyOpacity(renderComp));
        }
    }, {
        key: "commitModel",
        value: function commitModel(comp, model, mat) {
            if ((this._currMaterial !== this._emptyMaterial && this.autoMergeBatches(), mat) && (StencilManager.sharedManager.handleMaterial(mat) && model)) for (var i = 0; i < model.subModelNum; i++) model.setSubModelMaterial(i, mat);
            var uiCanvas = this._currCanvas, curDrawBatch = this._drawBatchPool.alloc();
            curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.model = model, curDrawBatch.bufferBatch = null, 
            curDrawBatch.material = mat, curDrawBatch.texView = null, curDrawBatch.sampler = null, 
            curDrawBatch.firstIdx = 0, curDrawBatch.idxCount = 0, curDrawBatch.pipelineState = null, 
            curDrawBatch.bindingLayout = null, this._currMaterial = this._emptyMaterial, this._currTexView = null, 
            this._currSampler = null, this._batches.push(curDrawBatch);
        }
    }, {
        key: "commitStaticBatch",
        value: function commitStaticBatch(comp) {
            this._batches.concat(comp.drawBatchList), this.finishMergeBatches();
        }
    }, {
        key: "autoMergeBatches",
        value: function autoMergeBatches() {
            var mat = this._currMaterial, buffer = this._currMeshBuffer, indicsStart = buffer.indiceStart, vCount = buffer.indiceOffset - indicsStart;
            if (vCount && mat) {
                var uiCanvas = this._currCanvas;
                StencilManager.sharedManager.handleMaterial(mat);
                var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
                curDrawBatch.camera = uiCanvas && uiCanvas.camera, curDrawBatch.bufferBatch = buffer, 
                curDrawBatch.material = mat, curDrawBatch.texView = this._currTexView, curDrawBatch.sampler = this._currSampler, 
                curDrawBatch.firstIdx = indicsStart, curDrawBatch.idxCount = vCount, curDrawBatch.pipelineState = this._getUIMaterial(mat).getPipelineState(), 
                curDrawBatch.bindingLayout = curDrawBatch.pipelineState.pipelineLayout.layouts[0], 
                this._batches.push(curDrawBatch), buffer.vertexStart = buffer.vertexOffset, buffer.indiceStart = buffer.indiceOffset, 
                buffer.byteStart = buffer.byteOffset;
            }
        }
    }, {
        key: "forceMergeBatches",
        value: function forceMergeBatches(material, sprite) {
            this._currMaterial = material, this._currTexView = sprite, this.autoMergeBatches();
        }
    }, {
        key: "finishMergeBatches",
        value: function finishMergeBatches() {
            this.autoMergeBatches(), this._currMaterial = this._emptyMaterial, this._currTexView = null;
        }
    }, {
        key: "_destroyUIMaterials",
        value: function _destroyUIMaterials() {
            for (var matIter = this._uiMaterials.values(), result = matIter.next(); !result.done; ) {
                result.value.destroy(), result = matIter.next();
            }
            this._uiMaterials.clear();
        }
    }, {
        key: "_walk",
        value: function _walk(node) {
            var level = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, len = node.children.length, parentOpacity = this._parentOpacity;
            if (this._parentOpacity *= node._uiProps.opacity, this._preprocess(node), len > 0 && !node._static) for (var children = node.children, i = 0; i < children.length; ++i) {
                var child = children[i];
                this._walk(child, level);
            }
            this._postprocess(node), this._parentOpacity = parentOpacity, level += 1;
        }
    }, {
        key: "_renderScreens",
        value: function _renderScreens() {
            for (var screens = this._screens, i = 0; i < screens.length; ++i) {
                var screen = screens[i];
                screen.enabledInHierarchy && (this._currCanvas = screen, this._recursiveScreenNode(screen.node));
            }
        }
    }, {
        key: "_preprocess",
        value: function _preprocess(c) {
            if (c._uiProps.uiTransformComp) {
                c._uiProps.uiTransformComp._canvas = this._currCanvas;
                var render = c._uiProps.uiComp;
                render && render.enabledInHierarchy && render.updateAssembler(this);
            }
        }
    }, {
        key: "_postprocess",
        value: function _postprocess(c) {
            var render = c._uiProps.uiComp;
            render && render.enabledInHierarchy && render.postUpdateAssembler(this);
        }
    }, {
        key: "_recursiveScreenNode",
        value: function _recursiveScreenNode(screen) {
            this._walk(screen), this.autoMergeBatches();
        }
    }, {
        key: "_reset",
        value: function _reset() {
            for (var i = 0; i < this._batches.length; ++i) {
                var batch = this._batches.array[i];
                batch.isStatic || (batch.clear(this), this._drawBatchPool.free(batch));
            }
            this._parentOpacity = 1, this._batches.clear(), this._currMaterial = this._emptyMaterial, 
            this._currCanvas = null, this._currTexView = null, this._currSampler = null, this._meshBufferUseCount = 0, 
            this._requireBufferBatch(), StencilManager.sharedManager.reset();
        }
    }, {
        key: "_createMeshBuffer",
        value: function _createMeshBuffer() {
            var batch = this._bufferBatchPool.add();
            return batch.initialize(this._attributes, this._requireBufferBatch.bind(this)), 
            this._meshBuffers.push(batch), batch;
        }
    }, {
        key: "_requireBufferBatch",
        value: function _requireBufferBatch() {
            this._meshBufferUseCount >= this._meshBuffers.length ? this._currMeshBuffer = this._createMeshBuffer() : this._currMeshBuffer = this._meshBuffers[this._meshBufferUseCount], 
            this._meshBufferUseCount++, 2 === arguments.length && this._currMeshBuffer.request(arguments[0], arguments[1]);
        }
    }, {
        key: "_screenSort",
        value: function _screenSort(a, b) {
            var delta = a.priority - b.priority;
            return 0 === delta ? a.node.getSiblingIndex() - b.node.getSiblingIndex() : delta;
        }
    }, {
        key: "_applyOpacity",
        value: function _applyOpacity(comp) {
            for (var color = comp.color.a / 255, opacity = this._parentOpacity = this._parentOpacity * color, byteOffset = this._currMeshBuffer.byteOffset >> 2, vbuf = this._currMeshBuffer.vData, i = this._currMeshBuffer.lastByteOffset >> 2; i < byteOffset; i += 9) vbuf[i + MeshBuffer.OPACITY_OFFSET] = opacity;
            this._currMeshBuffer.lastByteOffset = this._currMeshBuffer.byteOffset;
        }
    } ]), UI;
}(), Root = function() {
    function Root(device) {
        _classCallCheck(this, Root), this._createSceneFun = void 0, this._createViewFun = void 0, 
        this._device = void 0, this._windows = [], this._mainWindow = null, this._curWindow = null, 
        this._tempWindow = null, this._pipeline = null, this._ui = null, this._dataPoolMgr = void 0, 
        this._scenes = [], this._views = [], this._modelPools = new Map, this._cameraPool = null, 
        this._lightPools = new Map, this._time = 0, this._frameTime = 0, this._fpsTime = 0, 
        this._frameCount = 0, this._fps = 0, this._fixedFPS = 0, this._fixedFPSFrameTime = 0, 
        this._device = device, this._dataPoolMgr = new DataPoolManager(device), RenderScene.registerCreateFunc(this), 
        RenderView.registerCreateFunc(this), this._cameraPool = new Pool$1((function() {
            return new Camera;
        }), 4);
    }
    return _createClass(Root, [ {
        key: "device",
        get: function get() {
            return this._device;
        }
    }, {
        key: "mainWindow",
        get: function get() {
            return this._mainWindow;
        }
    }, {
        key: "curWindow",
        set: function set(window) {
            this._curWindow = window;
        },
        get: function get() {
            return this._curWindow;
        }
    }, {
        key: "tempWindow",
        set: function set(window) {
            this._tempWindow = window;
        },
        get: function get() {
            return this._tempWindow;
        }
    }, {
        key: "windows",
        get: function get() {
            return this._windows;
        }
    }, {
        key: "pipeline",
        get: function get() {
            return this._pipeline;
        }
    }, {
        key: "ui",
        get: function get() {
            return this._ui;
        }
    }, {
        key: "scenes",
        get: function get() {
            return this._scenes;
        }
    }, {
        key: "views",
        get: function get() {
            return this._views;
        }
    }, {
        key: "cumulativeTime",
        get: function get() {
            return this._time;
        }
    }, {
        key: "frameTime",
        get: function get() {
            return this._frameTime;
        }
    }, {
        key: "frameCount",
        get: function get() {
            return this._frameCount;
        }
    }, {
        key: "fps",
        get: function get() {
            return this._fps;
        }
    }, {
        key: "fixedFPS",
        set: function set(fps) {
            fps > 0 ? (this._fixedFPS = fps, this._fixedFPSFrameTime = 1e3 / fps) : this._fixedFPSFrameTime = 0;
        },
        get: function get() {
            return this._fixedFPS;
        }
    }, {
        key: "dataPoolManager",
        get: function get() {
            return this._dataPoolMgr;
        }
    } ]), _createClass(Root, [ {
        key: "initialize",
        value: function initialize(info) {
            var _this = this;
            return !!this._device.mainWindow && (this._mainWindow = this._device.mainWindow, 
            this._curWindow = this._mainWindow, builtinResMgr.initBuiltinRes(this._device), 
            cc.view.on("design-resolution-changed", (function() {
                var width = cc.game.canvas.width, height = cc.game.canvas.height;
                _this.resize(width, height);
            }), this), !0);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.destroyViews(), this.destroyScenes(), this._pipeline && (this._pipeline.destroy(), 
            this._pipeline = null), this._ui && (this._ui.destroy(), this._ui = null), this._curWindow = null, 
            this._mainWindow = null, this.dataPoolManager.clear();
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._device.resize(width, height), this._mainWindow.resize(width, height);
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._windows); !(_step = _iterator()).done; ) {
                var window = _step.value;
                window.isOffscreen || window.resize(width, height);
            }
            this._pipeline && this._pipeline.resize(width, height);
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._views); !(_step2 = _iterator2()).done; ) {
                var view = _step2.value;
                view.camera.isWindowSize && view.camera.resize(width, height);
            }
        }
    }, {
        key: "setRenderPipeline",
        value: function setRenderPipeline(rppl) {
            return this._pipeline = rppl, !!this._pipeline.activate(this) && (this._ui = new UI(this), 
            !!this._ui.initialize() || (this.destroy(), !1));
        }
    }, {
        key: "activeWindow",
        value: function activeWindow(window) {
            this._curWindow = window;
        }
    }, {
        key: "resetCumulativeTime",
        value: function resetCumulativeTime() {
            this._time = 0;
        }
    }, {
        key: "frameMove",
        value: function frameMove(deltaTime) {
            this._frameTime = deltaTime, ++this._frameCount, this._time += this._frameTime, 
            this._fpsTime += this._frameTime, this._fpsTime > 1 && (this._fps = this._frameCount, 
            this._frameCount = 0, this._fpsTime = 0);
            for (var views = this._views, i = 0; i < views.length; i++) {
                var view = views[i];
                view.isEnable && view.window && (view.window.isOffscreen || !view.window.isOffscreen && view.window === this._curWindow) && this._pipeline && this._pipeline.render(view);
            }
        }
    }, {
        key: "createWindow",
        value: function createWindow(info) {
            if (this._device) {
                var window = this._device.createWindow(info);
                if (window) return this._windows.push(window), window;
            }
            return null;
        }
    }, {
        key: "destroyWindow",
        value: function destroyWindow(window) {
            for (var i = 0; i < this._windows.length; ++i) if (this._windows[i] === window) return window.destroy(), 
            void this._windows.splice(i, 1);
        }
    }, {
        key: "destroyWindows",
        value: function destroyWindows() {
            for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._windows); !(_step3 = _iterator3()).done; ) {
                _step3.value.destroy();
            }
            this._windows = [];
        }
    }, {
        key: "createScene",
        value: function createScene(info) {
            var scene = this._createSceneFun(this);
            return scene.initialize(info), this._scenes.push(scene), scene;
        }
    }, {
        key: "destroyScene",
        value: function destroyScene(scene) {
            for (var i = 0; i < this._scenes.length; ++i) if (this._scenes[i] === scene) return scene.destroy(), 
            void this._scenes.splice(i, 1);
        }
    }, {
        key: "destroyScenes",
        value: function destroyScenes() {
            for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._scenes); !(_step4 = _iterator4()).done; ) {
                _step4.value.destroy();
            }
            this._scenes = [];
        }
    }, {
        key: "createView",
        value: function createView(info) {
            var view = this._createViewFun(this, info.camera);
            return view.initialize(info), this._views.push(view), this.sortViews(), view;
        }
    }, {
        key: "destroyView",
        value: function destroyView(view) {
            for (var i = 0; i < this._views.length; ++i) if (this._views[i] === view) return this._views.splice(i, 1), 
            void view.destroy();
        }
    }, {
        key: "destroyViews",
        value: function destroyViews() {
            for (var _step5, _iterator5 = _createForOfIteratorHelperLoose(this._views); !(_step5 = _iterator5()).done; ) {
                _step5.value.destroy();
            }
            this._views = [];
        }
    }, {
        key: "createModel",
        value: function createModel(mClass) {
            var p = this._modelPools.get(mClass);
            return p || (this._modelPools.set(mClass, new Pool$1((function() {
                return new mClass;
            }), 10)), p = this._modelPools.get(mClass)), p.alloc();
        }
    }, {
        key: "destroyModel",
        value: function destroyModel(m) {
            var p = this._modelPools.get(m.constructor);
            p ? (p.free(m), m.destroy(), m.scene && m.scene.removeModel(m)) : console.warn("'".concat(m.constructor.name, "'is not in the model pool and cannot be destroyed by destroyModel."));
        }
    }, {
        key: "createCamera",
        value: function createCamera() {
            return this._cameraPool.alloc();
        }
    }, {
        key: "destroyCamera",
        value: function destroyCamera(c) {
            this._cameraPool.free(c), c.destroy(), c.scene && c.scene.removeCamera(c), c.isWindowSize = !0;
        }
    }, {
        key: "createLight",
        value: function createLight(lClass) {
            var l = this._lightPools.get(lClass);
            return l || (this._lightPools.set(lClass, new Pool$1((function() {
                return new lClass;
            }), 4)), l = this._lightPools.get(lClass)), l.alloc();
        }
    }, {
        key: "destroyLight",
        value: function destroyLight(l) {
            var p = this._lightPools.get(l.constructor);
            if (l.destroy(), p && (p.free(l), l.scene)) switch (l.type) {
              case LightType.SPHERE:
                l.scene.removeSphereLight(l);
                break;

              case LightType.SPOT:
                l.scene.removeSpotLight(l);
            }
        }
    }, {
        key: "sortViews",
        value: function sortViews() {
            this._views.sort((function(a, b) {
                return a.priority - b.priority;
            }));
        }
    } ]), Root;
}(), Director = function(_EventTarget) {
    function Director() {
        var _this;
        return _classCallCheck(this, Director), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Director).call(this)))._compScheduler = void 0, 
        _this._nodeActivator = void 0, _this._invalid = void 0, _this._paused = void 0, 
        _this._purgeDirectorInNextLoop = void 0, _this._root = void 0, _this._loadingScene = void 0, 
        _this._scene = void 0, _this._totalFrames = void 0, _this._lastUpdate = void 0, 
        _this._deltaTime = void 0, _this._scheduler = void 0, _this._systems = void 0, _this._invalid = !1, 
        _this._paused = !1, _this._purgeDirectorInNextLoop = !1, _this._root = null, _this._loadingScene = "", 
        _this._scene = null, _this._totalFrames = 0, _this._lastUpdate = 0, _this._deltaTime = 0, 
        _this._scheduler = new Scheduler, _this._compScheduler = new ComponentScheduler, 
        _this._nodeActivator = new NodeActivator, _this._systems = [], cc.game.once(Game.EVENT_RENDERER_INITED, _this._initOnRendererInitialized, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(Director, EventTarget), _createClass(Director, [ {
        key: "calculateDeltaTime",
        value: function calculateDeltaTime() {
            var now = performance.now();
            this._deltaTime = (now - this._lastUpdate) / 1e3, this._deltaTime > 1 && (this._deltaTime = 1 / 60), 
            this._lastUpdate = now;
        }
    }, {
        key: "convertToGL",
        value: function convertToGL(uiPoint) {
            var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, x = view._devicePixelRatio * (uiPoint.x - left), y = view._devicePixelRatio * (top + box.height - uiPoint.y);
            return view._isRotated ? v2(view._viewportRect.width - y, x) : v2(x, y);
        }
    }, {
        key: "convertToUI",
        value: function convertToUI(glPoint) {
            var container = cc.game.container, view = cc.view, box = container.getBoundingClientRect(), left = box.left + window.pageXOffset - container.clientLeft, top = box.top + window.pageYOffset - container.clientTop, uiPoint = v2(0, 0);
            return view._isRotated ? (uiPoint.x = left + glPoint.y / view._devicePixelRatio, 
            uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio) : (uiPoint.x = left + glPoint.x * view._devicePixelRatio, 
            uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio), uiPoint;
        }
    }, {
        key: "end",
        value: function end() {
            this._purgeDirectorInNextLoop = !0;
        }
    }, {
        key: "getWinSize",
        value: function getWinSize() {
            return size(cc.winSize);
        }
    }, {
        key: "getWinSizeInPixels",
        value: function getWinSizeInPixels() {
            return size(cc.winSize);
        }
    }, {
        key: "pause",
        value: function pause() {
            this._paused || (this._paused = !0);
        }
    }, {
        key: "purgeCachedData",
        value: function purgeCachedData() {
            cc.loader.releaseAll();
        }
    }, {
        key: "purgeDirector",
        value: function purgeDirector() {
            this._scheduler.unscheduleAll(), this._compScheduler.unscheduleAll(), this._nodeActivator.reset(), 
            eventManager && eventManager.setEnabled(!1), cc.isValid(this._scene) && this._scene.destroy(), 
            this._scene = null, this.stopAnimation(), cc.loader.releaseAll();
        }
    }, {
        key: "reset",
        value: function reset() {
            this.purgeDirector(), this.emit(Director.EVENT_RESET), eventManager && eventManager.setEnabled(!0), 
            this.startAnimation();
        }
    }, {
        key: "runSceneImmediate",
        value: function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
            cc.assertID(scene instanceof cc.Scene, 1216);
            var uuid = cc.loader._getReferenceKey(scene.uuid);
            cc.loader.removeItem(uuid), console.time("InitScene"), scene._load(), console.timeEnd("InitScene"), 
            console.time("AttachPersist");
            for (var persistNodeList = Object.keys(cc.game._persistRootNodes).map((function(x) {
                return cc.game._persistRootNodes[x];
            })), i = 0; i < persistNodeList.length; i++) {
                var node = persistNodeList[i];
                node.emit(cc.Node.SCENE_CHANGED_FOR_PERSISTS, scene.renderScene);
                var existNode = scene.getChildByUuid(node.uuid);
                if (existNode) {
                    var index = existNode.getSiblingIndex();
                    existNode._destroyImmediate(), scene.insertChild(node, index);
                } else node.parent = scene;
            }
            console.timeEnd("AttachPersist");
            var oldScene = this._scene;
            console.time("AutoRelease"), function autoRelease(oldSceneAssets, nextSceneAssets, persistNodes) {
                var releaseSettings = cc.loader._autoReleaseSetting, excludeMap = createMap();
                if (nextSceneAssets) for (var i = 0; i < nextSceneAssets.length; i++) excludeMap[nextSceneAssets[i]] = !0;
                for (var _i2 = 0; _i2 < persistNodes.length; _i2++) visitNode(persistNodes[_i2], excludeMap);
                if (oldSceneAssets) for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
                    var key = oldSceneAssets[_i3];
                    !1 === releaseSettings[key] || excludeMap[key] || cc.loader.release(key);
                }
                for (var keys = Object.keys(releaseSettings), _i4 = 0; _i4 < keys.length; _i4++) {
                    var _key = keys[_i4];
                    !0 !== releaseSettings[_key] || excludeMap[_key] || cc.loader.release(_key);
                }
            }(oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets, scene.dependAssets, persistNodeList), 
            console.timeEnd("AutoRelease"), console.time("Destroy"), cc.isValid(oldScene) && oldScene.destroy(), 
            this._scene = null, CCObject._deferredDestroy(), console.timeEnd("Destroy"), onBeforeLoadScene && onBeforeLoadScene(), 
            this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene), this._scene = scene, console.time("Activate"), 
            scene._activate(), console.timeEnd("Activate"), this._root && this._root.resetCumulativeTime(), 
            this.startAnimation(), onLaunched && onLaunched(null, scene), this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
        }
    }, {
        key: "runScene",
        value: function runScene(scene, onBeforeLoadScene, onLaunched) {
            var _this2 = this;
            cc.assertID(scene, 1205), cc.assertID(scene instanceof cc.Scene, 1216), scene._load(), 
            this.once(cc.Director.EVENT_AFTER_UPDATE, (function() {
                _this2.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
            }));
        }
    }, {
        key: "_getSceneUuid",
        value: function _getSceneUuid(key) {
            var scenes = cc.game._sceneInfos;
            if ("string" == typeof key) {
                key.endsWith(".scene") || (key += ".scene"), "/" === key[0] || key.startsWith("db://") || (key = "/" + key);
                for (var i = 0; i < scenes.length; i++) {
                    var info = scenes[i];
                    if (info.url.endsWith(key)) return info;
                }
            } else if ("number" == typeof key) {
                if (0 <= key && key < scenes.length) return scenes[key];
                cc.errorID(1206, key);
            } else cc.errorID(1207, key);
            return null;
        }
    }, {
        key: "loadScene",
        value: function loadScene(sceneName, onLaunched, onUnloaded) {
            if (this._loadingScene) return cc.errorID(1208, sceneName, this._loadingScene), 
            !1;
            var info = this._getSceneUuid(sceneName);
            if (info) {
                var _uuid = info.uuid;
                return this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), this._loadingScene = sceneName, 
                this._loadSceneByUuid(_uuid, onLaunched, onUnloaded), !0;
            }
            return cc.errorID(1209, sceneName), !1;
        }
    }, {
        key: "preloadScene",
        value: function preloadScene(sceneName, arg1, arg2) {
            var onProgress, onLoaded;
            void 0 === arg2 ? (onLoaded = arg1, onProgress = void 0) : (onLoaded = arg2, onProgress = arg1);
            var info = this._getSceneUuid(sceneName);
            if (info) this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName), cc.loader.load({
                uuid: info.uuid,
                type: "uuid"
            }, onProgress, (function(error, asset) {
                error && cc.errorID(1210, sceneName, error.message), onLoaded && onLoaded(error, asset);
            })); else {
                var _error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
                onLoaded && onLoaded(new Error(_error)), cc.error("preloadScene: " + _error);
            }
        }
    }, {
        key: "_loadSceneByUuid",
        value: function _loadSceneByUuid(uuid, arg1, arg2, arg3) {
            var onLaunched, onUnloaded;
            onLaunched = arg1, onUnloaded = arg2, console.time("LoadScene " + uuid), cc.AssetLibrary.loadAsset(uuid, (function(error, sceneAsset) {
                console.timeEnd("LoadScene " + uuid);
                var self = director;
                if (self._loadingScene = "", error) error = "Failed to load scene: " + error, cc.error(error); else {
                    if (sceneAsset instanceof cc.SceneAsset) {
                        var _scene = sceneAsset.scene;
                        return _scene._id = sceneAsset._uuid, _scene._name = sceneAsset._name, void self.runSceneImmediate(_scene, onUnloaded, onLaunched);
                    }
                    error = "The asset " + uuid + " is not a scene", cc.error(error);
                }
                onLaunched && onLaunched(error);
            }));
        }
    }, {
        key: "resume",
        value: function resume() {
            this._paused && (this._lastUpdate = performance.now(), this._lastUpdate || cc.logID(1200), 
            this._paused = !1, this._deltaTime = 0);
        }
    }, {
        key: "setDepthTest",
        value: function setDepthTest(value) {
            cc.Camera.main && (cc.Camera.main.depth = !!value);
        }
    }, {
        key: "setClearColor",
        value: function setClearColor(clearColor) {
            cc.Camera.main && (cc.Camera.main.backgroundColor = clearColor);
        }
    }, {
        key: "getRunningScene",
        value: function getRunningScene() {
            return this._scene;
        }
    }, {
        key: "getScene",
        value: function getScene() {
            return this._scene;
        }
    }, {
        key: "getAnimationInterval",
        value: function getAnimationInterval() {
            return 1e3 / cc.game.getFrameRate();
        }
    }, {
        key: "setAnimationInterval",
        value: function setAnimationInterval(value) {
            cc.game.setFrameRate(Math.round(1e3 / value));
        }
    }, {
        key: "getDeltaTime",
        value: function getDeltaTime() {
            return this._deltaTime;
        }
    }, {
        key: "getCurrentTime",
        value: function getCurrentTime() {
            return this._lastUpdate;
        }
    }, {
        key: "getTotalFrames",
        value: function getTotalFrames() {
            return this._totalFrames;
        }
    }, {
        key: "isPaused",
        value: function isPaused() {
            return this._paused;
        }
    }, {
        key: "getScheduler",
        value: function getScheduler() {
            return this._scheduler;
        }
    }, {
        key: "setScheduler",
        value: function setScheduler(scheduler) {
            this._scheduler !== scheduler && (this.unregisterSystem(this._scheduler), this._scheduler = scheduler, 
            this.registerSystem(Scheduler.ID, scheduler, 200));
        }
    }, {
        key: "registerSystem",
        value: function registerSystem(name, sys, priority) {
            sys.id = name, sys.priority = priority, sys.init(), this._systems.push(sys), this._systems.sort(System.sortByPriority);
        }
    }, {
        key: "unregisterSystem",
        value: function unregisterSystem(sys) {
            array.fastRemove(this._systems, sys), this._systems.sort(System.sortByPriority);
        }
    }, {
        key: "getSystem",
        value: function getSystem(name) {
            return this._systems.find((function(sys) {
                return sys.id === name;
            }));
        }
    }, {
        key: "getAnimationManager",
        value: function getAnimationManager() {
            return this.getSystem(cc.AnimationManager.ID);
        }
    }, {
        key: "startAnimation",
        value: function startAnimation() {
            this._invalid = !1, this._lastUpdate = performance.now();
        }
    }, {
        key: "stopAnimation",
        value: function stopAnimation() {
            this._invalid = !0;
        }
    }, {
        key: "mainLoop",
        value: function mainLoop(time) {
            if (this._purgeDirectorInNextLoop) this._purgeDirectorInNextLoop = !1, this.purgeDirector(); else if (!this._invalid) {
                this.calculateDeltaTime();
                var dt = this._deltaTime;
                if (!this._paused) {
                    this.emit(Director.EVENT_BEFORE_UPDATE), this._compScheduler.startPhase(), this._compScheduler.updatePhase(dt);
                    for (var i = 0; i < this._systems.length; ++i) this._systems[i].update(dt);
                    this._compScheduler.lateUpdatePhase(dt), this.emit(Director.EVENT_AFTER_UPDATE), 
                    CCObject._deferredDestroy();
                    for (var _i = 0; _i < this._systems.length; ++_i) this._systems[_i].postUpdate(dt);
                }
                this.emit(Director.EVENT_BEFORE_DRAW), this._root.frameMove(this._deltaTime), this._root.device.present(), 
                this.emit(Director.EVENT_AFTER_DRAW), eventManager.frameUpdateListeners(), Node$1.bookOfChange.clear(), 
                this._totalFrames++;
            }
        }
    }, {
        key: "_initOnRendererInitialized",
        value: function _initOnRendererInitialized() {
            this._totalFrames = 0, this._lastUpdate = performance.now(), this._paused = !1, 
            this._purgeDirectorInNextLoop = !1, eventManager && eventManager.setEnabled(!0), 
            this.registerSystem(Scheduler.ID, this._scheduler, 200), this.emit(Director.EVENT_INIT);
        }
    }, {
        key: "_init",
        value: function _init() {
            cc.loader.init(this), this._root = new Root(cc.game._gfxDevice);
            return !!this._root.initialize({});
        }
    }, {
        key: "root",
        get: function get() {
            return this._root;
        }
    } ]), Director;
}();

Director.EVENT_INIT = "director_init", Director.EVENT_RESET = "director_reset", 
Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading", Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch", 
Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch", Director.EVENT_BEFORE_UPDATE = "director_before_update", 
Director.EVENT_AFTER_UPDATE = "director_after_update", Director.EVENT_BEFORE_DRAW = "director_before_draw", 
Director.EVENT_AFTER_DRAW = "director_after_draw", Director.EVENT_BEFORE_PHYSICS = "director_before_physics", 
Director.EVENT_AFTER_PHYSICS = "director_after_physics", Director.instance = void 0, 
cc.Director = Director;

var _dec$P, _dec2$r, _class$P, _class2$I, _descriptor$B, _descriptor2$r, _descriptor3$l, _descriptor4$f, _descriptor5$b, _class$Q, director = Director.instance = cc.director = new Director, EventHandler = (_dec$P = ccclass("cc.ClickEvent"), 
_dec2$r = property(cc.Node), _dec$P((_applyDecoratedDescriptor((_class2$I = function() {
    function EventHandler() {
        _classCallCheck(this, EventHandler), _initializerDefineProperty(this, "target", _descriptor$B, this), 
        _initializerDefineProperty(this, "component", _descriptor2$r, this), _initializerDefineProperty(this, "_componentId", _descriptor3$l, this), 
        _initializerDefineProperty(this, "handler", _descriptor4$f, this), _initializerDefineProperty(this, "customEventData", _descriptor5$b, this);
    }
    return _createClass(EventHandler, [ {
        key: "emit",
        value: function emit(params) {
            var target = this.target;
            if (cc.isValid(target)) {
                this._genCompIdIfNeeded();
                var compType = cc.js._getClassById(this._componentId), comp = target.getComponent(compType);
                if (cc.isValid(comp)) {
                    var handler = comp[this.handler];
                    "function" == typeof handler && (null != this.customEventData && "" !== this.customEventData && (params = params.slice()).push(this.customEventData), 
                    handler.apply(comp, params));
                }
            }
        }
    }, {
        key: "_compName2Id",
        value: function _compName2Id(compName) {
            var comp = cc.js.getClassByName(compName);
            return cc.js._getClassId(comp);
        }
    }, {
        key: "_compId2Name",
        value: function _compId2Name(compId) {
            var comp = cc.js._getClassById(compId);
            return cc.js.getClassName(comp);
        }
    }, {
        key: "_genCompIdIfNeeded",
        value: function _genCompIdIfNeeded() {
            this._componentId || (this._componentName = this.component, this.component = "");
        }
    }, {
        key: "_componentName",
        get: function get() {
            return this._genCompIdIfNeeded(), this._compId2Name(this._componentId);
        },
        set: function set(value) {
            this._componentId = this._compName2Id(value);
        }
    } ], [ {
        key: "emitEvents",
        value: function emitEvents(events) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
            for (var i = 0, l = events.length; i < l; i++) {
                var event = events[i];
                event instanceof EventHandler && event.emit(args);
            }
        }
    } ]), EventHandler;
}()).prototype, "_componentName", [ property ], Object.getOwnPropertyDescriptor(_class2$I.prototype, "_componentName"), _class2$I.prototype), 
_descriptor$B = _applyDecoratedDescriptor(_class2$I.prototype, "target", [ _dec2$r ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$r = _applyDecoratedDescriptor(_class2$I.prototype, "component", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor3$l = _applyDecoratedDescriptor(_class2$I.prototype, "_componentId", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor4$f = _applyDecoratedDescriptor(_class2$I.prototype, "handler", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor5$b = _applyDecoratedDescriptor(_class2$I.prototype, "customEventData", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$P = _class2$I)) || _class$P);

cc.Component.EventHandler = EventHandler;

var BlockEvents = [ exports.SystemEventType.TOUCH_START, exports.SystemEventType.TOUCH_END, exports.SystemEventType.TOUCH_MOVE, exports.SystemEventType.MOUSE_DOWN, exports.SystemEventType.MOUSE_MOVE, exports.SystemEventType.MOUSE_UP, exports.SystemEventType.MOUSE_ENTER, exports.SystemEventType.MOUSE_LEAVE, exports.SystemEventType.MOUSE_WHEEL ];

function stopPropagation(event) {
    event.propagationStopped = !0;
}

var _dec$R, _dec2$t, _dec3$h, _dec4$d, _dec5$c, _dec6$a, _dec7$7, _dec8$5, _dec9$4, _dec10$4, _dec11$4, _dec12$3, _dec13$3, _dec14$2, _dec15$2, _dec16$2, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _class$R, _class2$J, _descriptor$C, _descriptor2$s, _descriptor3$m, _descriptor4$g, _descriptor5$c, _descriptor6$6, _descriptor7$6, _descriptor8$5, _descriptor9$5, _descriptor10$5, _descriptor11$2, _descriptor12$2, _descriptor13$2, _descriptor14$2, _descriptor15$1, _descriptor16$1, _descriptor17$1, _descriptor18$1, _class3$g, _temp$M, BlockInputEventsComponent = ccclass("cc.BlockInputEventsComponent")(_class$Q = help("i18n:cc.BlockInputEventsComponent")(_class$Q = menu("Components/BlockInputEvents")(_class$Q = function(_Component) {
    function BlockInputEventsComponent() {
        return _classCallCheck(this, BlockInputEventsComponent), _possibleConstructorReturn(this, _getPrototypeOf(BlockInputEventsComponent).apply(this, arguments));
    }
    return _inherits(BlockInputEventsComponent, Component), _createClass(BlockInputEventsComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
        }
    } ]), BlockInputEventsComponent;
}()) || _class$Q) || _class$Q) || _class$Q;

cc.BlockInputEventsComponent = BlockInputEventsComponent;

var _dec$S, _dec2$u, _dec3$i, _dec4$e, _dec5$d, _dec6$b, _dec7$8, _dec8$6, _dec9$5, _dec10$5, _dec11$5, _dec12$4, _class$S, _class2$K, _descriptor$D, _descriptor2$t, _descriptor3$n, _descriptor4$h, _descriptor5$d, _temp_vec3_1 = new Vec3, ProjectionType = Enum(CameraProjection), FOVAxis = Enum(CameraFOVAxis), Aperture = Enum(CameraAperture), Shutter = Enum(CameraShutter), ISO = Enum(CameraISO), ClearFlag = Enum({
    SKYBOX: SKYBOX_FLAG | exports.GFXClearFlag.DEPTH_STENCIL,
    SOLID_COLOR: exports.GFXClearFlag.ALL,
    DEPTH_ONLY: exports.GFXClearFlag.DEPTH_STENCIL,
    DONT_CLEAR: exports.GFXClearFlag.NONE
});

exports.CameraComponent = (_dec$R = ccclass("cc.CameraComponent"), _dec2$t = help("i18n:cc.CameraComponent"), 
_dec3$h = menu("Components/Camera"), _dec4$d = property({
    tooltip: "i18n:camera.priority",
    displayOrder: 0
}), _dec5$c = property({
    type: Layers.BitMask,
    tooltip: "i18n:camera.visibility",
    displayOrder: 1
}), _dec6$a = property({
    type: ClearFlag,
    tooltip: "i18n:camera.clear_flags",
    displayOrder: 2
}), _dec7$7 = property({
    tooltip: "i18n:camera.color",
    displayOrder: 3
}), _dec8$5 = property({
    tooltip: "i18n:camera.depth",
    displayOrder: 4
}), _dec9$4 = property({
    tooltip: "i18n:camera.stencil",
    displayOrder: 5
}), _dec10$4 = property({
    type: ProjectionType,
    tooltip: "i18n:camera.projection",
    displayOrder: 6
}), _dec11$4 = property({
    type: FOVAxis,
    tooltip: "i18n:camera.fov_axis",
    displayOrder: 7
}), _dec12$3 = property({
    tooltip: "i18n:camera.fov",
    displayOrder: 8
}), _dec13$3 = property({
    tooltip: "i18n:camera.ortho_height",
    displayOrder: 9
}), _dec14$2 = property({
    tooltip: "i18n:camera.near",
    displayOrder: 10
}), _dec15$2 = property({
    tooltip: "i18n:camera.far",
    displayOrder: 11
}), _dec16$2 = property({
    type: Aperture,
    tooltip: "i18n:camera.aperture",
    displayOrder: 12
}), _dec17$1 = property({
    type: Shutter,
    tooltip: "i18n:camera.shutter",
    displayOrder: 13
}), _dec18$1 = property({
    type: ISO,
    tooltip: "i18n:camera.ISO",
    displayOrder: 14
}), _dec19$1 = property({
    tooltip: "i18n:camera.rect",
    displayOrder: 15
}), _dec20$1 = property({
    type: RenderTexture,
    tooltip: "i18n:camera.target_texture",
    displayOrder: 16
}), _dec$R(_class$R = _dec2$t(_class$R = _dec3$h(_class$R = executeInEditMode((_temp$M = _class3$g = function(_Component) {
    function CameraComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, CameraComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CameraComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_projection", _descriptor$C, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_priority", _descriptor2$s, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fov", _descriptor3$m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fovAxis", _descriptor4$g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_orthoHeight", _descriptor5$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_near", _descriptor6$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_far", _descriptor7$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_color", _descriptor8$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_depth", _descriptor9$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_stencil", _descriptor10$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_clearFlags", _descriptor11$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_rect", _descriptor12$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_aperture", _descriptor13$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_shutter", _descriptor14$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_iso", _descriptor15$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_screenScale", _descriptor16$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_visibility", _descriptor17$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_targetTexture", _descriptor18$1, _assertThisInitialized(_this)), 
        _this._camera = null, _this._inEditorMode = !1, _this._flows = void 0, _this;
    }
    return _inherits(CameraComponent, Component), _createClass(CameraComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneChanged, this), 
            this._createCamera();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this.node.hasChangedFlags |= TransformBit.POSITION, this._camera && this._attachToScene();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._camera && this._detachFromScene();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._camera && (cc.director.root.destroyCamera(this._camera), this._camera = null), 
            this._targetTexture && this._targetTexture.off("resize");
        }
    }, {
        key: "screenPointToRay",
        value: function screenPointToRay(x, y, out) {
            return out || (out = ray.create()), this._camera && this._camera.screenPointToRay(out, x, y), 
            out;
        }
    }, {
        key: "worldToScreen",
        value: function worldToScreen(worldPos, out) {
            return out || (out = new Vec3), this._camera && this._camera.worldToScreen(out, worldPos), 
            out;
        }
    }, {
        key: "screenToWorld",
        value: function screenToWorld(screenPos, out) {
            return out || (out = this.node.getWorldPosition()), this._camera && this._camera.screenToWorld(out, screenPos), 
            out;
        }
    }, {
        key: "convertToUINode",
        value: function convertToUINode(wpos, uiNode, out) {
            if (out || (out = new Vec3), !this._camera) return out;
            this.worldToScreen(wpos, _temp_vec3_1);
            var cmp = uiNode.getComponent("cc.UITransformComponent"), designSize = view.getVisibleSize(), xoffset = _temp_vec3_1.x - .5 * this._camera.width, yoffset = _temp_vec3_1.y - .5 * this._camera.height;
            return _temp_vec3_1.x = xoffset / cc.view.getScaleX() + .5 * designSize.width, _temp_vec3_1.y = yoffset / cc.view.getScaleY() + .5 * designSize.height, 
            cmp && cmp.convertToNodeSpaceAR(_temp_vec3_1, out), out;
        }
    }, {
        key: "_createCamera",
        value: function _createCamera() {
            if (this._camera = cc.director.root.createCamera(), this._camera.initialize({
                name: this.node.name,
                node: this.node,
                projection: this._projection,
                window: this._inEditorMode ? cc.director.root && cc.director.root.mainWindow : cc.director.root && cc.director.root.tempWindow,
                priority: this._priority,
                flows: this._flows
            }), this._camera) {
                this._camera.viewport = this._rect, this._camera.fovAxis = this._fovAxis, this._camera.fov = toRadian(this._fov), 
                this._camera.orthoHeight = this._orthoHeight, this._camera.nearClip = this._near, 
                this._camera.farClip = this._far;
                var r = this._color.x, g = this._color.y, b = this._color.z, a = this._color.w;
                this._camera.clearColor = {
                    r: r,
                    g: g,
                    b: b,
                    a: a
                }, this._camera.clearDepth = this._depth, this._camera.clearStencil = this._stencil, 
                this._camera.clearFlag = this._clearFlags, this._camera.visibility = this._visibility, 
                this._camera.aperture = this._aperture, this._camera.shutter = this._shutter, this._camera.iso = this._iso;
            }
            this._updateTargetTexture();
        }
    }, {
        key: "_attachToScene",
        value: function _attachToScene() {
            this.node.scene && this._camera && (this._camera && this._camera.scene && this._camera.scene.removeCamera(this._camera), 
            this._getRenderScene().addCamera(this._camera));
        }
    }, {
        key: "_detachFromScene",
        value: function _detachFromScene() {
            this._camera && this._camera.scene && this._camera.scene.removeCamera(this._camera);
        }
    }, {
        key: "onSceneChanged",
        value: function onSceneChanged(scene) {
            this._camera && null == this._camera.scene && this._attachToScene();
        }
    }, {
        key: "_chechTargetTextureEvent",
        value: function _chechTargetTextureEvent(old) {
            var _this2 = this;
            old && old.off("resize"), this._targetTexture && this._targetTexture.on("resize", (function resizeFunc(window) {
                _this2._camera && _this2._camera.setFixedSize(window.width, window.height);
            }), this);
        }
    }, {
        key: "_updateTargetTexture",
        value: function _updateTargetTexture() {
            if (this._camera && this._targetTexture) {
                var window = this._targetTexture.getGFXWindow();
                this._camera.changeTargetWindow(window), this._camera.setFixedSize(window.width, window.height);
            }
        }
    }, {
        key: "camera",
        get: function get() {
            return this._camera;
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        },
        set: function set(val) {
            this._priority = val, this._camera && (this._camera.priority = val);
        }
    }, {
        key: "visibility",
        get: function get() {
            return this._visibility;
        },
        set: function set(val) {
            this._visibility = val, this._camera && (this._camera.visibility = val);
        }
    }, {
        key: "clearFlags",
        get: function get() {
            return this._clearFlags;
        },
        set: function set(val) {
            this._clearFlags = val, this._camera && (this._camera.clearFlag = val);
        }
    }, {
        key: "clearColor",
        get: function get() {
            return this._color;
        },
        set: function set(val) {
            this._color.set(val), this._camera && (this._camera.clearColor.r = this._color.x, 
            this._camera.clearColor.g = this._color.y, this._camera.clearColor.b = this._color.z, 
            this._camera.clearColor.a = this._color.w);
        }
    }, {
        key: "clearDepth",
        get: function get() {
            return this._depth;
        },
        set: function set(val) {
            this._depth = val, this._camera && (this._camera.clearDepth = val);
        }
    }, {
        key: "clearStencil",
        get: function get() {
            return this._stencil;
        },
        set: function set(val) {
            this._stencil = val, this._camera && (this._camera.clearStencil = val);
        }
    }, {
        key: "projection",
        get: function get() {
            return this._projection;
        },
        set: function set(val) {
            this._projection = val, this._camera && (this._camera.projectionType = val);
        }
    }, {
        key: "fovAxis",
        get: function get() {
            return this._fovAxis;
        },
        set: function set(val) {
            val !== this._fovAxis && (this._fovAxis = val, this._camera && (this._camera.fovAxis = val, 
            val === CameraFOVAxis.VERTICAL ? this.fov = this._fov * this._camera.aspect : this.fov = this._fov / this._camera.aspect));
        }
    }, {
        key: "fov",
        get: function get() {
            return this._fov;
        },
        set: function set(val) {
            this._fov = val, this._camera && (this._camera.fov = toRadian(val));
        }
    }, {
        key: "orthoHeight",
        get: function get() {
            return this._orthoHeight;
        },
        set: function set(val) {
            this._orthoHeight = val, this._camera && (this._camera.orthoHeight = val);
        }
    }, {
        key: "near",
        get: function get() {
            return this._near;
        },
        set: function set(val) {
            this._near = val, this._camera && (this._camera.nearClip = val);
        }
    }, {
        key: "far",
        get: function get() {
            return this._far;
        },
        set: function set(val) {
            this._far = val, this._camera && (this._camera.farClip = val);
        }
    }, {
        key: "aperture",
        get: function get() {
            return this._aperture;
        },
        set: function set(val) {
            this._aperture = val, this._camera && (this._camera.aperture = val);
        }
    }, {
        key: "shutter",
        get: function get() {
            return this._shutter;
        },
        set: function set(val) {
            this._shutter = val, this._camera && (this._camera.shutter = val);
        }
    }, {
        key: "iso",
        get: function get() {
            return this._iso;
        },
        set: function set(val) {
            this._iso = val, this._camera && (this._camera.iso = val);
        }
    }, {
        key: "rect",
        get: function get() {
            return this._rect;
        },
        set: function set(val) {
            this._rect = val, this._camera && (this._camera.viewport = val);
        }
    }, {
        key: "targetTexture",
        get: function get() {
            return this._targetTexture;
        },
        set: function set(value) {
            if (this._targetTexture !== value) {
                var old = this._targetTexture;
                this._targetTexture = value, this._chechTargetTextureEvent(old), this._updateTargetTexture(), 
                !value && this._camera && (this._camera.changeTargetWindow(null), this._camera.isWindowSize = !0);
            }
        }
    }, {
        key: "screenScale",
        get: function get() {
            return this._screenScale;
        },
        set: function set(val) {
            this._screenScale = val, this._camera && (this._camera.screenScale = val);
        }
    }, {
        key: "inEditorMode",
        get: function get() {
            return this._inEditorMode;
        },
        set: function set(value) {
            this._inEditorMode = value, this._camera && this._camera.changeTargetWindow(value ? cc.director.root && cc.director.root.mainWindow : cc.director.root && cc.director.root.tempWindow);
        }
    }, {
        key: "flows",
        set: function set(val) {
            this._camera && (this._camera.flows = val), this._flows = val;
        }
    } ]), CameraComponent;
}(), _class3$g.ProjectionType = ProjectionType, _class3$g.FOVAxis = FOVAxis, _class3$g.ClearFlag = ClearFlag, 
_class3$g.Aperture = Aperture, _class3$g.Shutter = Shutter, _class3$g.ISO = ISO, 
_descriptor$C = _applyDecoratedDescriptor((_class2$J = _temp$M).prototype, "_projection", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ProjectionType.PERSPECTIVE;
    }
}), _descriptor2$s = _applyDecoratedDescriptor(_class2$J.prototype, "_priority", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor3$m = _applyDecoratedDescriptor(_class2$J.prototype, "_fov", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 45;
    }
}), _descriptor4$g = _applyDecoratedDescriptor(_class2$J.prototype, "_fovAxis", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return FOVAxis.VERTICAL;
    }
}), _descriptor5$c = _applyDecoratedDescriptor(_class2$J.prototype, "_orthoHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 10;
    }
}), _descriptor6$6 = _applyDecoratedDescriptor(_class2$J.prototype, "_near", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor7$6 = _applyDecoratedDescriptor(_class2$J.prototype, "_far", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1e3;
    }
}), _descriptor8$5 = _applyDecoratedDescriptor(_class2$J.prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color("#333333");
    }
}), _descriptor9$5 = _applyDecoratedDescriptor(_class2$J.prototype, "_depth", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor10$5 = _applyDecoratedDescriptor(_class2$J.prototype, "_stencil", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11$2 = _applyDecoratedDescriptor(_class2$J.prototype, "_clearFlags", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ClearFlag.SOLID_COLOR;
    }
}), _descriptor12$2 = _applyDecoratedDescriptor(_class2$J.prototype, "_rect", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Rect(0, 0, 1, 1);
    }
}), _descriptor13$2 = _applyDecoratedDescriptor(_class2$J.prototype, "_aperture", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Aperture.F16_0;
    }
}), _descriptor14$2 = _applyDecoratedDescriptor(_class2$J.prototype, "_shutter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Shutter.D125;
    }
}), _descriptor15$1 = _applyDecoratedDescriptor(_class2$J.prototype, "_iso", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ISO.ISO100;
    }
}), _descriptor16$1 = _applyDecoratedDescriptor(_class2$J.prototype, "_screenScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor17$1 = _applyDecoratedDescriptor(_class2$J.prototype, "_visibility", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return CAMERA_DEFAULT_MASK;
    }
}), _descriptor18$1 = _applyDecoratedDescriptor(_class2$J.prototype, "_targetTexture", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$J.prototype, "priority", [ _dec4$d ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "priority"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "visibility", [ _dec5$c ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "visibility"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "clearFlags", [ _dec6$a ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "clearFlags"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "clearColor", [ _dec7$7 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "clearColor"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "clearDepth", [ _dec8$5 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "clearDepth"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "clearStencil", [ _dec9$4 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "clearStencil"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "projection", [ _dec10$4 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "projection"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "fovAxis", [ _dec11$4 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "fovAxis"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "fov", [ _dec12$3 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "fov"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "orthoHeight", [ _dec13$3 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "orthoHeight"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "near", [ _dec14$2 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "near"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "far", [ _dec15$2 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "far"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "aperture", [ _dec16$2 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "aperture"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "shutter", [ _dec17$1 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "shutter"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "iso", [ _dec18$1 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "iso"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "rect", [ _dec19$1 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "rect"), _class2$J.prototype), 
_applyDecoratedDescriptor(_class2$J.prototype, "targetTexture", [ _dec20$1 ], Object.getOwnPropertyDescriptor(_class2$J.prototype, "targetTexture"), _class2$J.prototype), 
_class$R = _class2$J)) || _class$R) || _class$R) || _class$R) || _class$R), exports.CameraComponent || (exports.CameraComponent = {});

var _dec$T, _dec2$v, _dec3$j, _dec4$f, _dec5$e, _dec6$c, _dec7$9, _dec8$7, _class$T, _class2$L, _descriptor$E, _descriptor2$u, _worldPos = new Vec3, CanvasClearFlag = Enum({
    SOLID_COLOR: exports.GFXClearFlag.ALL,
    DEPTH_ONLY: exports.GFXClearFlag.DEPTH_STENCIL,
    DONT_CLEAR: exports.GFXClearFlag.NONE
}), RenderMode = Enum({
    OVERLAY: 0,
    INTERSPERSE: 1
}), CanvasComponent = (_dec$S = ccclass("cc.CanvasComponent"), _dec2$u = help("i18n:cc.CanvasComponent"), 
_dec3$i = executionOrder(100), _dec4$e = requireComponent(UITransformComponent), 
_dec5$d = menu("UI/Canvas"), _dec6$b = property({
    type: CanvasClearFlag,
    tooltip: "清理屏幕缓冲标记"
}), _dec7$8 = property({
    tooltip: "清理颜色缓冲区后的颜色"
}), _dec8$6 = property({
    type: RenderMode,
    tooltip: "Canvas 渲染模式，intersperse 下可以指定 Canvas 与场景中的相机的渲染顺序，overlay 下 Canvas 会在所有场景相机渲染完成后渲染。\n注意：注意：场景里的相机（包括 Canvas 内置的相机）必须有一个的 ClearFlag 选择 SOLID_COLOR，否则在移动端可能会出现闪屏"
}), _dec9$5 = property({
    tooltip: "相机排序优先级。当 RenderMode 为 intersperse 时，指定与其它相机的渲染顺序，当 RenderMode 为 overlay 时，指定跟其余 Canvas 做排序使用。需要对多 Canvas 设定 priority 以免出现不同平台下的闪屏问题。"
}), _dec10$5 = property({
    type: RenderTexture,
    tooltip: "目标渲染纹理"
}), _dec11$5 = property({
    type: CanvasClearFlag
}), _dec12$4 = property({
    type: RenderMode
}), _dec$S(_class$S = _dec2$u(_class$S = _dec3$i(_class$S = _dec4$e(_class$S = _dec5$d(_class$S = executeInEditMode(_class$S = disallowMultiple((_applyDecoratedDescriptor((_class2$K = function(_Component) {
    function CanvasComponent() {
        var _this;
        return _classCallCheck(this, CanvasComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CanvasComponent).call(this)), "_priority", _descriptor$D, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_targetTexture", _descriptor2$t, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_clearFlag", _descriptor3$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_color", _descriptor4$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_renderMode", _descriptor5$d, _assertThisInitialized(_this)), 
        _this._thisOnResized = void 0, _this._camera = null, _this._pos = new Vec3, _this._thisOnResized = _this.alignWithScreen.bind(_assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(CanvasComponent, Component), _createClass(CanvasComponent, [ {
        key: "clearFlag",
        get: function get() {
            return this._clearFlag;
        },
        set: function set(val) {
            this._clearFlag = val, this._camera && (this._camera.clearFlag = this._clearFlag);
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(val) {
            Color.copy(this._color, val), this._camera && (this._camera.clearColor.r = val.r / 255, 
            this._camera.clearColor.g = val.g / 255, this._camera.clearColor.b = val.b / 255, 
            this._camera.clearColor.a = val.a / 255);
        }
    }, {
        key: "renderMode",
        get: function get() {
            return this._renderMode;
        },
        set: function set(val) {
            this._renderMode = val, this._camera && (this._camera.priority = this._getViewPriority());
        }
    }, {
        key: "priority",
        get: function get() {
            return this._priority;
        },
        set: function set(val) {
            this._priority = val, this._camera && (this._camera.priority = this._getViewPriority()), 
            director.root && director.root.ui && director.root.ui.sortScreens();
        }
    }, {
        key: "targetTexture",
        get: function get() {
            return this._targetTexture;
        },
        set: function set(value) {
            if (this._targetTexture !== value) {
                var old = this._targetTexture;
                this._targetTexture = value, this._checkTargetTextureEvent(old), this._updateTargetTexture();
            }
        }
    }, {
        key: "visibility",
        get: function get() {
            return this._camera ? this._camera.view.visibility : -1;
        }
    }, {
        key: "camera",
        get: function get() {
            return this._camera;
        }
    } ]), _createClass(CanvasComponent, [ {
        key: "__preload",
        value: function __preload() {
            var cameraNode = new Node$1("UICamera_" + this.node.name);
            if (cameraNode.setPosition(0, 0, 1e3), this._camera = director.root.createCamera(), 
            this._camera.initialize({
                name: "ui_" + this.node.name,
                node: cameraNode,
                projection: exports.CameraComponent.ProjectionType.ORTHO,
                priority: this._getViewPriority(),
                flows: [ "UIFlow" ]
            }), this._camera.fov = 45, this._camera.clearFlag = this.clearFlag, this._camera.farClip = 2e3, 
            this._camera.viewport = new Rect(0, 0, 1, 1), this.color = this._color, this._targetTexture) {
                var win = this._targetTexture.getGFXWindow();
                this._camera.changeTargetWindow(win);
            }
            view.on("design-resolution-changed", this._thisOnResized), this.alignWithScreen(), 
            director.root.ui.addScreen(this);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._camera && director.root.ui.renderScene.addCamera(this._camera);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._camera && director.root.ui.renderScene.removeCamera(this._camera);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            director.root.ui.removeScreen(this), this._camera && director.root.destroyCamera(this._camera), 
            this._targetTexture && this._targetTexture.off("resize"), view.off("design-resolution-changed", this._thisOnResized);
        }
    }, {
        key: "alignWithScreen",
        value: function alignWithScreen() {
            var nodeSize, designSize;
            this.node.getPosition(this._pos);
            var visibleSize = visibleRect;
            nodeSize = visibleSize, designSize = view.getDesignResolutionSize();
            var offsetX = 0, offsetY = 0;
            view.getResolutionPolicy() === cc.view._rpNoBorder && (offsetX = .5 * (designSize.width - visibleSize.width), 
            offsetY = .5 * (designSize.height - visibleSize.height)), Vec3.set(_worldPos, .5 * visibleSize.width + offsetX, .5 * visibleSize.height + offsetY, 0), 
            this._pos.equals(_worldPos) || this.node.setPosition(_worldPos), this.node.width !== nodeSize.width && (this.node.width = nodeSize.width), 
            this.node.height !== nodeSize.height && (this.node.height = nodeSize.height), this.node.getWorldPosition(_worldPos);
            var camera = this._camera;
            if (camera) {
                if (this._targetTexture) camera.setFixedSize(visibleSize.width, visibleSize.height), 
                camera.orthoHeight = visibleSize.height / 2; else {
                    var size = game.canvas;
                    camera.resize(size.width, size.height), camera.orthoHeight = game.canvas.height / view.getScaleY() / 2;
                }
                camera.node.setPosition(_worldPos.x, _worldPos.y, 1e3), camera.update();
            }
        }
    }, {
        key: "_checkTargetTextureEvent",
        value: function _checkTargetTextureEvent(old) {
            var _this2 = this;
            old && old.off("resize"), this._targetTexture && this._targetTexture.on("resize", (function resizeFunc(win) {
                _this2._camera && _this2._camera.setFixedSize(win.width, win.height);
            }), this);
        }
    }, {
        key: "_updateTargetTexture",
        value: function _updateTargetTexture() {
            if (this._camera) {
                var camera = this._camera;
                if (this._targetTexture) {
                    var win = this._targetTexture.getGFXWindow();
                    camera.changeTargetWindow(win), camera.orthoHeight = visibleRect.height / 2, camera.isWindowSize = !1;
                } else camera.changeTargetWindow(), camera.orthoHeight = game.canvas.height / view.getScaleY() / 2, 
                camera.isWindowSize = !0;
            }
        }
    }, {
        key: "_getViewPriority",
        value: function _getViewPriority() {
            return this._renderMode === RenderMode.OVERLAY ? this._priority | 1 << 30 : this._priority;
        }
    } ]), CanvasComponent;
}()).prototype, "clearFlag", [ _dec6$b ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "clearFlag"), _class2$K.prototype), 
_applyDecoratedDescriptor(_class2$K.prototype, "color", [ _dec7$8 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "color"), _class2$K.prototype), 
_applyDecoratedDescriptor(_class2$K.prototype, "renderMode", [ _dec8$6 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "renderMode"), _class2$K.prototype), 
_applyDecoratedDescriptor(_class2$K.prototype, "priority", [ _dec9$5 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "priority"), _class2$K.prototype), 
_applyDecoratedDescriptor(_class2$K.prototype, "targetTexture", [ _dec10$5 ], Object.getOwnPropertyDescriptor(_class2$K.prototype, "targetTexture"), _class2$K.prototype), 
_descriptor$D = _applyDecoratedDescriptor(_class2$K.prototype, "_priority", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$t = _applyDecoratedDescriptor(_class2$K.prototype, "_targetTexture", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$n = _applyDecoratedDescriptor(_class2$K.prototype, "_clearFlag", [ _dec11$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return CanvasClearFlag.DONT_CLEAR;
    }
}), _descriptor4$h = _applyDecoratedDescriptor(_class2$K.prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(0, 0, 0, 0);
    }
}), _descriptor5$d = _applyDecoratedDescriptor(_class2$K.prototype, "_renderMode", [ _dec12$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return RenderMode.OVERLAY;
    }
}), _class$S = _class2$K)) || _class$S) || _class$S) || _class$S) || _class$S) || _class$S) || _class$S) || _class$S);

cc.CanvasComponent = CanvasComponent, exports.removeProperty(UIComponent.prototype, "UIComponent", [ {
    name: "_visibility"
}, {
    name: "setVisibility"
} ]);

var _dec$U, _dec2$w, _dec3$k, _dec4$g, _dec5$f, _class$U, _class2$M, _descriptor$F, _descriptor2$v, _descriptor3$o, _descriptor4$i, _descriptor5$e, _descriptor6$7, _dec6$d, _dec7$a, _dec8$8, _dec9$6, _dec10$6, _dec11$6, _dec12$5, _dec13$4, _dec14$3, _class4$6, _class5$6, _descriptor7$7, _descriptor8$6, _descriptor9$6, _class$V, _class2$N, _descriptor$G, _descriptor2$w, _descriptor3$p, _dec2$x, _dec3$l, _dec4$h, _dec5$g, _dec6$e, _class4$7, _class5$7, _descriptor4$j, _descriptor5$f, _descriptor6$8, _descriptor7$8, _class6$1, _temp2$7, _dec$W, _dec2$y, _dec3$m, _dec4$i, _class$W, _class2$O, _descriptor$H, SkinningModelComponent = (_dec$T = ccclass("cc.SkinningModelComponent"), 
_dec2$v = help("i18n:cc.SkinningModelComponent"), _dec3$j = executionOrder(100), 
_dec4$f = menu("Components/SkinningModel"), _dec5$e = property(Skeleton), _dec6$c = property(Node$1), 
_dec7$9 = property({
    type: Skeleton
}), _dec8$7 = property({
    type: Node$1,
    tooltip: "i18n:model.skinning_root"
}), _dec$T(_class$T = _dec2$v(_class$T = _dec3$j(_class$T = executeInEditMode(_class$T = _dec4$f((_descriptor$E = _applyDecoratedDescriptor((_class2$L = function(_ModelComponent) {
    function SkinningModelComponent() {
        var _this;
        return _classCallCheck(this, SkinningModelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SkinningModelComponent).call(this)), "_skeleton", _descriptor$E, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_skinningRoot", _descriptor2$u, _assertThisInitialized(_this)), 
        _this._clip = null, _this._modelType = BakedSkinningModel, _this;
    }
    return _inherits(SkinningModelComponent, exports.ModelComponent), _createClass(SkinningModelComponent, [ {
        key: "skeleton",
        get: function get() {
            return this._skeleton;
        },
        set: function set(val) {
            val !== this._skeleton && (this._skeleton = val, this._update());
        }
    }, {
        key: "skinningRoot",
        get: function get() {
            return this._skinningRoot;
        },
        set: function set(value) {
            value !== this._skinningRoot && (this._skinningRoot = value, this._updateModelType(), 
            this._update());
        }
    }, {
        key: "model",
        get: function get() {
            return this._model;
        }
    } ]), _createClass(SkinningModelComponent, [ {
        key: "__preload",
        value: function __preload() {
            this._updateModelType();
        }
    }, {
        key: "uploadAnimation",
        value: function uploadAnimation(clip) {
            this._clip = clip, this.model && this.model.uploadAnimation && this.model.uploadAnimation(clip);
        }
    }, {
        key: "setUseBakedAnimation",
        value: function setUseBakedAnimation() {
            var val = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], modelType = val ? BakedSkinningModel : SkinningModel;
            if (this._modelType !== modelType) {
                this._modelType = modelType;
                var modelCreated = !!this._model;
                modelCreated && (cc.director.root.destroyModel(this._model), this._model = null, 
                this._models.length = 0);
                var meshCount = this._mesh ? this._mesh.subMeshCount : 0;
                if (this._modelType === SkinningModel) for (var last = null, i = 0; i < meshCount; ++i) {
                    var cur = this.getRenderMaterial(i);
                    cur === last ? this.getMaterialInstance(i) : last = cur;
                } else for (var _i = 0; _i < meshCount; ++_i) {
                    var _cur = this.getRenderMaterial(_i);
                    _cur && _cur.parent && _cur.parent.passes[0].instancedBuffer && (this._materialInstances[_i].destroy(), 
                    this._materialInstances[_i] = null);
                }
                modelCreated && (this._updateModels(), this._updateCastShadow(), this.enabledInHierarchy && this._attachToScene());
            }
        }
    }, {
        key: "setMaterial",
        value: function setMaterial(material, index) {
            _get(_getPrototypeOf(SkinningModelComponent.prototype), "setMaterial", this).call(this, material, index), 
            this._modelType === SkinningModel && this.getMaterialInstance(index);
        }
    }, {
        key: "_updateModelParams",
        value: function _updateModelParams() {
            this._update(), _get(_getPrototypeOf(SkinningModelComponent.prototype), "_updateModelParams", this).call(this);
        }
    }, {
        key: "_updateModelType",
        value: function _updateModelType() {
            if (this._skinningRoot) {
                var comp = this._skinningRoot.getComponent("cc.SkeletalAnimationComponent");
                comp && this.setUseBakedAnimation(comp.useBakedAnimation);
            }
        }
    }, {
        key: "_update",
        value: function _update() {
            this.model && (this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh), 
            this.model.uploadAnimation && this.model.uploadAnimation(this._clip));
        }
    } ]), SkinningModelComponent;
}()).prototype, "_skeleton", [ _dec5$e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$u = _applyDecoratedDescriptor(_class2$L.prototype, "_skinningRoot", [ _dec6$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$L.prototype, "skeleton", [ _dec7$9 ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "skeleton"), _class2$L.prototype), 
_applyDecoratedDescriptor(_class2$L.prototype, "skinningRoot", [ _dec8$7 ], Object.getOwnPropertyDescriptor(_class2$L.prototype, "skinningRoot"), _class2$L.prototype), 
_class$T = _class2$L)) || _class$T) || _class$T) || _class$T) || _class$T) || _class$T), batch_id = {
    name: exports.GFXAttributeName.ATTR_BATCH_ID,
    format: exports.GFXFormat.R32F,
    isNormalized: !1
}, batch_uv = {
    name: exports.GFXAttributeName.ATTR_BATCH_UV,
    format: exports.GFXFormat.RG32F,
    isNormalized: !1
}, batch_extras_size = GFXFormatInfos[batch_id.format].size + GFXFormatInfos[batch_uv.format].size, SkinningModelUnit = (_dec$U = ccclass("cc.SkinningModelUnit"), 
_dec2$w = property(Mesh), _dec3$k = property(Skeleton), _dec4$g = property(Material), 
_dec5$f = property({
    type: SkinningModelComponent
}), _dec$U((_descriptor$F = _applyDecoratedDescriptor((_class2$M = function() {
    function SkinningModelUnit() {
        _classCallCheck(this, SkinningModelUnit), _initializerDefineProperty(this, "mesh", _descriptor$F, this), 
        _initializerDefineProperty(this, "skeleton", _descriptor2$v, this), _initializerDefineProperty(this, "material", _descriptor3$o, this), 
        _initializerDefineProperty(this, "_localTransform", _descriptor4$i, this), _initializerDefineProperty(this, "_offset", _descriptor5$e, this), 
        _initializerDefineProperty(this, "_size", _descriptor6$7, this);
    }
    return _createClass(SkinningModelUnit, [ {
        key: "offset",
        set: function set(offset) {
            Vec2.copy(this._offset, offset);
        },
        get: function get() {
            return this._offset;
        }
    }, {
        key: "size",
        set: function set(size) {
            Vec2.copy(this._size, size);
        },
        get: function get() {
            return this._size;
        }
    }, {
        key: "copyFrom",
        set: function set(comp) {
            comp && (this.mesh = comp.mesh, this.skeleton = comp.skeleton, this.material = comp.getMaterial(0), 
            comp.skinningRoot && getWorldTransformUntilRoot(comp.node, comp.skinningRoot, this._localTransform));
        },
        get: function get() {
            return null;
        }
    } ]), SkinningModelUnit;
}()).prototype, "mesh", [ _dec2$w ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$v = _applyDecoratedDescriptor(_class2$M.prototype, "skeleton", [ _dec3$k ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$o = _applyDecoratedDescriptor(_class2$M.prototype, "material", [ _dec4$g ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor4$i = _applyDecoratedDescriptor(_class2$M.prototype, "_localTransform", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Mat4;
    }
}), _descriptor5$e = _applyDecoratedDescriptor(_class2$M.prototype, "_offset", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(0, 0);
    }
}), _descriptor6$7 = _applyDecoratedDescriptor(_class2$M.prototype, "_size", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(1, 1);
    }
}), _applyDecoratedDescriptor(_class2$M.prototype, "offset", [ property ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "offset"), _class2$M.prototype), 
_applyDecoratedDescriptor(_class2$M.prototype, "size", [ property ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "size"), _class2$M.prototype), 
_applyDecoratedDescriptor(_class2$M.prototype, "copyFrom", [ _dec5$f ], Object.getOwnPropertyDescriptor(_class2$M.prototype, "copyFrom"), _class2$M.prototype), 
_class$U = _class2$M)) || _class$U), m4_local = new Mat4, v3_1$9 = (new Mat4, new Vec3), BatchedSkinningModelComponent = (_dec6$d = ccclass("cc.BatchedSkinningModelComponent"), 
_dec7$a = help("i18n:cc.BatchedSkinningModelComponent"), _dec8$8 = executionOrder(100), 
_dec9$6 = menu("Components/BatchedSkinningModel"), _dec10$6 = property({
    tooltip: "i18n:batched_skinning_model.atlas_size"
}), _dec11$6 = property({
    type: [ CCString ],
    tooltip: "i18n:batched_skinning_model.batchable_texture_names"
}), _dec12$5 = property({
    type: [ SkinningModelUnit ],
    tooltip: "i18n:batched_skinning_model.units"
}), _dec13$4 = property({
    override: !0,
    visible: !1
}), _dec14$3 = property({
    override: !0,
    visible: !1
}), _dec6$d(_class4$6 = _dec7$a(_class4$6 = _dec8$8(_class4$6 = executeInEditMode(_class4$6 = _dec9$6((_descriptor7$7 = _applyDecoratedDescriptor((_class5$6 = function(_SkinningModelCompone) {
    function BatchedSkinningModelComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, BatchedSkinningModelComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BatchedSkinningModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "atlasSize", _descriptor7$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "batchableTextureNames", _descriptor8$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "units", _descriptor9$6, _assertThisInitialized(_this)), 
        _this._textures = {}, _this._batchMaterial = null, _this;
    }
    return _inherits(BatchedSkinningModelComponent, SkinningModelComponent), _createClass(BatchedSkinningModelComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onLoad", this).call(this), 
            this.cook();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            for (var tex in this._textures) this._textures[tex].destroy();
            this._textures = {}, this._mesh && (this._mesh.destroy(), this._mesh = null), _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onDestroy", this).call(this);
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(idx, material) {
            this.cookMaterials(), _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "_onMaterialModified", this).call(this, idx, this.getMaterialInstance(idx));
        }
    }, {
        key: "cook",
        value: function cook() {
            this.cookMaterials(), this.cookSkeletons(), this.cookMeshes();
        }
    }, {
        key: "cookMaterials",
        value: function cookMaterials() {
            var _this2 = this;
            this._batchMaterial || (this._batchMaterial = this.getMaterial(0));
            var mat = this.getMaterialInstance(0);
            if (mat && this._batchMaterial && this._batchMaterial.effectAsset) {
                mat.copy(this._batchMaterial), this.resizeAtlases();
                for (var tech = mat.effectAsset.techniques[mat.technique], _loop = function _loop(i) {
                    var pass = tech.passes[i];
                    if (!pass.properties) return "continue";
                    var _loop2 = function _loop2(prop) {
                        if (pass.properties[prop].type >= exports.GFXType.SAMPLER1D) {
                            var tex = null;
                            _this2.batchableTextureNames.find((function(n) {
                                return n === prop;
                            })) ? ((tex = _this2._textures[prop]) || (tex = _this2.createTexture(prop)), _this2.cookTextures(tex, prop, i)) : _this2.units.some((function(u) {
                                return tex = u.material && u.material.getProperty(prop, i);
                            })), tex && mat.setProperty(prop, tex, i);
                        } else {
                            for (var value = [], u = 0; u < _this2.units.length; u++) {
                                var unit = _this2.units[u];
                                unit.material && value.push(unit.material.getProperty(prop.slice(0, -3), i));
                            }
                            mat.setProperty(prop, value, i);
                        }
                    };
                    for (var prop in pass.properties) _loop2(prop);
                }, i = 0; i < tech.passes.length; i++) _loop(i);
            } else console.warn("incomplete batch material!");
        }
    }, {
        key: "cookSkeletons",
        value: function cookSkeletons() {
            if (this._skinningRoot) {
                for (var joints = [], bindposes = [], u = 0; u < this.units.length; u++) {
                    var unit = this.units[u];
                    if (unit && unit.skeleton) {
                        var partial = unit.skeleton;
                        Mat4.invert(m4_local, unit._localTransform);
                        for (var _loop3 = function _loop3(i) {
                            var path = partial.joints[i];
                            if (joints.findIndex((function(p) {
                                return p === path;
                            })) >= 0) return "continue";
                            joints.push(path), bindposes.push(Mat4.multiply(new Mat4, partial.bindposes[i] || Mat4.IDENTITY, m4_local));
                        }, i = 0; i < partial.joints.length; i++) _loop3(i);
                    }
                }
                var idxMap = Array.from(Array(joints.length).keys()).sort((function(a, b) {
                    return joints[a] > joints[b] ? 1 : joints[a] < joints[b] ? -1 : 0;
                })), skeleton = new Skeleton;
                skeleton.joints = joints.map((function(_, idx, arr) {
                    return arr[idxMap[idx]];
                })), skeleton.bindposes = bindposes.map((function(_, idx, arr) {
                    return arr[idxMap[idx]];
                })), this._skeleton && this._skeleton.destroy(), this.skeleton = skeleton;
            } else console.warn("no skinning root specified!");
        }
    }, {
        key: "cookMeshes",
        value: function cookMeshes() {
            for (var _this4 = this, isValid = !1, u = 0; u < this.units.length; u++) {
                if (this.units[u].mesh) {
                    isValid = !0;
                    break;
                }
            }
            if (isValid && this._skinningRoot) {
                this._mesh ? this._mesh.destroyRenderingMesh() : this._mesh = new Mesh;
                for (var posOffset = 0, posFormat = exports.GFXFormat.UNKNOWN, normalOffset = 0, normalFormat = exports.GFXFormat.UNKNOWN, tangentOffset = 0, tangentFormat = exports.GFXFormat.UNKNOWN, uvOffset = 0, uvFormat = exports.GFXFormat.UNKNOWN, jointOffset = 0, jointFormat = exports.GFXFormat.UNKNOWN, jointIndexMap = new Array(this.units.length), unitLen = this.units.length, i = 0; i < unitLen; i++) {
                    var _unit = this.units[i];
                    _unit && _unit.skeleton && (jointIndexMap[i] = _unit.skeleton.joints.map((function(j) {
                        return _this4._skeleton.joints.findIndex((function(ref) {
                            return j === ref;
                        }));
                    })));
                }
                for (var _loop4 = function _loop4(_i) {
                    var unit = _this4.units[_i];
                    if (!unit || !unit.mesh || !unit.mesh.data) return "continue";
                    var newMesh = _this4._createUnitMesh(_i, unit.mesh), dataView = new DataView(newMesh.data.buffer);
                    Mat4.inverseTranspose(m4_local, unit._localTransform);
                    for (var offset = unit.offset, size = unit.size, _loop5 = function _loop5(b) {
                        var bundle = newMesh.struct.vertexBundles[b];
                        posOffset = bundle.view.offset, posFormat = exports.GFXFormat.UNKNOWN;
                        for (var a = 0; a < bundle.attributes.length; a++) {
                            var attr = bundle.attributes[a];
                            if (attr.name === exports.GFXAttributeName.ATTR_POSITION) {
                                posFormat = attr.format;
                                break;
                            }
                            posOffset += GFXFormatInfos[attr.format].size;
                        }
                        if (posFormat) {
                            for (var pos = readBuffer(dataView, posFormat, posOffset, bundle.view.length, bundle.view.stride), j = 0; j < pos.length; j += 3) Vec3.fromArray(v3_1$9, pos, j), 
                            Vec3.transformMat4(v3_1$9, v3_1$9, unit._localTransform), Vec3.toArray(pos, v3_1$9, j);
                            writeBuffer(dataView, pos, posFormat, posOffset, bundle.view.stride);
                        }
                        normalOffset = bundle.view.offset, normalFormat = exports.GFXFormat.UNKNOWN;
                        for (var _a = 0; _a < bundle.attributes.length; _a++) {
                            var _attr = bundle.attributes[_a];
                            if (_attr.name === exports.GFXAttributeName.ATTR_NORMAL) {
                                normalFormat = _attr.format;
                                break;
                            }
                            normalOffset += GFXFormatInfos[_attr.format].size;
                        }
                        if (normalFormat) {
                            for (var normal = readBuffer(dataView, normalFormat, normalOffset, bundle.view.length, bundle.view.stride), _j = 0; _j < normal.length; _j += 3) Vec3.fromArray(v3_1$9, normal, _j), 
                            Vec3.transformMat4Normal(v3_1$9, v3_1$9, m4_local), Vec3.toArray(normal, v3_1$9, _j);
                            writeBuffer(dataView, normal, normalFormat, normalOffset, bundle.view.stride);
                        }
                        tangentOffset = bundle.view.offset, tangentFormat = exports.GFXFormat.UNKNOWN;
                        for (var _a2 = 0; _a2 < bundle.attributes.length; _a2++) {
                            var _attr2 = bundle.attributes[_a2];
                            if (_attr2.name === exports.GFXAttributeName.ATTR_TANGENT) {
                                tangentFormat = _attr2.format;
                                break;
                            }
                            tangentOffset += GFXFormatInfos[_attr2.format].size;
                        }
                        if (tangentFormat) {
                            for (var tangent = readBuffer(dataView, tangentFormat, tangentOffset, bundle.view.length, bundle.view.stride), _j2 = 0; _j2 < tangent.length; _j2 += 3) Vec3.fromArray(v3_1$9, tangent, _j2), 
                            Vec3.transformMat4Normal(v3_1$9, v3_1$9, m4_local), Vec3.toArray(tangent, v3_1$9, _j2);
                            writeBuffer(dataView, tangent, tangentFormat, tangentOffset, bundle.view.stride);
                        }
                        uvOffset = bundle.view.offset, uvFormat = exports.GFXFormat.UNKNOWN;
                        for (var _a3 = 0; _a3 < bundle.attributes.length; _a3++) {
                            var _attr3 = bundle.attributes[_a3];
                            if (_attr3.name === exports.GFXAttributeName.ATTR_BATCH_UV) {
                                uvFormat = _attr3.format;
                                break;
                            }
                            uvOffset += GFXFormatInfos[_attr3.format].size;
                        }
                        uvFormat && mapBuffer(dataView, (function(cur, idx) {
                            var comp = 0 === idx ? "x" : "y";
                            return (cur = function repeat(n) {
                                return n - Math.floor(n);
                            }(cur)) * size[comp] + offset[comp];
                        }), uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                        var idxMap = jointIndexMap[_i];
                        if (!idxMap) return "continue";
                        jointOffset = bundle.view.offset, jointFormat = exports.GFXFormat.UNKNOWN;
                        for (var _a4 = 0; _a4 < bundle.attributes.length; _a4++) {
                            var _attr4 = bundle.attributes[_a4];
                            if (_attr4.name === exports.GFXAttributeName.ATTR_JOINTS) {
                                jointFormat = _attr4.format;
                                break;
                            }
                            jointOffset += GFXFormatInfos[_attr4.format].size;
                        }
                        jointFormat && mapBuffer(dataView, (function(cur) {
                            return idxMap[cur];
                        }), jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    }, b = 0; b < newMesh.struct.vertexBundles.length; b++) _loop5(b);
                    _this4._mesh.merge(newMesh);
                }, _i = 0; _i < unitLen; _i++) _loop4(_i);
                this._onMeshChanged(this._mesh), this._updateModels();
            }
        }
    }, {
        key: "cookTextures",
        value: function cookTextures(target, prop, passIdx) {
            for (var texImages = [], texImageRegions = [], texBuffers = [], texBufferRegions = [], u = 0; u < this.units.length; u++) {
                var unit = this.units[u];
                if (unit.material) {
                    var partial = unit.material.getProperty(prop, passIdx);
                    if (partial && partial.image && partial.image.data) {
                        var region = new GFXBufferTextureCopy;
                        region.texOffset.x = unit.offset.x * this.atlasSize, region.texOffset.y = unit.offset.y * this.atlasSize, 
                        region.texExtent.width = unit.size.x * this.atlasSize, region.texExtent.height = unit.size.y * this.atlasSize;
                        var data = partial.image.data;
                        data instanceof HTMLCanvasElement || data instanceof HTMLImageElement ? (texImages.push(data), 
                        texImageRegions.push(region)) : (texBuffers.push(data), texBufferRegions.push(region));
                    }
                }
            }
            var gfxTex = target.getGFXTexture(), device = cc.director.root.device;
            texBuffers.length > 0 && device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions), 
            texImages.length > 0 && device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
        }
    }, {
        key: "createTexture",
        value: function createTexture(prop) {
            var tex = new Texture2D;
            return tex.setFilters(Filter.LINEAR, Filter.LINEAR), tex.setMipFilter(Filter.LINEAR), 
            tex.reset({
                width: this.atlasSize,
                height: this.atlasSize,
                format: PixelFormat.RGBA8888
            }), tex.loaded = !0, this._textures[prop] = tex, tex;
        }
    }, {
        key: "resizeAtlases",
        value: function resizeAtlases() {
            for (var prop in this._textures) {
                this._textures[prop].reset({
                    width: this.atlasSize,
                    height: this.atlasSize,
                    format: PixelFormat.RGBA8888
                });
            }
        }
    }, {
        key: "_createUnitMesh",
        value: function _createUnitMesh(unitIdx, mesh) {
            for (var newMeshStruct = JSON.parse(JSON.stringify(mesh.struct)), modifiedBundles = {}, p = 0; p < mesh.struct.primitives.length; p++) {
                for (var primitive = mesh.struct.primitives[p], uvOffset = 0, uvFormat = exports.GFXFormat.UNKNOWN, bundleIdx = 0; bundleIdx < primitive.vertexBundelIndices.length; bundleIdx++) {
                    var bundle = mesh.struct.vertexBundles[primitive.vertexBundelIndices[bundleIdx]];
                    uvOffset = bundle.view.offset, uvFormat = exports.GFXFormat.UNKNOWN;
                    for (var a = 0; a < bundle.attributes.length; a++) {
                        var attr = bundle.attributes[a];
                        if (attr.name === exports.GFXAttributeName.ATTR_TEX_COORD) {
                            uvFormat = attr.format;
                            break;
                        }
                        uvOffset += GFXFormatInfos[attr.format].size;
                    }
                    if (uvFormat) break;
                }
                if (void 0 === modifiedBundles[bundleIdx]) {
                    modifiedBundles[bundleIdx] = [ uvFormat, uvOffset ];
                    var newBundle = newMeshStruct.vertexBundles[bundleIdx];
                    newBundle.attributes.push(batch_id), newBundle.attributes.push(batch_uv), newBundle.view.offset = 0, 
                    newBundle.view.length += newBundle.view.count * batch_extras_size, newBundle.view.stride += batch_extras_size;
                }
            }
            for (var totalLength = 0, b = 0; b < newMeshStruct.vertexBundles.length; b++) totalLength += newMeshStruct.vertexBundles[b].view.length;
            for (var _p = 0; _p < newMeshStruct.primitives.length; _p++) {
                var pm = newMeshStruct.primitives[_p];
                pm.indexView && (pm.indexView.offset = totalLength, totalLength += pm.indexView.length);
            }
            var newMeshData = new Uint8Array(totalLength), oldMeshData = mesh.data, newDataView = new DataView(newMeshData.buffer), oldDataView = new DataView(oldMeshData.buffer), isLittleEndian = sys.isLittleEndian;
            for (var _b in modifiedBundles) for (var _newBundle = newMeshStruct.vertexBundles[_b], oldBundle = mesh.struct.vertexBundles[_b], _modifiedBundles$_b = _slicedToArray(modifiedBundles[_b], 2), uvs = readBuffer(oldDataView, _modifiedBundles$_b[0], _modifiedBundles$_b[1], oldBundle.view.length, oldBundle.view.stride), oldView = oldBundle.view, newView = _newBundle.view, oldStride = oldView.stride, newStride = newView.stride, oldOffset = oldView.offset, newOffset = newView.offset, j = 0; j < newView.count; j++) {
                var srcVertex = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
                newMeshData.set(srcVertex, newOffset), newDataView.setFloat32(newOffset + oldStride, unitIdx), 
                newDataView.setFloat32(newOffset + oldStride + 4, uvs[2 * j], isLittleEndian), newDataView.setFloat32(newOffset + oldStride + 8, uvs[2 * j + 1], isLittleEndian), 
                newOffset += newStride, oldOffset += oldStride;
            }
            for (var k = 0; k < newMeshStruct.primitives.length; k++) {
                var oldPrimitive = mesh.struct.primitives[k], newPrimitive = newMeshStruct.primitives[k];
                if (oldPrimitive.indexView && newPrimitive.indexView) for (var _oldStride = oldPrimitive.indexView.stride, _newStride = newPrimitive.indexView.stride, _oldOffset = oldPrimitive.indexView.offset, _newOffset = newPrimitive.indexView.offset, _j3 = 0; _j3 < newPrimitive.indexView.count; _j3++) {
                    var srcIndices = oldMeshData.subarray(_oldOffset, _oldOffset + _oldStride);
                    newMeshData.set(srcIndices, _newOffset), _newOffset += _newStride, _oldOffset += _oldStride;
                }
            }
            var newMesh = new Mesh;
            return newMesh.reset({
                struct: newMeshStruct,
                data: newMeshData
            }), newMesh;
        }
    }, {
        key: "mesh",
        get: function get() {
            return _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "mesh", this);
        },
        set: function set(val) {
            _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "mesh", val, this, !0);
        }
    }, {
        key: "skeleton",
        get: function get() {
            return _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", this);
        },
        set: function set(val) {
            _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", val, this, !0);
        }
    } ]), BatchedSkinningModelComponent;
}()).prototype, "atlasSize", [ _dec10$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1024;
    }
}), _descriptor8$6 = _applyDecoratedDescriptor(_class5$6.prototype, "batchableTextureNames", [ _dec11$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor9$6 = _applyDecoratedDescriptor(_class5$6.prototype, "units", [ _dec12$5 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _applyDecoratedDescriptor(_class5$6.prototype, "mesh", [ _dec13$4 ], Object.getOwnPropertyDescriptor(_class5$6.prototype, "mesh"), _class5$6.prototype), 
_applyDecoratedDescriptor(_class5$6.prototype, "skeleton", [ _dec14$3 ], Object.getOwnPropertyDescriptor(_class5$6.prototype, "skeleton"), _class5$6.prototype), 
_class4$6 = _class5$6)) || _class4$6) || _class4$6) || _class4$6) || _class4$6) || _class4$6), PhotometricTerm = Enum({
    LUMINOUS_POWER: 0,
    LUMINANCE: 1
}), StaticLightSettings = ccclass("cc.StaticLightSettings")((_descriptor$G = _applyDecoratedDescriptor((_class2$N = function() {
    function StaticLightSettings() {
        _classCallCheck(this, StaticLightSettings), _initializerDefineProperty(this, "_editorOnly", _descriptor$G, this), 
        _initializerDefineProperty(this, "_bakeable", _descriptor2$w, this), _initializerDefineProperty(this, "_castShadow", _descriptor3$p, this);
    }
    return _createClass(StaticLightSettings, [ {
        key: "editorOnly",
        get: function get() {
            return this._editorOnly;
        },
        set: function set(val) {
            this._editorOnly = val;
        }
    }, {
        key: "bakeable",
        get: function get() {
            return this._bakeable;
        },
        set: function set(val) {
            this._bakeable = val;
        }
    }, {
        key: "castShadow",
        get: function get() {
            return this._castShadow;
        },
        set: function set(val) {
            this._castShadow = val;
        }
    } ]), StaticLightSettings;
}()).prototype, "_editorOnly", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$w = _applyDecoratedDescriptor(_class2$N.prototype, "_bakeable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$p = _applyDecoratedDescriptor(_class2$N.prototype, "_castShadow", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$N.prototype, "editorOnly", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "editorOnly"), _class2$N.prototype), 
_applyDecoratedDescriptor(_class2$N.prototype, "bakeable", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "bakeable"), _class2$N.prototype), 
_applyDecoratedDescriptor(_class2$N.prototype, "castShadow", [ property ], Object.getOwnPropertyDescriptor(_class2$N.prototype, "castShadow"), _class2$N.prototype), 
_class$V = _class2$N)) || _class$V;

exports.LightComponent || (exports.LightComponent = {}), exports.LightComponent = (_dec2$x = ccclass("cc.LightComponent"), 
_dec3$l = property({
    tooltip: "i18n:lights.color"
}), _dec4$h = property({
    tooltip: "i18n:lights.use_color_temperature"
}), _dec5$g = property({
    slide: !0,
    range: [ 1e3, 15e3, 1 ],
    tooltip: "i18n:lights.color_temperature"
}), _dec6$e = property({
    type: StaticLightSettings
}), _dec2$x((_temp2$7 = _class6$1 = function(_Component) {
    function LightComponent() {
        var _this;
        return _classCallCheck(this, LightComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LightComponent).call(this)), "_color", _descriptor4$j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_useColorTemperature", _descriptor5$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_colorTemperature", _descriptor6$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_staticSettings", _descriptor7$8, _assertThisInitialized(_this)), 
        _this._type = LightType.UNKNOWN, _this._lightType = void 0, _this._light = null, 
        _this._lightType = Light, _this;
    }
    return _inherits(LightComponent, Component), _createClass(LightComponent, [ {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(val) {
            this._color = val, this._light && (this._light.color.x = val.r / 255, this._light.color.y = val.g / 255, 
            this._light.color.z = val.b / 255);
        }
    }, {
        key: "useColorTemperature",
        get: function get() {
            return this._useColorTemperature;
        },
        set: function set(enable) {
            this._useColorTemperature = enable, this._light && (this._light.useColorTemperature = enable);
        }
    }, {
        key: "colorTemperature",
        get: function get() {
            return this._colorTemperature;
        },
        set: function set(val) {
            this._colorTemperature = val, this._light && (this._light.colorTemperature = val);
        }
    }, {
        key: "staticSettings",
        get: function get() {
            return this._staticSettings;
        },
        set: function set(val) {
            this._staticSettings = val;
        }
    }, {
        key: "type",
        get: function get() {
            return this._type;
        }
    } ]), _createClass(LightComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._createLight();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._attachToScene();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._detachFromScene();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._destroyLight();
        }
    }, {
        key: "_createLight",
        value: function _createLight() {
            this._light || (this._light = cc.director.root.createLight(this._lightType)), this.color = this._color, 
            this.useColorTemperature = this._useColorTemperature, this.colorTemperature = this._colorTemperature, 
            this._light.node = this.node;
        }
    }, {
        key: "_destroyLight",
        value: function _destroyLight() {
            this._light && (cc.director.root.destroyLight(this), this._light = null);
        }
    }, {
        key: "_attachToScene",
        value: function _attachToScene() {
            if (this._detachFromScene(), this._light && !this._light.scene && this.node.scene) switch (this._type) {
              case LightType.DIRECTIONAL:
                this._getRenderScene().addDirectionalLight(this._light), this._getRenderScene().setMainLight(this._light);
                break;

              case LightType.SPHERE:
                this._getRenderScene().addSphereLight(this._light);
                break;

              case LightType.SPOT:
                this._getRenderScene().addSpotLight(this._light);
            }
        }
    }, {
        key: "_detachFromScene",
        value: function _detachFromScene() {
            if (this._light && this._light.scene) switch (this._type) {
              case LightType.DIRECTIONAL:
                var scene = this._light.scene;
                scene.removeDirectionalLight(this._light), scene.unsetMainLight(this._light);
                break;

              case LightType.SPHERE:
                this._light.scene.removeSphereLight(this._light);
                break;

              case LightType.SPOT:
                this._light.scene.removeSpotLight(this._light);
            }
        }
    } ]), LightComponent;
}(), _class6$1.Type = LightType, _class6$1.PhotometricTerm = PhotometricTerm, _descriptor4$j = _applyDecoratedDescriptor((_class5$7 = _temp2$7).prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor5$f = _applyDecoratedDescriptor(_class5$7.prototype, "_useColorTemperature", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor6$8 = _applyDecoratedDescriptor(_class5$7.prototype, "_colorTemperature", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 6550;
    }
}), _descriptor7$8 = _applyDecoratedDescriptor(_class5$7.prototype, "_staticSettings", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new StaticLightSettings;
    }
}), _applyDecoratedDescriptor(_class5$7.prototype, "color", [ _dec3$l ], Object.getOwnPropertyDescriptor(_class5$7.prototype, "color"), _class5$7.prototype), 
_applyDecoratedDescriptor(_class5$7.prototype, "useColorTemperature", [ _dec4$h ], Object.getOwnPropertyDescriptor(_class5$7.prototype, "useColorTemperature"), _class5$7.prototype), 
_applyDecoratedDescriptor(_class5$7.prototype, "colorTemperature", [ _dec5$g ], Object.getOwnPropertyDescriptor(_class5$7.prototype, "colorTemperature"), _class5$7.prototype), 
_applyDecoratedDescriptor(_class5$7.prototype, "staticSettings", [ _dec6$e ], Object.getOwnPropertyDescriptor(_class5$7.prototype, "staticSettings"), _class5$7.prototype), 
_class4$7 = _class5$7)) || _class4$7);

var _dec$X, _dec2$z, _dec3$n, _dec4$j, _dec5$h, _dec6$f, _dec7$b, _dec8$9, _class$X, _class2$P, _descriptor$I, _descriptor2$x, _descriptor3$q, _descriptor4$k, _dec$Y, _dec2$A, _dec3$o, _dec4$k, _dec5$i, _dec6$g, _dec7$c, _dec8$a, _dec9$7, _class$Y, _class2$Q, _descriptor$J, _descriptor2$y, _descriptor3$r, _descriptor4$l, _descriptor5$g, _dec$Z, _dec2$B, _dec3$p, _dec4$l, _dec5$j, _dec6$h, _dec7$d, _dec8$b, _dec9$8, _class$Z, _class2$R, _descriptor$K, _descriptor2$z, _descriptor3$s, _descriptor4$m, _descriptor5$h, DirectionalLightComponent = (_dec$W = ccclass("cc.DirectionalLightComponent"), 
_dec2$y = help("i18n:cc.DirectionalLightComponent"), _dec3$m = menu("Light/DirectionalLight"), 
_dec4$i = property({
    unit: "lx",
    tooltip: "i18n:lights.illuminance"
}), _dec$W(_class$W = _dec2$y(_class$W = _dec3$m(_class$W = executeInEditMode((_descriptor$H = _applyDecoratedDescriptor((_class2$O = function(_LightComponent) {
    function DirectionalLightComponent() {
        var _this;
        return _classCallCheck(this, DirectionalLightComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLightComponent).call(this)), "_illuminance", _descriptor$H, _assertThisInitialized(_this)), 
        _this._type = LightType.DIRECTIONAL, _this._light = null, _this._lightType = DirectionalLight, 
        _this;
    }
    return _inherits(DirectionalLightComponent, exports.LightComponent), _createClass(DirectionalLightComponent, [ {
        key: "illuminance",
        get: function get() {
            return this._illuminance;
        },
        set: function set(val) {
            this._illuminance = val, this._light && (this._light.illuminance = this._illuminance);
        }
    } ]), _createClass(DirectionalLightComponent, [ {
        key: "_createLight",
        value: function _createLight() {
            _get(_getPrototypeOf(DirectionalLightComponent.prototype), "_createLight", this).call(this), 
            this._light && (this.illuminance = this._illuminance);
        }
    } ]), DirectionalLightComponent;
}()).prototype, "_illuminance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 65e3;
    }
}), _applyDecoratedDescriptor(_class2$O.prototype, "illuminance", [ _dec4$i ], Object.getOwnPropertyDescriptor(_class2$O.prototype, "illuminance"), _class2$O.prototype), 
_class$W = _class2$O)) || _class$W) || _class$W) || _class$W) || _class$W), SphereLightComponent = (_dec$X = ccclass("cc.SphereLightComponent"), 
_dec2$z = help("i18n:cc.SphereLightComponent"), _dec3$n = menu("Light/SphereLight"), 
_dec4$j = property({
    unit: "lm",
    tooltip: "i18n:lights.luminous_power"
}), _dec5$h = property({
    unit: "cd/m²",
    tooltip: "i18n:lights.luminance"
}), _dec6$f = property({
    type: PhotometricTerm,
    tooltip: "i18n:lights.term"
}), _dec7$b = property({
    tooltip: "i18n:lights.size"
}), _dec8$9 = property({
    tooltip: "i18n:lights.range"
}), _dec$X(_class$X = _dec2$z(_class$X = _dec3$n(_class$X = executeInEditMode((_descriptor$I = _applyDecoratedDescriptor((_class2$P = function(_LightComponent) {
    function SphereLightComponent() {
        var _this;
        return _classCallCheck(this, SphereLightComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereLightComponent).call(this)), "_size", _descriptor$I, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_luminance", _descriptor2$x, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_term", _descriptor3$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_range", _descriptor4$k, _assertThisInitialized(_this)), 
        _this._type = LightType.SPHERE, _this._light = null, _this._lightType = SphereLight, 
        _this;
    }
    return _inherits(SphereLightComponent, exports.LightComponent), _createClass(SphereLightComponent, [ {
        key: "luminousPower",
        get: function get() {
            return this._luminance * nt2lm(this._size);
        },
        set: function set(val) {
            this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
        }
    }, {
        key: "luminance",
        get: function get() {
            return this._luminance;
        },
        set: function set(val) {
            this._luminance = val, this._light && (this._light.luminance = val);
        }
    }, {
        key: "term",
        get: function get() {
            return this._term;
        },
        set: function set(val) {
            this._term = val;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        },
        set: function set(val) {
            this._size = val, this._light && (this._light.size = val);
        }
    }, {
        key: "range",
        get: function get() {
            return this._range;
        },
        set: function set(val) {
            this._range = val, this._light && (this._light.range = val);
        }
    } ]), _createClass(SphereLightComponent, [ {
        key: "_createLight",
        value: function _createLight() {
            _get(_getPrototypeOf(SphereLightComponent.prototype), "_createLight", this).call(this), 
            this._light && (this.luminance = this._luminance, this.size = this._size, this.range = this._range);
        }
    } ]), SphereLightComponent;
}()).prototype, "_size", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .15;
    }
}), _descriptor2$x = _applyDecoratedDescriptor(_class2$P.prototype, "_luminance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1700 / nt2lm(.15);
    }
}), _descriptor3$q = _applyDecoratedDescriptor(_class2$P.prototype, "_term", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return PhotometricTerm.LUMINOUS_POWER;
    }
}), _descriptor4$k = _applyDecoratedDescriptor(_class2$P.prototype, "_range", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _applyDecoratedDescriptor(_class2$P.prototype, "luminousPower", [ _dec4$j ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "luminousPower"), _class2$P.prototype), 
_applyDecoratedDescriptor(_class2$P.prototype, "luminance", [ _dec5$h ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "luminance"), _class2$P.prototype), 
_applyDecoratedDescriptor(_class2$P.prototype, "term", [ _dec6$f ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "term"), _class2$P.prototype), 
_applyDecoratedDescriptor(_class2$P.prototype, "size", [ _dec7$b ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "size"), _class2$P.prototype), 
_applyDecoratedDescriptor(_class2$P.prototype, "range", [ _dec8$9 ], Object.getOwnPropertyDescriptor(_class2$P.prototype, "range"), _class2$P.prototype), 
_class$X = _class2$P)) || _class$X) || _class$X) || _class$X) || _class$X), SpotLightComponent = (_dec$Y = ccclass("cc.SpotLightComponent"), 
_dec2$A = help("i18n:cc.SpotLightComponent"), _dec3$o = menu("Light/SpotLight"), 
_dec4$k = property({
    unit: "lm",
    tooltip: "i18n:lights.luminous_power"
}), _dec5$i = property({
    unit: "cd/m²",
    tooltip: "i18n:lights.luminance"
}), _dec6$g = property({
    type: PhotometricTerm,
    tooltip: "i18n:lights.term"
}), _dec7$c = property({
    tooltip: "i18n:lights.size"
}), _dec8$a = property({
    tooltip: "i18n:lights.range"
}), _dec9$7 = property({
    slide: !0,
    range: [ 2, 180, 1 ],
    tooltip: "The spot light cone angle"
}), _dec$Y(_class$Y = _dec2$A(_class$Y = _dec3$o(_class$Y = executeInEditMode((_descriptor$J = _applyDecoratedDescriptor((_class2$Q = function(_LightComponent) {
    function SpotLightComponent() {
        var _this;
        return _classCallCheck(this, SpotLightComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLightComponent).call(this)), "_size", _descriptor$J, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_luminance", _descriptor2$y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_term", _descriptor3$r, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_range", _descriptor4$l, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_spotAngle", _descriptor5$g, _assertThisInitialized(_this)), 
        _this._type = LightType.SPOT, _this._light = null, _this._lightType = SpotLight, 
        _this;
    }
    return _inherits(SpotLightComponent, exports.LightComponent), _createClass(SpotLightComponent, [ {
        key: "luminousPower",
        get: function get() {
            return this._luminance * nt2lm(this._size);
        },
        set: function set(val) {
            this._luminance = val / nt2lm(this._size), this._light && (this._light.luminance = this._luminance);
        }
    }, {
        key: "luminance",
        get: function get() {
            return this._luminance;
        },
        set: function set(val) {
            this._luminance = val, this._light && (this._light.luminance = val);
        }
    }, {
        key: "term",
        get: function get() {
            return this._term;
        },
        set: function set(val) {
            this._term = val;
        }
    }, {
        key: "size",
        get: function get() {
            return this._size;
        },
        set: function set(val) {
            this._size = val, this._light && (this._light.size = val);
        }
    }, {
        key: "range",
        get: function get() {
            return this._range;
        },
        set: function set(val) {
            this._range = val, this._light && (this._light.range = val);
        }
    }, {
        key: "spotAngle",
        get: function get() {
            return this._spotAngle;
        },
        set: function set(val) {
            this._spotAngle = val, this._light && (this._light.spotAngle = toRadian(val));
        }
    } ]), _createClass(SpotLightComponent, [ {
        key: "_createLight",
        value: function _createLight() {
            _get(_getPrototypeOf(SpotLightComponent.prototype), "_createLight", this).call(this), 
            this._light && (this.luminance = this._luminance, this.size = this._size, this.range = this._range, 
            this.spotAngle = this._spotAngle);
        }
    } ]), SpotLightComponent;
}()).prototype, "_size", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .15;
    }
}), _descriptor2$y = _applyDecoratedDescriptor(_class2$Q.prototype, "_luminance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1700 / nt2lm(.15);
    }
}), _descriptor3$r = _applyDecoratedDescriptor(_class2$Q.prototype, "_term", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return PhotometricTerm.LUMINOUS_POWER;
    }
}), _descriptor4$l = _applyDecoratedDescriptor(_class2$Q.prototype, "_range", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor5$g = _applyDecoratedDescriptor(_class2$Q.prototype, "_spotAngle", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 60;
    }
}), _applyDecoratedDescriptor(_class2$Q.prototype, "luminousPower", [ _dec4$k ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "luminousPower"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "luminance", [ _dec5$i ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "luminance"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "term", [ _dec6$g ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "term"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "size", [ _dec7$c ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "size"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "range", [ _dec8$a ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "range"), _class2$Q.prototype), 
_applyDecoratedDescriptor(_class2$Q.prototype, "spotAngle", [ _dec9$7 ], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "spotAngle"), _class2$Q.prototype), 
_class$Y = _class2$Q)) || _class$Y) || _class$Y) || _class$Y) || _class$Y);

exports.removeProperty(exports.ModelComponent.prototype, "ModelComponent.prototype", [ {
    name: "enableDynamicBatching"
}, {
    name: "recieveShadows"
} ]), exports.replaceProperty(exports.CameraComponent, "CameraComponent", [ {
    name: "CameraClearFlag",
    newName: "ClearFlag"
} ]), cc.CameraComponent = exports.CameraComponent, cc.RenderableComponent = RenderableComponent, 
cc.ModelComponent = exports.ModelComponent, cc.SkinningModelComponent = SkinningModelComponent, 
cc.BatchedSkinningModelComponent = BatchedSkinningModelComponent, cc.SkinningModelUnit = SkinningModelUnit, 
cc.LightComponent = exports.LightComponent, cc.DirectionalLightComponent = DirectionalLightComponent, 
cc.SphereLightComponent = SphereLightComponent, cc.SpotLightComponent = SpotLightComponent, 
cc.utils = utils;

var _class$_, _class2$S, _descriptor$L, _descriptor2$A, _descriptor3$t, _class$$, _class2$T, _descriptor$M, _class4$8, UICoordinateTrackerComponent = (_dec$Z = ccclass("cc.UICoordinateTrackerComponent"), 
_dec2$B = help("i18n:cc.UICoordinateTrackerComponent"), _dec3$p = menu("Components/UICoordinateTracker"), 
_dec4$l = executionOrder(110), _dec5$j = property({
    type: Node$1,
    tooltip: "目标对象"
}), _dec6$h = property({
    type: exports.CameraComponent,
    tooltip: "照射相机"
}), _dec7$d = property({
    tooltip: "是否是缩放映射"
}), _dec8$b = property({
    tooltip: "距相机多少距离为正常显示计算大小"
}), _dec9$8 = property({
    type: [ EventHandler ],
    tooltip: "映射数据事件。回调的第一个参数是映射后的本地坐标，第二个是距相机距离比"
}), _dec$Z(_class$Z = _dec2$B(_class$Z = _dec3$p(_class$Z = _dec4$l((_applyDecoratedDescriptor((_class2$R = function(_Component) {
    function UICoordinateTrackerComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UICoordinateTrackerComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UICoordinateTrackerComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "syncEvents", _descriptor$K, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_target", _descriptor2$z, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_camera", _descriptor3$s, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_useScale", _descriptor4$m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_distance", _descriptor5$h, _assertThisInitialized(_this)), 
        _this._transformPos = new Vec3, _this._viewPos = new Vec3, _this._canMove = !0, 
        _this._lastWpos = new Vec3, _this._lastCameraPos = new Vec3, _this;
    }
    return _inherits(UICoordinateTrackerComponent, Component), _createClass(UICoordinateTrackerComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this._checkCanMove();
        }
    }, {
        key: "update",
        value: function update() {
            var wpos = this.node.worldPosition, camera = this._camera;
            if (this._canMove && camera._camera && (!this._lastWpos.equals(wpos) || !this._lastCameraPos.equals(camera.node.worldPosition)) && (this._lastWpos.set(wpos), 
            this._lastCameraPos.set(camera.node.worldPosition), camera._camera.update(), convertUtils.WorldNode3DToLocalNodeUI(camera, wpos, this._target, this._transformPos), 
            this._useScale && Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera._camera.matView), 
            this.syncEvents.length > 0)) {
                var data = this._distance / Math.abs(this._viewPos.z);
                EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
            }
        }
    }, {
        key: "_checkCanMove",
        value: function _checkCanMove() {
            this._canMove = !(!this._camera || !this._target);
        }
    }, {
        key: "target",
        get: function get() {
            return this._target;
        },
        set: function set(value) {
            this._target !== value && (this._target = value, this._checkCanMove());
        }
    }, {
        key: "camera",
        get: function get() {
            return this._camera;
        },
        set: function set(value) {
            this._camera !== value && (this._camera = value, this._checkCanMove());
        }
    }, {
        key: "useScale",
        get: function get() {
            return this._useScale;
        },
        set: function set(value) {
            this._useScale !== value && (this._useScale = value);
        }
    }, {
        key: "distance",
        get: function get() {
            return this._distance;
        },
        set: function set(value) {
            this._distance !== value && (this._distance = value);
        }
    } ]), UICoordinateTrackerComponent;
}()).prototype, "target", [ _dec5$j ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "target"), _class2$R.prototype), 
_applyDecoratedDescriptor(_class2$R.prototype, "camera", [ _dec6$h ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "camera"), _class2$R.prototype), 
_applyDecoratedDescriptor(_class2$R.prototype, "useScale", [ _dec7$d ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "useScale"), _class2$R.prototype), 
_applyDecoratedDescriptor(_class2$R.prototype, "distance", [ _dec8$b ], Object.getOwnPropertyDescriptor(_class2$R.prototype, "distance"), _class2$R.prototype), 
_descriptor$K = _applyDecoratedDescriptor(_class2$R.prototype, "syncEvents", [ _dec9$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$z = _applyDecoratedDescriptor(_class2$R.prototype, "_target", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$s = _applyDecoratedDescriptor(_class2$R.prototype, "_camera", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor4$m = _applyDecoratedDescriptor(_class2$R.prototype, "_useScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor5$h = _applyDecoratedDescriptor(_class2$R.prototype, "_distance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _class$Z = _class2$R)) || _class$Z) || _class$Z) || _class$Z) || _class$Z), UniformProxyFactory = ccclass("cc.animation.UniformProxyFactory")((_descriptor$L = _applyDecoratedDescriptor((_class2$S = function() {
    function UniformProxyFactory(uniformName, passIndex) {
        _classCallCheck(this, UniformProxyFactory), _initializerDefineProperty(this, "passIndex", _descriptor$L, this), 
        _initializerDefineProperty(this, "uniformName", _descriptor2$A, this), _initializerDefineProperty(this, "channelIndex", _descriptor3$t, this), 
        this.passIndex = passIndex || 0, this.uniformName = uniformName || "";
    }
    return _createClass(UniformProxyFactory, [ {
        key: "forTarget",
        value: function forTarget(target) {
            var pass = target.passes[this.passIndex], handle = pass.getHandle(this.uniformName);
            if (void 0 === handle) throw new Error('Material "'.concat(target.name, '" has no uniform "').concat(this.uniformName, '"'));
            var bindingType = Pass.getBindingTypeFromHandle(handle);
            if (bindingType === exports.GFXBindingType.UNIFORM_BUFFER) {
                var realHandle = void 0 === this.channelIndex ? handle : pass.getHandle(this.uniformName, this.channelIndex, exports.GFXType.FLOAT);
                if (void 0 === realHandle) throw new Error('Uniform "'.concat(this.uniformName, " (in material ").concat(target.name, ") has no channel ").concat(this.channelIndex, '"'));
                return function isUniformArray(pass, name) {
                    for (var _step, _iterator = _createForOfIteratorHelperLoose(pass.shaderInfo.blocks); !(_step = _iterator()).done; ) for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(_step.value.members); !(_step2 = _iterator2()).done; ) {
                        var uniform = _step2.value;
                        if (uniform.name === name) return uniform.count > 1;
                    }
                    return !1;
                }(pass, this.uniformName) ? {
                    set: function set(value) {
                        pass.setUniformArray(realHandle, value);
                    }
                } : {
                    set: function set(value) {
                        pass.setUniform(realHandle, value);
                    }
                };
            }
            if (bindingType === exports.GFXBindingType.SAMPLER) {
                var binding = Pass.getBindingFromHandle(handle), prop = pass.properties[this.uniformName], texName = prop && prop.value ? prop.value + "-texture" : getDefaultFromType(prop.type), dftTex = builtinResMgr.get(texName);
                return dftTex || (warn("Illegal texture default value: ".concat(texName, ".")), 
                dftTex = builtinResMgr.get("default-texture")), {
                    set: function set(value) {
                        value || (value = dftTex);
                        var tv = value.getGFXTextureView();
                        tv && tv.texture.width && tv.texture.height && (pass.bindTextureView(binding, tv), 
                        value instanceof TextureBase && pass.bindSampler(binding, samplerLib.getSampler(cc.game._gfxDevice, value.getSamplerHash())));
                    }
                };
            }
            throw new Error("Animations are not available for uniforms with binding type ".concat(bindingType, "."));
        }
    } ]), UniformProxyFactory;
}()).prototype, "passIndex", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$A = _applyDecoratedDescriptor(_class2$S.prototype, "uniformName", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor3$t = _applyDecoratedDescriptor(_class2$S.prototype, "channelIndex", [ _float ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {}
}), _class$_ = _class2$S)) || _class$_;

var _class4$9, _class5$8, _descriptor4$n, _descriptor5$i, _descriptor6$9, MorphWeightsValueProxy = ccclass("cc.animation.MorphWeightsValueProxy")((_descriptor$M = _applyDecoratedDescriptor((_class2$T = function() {
    function MorphWeightsValueProxy() {
        _classCallCheck(this, MorphWeightsValueProxy), _initializerDefineProperty(this, "subMeshIndex", _descriptor$M, this);
    }
    return _createClass(MorphWeightsValueProxy, [ {
        key: "forTarget",
        value: function forTarget(target) {
            var _this = this;
            return {
                set: function set(value) {
                    target.setWeights(value, _this.subMeshIndex);
                }
            };
        }
    } ]), MorphWeightsValueProxy;
}()).prototype, "subMeshIndex", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$$ = _class2$T)) || _class$$, MorphWeightsAllValueProxy = ccclass("cc.animation.MorphWeightsAllValueProxy")(_class4$8 = function() {
    function MorphWeightsAllValueProxy() {
        _classCallCheck(this, MorphWeightsAllValueProxy);
    }
    return _createClass(MorphWeightsAllValueProxy, [ {
        key: "forTarget",
        value: function forTarget(target) {
            return {
                set: function set(value) {
                    for (var _target$mesh$struct$p, _target$mesh, nSubMeshes = null !== (_target$mesh$struct$p = null === (_target$mesh = target.mesh) || void 0 === _target$mesh ? void 0 : _target$mesh.struct.primitives.length) && void 0 !== _target$mesh$struct$p ? _target$mesh$struct$p : 0, iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) target.setWeights(value, iSubMesh);
                }
            };
        }
    } ]), MorphWeightsAllValueProxy;
}()) || _class4$8;

function makeCubicSplineValueConstructor(name, constructorX, scaleFx, scaleAndAdd) {
    var _class, _class2, _descriptor, _descriptor2, _descriptor3, tempValue = new constructorX, m0 = new constructorX, m1 = new constructorX, CubicSplineValueClass = ccclass(name)((_descriptor = _applyDecoratedDescriptor((_class2 = function() {
        function CubicSplineValueClass(dataPoint, inTangent, outTangent) {
            _classCallCheck(this, CubicSplineValueClass), _initializerDefineProperty(this, "dataPoint", _descriptor, this), 
            _initializerDefineProperty(this, "inTangent", _descriptor2, this), _initializerDefineProperty(this, "outTangent", _descriptor3, this), 
            this.dataPoint = dataPoint || new constructorX, this.inTangent = inTangent || new constructorX, 
            this.outTangent = outTangent || new constructorX;
        }
        return _createClass(CubicSplineValueClass, [ {
            key: "lerp",
            value: function lerp(to, t, dt) {
                var p0 = this.dataPoint, p1 = to.dataPoint;
                m0 = scaleFx(m0, this.inTangent, dt), m1 = scaleFx(m1, to.outTangent, dt);
                var t_3 = t * t * t, t_2 = t * t, f_1 = t_3 - 2 * t_2 + t, f_2 = -2 * t_3 + 3 * t_2, f_3 = t_3 - t_2;
                return tempValue = scaleFx(tempValue, p0, 2 * t_3 - 3 * t_2 + 1), tempValue = scaleAndAdd(tempValue, tempValue, m0, f_1), 
                tempValue = scaleAndAdd(tempValue, tempValue, p1, f_2), tempValue = scaleAndAdd(tempValue, tempValue, m1, f_3);
            }
        }, {
            key: "getNoLerp",
            value: function getNoLerp() {
                return this.dataPoint;
            }
        } ]), CubicSplineValueClass;
    }()).prototype, "dataPoint", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new constructorX;
        }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "inTangent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new constructorX;
        }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "outTangent", [ property ], {
        configurable: !0,
        enumerable: !0,
        writable: !0,
        initializer: function initializer() {
            return new constructorX;
        }
    }), _class = _class2)) || _class;
    if (constructorX === Quat) {
        var _lerp = CubicSplineValueClass.prototype.lerp;
        CubicSplineValueClass.prototype.lerp = function(to, t, dt) {
            var result = _lerp.call(this, to, t, dt);
            return Quat.normalize(result, result), result;
        };
    }
    return CubicSplineValueClass;
}

var CubicSplineVec2Value = makeCubicSplineValueConstructor("cc.CubicSplineVec2Value", Vec2, Vec2.multiplyScalar, Vec2.scaleAndAdd);

cc.CubicSplineVec2Value = CubicSplineVec2Value;

var CubicSplineVec3Value = makeCubicSplineValueConstructor("cc.CubicSplineVec3Value", Vec3, Vec3.multiplyScalar, Vec3.scaleAndAdd);

cc.CubicSplineVec3Value = CubicSplineVec3Value;

var CubicSplineVec4Value = makeCubicSplineValueConstructor("cc.CubicSplineVec4Value", Vec4, Vec4.multiplyScalar, Vec4.scaleAndAdd);

cc.CubicSplineVec4Value = CubicSplineVec4Value;

var CubicSplineQuatValue = makeCubicSplineValueConstructor("cc.CubicSplineQuatValue", Quat, Quat.multiplyScalar, Quat.scaleAndAdd);

cc.CubicSplineQuatValue = CubicSplineQuatValue;

var CubicSplineNumberValue = ccclass("cc.CubicSplineNumberValue")((_descriptor4$n = _applyDecoratedDescriptor((_class5$8 = function() {
    function CubicSplineNumberValue(dataPoint, inTangent, outTangent) {
        _classCallCheck(this, CubicSplineNumberValue), _initializerDefineProperty(this, "dataPoint", _descriptor4$n, this), 
        _initializerDefineProperty(this, "inTangent", _descriptor5$i, this), _initializerDefineProperty(this, "outTangent", _descriptor6$9, this), 
        this.dataPoint = dataPoint, this.inTangent = inTangent, this.outTangent = outTangent;
    }
    return _createClass(CubicSplineNumberValue, [ {
        key: "lerp",
        value: function lerp(to, t, dt) {
            var p0 = this.dataPoint, p1 = to.dataPoint, t_3 = t * t * t, t_2 = t * t;
            return p0 * (2 * t_3 - 3 * t_2 + 1) + this.outTangent * dt * (t_3 - 2 * t_2 + t) + p1 * (-2 * t_3 + 3 * t_2) + to.inTangent * dt * (t_3 - t_2);
        }
    }, {
        key: "getNoLerp",
        value: function getNoLerp() {
            return this.dataPoint;
        }
    } ]), CubicSplineNumberValue;
}()).prototype, "dataPoint", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor5$i = _applyDecoratedDescriptor(_class5$8.prototype, "inTangent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$9 = _applyDecoratedDescriptor(_class5$8.prototype, "outTangent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class4$9 = _class5$8)) || _class4$9;

cc.CubicSplineNumberValue = CubicSplineNumberValue;

var animation = Object.freeze({
    __proto__: null,
    UniformProxyFactory: UniformProxyFactory,
    MorphWeightsValueProxy: MorphWeightsValueProxy,
    MorphWeightsAllValueProxy: MorphWeightsAllValueProxy,
    isPropertyPath: isPropertyPath,
    isCustomPath: isCustomPath,
    HierarchyPath: HierarchyPath,
    ComponentPath: ComponentPath,
    evaluatePath: evaluatePath,
    CubicSplineVec2Value: CubicSplineVec2Value,
    CubicSplineVec3Value: CubicSplineVec3Value,
    CubicSplineVec4Value: CubicSplineVec4Value,
    CubicSplineQuatValue: CubicSplineQuatValue,
    CubicSplineNumberValue: CubicSplineNumberValue
});

function binarySearchEpsilon$1(array, value) {
    for (var low = 0, high = array.length - 1, middle = high >>> 1; low <= high; middle = low + high >>> 1) {
        var middleValue = array[middle];
        if (middleValue > value + 1e-6) high = middle - 1; else {
            if (!(middleValue < value - 1e-6)) return middle;
            low = middle + 1;
        }
    }
    return ~low;
}

function bezier(C1, C2, C3, C4, t) {
    var t1 = 1 - t;
    return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
}

cc.bezier = bezier;

var cos = Math.cos, acos = Math.acos, max$2 = Math.max, tau = 2 * Math.PI, sqrt = Math.sqrt;

function crt(v) {
    return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
}

function bezierByTime(controlPoints, x) {
    var percent = function cardano(curve, x) {
        var u1, x1, x2, x3, pa = x - 0, pb = x - curve[0], pa3 = 3 * pa, pb3 = 3 * pb, pc3 = 3 * (x - curve[2]), rd = 1 / (-pa + pb3 - pc3 + (x - 1)), a = (pa3 - 6 * pb + pc3) * rd, a3 = a * (1 / 3), b = (-pa3 + pb3) * rd, p = 1 / 3 * (3 * b - a * a), p3 = p * (1 / 3), q = (2 * a * a * a - 9 * a * b + 27 * (pa * rd)) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3;
        if (discriminant < 0) {
            var mp3 = 1 / 3 * -p, r = sqrt(mp3 * mp3 * mp3), t = -q / (2 * r), phi = acos(t < -1 ? -1 : t > 1 ? 1 : t), t1 = 2 * crt(r);
            return x1 = t1 * cos(phi * (1 / 3)) - a3, x2 = t1 * cos((phi + tau) * (1 / 3)) - a3, 
            x3 = t1 * cos((phi + 2 * tau) * (1 / 3)) - a3, 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$2(x1, x2, x3) : max$2(x1, x2) : 0 <= x3 && x3 <= 1 ? max$2(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max$2(x2, x3) : x2 : x3;
        }
        if (0 === discriminant) return x2 = -(u1 = q2 < 0 ? crt(-q2) : -crt(q2)) - a3, 0 <= (x1 = 2 * u1 - a3) && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max$2(x1, x2) : x1 : x2;
        var sd = sqrt(discriminant);
        return x1 = (u1 = crt(-q2 + sd)) - crt(q2 + sd) - a3;
    }(controlPoints, x), t1 = 1 - percent;
    return 0 * t1 * t1 * t1 + 3 * controlPoints[1] * percent * t1 * t1 + 3 * controlPoints[3] * percent * percent * t1 + 1 * percent * percent * percent;
}

function quadIn(k) {
    return k * k;
}

function quadOut(k) {
    return k * (2 - k);
}

function cubicIn(k) {
    return k * k * k;
}

function cubicOut(k) {
    return --k * k * k + 1;
}

function quartIn(k) {
    return k * k * k * k;
}

function quartOut(k) {
    return 1 - --k * k * k * k;
}

function quintIn(k) {
    return k * k * k * k * k;
}

function quintOut(k) {
    return --k * k * k * k * k + 1;
}

function sineIn(k) {
    return 1 - Math.cos(k * Math.PI / 2);
}

function sineOut(k) {
    return Math.sin(k * Math.PI / 2);
}

function expoIn(k) {
    return 0 === k ? 0 : Math.pow(1024, k - 1);
}

function expoOut(k) {
    return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
}

function circIn(k) {
    return 1 - Math.sqrt(1 - k * k);
}

function circOut(k) {
    return Math.sqrt(1 - --k * k);
}

function elasticIn(k) {
    var s, a = .1;
    return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
    -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / .4));
}

function elasticOut(k) {
    var s, a = .1;
    return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = .4 * Math.asin(1 / a) / (2 * Math.PI), 
    a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / .4) + 1);
}

function backIn(k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
}

function backOut(k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
}

function bounceIn(k) {
    return 1 - bounceOut(1 - k);
}

function bounceOut(k) {
    return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
}

cc.bezierByTime = bezierByTime;

var quadOutIn = _makeOutIn(quadIn, quadOut), cubicOutIn = _makeOutIn(cubicIn, cubicOut), quartOutIn = _makeOutIn(quartIn, quartOut), quintOutIn = _makeOutIn(quintIn, quintOut), sineOutIn = _makeOutIn(sineIn, sineOut), expoOutIn = _makeOutIn(expoIn, expoOut), circOutIn = _makeOutIn(circIn, circOut), elasticOutIn = _makeOutIn(elasticIn, elasticOut), backOutIn = _makeOutIn(backIn, backOut), bounceOutIn = _makeOutIn(bounceIn, bounceOut);

function _makeOutIn(fnIn, fnOut) {
    return function(k) {
        return k < .5 ? fnOut(2 * k) / 2 : fnIn(2 * k - 1) / 2 + .5;
    };
}

var WrapModeMask, WrapMode$2, easing = Object.freeze({
    __proto__: null,
    constant: function constant() {
        return 0;
    },
    linear: function linear(k) {
        return k;
    },
    quadIn: quadIn,
    quadOut: quadOut,
    quadInOut: function quadInOut(k) {
        return (k *= 2) < 1 ? .5 * k * k : -.5 * (--k * (k - 2) - 1);
    },
    cubicIn: cubicIn,
    cubicOut: cubicOut,
    cubicInOut: function cubicInOut(k) {
        return (k *= 2) < 1 ? .5 * k * k * k : .5 * ((k -= 2) * k * k + 2);
    },
    quartIn: quartIn,
    quartOut: quartOut,
    quartInOut: function quartInOut(k) {
        return (k *= 2) < 1 ? .5 * k * k * k * k : -.5 * ((k -= 2) * k * k * k - 2);
    },
    quintIn: quintIn,
    quintOut: quintOut,
    quintInOut: function quintInOut(k) {
        return (k *= 2) < 1 ? .5 * k * k * k * k * k : .5 * ((k -= 2) * k * k * k * k + 2);
    },
    sineIn: sineIn,
    sineOut: sineOut,
    sineInOut: function sineInOut(k) {
        return .5 * (1 - Math.cos(Math.PI * k));
    },
    expoIn: expoIn,
    expoOut: expoOut,
    expoInOut: function expoInOut(k) {
        return 0 === k ? 0 : 1 === k ? 1 : (k *= 2) < 1 ? .5 * Math.pow(1024, k - 1) : .5 * (2 - Math.pow(2, -10 * (k - 1)));
    },
    circIn: circIn,
    circOut: circOut,
    circInOut: function circInOut(k) {
        return (k *= 2) < 1 ? -.5 * (Math.sqrt(1 - k * k) - 1) : .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    },
    elasticIn: elasticIn,
    elasticOut: elasticOut,
    elasticInOut: function elasticInOut(k) {
        var s, a = .1, p = .4;
        return 0 === k ? 0 : 1 === k ? 1 : (!a || a < 1 ? (a = 1, s = .1) : s = p * Math.asin(1 / a) / (2 * Math.PI), 
        (k *= 2) < 1 ? a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * -.5 : a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1);
    },
    backIn: backIn,
    backOut: backOut,
    backInOut: function backInOut(k) {
        var s = 2.5949095;
        return (k *= 2) < 1 ? k * k * ((s + 1) * k - s) * .5 : .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    },
    bounceIn: bounceIn,
    bounceOut: bounceOut,
    bounceInOut: function bounceInOut(k) {
        return k < .5 ? .5 * bounceIn(2 * k) : .5 * bounceOut(2 * k - 1) + .5;
    },
    smooth: function smooth(k) {
        return k <= 0 ? 0 : k >= 1 ? 1 : k * k * (3 - 2 * k);
    },
    fade: function fade(k) {
        return k <= 0 ? 0 : k >= 1 ? 1 : k * k * k * (k * (6 * k - 15) + 10);
    },
    quadOutIn: quadOutIn,
    cubicOutIn: cubicOutIn,
    quartOutIn: quartOutIn,
    quintOutIn: quintOutIn,
    sineOutIn: sineOutIn,
    expoOutIn: expoOutIn,
    circOutIn: circOutIn,
    elasticOutIn: elasticOutIn,
    backOutIn: backOutIn,
    bounceOutIn: bounceOutIn
});

!function(WrapModeMask) {
    WrapModeMask[WrapModeMask.Loop = 2] = "Loop", WrapModeMask[WrapModeMask.ShouldWrap = 4] = "ShouldWrap", 
    WrapModeMask[WrapModeMask.PingPong = 22] = "PingPong", WrapModeMask[WrapModeMask.Reverse = 36] = "Reverse";
}(WrapModeMask || (WrapModeMask = {})), function(WrapMode) {
    WrapMode[WrapMode.Default = 0] = "Default", WrapMode[WrapMode.Normal = 1] = "Normal", 
    WrapMode[WrapMode.Reverse = WrapModeMask.Reverse] = "Reverse", WrapMode[WrapMode.Loop = WrapModeMask.Loop] = "Loop", 
    WrapMode[WrapMode.LoopReverse = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse", 
    WrapMode[WrapMode.PingPong = WrapModeMask.PingPong] = "PingPong", WrapMode[WrapMode.PingPongReverse = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
}(WrapMode$2 || (WrapMode$2 = {})), ccenum(WrapMode$2);

var WrappedInfo = function() {
    function WrappedInfo(info) {
        _classCallCheck(this, WrappedInfo), this.ratio = 0, this.time = 0, this.direction = 1, 
        this.stopped = !0, this.iterations = 0, this.frameIndex = void 0, info && this.set(info);
    }
    return _createClass(WrappedInfo, [ {
        key: "set",
        value: function set(info) {
            this.ratio = info.ratio, this.time = info.time, this.direction = info.direction, 
            this.stopped = info.stopped, this.iterations = info.iterations, this.frameIndex = info.frameIndex;
        }
    } ]), WrappedInfo;
}();

var RatioSampler = function() {
    function RatioSampler(ratios) {
        var currRatioDif, lastRatioDif;
        _classCallCheck(this, RatioSampler), this.ratios = void 0, this._findRatio = void 0, 
        this.ratios = ratios;
        for (var canOptimize = !0, i = 1, l = ratios.length; i < l; i++) if (currRatioDif = ratios[i] - ratios[i - 1], 
        1 === i) lastRatioDif = currRatioDif; else if (Math.abs(currRatioDif - lastRatioDif) > 1e-6) {
            canOptimize = !1;
            break;
        }
        this._findRatio = canOptimize ? quickFindIndex : binarySearchEpsilon$1;
    }
    return _createClass(RatioSampler, [ {
        key: "sample",
        value: function sample(ratio) {
            return this._findRatio(this.ratios, ratio);
        }
    } ]), RatioSampler;
}();

cc.RatioSampler = RatioSampler;

var AnimCurve = function() {
    function AnimCurve(propertyCurveData, duration) {
        _classCallCheck(this, AnimCurve), this.types = void 0, this.type = null, this._values = [], 
        this._lerp = void 0, this._duration = void 0, this._array = void 0, this._duration = duration, 
        this._values = propertyCurveData.values;
        var getCurveType = function getCurveType(easingMethod) {
            return "string" == typeof easingMethod ? easingMethod : Array.isArray(easingMethod) ? easingMethod[0] === easingMethod[1] && easingMethod[2] === easingMethod[3] ? AnimCurve.Linear : AnimCurve.Bezier(easingMethod) : AnimCurve.Linear;
        };
        if (void 0 !== propertyCurveData.easingMethod) this.type = getCurveType(propertyCurveData.easingMethod); else if (Array.isArray(propertyCurveData.easingMethods)) this.types = propertyCurveData.easingMethods.map(getCurveType); else if (void 0 !== propertyCurveData.easingMethods) {
            this.types = new Array(this._values.length).fill(null);
            for (var _i = 0, _Object$keys = Object.keys(propertyCurveData.easingMethods); _i < _Object$keys.length; _i++) {
                var index = _Object$keys[_i];
                this.types[index] = getCurveType(propertyCurveData.easingMethods[index]);
            }
        } else this.type = null;
        var firstValue = propertyCurveData.values[0];
        (void 0 === propertyCurveData.interpolate || propertyCurveData.interpolate) && (this._lerp = selectLerpFx(firstValue)), 
        void 0 !== propertyCurveData._arrayLength && (this._array = new Array(propertyCurveData._arrayLength));
    }
    return _createClass(AnimCurve, null, [ {
        key: "Bezier",
        value: function Bezier(controlPoints) {
            return controlPoints;
        }
    } ]), _createClass(AnimCurve, [ {
        key: "hasLerp",
        value: function hasLerp() {
            return !!this._lerp;
        }
    }, {
        key: "valueAt",
        value: function valueAt(index) {
            if (void 0 === this._array) {
                var value = this._values[index];
                return value && value.getNoLerp ? value.getNoLerp() : value;
            }
            for (var i = 0; i < this._array.length; ++i) this._array[i] = this._values[this._array.length * index + i];
            return this._array;
        }
    }, {
        key: "valueBetween",
        value: function valueBetween(ratio, from, fromRatio, to, toRatio) {
            if (this._lerp) {
                var type = this.types ? this.types[from] : this.type, dRatio = toRatio - fromRatio, ratioBetweenFrames = (ratio - fromRatio) / dRatio;
                if (type && (ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type)), 
                void 0 === this._array) {
                    var fromVal = this._values[from], toVal = this._values[to];
                    return this._lerp(fromVal, toVal, ratioBetweenFrames, dRatio * this._duration);
                }
                for (var i = 0; i < this._array.length; ++i) {
                    var _fromVal = this._values[this._array.length * from + i], _toVal = this._values[this._array.length * to + i];
                    this._array[i] = this._lerp(_fromVal, _toVal, ratioBetweenFrames, dRatio * this._duration);
                }
                return this._array;
            }
            if (void 0 === this._array) return this.valueAt(from);
            for (var _i2 = 0; _i2 < this._array.length; ++_i2) this._array[_i2] = this._values[this._array.length * from + _i2];
            return this._array;
        }
    }, {
        key: "empty",
        value: function empty() {
            return 0 === this._values.length;
        }
    }, {
        key: "constant",
        value: function constant() {
            return 1 === this._values.length;
        }
    } ]), AnimCurve;
}();

AnimCurve.Linear = null, cc.AnimCurve = AnimCurve;

var EventInfo = function() {
    function EventInfo() {
        _classCallCheck(this, EventInfo), this.events = [];
    }
    return _createClass(EventInfo, [ {
        key: "add",
        value: function add(func, params) {
            this.events.push({
                func: func || "",
                params: params || []
            });
        }
    } ]), EventInfo;
}();

function sampleAnimationCurve(curve, sampler, ratio) {
    var index = sampler.sample(ratio);
    if (index < 0) if ((index = ~index) <= 0) index = 0; else {
        if (!(index >= sampler.ratios.length)) return curve.valueBetween(ratio, index - 1, sampler.ratios[index - 1], index, sampler.ratios[index]);
        index = sampler.ratios.length - 1;
    }
    return curve.valueAt(index);
}

function computeRatioByType(ratio, type) {
    if ("string" == typeof type) {
        var func = easing[type];
        func ? ratio = func(ratio) : errorID(3906, type);
    } else Array.isArray(type) && (ratio = bezierByTime(type, ratio));
    return ratio;
}

function quickFindIndex(ratios, ratio) {
    var length = ratios.length - 1;
    if (0 === length) return 0;
    var start = ratios[0];
    if (ratio < start) return 0;
    var end = ratios[length];
    if (ratio > end) return length;
    var index = (ratio = (ratio - start) / (end - start)) / (1 / length), floorIndex = 0 | index;
    return index - floorIndex < 1e-6 ? floorIndex : floorIndex + 1 - index < 1e-6 ? floorIndex + 1 : ~(floorIndex + 1);
}

cc.sampleAnimationCurve = sampleAnimationCurve;

var _dec$10, _dec2$E, _class$10, _class2$U, _descriptor$N, _descriptor2$B, _descriptor3$u, _descriptor4$o, _descriptor5$j, _descriptor6$a, _descriptor7$9, _descriptor8$7, _descriptor9$7, _descriptor10$6, _class3$h, _temp$X, selectLerpFx = function() {
    function callLerpable(from, to, t, dt) {
        return from.lerp(to, t, dt);
    }
    return function(value) {
        if (null !== value) {
            if ("number" == typeof value) return lerp;
            if ("object" === _typeof(value) && value.constructor) {
                if (value instanceof Quat) return function makeQuatSlerpFx() {
                    var tempValue = new Quat;
                    return function(from, to, t, dt) {
                        return Quat.slerp(tempValue, from, to, t);
                    };
                }();
                if (value instanceof ValueType) return function makeValueTypeLerpFx(constructor) {
                    var tempValue = new constructor;
                    return function(from, to, ratio) {
                        return constructor.lerp(tempValue, from, to, ratio), tempValue;
                    };
                }(value.constructor);
                if (value.constructor === Number) return lerp;
                if (function isLerpable(object) {
                    return "function" == typeof object.lerp;
                }(value)) return callLerpable;
            }
        }
    };
}();

function createBoundTarget(target, modifiers, valueAdapter) {
    var ap, lastPath = modifiers[modifiers.length - 1];
    if (0 !== modifiers.length && isPropertyPath(lastPath) && !valueAdapter) {
        var resultTarget = evaluatePath.apply(void 0, [ target ].concat(_toConsumableArray(modifiers.slice(0, modifiers.length - 1))));
        if (null === resultTarget) return null;
        ap = {
            isProxy: !1,
            object: resultTarget,
            property: lastPath
        };
    } else {
        if (!valueAdapter) return error("Empty animation curve."), null;
        var _resultTarget = evaluatePath.apply(void 0, [ target ].concat(_toConsumableArray(modifiers)));
        if (null === _resultTarget) return null;
        ap = {
            isProxy: !0,
            proxy: valueAdapter.forTarget(_resultTarget)
        };
    }
    return {
        setValue: function setValue(value) {
            ap.isProxy ? ap.proxy.set(value) : ap.object[ap.property] = value;
        },
        getValue: function getValue() {
            return ap.isProxy ? ap.proxy.get ? ap.proxy.get() : (error("Target doesn't provide a get method."), 
            null) : ap.object[ap.property];
        }
    };
}

function createBufferedTarget(target, modifiers, valueAdapter) {
    var boundTarget = createBoundTarget(target, modifiers, valueAdapter);
    if (null === boundTarget) return null;
    var value = boundTarget.getValue(), copyable = getBuiltinCopy(value);
    if (!copyable) return error("Value is not copyable!"), null;
    var buffer = copyable.createBuffer(), copy = copyable.copy;
    return Object.assign(boundTarget, {
        peek: function peek() {
            return buffer;
        },
        pull: function pull() {
            var value = boundTarget.getValue();
            copy(buffer, value);
        },
        push: function push() {
            boundTarget.setValue(buffer);
        }
    });
}

exports.AnimationClip = (_dec$10 = ccclass("cc.AnimationClip"), _dec2$E = property({
    visible: !1
}), _dec$10((_temp$X = _class3$h = function(_Asset) {
    function AnimationClip() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, AnimationClip);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationClip)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "sample", _descriptor$N, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "speed", _descriptor2$B, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "wrapMode", _descriptor3$u, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "events", _descriptor4$o, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_duration", _descriptor5$j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_keys", _descriptor6$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_stepness", _descriptor7$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_curves", _descriptor8$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_commonTargets", _descriptor9$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_hash", _descriptor10$6, _assertThisInitialized(_this)), 
        _this.frameRate = 0, _this._ratioSamplers = [], _this._runtimeCurves = void 0, _this._runtimeEvents = void 0, 
        _this._data = null, _this;
    }
    return _inherits(AnimationClip, Asset), _createClass(AnimationClip, [ {
        key: "onLoaded",
        value: function onLoaded() {
            this.frameRate = this.sample, this._decodeCVTAs();
        }
    }, {
        key: "getPropertyCurves",
        value: function getPropertyCurves() {
            return this._runtimeCurves || this._createPropertyCurves(), this._runtimeCurves;
        }
    }, {
        key: "updateEventDatas",
        value: function updateEventDatas() {
            delete this._runtimeEvents;
        }
    }, {
        key: "getEventGroupIndexAtRatio",
        value: function getEventGroupIndexAtRatio(ratio) {
            return this._runtimeEvents || this._createRuntimeEvents(), function binarySearchEpsilon(array, value) {
                for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                    var test = array[m];
                    if (test > value + 1e-6) h = m - 1; else {
                        if (!(test < value - 1e-6)) return m;
                        l = m + 1;
                    }
                }
                return ~l;
            }(this._runtimeEvents.ratios, ratio);
        }
    }, {
        key: "hasEvents",
        value: function hasEvents() {
            return 0 !== this.events.length;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            return cc.director.root.dataPoolManager.releaseAnimationClip(this), SkelAnimDataHub.destroy(this), 
            _get(_getPrototypeOf(AnimationClip.prototype), "destroy", this).call(this);
        }
    }, {
        key: "_createPropertyCurves",
        value: function _createPropertyCurves() {
            var _this2 = this;
            this._ratioSamplers = this._keys.map((function(keys) {
                return new RatioSampler(keys.map((function(key) {
                    return key / _this2._duration;
                })));
            })), this._runtimeCurves = this._curves.map((function(targetCurve) {
                return {
                    curve: new AnimCurve(targetCurve.data, _this2._duration),
                    modifiers: targetCurve.modifiers,
                    valueAdapter: targetCurve.valueAdapter,
                    sampler: _this2._ratioSamplers[targetCurve.data.keys],
                    commonTarget: targetCurve.commonTarget
                };
            })), this._applyStepness();
        }
    }, {
        key: "_createRuntimeEvents",
        value: function _createRuntimeEvents() {
            for (var _step, _this3 = this, ratios = [], eventGroups = [], _loop = function _loop() {
                var eventData = _step.value, ratio = eventData.frame / _this3._duration, i = ratios.findIndex((function(r) {
                    return r === ratio;
                }));
                i < 0 && (i = ratios.length, ratios.push(ratio), eventGroups.push({
                    events: []
                })), eventGroups[i].events.push({
                    functionName: eventData.func,
                    parameters: eventData.params
                });
            }, _iterator = _createForOfIteratorHelperLoose(this.events.sort((function(a, b) {
                return a.frame - b.frame;
            }))); !(_step = _iterator()).done; ) _loop();
            this._runtimeEvents = {
                ratios: ratios,
                eventGroups: eventGroups
            };
        }
    }, {
        key: "_applyStepness",
        value: function _applyStepness() {
            this._runtimeCurves;
        }
    }, {
        key: "_decodeCVTAs",
        value: function _decodeCVTAs() {
            var binaryBuffer = ArrayBuffer.isView(this._nativeAsset) ? this._nativeAsset.buffer : this._nativeAsset;
            if (binaryBuffer) {
                for (var maybeCompressedKeys = this._keys, iKey = 0; iKey < maybeCompressedKeys.length; ++iKey) {
                    var keys = maybeCompressedKeys[iKey];
                    keys instanceof CompactValueTypeArray && (maybeCompressedKeys[iKey] = keys.decompress(binaryBuffer));
                }
                for (var iCurve = 0; iCurve < this._curves.length; ++iCurve) {
                    var curve = this._curves[iCurve];
                    curve.data.values instanceof CompactValueTypeArray && (curve.data.values = curve.data.values.decompress(binaryBuffer));
                }
            }
        }
    }, {
        key: "duration",
        get: function get() {
            return this._duration;
        },
        set: function set(value) {
            this._duration = value;
        }
    }, {
        key: "keys",
        get: function get() {
            return this._keys;
        },
        set: function set(value) {
            this._keys = value;
        }
    }, {
        key: "eventGroups",
        get: function get() {
            return this._runtimeEvents || this._createRuntimeEvents(), this._runtimeEvents.eventGroups;
        }
    }, {
        key: "stepness",
        get: function get() {
            return this._stepness;
        },
        set: function set(value) {
            this._stepness = value, this._applyStepness();
        }
    }, {
        key: "hash",
        get: function get() {
            if (this._hash) return this._hash;
            var data = this._nativeAsset, buffer = new Uint8Array(ArrayBuffer.isView(data) ? data.buffer : data);
            return this._hash = murmurhash2_32_gc(buffer, 666);
        }
    }, {
        key: "curves",
        get: function get() {
            return this._curves;
        },
        set: function set(value) {
            this._curves = value, delete this._runtimeCurves;
        }
    }, {
        key: "data",
        get: function get() {
            return this._data;
        }
    }, {
        key: "commonTargets",
        get: function get() {
            return this._commonTargets;
        },
        set: function set(value) {
            this._commonTargets = value;
        }
    } ], [ {
        key: "createWithSpriteFrames",
        value: function createWithSpriteFrames(spriteFrames, sample) {
            if (!Array.isArray(spriteFrames)) return errorID(3905), null;
            var clip = new AnimationClip;
            clip.sample = sample || clip.sample, clip.duration = spriteFrames.length / clip.sample;
            for (var step = 1 / clip.sample, keys = new Array(spriteFrames.length), values = new Array(keys.length), i = 0; i < spriteFrames.length; i++) keys[i] = i * step, 
            values[i] = spriteFrames[i];
            return clip.keys = [ keys ], clip.curves = [ {
                modifiers: [ new ComponentPath("cc.SpriteComponent"), "spriteFrame" ],
                data: {
                    keys: 0,
                    values: values
                }
            } ], clip;
        }
    } ]), AnimationClip;
}(), _class3$h.preventDeferredLoadDependents = !0, _class3$h.WrapMode = WrapMode$2, 
_descriptor$N = _applyDecoratedDescriptor((_class2$U = _temp$X).prototype, "sample", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 60;
    }
}), _descriptor2$B = _applyDecoratedDescriptor(_class2$U.prototype, "speed", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor3$u = _applyDecoratedDescriptor(_class2$U.prototype, "wrapMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return WrapMode$2.Normal;
    }
}), _descriptor4$o = _applyDecoratedDescriptor(_class2$U.prototype, "events", [ _dec2$E ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor5$j = _applyDecoratedDescriptor(_class2$U.prototype, "_duration", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$a = _applyDecoratedDescriptor(_class2$U.prototype, "_keys", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor7$9 = _applyDecoratedDescriptor(_class2$U.prototype, "_stepness", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$7 = _applyDecoratedDescriptor(_class2$U.prototype, "_curves", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor9$7 = _applyDecoratedDescriptor(_class2$U.prototype, "_commonTargets", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor10$6 = _applyDecoratedDescriptor(_class2$U.prototype, "_hash", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$10 = _class2$U)) || _class$10), exports.AnimationClip || (exports.AnimationClip = {}), 
cc.AnimationClip = exports.AnimationClip;

var map, getBuiltinCopy = ((map = new Map).set(Vec2, {
    createBuffer: function createBuffer() {
        return new Vec2;
    },
    copy: Vec2.copy
}), map.set(Vec3, {
    createBuffer: function createBuffer() {
        return new Vec3;
    },
    copy: Vec3.copy
}), map.set(Vec4, {
    createBuffer: function createBuffer() {
        return new Vec4;
    },
    copy: Vec4.copy
}), map.set(Color, {
    createBuffer: function createBuffer() {
        return new Color;
    },
    copy: Color.copy
}), function(value) {
    return map.get(null == value ? void 0 : value.constructor);
}), Playable = function() {
    function Playable() {
        _classCallCheck(this, Playable), this._isPlaying = !1, this._isPaused = !1, this._stepOnce = !1;
    }
    return _createClass(Playable, [ {
        key: "play",
        value: function play() {
            this._isPlaying ? this._isPaused ? (this._isPaused = !1, this.onResume()) : this.onError(getError(3912)) : (this._isPlaying = !0, 
            this.onPlay());
        }
    }, {
        key: "stop",
        value: function stop() {
            this._isPlaying && (this._isPlaying = !1, this.onStop(), this._isPaused = !1);
        }
    }, {
        key: "pause",
        value: function pause() {
            this._isPlaying && !this._isPaused && (this._isPaused = !0, this.onPause());
        }
    }, {
        key: "resume",
        value: function resume() {
            this._isPlaying && this._isPaused && (this._isPaused = !1, this.onResume());
        }
    }, {
        key: "step",
        value: function step() {
            this.pause(), this._stepOnce = !0, this._isPlaying || this.play();
        }
    }, {
        key: "update",
        value: function update(deltaTime) {}
    }, {
        key: "onPlay",
        value: function onPlay() {}
    }, {
        key: "onPause",
        value: function onPause() {}
    }, {
        key: "onResume",
        value: function onResume() {}
    }, {
        key: "onStop",
        value: function onStop() {}
    }, {
        key: "onError",
        value: function onError(message) {}
    }, {
        key: "isPlaying",
        get: function get() {
            return this._isPlaying;
        }
    }, {
        key: "isPaused",
        get: function get() {
            return this._isPaused;
        }
    }, {
        key: "isMotionless",
        get: function get() {
            return !this.isPlaying || this.isPaused;
        }
    } ]), Playable;
}(), BlendStateBuffer = function() {
    function BlendStateBuffer() {
        _classCallCheck(this, BlendStateBuffer), this._nodeBlendStates = new Map;
    }
    return _createClass(BlendStateBuffer, [ {
        key: "ref",
        value: function ref(node, property) {
            var nodeBlendState = this._nodeBlendStates.get(node);
            nodeBlendState || (nodeBlendState = {
                dirty: !1,
                properties: {}
            }, this._nodeBlendStates.set(node, nodeBlendState));
            var propertyBlendState = nodeBlendState.properties[property];
            return propertyBlendState || (propertyBlendState = nodeBlendState.properties[property] = new PropertyBlendState(nodeBlendState, isVec3Property(property) ? new Vec3 : new Quat)), 
            ++propertyBlendState.refCount, propertyBlendState;
        }
    }, {
        key: "deRef",
        value: function deRef(node, property) {
            var nodeBlendState = this._nodeBlendStates.get(node);
            if (nodeBlendState) {
                var propertyBlendState = nodeBlendState.properties[property];
                propertyBlendState && (--propertyBlendState.refCount, propertyBlendState.refCount > 0 || (delete nodeBlendState.properties[property], 
                function isEmptyNodeBlendState(nodeBlendState) {
                    return !(nodeBlendState.properties.position || nodeBlendState.properties.rotation || nodeBlendState.properties.eulerAngles || nodeBlendState.properties.scale);
                }(nodeBlendState) && this._nodeBlendStates.delete(node)));
            }
        }
    }, {
        key: "apply",
        value: function apply() {
            this._nodeBlendStates.forEach((function(nodeBlendState, node) {
                if (nodeBlendState.dirty) {
                    nodeBlendState.dirty = !1;
                    var t, s, r, _nodeBlendState$prope = nodeBlendState.properties, position = _nodeBlendState$prope.position, scale = _nodeBlendState$prope.scale, rotation = _nodeBlendState$prope.rotation, eulerAngles = _nodeBlendState$prope.eulerAngles, anyChanged = !1;
                    position && 0 !== position.weight && (position.weight = 0, t = position.value, anyChanged = !0), 
                    scale && 0 !== scale.weight && (scale.weight = 0, s = scale.value, anyChanged = !0), 
                    rotation && 0 !== rotation.weight && (rotation.weight = 0, r = rotation.value, anyChanged = !0), 
                    eulerAngles && 0 !== eulerAngles.weight && (eulerAngles.weight = 0, r = eulerAngles.value, 
                    anyChanged = !0), anyChanged && node.setRTS(r, t, s);
                }
            }));
        }
    } ]), BlendStateBuffer;
}();

function isVec3Property(property) {
    return !function isQuatProperty(property) {
        return "rotation" === property;
    }(property);
}

var EventType$1, PropertyBlendState = function() {
    function PropertyBlendState(node, value) {
        _classCallCheck(this, PropertyBlendState), this.weight = 0, this.value = void 0, 
        this.refCount = 0, this._node = void 0, this._node = node, this.value = value;
    }
    return _createClass(PropertyBlendState, [ {
        key: "markAsDirty",
        value: function markAsDirty() {
            this._node.dirty = !0;
        }
    } ]), PropertyBlendState;
}();

function additive3D(value, weight, propertyBlendState) {
    return 0 === propertyBlendState.weight && Vec3.zero(propertyBlendState.value), 0 === weight ? propertyBlendState.value : 1 === weight ? Vec3.copy(propertyBlendState.value, value) : Vec3.scaleAndAdd(propertyBlendState.value, propertyBlendState.value, value, weight);
}

function additiveQuat(value, weight, propertyBlendState) {
    if (0 === propertyBlendState.weight && Quat.identity(propertyBlendState.value), 
    0 === weight) return propertyBlendState.value;
    if (1 === weight) return Quat.copy(propertyBlendState.value, value);
    var t = weight / (propertyBlendState.weight + weight);
    return Quat.slerp(propertyBlendState.value, propertyBlendState.value, value, t);
}

!function(EventType) {
    EventType.PLAY = "play", EventType.STOP = "stop", EventType.PAUSE = "pause", EventType.RESUME = "resume", 
    EventType.LASTFRAME = "lastframe", EventType.FINISHED = "finished";
}(EventType$1 || (EventType$1 = {})), ccenum(EventType$1);

var ICurveInstance = function() {
    function ICurveInstance(runtimeCurve, target, boundTarget) {
        _classCallCheck(this, ICurveInstance), this.commonTargetIndex = void 0, this._curve = void 0, 
        this._boundTarget = void 0, this._rootTargetProperty = void 0, this._curveDetail = void 0, 
        this._curve = runtimeCurve.curve, this._curveDetail = runtimeCurve, this._boundTarget = boundTarget;
    }
    return _createClass(ICurveInstance, [ {
        key: "applySample",
        value: function applySample(ratio, index, lerpRequired, samplerResultCache, weight) {
            var value;
            this._curve.empty() || (value = this._curve.hasLerp() && lerpRequired ? this._curve.valueBetween(ratio, samplerResultCache.from, samplerResultCache.fromRatio, samplerResultCache.to, samplerResultCache.toRatio) : this._curve.valueAt(index), 
            this._setValue(value, weight));
        }
    }, {
        key: "_setValue",
        value: function _setValue(value, weight) {
            this._boundTarget.setValue(value);
        }
    }, {
        key: "propertyName",
        get: function get() {
            return this._rootTargetProperty || "";
        }
    }, {
        key: "curveDetail",
        get: function get() {
            return this._curveDetail;
        }
    } ]), ICurveInstance;
}();

var AnimationState = function(_Playable) {
    function AnimationState(clip) {
        var _this, name = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        return _classCallCheck(this, AnimationState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(AnimationState).call(this))).duration = 1, 
        _this.speed = 1, _this.time = 0, _this.weight = 0, _this.frameRate = 0, _this._wrapMode = WrapMode$2.Normal, 
        _this._repeatCount = 1, _this._currentFramePlayed = !1, _this._delay = 0, _this._delayTime = 0, 
        _this._wrappedInfo = new WrappedInfo, _this._lastWrapInfo = null, _this._lastWrapInfoEvent = null, 
        _this._process = _this.process, _this._target = null, _this._targetNode = null, 
        _this._clip = void 0, _this._name = void 0, _this._lastIterations = void 0, _this._samplerSharedGroups = [], 
        _this._commonTargetStatuses = [], _this._curveLoaded = !1, _this._ignoreIndex = -1, 
        _this._blendStateBuffer = null, _this._blendStateWriters = [], _this._allowLastFrame = !1, 
        _this._clip = clip, _this._name = name || clip && clip.name, _this;
    }
    return _inherits(AnimationState, Playable), _createClass(AnimationState, [ {
        key: "clip",
        get: function get() {
            return this._clip;
        }
    }, {
        key: "name",
        get: function get() {
            return this._name;
        }
    }, {
        key: "length",
        get: function get() {
            return this.duration;
        }
    }, {
        key: "wrapMode",
        get: function get() {
            return this._wrapMode;
        },
        set: function set(value) {
            this._wrapMode = value, this.time = 0, value & WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
        }
    }, {
        key: "repeatCount",
        get: function get() {
            return this._repeatCount;
        },
        set: function set(value) {
            this._repeatCount = value;
            var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap, reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;
            this._process = value !== 1 / 0 || shouldWrap || reverse ? this.process : this.simpleProcess;
        }
    }, {
        key: "delay",
        get: function get() {
            return this._delay;
        },
        set: function set(value) {
            this._delayTime = this._delay = value;
        }
    } ]), _createClass(AnimationState, [ {
        key: "initialize",
        value: function initialize(root, propertyCurves) {
            var _cc$director$getAnima, _cc$director$getAnima2, _this2 = this;
            if (!this._curveLoaded) {
                this._curveLoaded = !0, this._destroyBlendStateWriters(), this._samplerSharedGroups.length = 0, 
                this._blendStateBuffer = null !== (_cc$director$getAnima = null === (_cc$director$getAnima2 = cc.director.getAnimationManager()) || void 0 === _cc$director$getAnima2 ? void 0 : _cc$director$getAnima2.blendState) && void 0 !== _cc$director$getAnima ? _cc$director$getAnima : null, 
                this._targetNode = root;
                var clip = this._clip;
                this.duration = clip.duration, this.speed = clip.speed, this.wrapMode = clip.wrapMode, 
                this.frameRate = clip.sample, (this.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
                var createBoundTargetOptimized = function createBoundTargetOptimized(createFn, rootTarget, path, valueAdapter, isConstant) {
                    if (!function isTargetingTRS(path) {
                        var prs;
                        if (1 === path.length && "string" == typeof path[0]) prs = path[0]; else if (path.length > 1) {
                            for (var i = 0; i < path.length - 1; ++i) if (!(path[i] instanceof HierarchyPath)) return !1;
                            prs = path[path.length - 1];
                        }
                        switch (prs) {
                          case "position":
                          case "scale":
                          case "rotation":
                          case "eulerAngles":
                            return !0;

                          default:
                            return !1;
                        }
                    }(path) || !_this2._blendStateBuffer) return createFn(rootTarget, path, valueAdapter);
                    var targetNode = evaluatePath.apply(void 0, [ rootTarget ].concat(_toConsumableArray(path.slice(0, path.length - 1))));
                    if (null !== targetNode && targetNode instanceof Node$1) {
                        var propertyName = path[path.length - 1], blendStateWriter = function createBlendStateWriter(blendState, node, property, weightProxy, constants) {
                            var blendFunction = isVec3Property(property) ? additive3D : additiveQuat, propertyBlendState = blendState.ref(node, property), isConstCacheValid = !1, lastWeight = -1;
                            return {
                                destroy: function destroy() {
                                    assertIsNonNullable(propertyBlendState), propertyBlendState && (blendState.deRef(node, property), 
                                    propertyBlendState = null);
                                },
                                forTarget: function forTarget() {
                                    return {
                                        get: function get() {
                                            return node[property];
                                        },
                                        set: function set(value) {
                                            if (propertyBlendState) {
                                                var weight = weightProxy.weight;
                                                if (constants) if (1 !== weight || weight !== lastWeight) isConstCacheValid = !1; else if (isConstCacheValid) return;
                                                blendFunction(value, weight, propertyBlendState), propertyBlendState.weight += weight, 
                                                propertyBlendState.markAsDirty(), isConstCacheValid = !0, lastWeight = weight;
                                            }
                                        }
                                    };
                                }
                            };
                        }(_this2._blendStateBuffer, targetNode, propertyName, _this2, isConstant);
                        return _this2._blendStateWriters.push(blendStateWriter), createFn(rootTarget, [], blendStateWriter);
                    }
                    return null;
                };
                this._commonTargetStatuses = clip.commonTargets.map((function(commonTarget, index) {
                    var target = createBoundTargetOptimized(createBufferedTarget, root, commonTarget.modifiers, commonTarget.valueAdapter, !1);
                    return null === target ? null : {
                        target: target,
                        changed: !1
                    };
                })), propertyCurves || (propertyCurves = clip.getPropertyCurves());
                for (var _loop = function _loop(iPropertyCurve) {
                    var propertyCurve = propertyCurves[iPropertyCurve], samplerSharedGroup = _this2._samplerSharedGroups.find((function(value) {
                        return value.sampler === propertyCurve.sampler;
                    }));
                    samplerSharedGroup || (samplerSharedGroup = function makeSamplerSharedGroup(sampler) {
                        return {
                            sampler: sampler,
                            curves: [],
                            samplerResultCache: {
                                from: 0,
                                fromRatio: 0,
                                to: 0,
                                toRatio: 0
                            }
                        };
                    }(propertyCurve.sampler), _this2._samplerSharedGroups.push(samplerSharedGroup));
                    var rootTarget = void 0;
                    if (void 0 === propertyCurve.commonTarget) rootTarget = root; else {
                        var commonTargetStatus = _this2._commonTargetStatuses[propertyCurve.commonTarget];
                        if (!commonTargetStatus) return "continue";
                        rootTarget = commonTargetStatus.target.peek();
                    }
                    var boundTarget = createBoundTargetOptimized(createBoundTarget, rootTarget, propertyCurve.modifiers, propertyCurve.valueAdapter, propertyCurve.curve.constant());
                    if (null === boundTarget) ; else {
                        var curveInstance = new ICurveInstance(propertyCurve, rootTarget, boundTarget);
                        curveInstance.commonTargetIndex = propertyCurve.commonTarget, samplerSharedGroup.curves.push(curveInstance);
                    }
                }, iPropertyCurve = 0; iPropertyCurve < propertyCurves.length; ++iPropertyCurve) _loop(iPropertyCurve);
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._destroyBlendStateWriters();
        }
    }, {
        key: "emit",
        value: function emit() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            cc.director.getAnimationManager().pushDelayEvent(this._emit, this, args);
        }
    }, {
        key: "on",
        value: function on(type, callback, target) {
            return this._target && this._target.isValid ? this._target.on(type, callback, target) : null;
        }
    }, {
        key: "once",
        value: function once(type, callback, target) {
            return this._target && this._target.isValid ? this._target.once(type, callback, target) : null;
        }
    }, {
        key: "off",
        value: function off(type, callback, target) {
            this._target && this._target.isValid && this._target.off(type, callback, target);
        }
    }, {
        key: "allowLastFrameEvent",
        value: function allowLastFrameEvent(allowed) {
            this._allowLastFrame = allowed;
        }
    }, {
        key: "_setEventTarget",
        value: function _setEventTarget(target) {
            this._target = target;
        }
    }, {
        key: "setTime",
        value: function setTime(time) {
            this._currentFramePlayed = !1, this.time = time || 0, this._lastWrapInfoEvent = null, 
            this._ignoreIndex = -1;
            var info = this.getWrappedInfo(time, this._wrappedInfo), direction = info.direction, frameIndex = this._clip.getEventGroupIndexAtRatio(info.ratio);
            frameIndex < 0 && (frameIndex = ~frameIndex - 1, direction < 0 && (frameIndex += 1), 
            this._ignoreIndex = frameIndex);
        }
    }, {
        key: "update",
        value: function update(delta) {
            this._delayTime > 0 && (this._delayTime -= delta, this._delayTime > 0) || (this._currentFramePlayed ? this.time += delta * this.speed : this._currentFramePlayed = !0, 
            this._process());
        }
    }, {
        key: "_needReverse",
        value: function _needReverse(currentIterations) {
            var wrapMode = this.wrapMode, needReverse = !1;
            (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong && (currentIterations - (0 | currentIterations) == 0 && currentIterations > 0 && (currentIterations -= 1), 
            1 & currentIterations && (needReverse = !needReverse));
            return (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needReverse = !needReverse), 
            needReverse;
        }
    }, {
        key: "getWrappedInfo",
        value: function getWrappedInfo(time, info) {
            info = info || new WrappedInfo;
            var stopped = !1, duration = this.duration, repeatCount = this.repeatCount, currentIterations = time > 0 ? time / duration : -time / duration;
            if (currentIterations >= repeatCount) {
                currentIterations = repeatCount, stopped = !0;
                var tempRatio = repeatCount - (0 | repeatCount);
                0 === tempRatio && (tempRatio = 1), time = tempRatio * duration * (time > 0 ? 1 : -1);
            }
            if (time > duration) {
                var tempTime = time % duration;
                time = 0 === tempTime ? duration : tempTime;
            } else time < 0 && 0 !== (time %= duration) && (time += duration);
            var needReverse = !1, shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
            shouldWrap && (needReverse = this._needReverse(currentIterations));
            var direction = needReverse ? -1 : 1;
            return this.speed < 0 && (direction *= -1), shouldWrap && needReverse && (time = duration - time), 
            info.ratio = time / duration, info.time = time, info.direction = direction, info.stopped = stopped, 
            info.iterations = currentIterations, info;
        }
    }, {
        key: "sample",
        value: function sample() {
            var info = this.getWrappedInfo(this.time, this._wrappedInfo);
            return this._sampleCurves(info.ratio), this._sampleEvents(info), info;
        }
    }, {
        key: "process",
        value: function process() {
            var lastInfo, info = this.sample();
            this._allowLastFrame && (lastInfo = this._lastWrapInfo ? this._lastWrapInfo : this._lastWrapInfo = new WrappedInfo(info), 
            this.repeatCount > 1 && (0 | info.iterations) > (0 | lastInfo.iterations) && this.emit(EventType$1.LASTFRAME, this), 
            lastInfo.set(info));
            info.stopped && (this.stop(), this.emit(EventType$1.FINISHED, this));
        }
    }, {
        key: "simpleProcess",
        value: function simpleProcess() {
            var duration = this.duration, time = this.time % duration;
            time < 0 && (time += duration);
            var ratio = time / duration;
            this._sampleCurves(ratio), this._clip.hasEvents() && this._sampleEvents(this.getWrappedInfo(this.time, this._wrappedInfo)), 
            this._allowLastFrame && (void 0 === this._lastIterations && (this._lastIterations = ratio), 
            (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) && this.emit(EventType$1.LASTFRAME, this), 
            this._lastIterations = ratio);
        }
    }, {
        key: "cache",
        value: function cache(frames) {}
    }, {
        key: "onPlay",
        value: function onPlay() {
            this.setTime(0), this._delayTime = this._delay, this._onReplayOrResume(), this.emit(EventType$1.PLAY, this);
        }
    }, {
        key: "onStop",
        value: function onStop() {
            this.isPaused || this._onPauseOrStop(), this.emit(EventType$1.STOP, this);
        }
    }, {
        key: "onResume",
        value: function onResume() {
            this._onReplayOrResume(), this.emit(EventType$1.RESUME, this);
        }
    }, {
        key: "onPause",
        value: function onPause() {
            this._onPauseOrStop(), this.emit(EventType$1.PAUSE, this);
        }
    }, {
        key: "_sampleCurves",
        value: function _sampleCurves(ratio) {
            for (var iCommonTarget = 0; iCommonTarget < this._commonTargetStatuses.length; ++iCommonTarget) {
                var commonTargetStatus = this._commonTargetStatuses[iCommonTarget];
                commonTargetStatus && (commonTargetStatus.target.pull(), commonTargetStatus.changed = !1);
            }
            for (var iSamplerSharedGroup = 0, szSamplerSharedGroup = this._samplerSharedGroups.length; iSamplerSharedGroup < szSamplerSharedGroup; ++iSamplerSharedGroup) {
                var samplerSharedGroup = this._samplerSharedGroups[iSamplerSharedGroup], sampler = samplerSharedGroup.sampler, samplerResultCache = samplerSharedGroup.samplerResultCache, index = 0, lerpRequired = !1;
                sampler ? (index = sampler.sample(ratio)) < 0 && ((index = ~index) <= 0 ? index = 0 : index >= sampler.ratios.length ? index = sampler.ratios.length - 1 : (lerpRequired = !0, 
                samplerResultCache.from = index - 1, samplerResultCache.fromRatio = sampler.ratios[samplerResultCache.from], 
                samplerResultCache.to = index, samplerResultCache.toRatio = sampler.ratios[samplerResultCache.to], 
                index = samplerResultCache.from)) : index = 0;
                for (var iCurveInstance = 0, szCurves = samplerSharedGroup.curves.length; iCurveInstance < szCurves; ++iCurveInstance) {
                    var curveInstance = samplerSharedGroup.curves[iCurveInstance];
                    if (curveInstance.applySample(ratio, index, lerpRequired, samplerResultCache, this.weight), 
                    void 0 !== curveInstance.commonTargetIndex) {
                        var _commonTargetStatus = this._commonTargetStatuses[curveInstance.commonTargetIndex];
                        _commonTargetStatus && (_commonTargetStatus.changed = !0);
                    }
                }
            }
            for (var _iCommonTarget = 0; _iCommonTarget < this._commonTargetStatuses.length; ++_iCommonTarget) {
                var _commonTargetStatus2 = this._commonTargetStatuses[_iCommonTarget];
                _commonTargetStatus2 && (_commonTargetStatus2.changed && _commonTargetStatus2.target.push());
            }
        }
    }, {
        key: "_sampleEvents",
        value: function _sampleEvents(wrapInfo) {
            var length = this._clip.eventGroups.length, direction = wrapInfo.direction, eventIndex = this._clip.getEventGroupIndexAtRatio(wrapInfo.ratio);
            if (eventIndex < 0 && (eventIndex = ~eventIndex - 1, direction < 0 && (eventIndex += 1)), 
            this._ignoreIndex !== eventIndex && (this._ignoreIndex = -1), wrapInfo.frameIndex = eventIndex, 
            !this._lastWrapInfoEvent) return this._fireEvent(eventIndex), void (this._lastWrapInfoEvent = new WrappedInfo(wrapInfo));
            var wrapMode = this.wrapMode, currentIterations = wrapIterations(wrapInfo.iterations), lastWrappedInfo = this._lastWrapInfoEvent, lastIterations = wrapIterations(lastWrappedInfo.iterations), lastIndex = lastWrappedInfo.frameIndex, lastDirection = lastWrappedInfo.direction, iterationsChanged = -1 !== lastIterations && currentIterations !== lastIterations;
            if (lastIndex === eventIndex && iterationsChanged && 1 === length) this._fireEvent(0); else if (lastIndex !== eventIndex || iterationsChanged) {
                direction = lastDirection;
                do {
                    if (lastIndex !== eventIndex) {
                        if (-1 === direction && 0 === lastIndex && eventIndex > 0 ? ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length, 
                        lastIterations++) : 1 === direction && lastIndex === length - 1 && eventIndex < length - 1 && ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1, 
                        lastIterations++), lastIndex === eventIndex) break;
                        if (lastIterations > currentIterations) break;
                    }
                    lastIndex += direction, cc.director.getAnimationManager().pushDelayEvent(this._fireEvent, this, [ lastIndex ]);
                } while (lastIndex !== eventIndex && lastIndex > -1 && lastIndex < length);
            }
            this._lastWrapInfoEvent.set(wrapInfo);
        }
    }, {
        key: "_emit",
        value: function _emit(type, state) {
            this._target && this._target.isValid && this._target.emit(type, type, state);
        }
    }, {
        key: "_fireEvent",
        value: function _fireEvent(index) {
            if (this._targetNode && this._targetNode.isValid) {
                var eventGroups = this._clip.eventGroups;
                if (!(index < 0 || index >= eventGroups.length || this._ignoreIndex === index)) for (var _step, eventGroup = eventGroups[index], components = this._targetNode.components, _iterator = _createForOfIteratorHelperLoose(eventGroup.events); !(_step = _iterator()).done; ) for (var _step2, event = _step.value, functionName = event.functionName, _iterator2 = _createForOfIteratorHelperLoose(components); !(_step2 = _iterator2()).done; ) {
                    var component = _step2.value, fx = component[functionName];
                    "function" == typeof fx && fx.apply(component, event.parameters);
                }
            }
        }
    }, {
        key: "_onReplayOrResume",
        value: function _onReplayOrResume() {
            cc.director.getAnimationManager().addAnimation(this);
        }
    }, {
        key: "_onPauseOrStop",
        value: function _onPauseOrStop() {
            cc.director.getAnimationManager().removeAnimation(this);
        }
    }, {
        key: "_destroyBlendStateWriters",
        value: function _destroyBlendStateWriters() {
            for (var iBlendStateWriter = 0; iBlendStateWriter < this._blendStateWriters.length; ++iBlendStateWriter) this._blendStateWriters[iBlendStateWriter].destroy();
            this._blendStateWriters.length = 0;
        }
    }, {
        key: "curveLoaded",
        get: function get() {
            return this._curveLoaded;
        }
    } ]), AnimationState;
}();

function wrapIterations(iterations) {
    return iterations - (0 | iterations) == 0 && (iterations -= 1), 0 | iterations;
}

cc.AnimationState = AnimationState;

var _dec$11, _dec2$F, _dec3$q, _dec4$m, _dec5$k, _dec6$i, _dec7$e, _dec8$c, _class$11, _class2$V, _descriptor$O, _descriptor2$C, _descriptor3$v, _class3$i, _temp$Y, _class$12, _class2$W, _temp$Z, CrossFade = function(_Playable) {
    function CrossFade() {
        var _this;
        return _classCallCheck(this, CrossFade), (_this = _possibleConstructorReturn(this, _getPrototypeOf(CrossFade).call(this)))._managedStates = [], 
        _this._fadings = [], _this;
    }
    return _inherits(CrossFade, Playable), _createClass(CrossFade, [ {
        key: "update",
        value: function update(deltaTime) {
            if (!this.isMotionless) {
                for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                    var state = this._managedStates[iManagedState].state;
                    state && (state.weight = 0);
                }
                for (var absoluteWeight = 1, deadFadingBegin = this._fadings.length, iFading = 0; iFading < this._fadings.length; ++iFading) {
                    var fading = this._fadings[iFading];
                    fading.easeTime += deltaTime;
                    var relativeWeight = 0 === fading.easeDuration ? 1 : clamp01(fading.easeTime / fading.easeDuration), weight = relativeWeight * absoluteWeight;
                    if (absoluteWeight *= 1 - relativeWeight, fading.target.state && (fading.target.state.weight += weight), 
                    fading.easeTime >= fading.easeDuration) {
                        deadFadingBegin = iFading + 1, fading.easeTime = fading.easeDuration;
                        break;
                    }
                }
                if (deadFadingBegin !== this._fadings.length) {
                    for (var iDeadFading = deadFadingBegin; iDeadFading < this._fadings.length; ++iDeadFading) {
                        var deadFading = this._fadings[iDeadFading];
                        --deadFading.target.reference, deadFading.target.reference <= 0 && (deadFading.target.state && deadFading.target.state.stop(), 
                        remove(this._managedStates, deadFading.target));
                    }
                    this._fadings.splice(deadFadingBegin);
                }
                for (var _iManagedState = 0; _iManagedState < this._managedStates.length; ++_iManagedState) {
                    var _state = this._managedStates[_iManagedState].state;
                    _state && _state.isMotionless && _state.sample();
                }
            }
        }
    }, {
        key: "crossFade",
        value: function crossFade(state, duration) {
            var _target$state;
            0 === this._managedStates.length && (duration = 0), 0 === duration && this.clear();
            var target = this._managedStates.find((function(weightedState) {
                return weightedState.state === state;
            }));
            target ? (null === (_target$state = target.state) || void 0 === _target$state ? void 0 : _target$state.isMotionless) && target.state.play() : (target = {
                state: state,
                reference: 0
            }, state && state.play(), this._managedStates.push(target)), ++target.reference, 
            this._fadings.unshift({
                easeDuration: duration,
                easeTime: 0,
                target: target
            });
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                var state = this._managedStates[iManagedState].state;
                state && state.stop();
            }
            this._managedStates.length = 0, this._fadings.length = 0;
        }
    }, {
        key: "onPlay",
        value: function onPlay() {
            _get(_getPrototypeOf(CrossFade.prototype), "onPlay", this).call(this), cc.director.getAnimationManager().addCrossFade(this);
        }
    }, {
        key: "onPause",
        value: function onPause() {
            _get(_getPrototypeOf(CrossFade.prototype), "onPause", this).call(this), cc.director.getAnimationManager().removeCrossFade(this);
            for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                var state = this._managedStates[iManagedState].state;
                state && state.pause();
            }
        }
    }, {
        key: "onResume",
        value: function onResume() {
            _get(_getPrototypeOf(CrossFade.prototype), "onResume", this).call(this), cc.director.getAnimationManager().addCrossFade(this);
            for (var iManagedState = 0; iManagedState < this._managedStates.length; ++iManagedState) {
                var state = this._managedStates[iManagedState].state;
                state && state.resume();
            }
        }
    }, {
        key: "onStop",
        value: function onStop() {
            _get(_getPrototypeOf(CrossFade.prototype), "onStop", this).call(this), cc.director.getAnimationManager().removeCrossFade(this), 
            this.clear();
        }
    } ]), CrossFade;
}();

function equalClips(clip1, clip2) {
    return clip1 === clip2 || !(!clip1 || !clip2 || clip1.name !== clip2.name && clip1._uuid !== clip2._uuid);
}

exports.AnimationComponent = (_dec$11 = ccclass("cc.AnimationComponent"), _dec2$F = help("i18n:cc.AnimationComponent"), 
_dec3$q = executionOrder(99), _dec4$m = menu("Components/Animation"), _dec5$k = property({
    type: [ exports.AnimationClip ],
    tooltip: "此动画组件管理的动画剪辑"
}), _dec6$i = property({
    type: exports.AnimationClip,
    tooltip: "默认动画剪辑"
}), _dec7$e = property({
    tooltip: "是否在动画组件开始运行时自动播放默认动画剪辑"
}), _dec8$c = property({
    type: [ exports.AnimationClip ]
}), _dec$11(_class$11 = _dec2$F(_class$11 = _dec3$q(_class$11 = executeInEditMode(_class$11 = _dec4$m((_temp$Y = _class3$i = function(_Eventify) {
    function AnimationComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, AnimationComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "playOnLoad", _descriptor$O, _assertThisInitialized(_this)), 
        _this._crossFade = new CrossFade, _this._nameToState = createMap(!0), _initializerDefineProperty(_this, "_clips", _descriptor2$C, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_defaultClip", _descriptor3$v, _assertThisInitialized(_this)), 
        _this._hasBeenPlayed = !1, _this;
    }
    return _inherits(AnimationComponent, Eventify(Component)), _createClass(AnimationComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            for (var stateName in this.clips = this._clips, this._nameToState) {
                this._nameToState[stateName].initialize(this.node);
            }
        }
    }, {
        key: "start",
        value: function start() {
            this.playOnLoad && !this._hasBeenPlayed && this._defaultClip && this.crossFade(this._defaultClip.name, 0);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._crossFade.resume();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._crossFade.pause();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            for (var name in this._crossFade.stop(), this._nameToState) {
                this._nameToState[name].destroy();
            }
            this._nameToState = createMap(!0);
        }
    }, {
        key: "play",
        value: function play(name) {
            if (this._hasBeenPlayed = !0, !name) {
                if (!this._defaultClip) return;
                name = this._defaultClip.name;
            }
            this.crossFade(name, 0);
        }
    }, {
        key: "crossFade",
        value: function crossFade(name) {
            var duration = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3;
            this._hasBeenPlayed = !0;
            var state = this._nameToState[name];
            state && (this._crossFade.play(), this._crossFade.crossFade(state, duration));
        }
    }, {
        key: "pause",
        value: function pause() {
            this._crossFade.pause();
        }
    }, {
        key: "resume",
        value: function resume() {
            this._crossFade.resume();
        }
    }, {
        key: "stop",
        value: function stop() {
            this._crossFade.stop();
        }
    }, {
        key: "getAnimationState",
        value: function getAnimationState(name) {
            return this.getState(name);
        }
    }, {
        key: "getState",
        value: function getState(name) {
            var state = this._nameToState[name];
            return state && !state.curveLoaded && state.initialize(this.node), state || null;
        }
    }, {
        key: "createState",
        value: function createState(clip, name) {
            return name = name || clip.name, this.removeState(name), this._doCreateState(clip, name);
        }
    }, {
        key: "removeState",
        value: function removeState(name) {
            var state = this._nameToState[name];
            state && (state.allowLastFrameEvent(!1), state.stop(), delete this._nameToState[name]);
        }
    }, {
        key: "addClip",
        value: function addClip(clip, name) {
            return contains(this._clips, clip) || this._clips.push(clip), this.createState(clip, name);
        }
    }, {
        key: "removeClip",
        value: function removeClip(clip, force) {
            var removalState;
            for (var name in this._nameToState) {
                var state = this._nameToState[name];
                if (state.clip === clip) {
                    removalState = state;
                    break;
                }
            }
            if (clip === this._defaultClip) {
                if (!force) return void warnID(3902);
                this._defaultClip = null;
            }
            if (removalState && removalState.isPlaying) {
                if (!force) return void warnID(3903);
                removalState.stop();
            }
            this._clips = this._clips.filter((function(item) {
                return item !== clip;
            })), removalState && delete this._nameToState[removalState.name];
        }
    }, {
        key: "on",
        value: function on(type, callback, thisArg, once) {
            var ret = _get(_getPrototypeOf(AnimationComponent.prototype), "on", this).call(this, type, callback, thisArg, once);
            return type === EventType$1.LASTFRAME && this._syncAllowLastFrameEvent(), ret;
        }
    }, {
        key: "once",
        value: function once(type, callback, thisArg) {
            var ret = _get(_getPrototypeOf(AnimationComponent.prototype), "once", this).call(this, type, callback, thisArg);
            return type === EventType$1.LASTFRAME && this._syncAllowLastFrameEvent(), ret;
        }
    }, {
        key: "off",
        value: function off(type, callback, thisArg) {
            _get(_getPrototypeOf(AnimationComponent.prototype), "off", this).call(this, type, callback, thisArg), 
            type === EventType$1.LASTFRAME && this._syncDisallowLastFrameEvent();
        }
    }, {
        key: "_createState",
        value: function _createState(clip, name) {
            return new AnimationState(clip, name);
        }
    }, {
        key: "_doCreateState",
        value: function _doCreateState(clip, name) {
            var state = this._createState(clip, name);
            return state._setEventTarget(this), state.allowLastFrameEvent(this.hasEventListener(EventType$1.LASTFRAME)), 
            this.node && state.initialize(this.node), this._nameToState[state.name] = state, 
            state;
        }
    }, {
        key: "_getStateByNameOrDefaultClip",
        value: function _getStateByNameOrDefaultClip(name) {
            if (!name) {
                if (!this._defaultClip) return null;
                name = this._defaultClip.name;
            }
            var state = this._nameToState[name];
            return state || null;
        }
    }, {
        key: "_removeStateOfAutomaticClip",
        value: function _removeStateOfAutomaticClip(clip) {
            for (var name in this._nameToState) {
                var state = this._nameToState[name];
                equalClips(clip, state.clip) && (state.stop(), delete this._nameToState[name]);
            }
        }
    }, {
        key: "_syncAllowLastFrameEvent",
        value: function _syncAllowLastFrameEvent() {
            if (this.hasEventListener(EventType$1.LASTFRAME)) for (var stateName in this._nameToState) this._nameToState[stateName].allowLastFrameEvent(!0);
        }
    }, {
        key: "_syncDisallowLastFrameEvent",
        value: function _syncDisallowLastFrameEvent() {
            if (!this.hasEventListener(EventType$1.LASTFRAME)) for (var stateName in this._nameToState) this._nameToState[stateName].allowLastFrameEvent(!1);
        }
    }, {
        key: "clips",
        get: function get() {
            return this._clips;
        },
        set: function set(value) {
            var _this2 = this;
            this._crossFade && this._crossFade.clear();
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._clips); !(_step = _iterator()).done; ) {
                var clip = _step.value;
                clip && this._removeStateOfAutomaticClip(clip);
            }
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(value); !(_step2 = _iterator2()).done; ) {
                var _clip = _step2.value;
                _clip && this.createState(_clip);
            }
            var newDefaultClip = value.find((function(clip) {
                return equalClips(clip, _this2._defaultClip);
            }));
            this._defaultClip = newDefaultClip || null, this._clips = value;
        }
    }, {
        key: "defaultClip",
        get: function get() {
            return this._defaultClip;
        },
        set: function set(value) {
            (this._defaultClip = value, value) && (this._clips.findIndex((function(clip) {
                return equalClips(clip, value);
            })) >= 0 || (this._clips.push(value), this.createState(value)));
        }
    } ]), AnimationComponent;
}(), _class3$i.EventType = EventType$1, _applyDecoratedDescriptor((_class2$V = _temp$Y).prototype, "clips", [ _dec5$k ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "clips"), _class2$V.prototype), 
_applyDecoratedDescriptor(_class2$V.prototype, "defaultClip", [ _dec6$i ], Object.getOwnPropertyDescriptor(_class2$V.prototype, "defaultClip"), _class2$V.prototype), 
_descriptor$O = _applyDecoratedDescriptor(_class2$V.prototype, "playOnLoad", [ _dec7$e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$C = _applyDecoratedDescriptor(_class2$V.prototype, "_clips", [ _dec8$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$v = _applyDecoratedDescriptor(_class2$V.prototype, "_defaultClip", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$11 = _class2$V)) || _class$11) || _class$11) || _class$11) || _class$11) || _class$11), 
exports.AnimationComponent || (exports.AnimationComponent = {}), cc.AnimationComponent = exports.AnimationComponent, 
exports.replaceProperty(exports.AnimationComponent.prototype, "AnimationComponent", [ {
    name: "getAnimationState",
    newName: "getState"
}, {
    name: "addClip",
    newName: "createState"
}, {
    name: "removeClip",
    newName: "removeState",
    customFunction: function customFunction() {
        var arg0 = arguments.length <= 0 ? void 0 : arguments[0];
        return exports.AnimationComponent.prototype.removeState.call(this, arg0.name);
    }
} ]);

var AnimationManager = ccclass((_temp$Z = _class2$W = function(_System) {
    function AnimationManager() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, AnimationManager);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationManager)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._anims = new MutableForwardIterator([]), 
        _this._delayEvents = [], _this._blendStateBuffer = new BlendStateBuffer, _this._crossFades = [], 
        _this._sockets = [], _this;
    }
    return _inherits(AnimationManager, System), _createClass(AnimationManager, [ {
        key: "addCrossFade",
        value: function addCrossFade(crossFade) {
            this._crossFades.push(crossFade);
        }
    }, {
        key: "removeCrossFade",
        value: function removeCrossFade(crossFade) {
            remove(this._crossFades, crossFade);
        }
    }, {
        key: "update",
        value: function update(dt) {
            for (var _delayEvents = this._delayEvents, _crossFades = this._crossFades, _sockets = this._sockets, i = 0, l = _crossFades.length; i < l; i++) _crossFades[i].update(dt);
            var iterator = this._anims, array = iterator.array;
            for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var anim = array[iterator.i];
                anim.isMotionless || anim.update(dt);
            }
            this._blendStateBuffer.apply();
            for (var stamp = cc.director.getTotalFrames(), _i = 0, _l = _sockets.length; _i < _l; _i++) {
                var _sockets$_i = _sockets[_i], target = _sockets$_i.target, transform = _sockets$_i.transform;
                target.matrix = getWorldMatrix(transform, stamp);
            }
            for (var _i2 = 0, _l2 = _delayEvents.length; _i2 < _l2; _i2++) {
                var event = _delayEvents[_i2];
                event.fn.apply(event.thisArg, event.args);
            }
            _delayEvents.length = 0;
        }
    }, {
        key: "destruct",
        value: function destruct() {}
    }, {
        key: "addAnimation",
        value: function addAnimation(anim) {
            -1 === this._anims.array.indexOf(anim) && this._anims.push(anim);
        }
    }, {
        key: "removeAnimation",
        value: function removeAnimation(anim) {
            var index = this._anims.array.indexOf(anim);
            index >= 0 ? this._anims.fastRemoveAt(index) : errorID(3907);
        }
    }, {
        key: "pushDelayEvent",
        value: function pushDelayEvent(fn, thisArg, args) {
            this._delayEvents.push({
                fn: fn,
                thisArg: thisArg,
                args: args
            });
        }
    }, {
        key: "addSockets",
        value: function addSockets(root, sockets) {
            for (var _this2 = this, _loop = function _loop(i) {
                var socket = sockets[i];
                if (_this2._sockets.find((function(s) {
                    return s.target === socket.target;
                }))) return "continue";
                var targetNode = root.getChildByPath(socket.path), transform = socket.target && targetNode && getTransform(targetNode, root);
                transform && _this2._sockets.push({
                    target: socket.target,
                    transform: transform
                });
            }, i = 0; i < sockets.length; ++i) _loop(i);
        }
    }, {
        key: "removeSockets",
        value: function removeSockets(root, sockets) {
            for (var i = 0; i < sockets.length; ++i) for (var socketToRemove = sockets[i], j = 0; j < this._sockets.length; ++j) {
                var socket = this._sockets[j];
                if (socket.target === socketToRemove.target) {
                    deleteTransform(socket.transform.node), this._sockets[j] = this._sockets[this._sockets.length - 1], 
                    this._sockets.length--;
                    break;
                }
            }
        }
    }, {
        key: "blendState",
        get: function get() {
            return this._blendStateBuffer;
        }
    } ]), AnimationManager;
}(), _class2$W.ID = "animation", _class$12 = _temp$Z)) || _class$12;

director.on(Director.EVENT_INIT, (function() {
    var animationManager = new AnimationManager;
    director.registerSystem(AnimationManager.ID, animationManager, Scheduler.PRIORITY_SYSTEM);
})), cc.AnimationManager = AnimationManager;

var _dec$12, _dec2$G, _class$13, _class2$X, _descriptor$P, _descriptor2$D, _dec3$r, _dec4$n, _dec5$l, _dec6$j, _dec7$f, _dec8$d, _dec9$9, _class4$a, _class5$9, _descriptor3$w, _descriptor4$p, _class6$2, _temp2$9, m4_1$6 = new Mat4, m4_2$1 = new Mat4, noCurves = [], SkeletalAnimationState = function(_AnimationState) {
    function SkeletalAnimationState(clip) {
        var _this, name = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
        return _classCallCheck(this, SkeletalAnimationState), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SkeletalAnimationState).call(this, clip, name)))._frames = 1, 
        _this._bakedDuration = 0, _this._animInfo = null, _this._sockets = [], _this._animInfoMgr = void 0, 
        _this._comps = [], _this._parent = null, _this._curvesInited = !1, _this._animInfoMgr = cc.director.root.dataPoolManager.jointAnimationInfo, 
        _this;
    }
    return _inherits(SkeletalAnimationState, AnimationState), _createClass(SkeletalAnimationState, [ {
        key: "initialize",
        value: function initialize(root) {
            if (!this._curveLoaded) {
                this._comps.length = 0;
                for (var comps = root.getComponentsInChildren(SkinningModelComponent), i = 0; i < comps.length; ++i) {
                    var comp = comps[i];
                    comp.skinningRoot === root && this._comps.push(comp);
                }
                this._parent = root.getComponent("cc.SkeletalAnimationComponent");
                var baked = this._parent.useBakedAnimation;
                _get(_getPrototypeOf(SkeletalAnimationState.prototype), "initialize", this).call(this, root, baked ? noCurves : void 0), 
                this._curvesInited = !baked;
                var info = SkelAnimDataHub.getOrExtract(this.clip).info;
                this._frames = info.frames - 1, this._animInfo = this._animInfoMgr.getData(root.uuid), 
                this._bakedDuration = this._frames / info.sample;
            }
        }
    }, {
        key: "onPlay",
        value: function onPlay() {
            if (_get(_getPrototypeOf(SkeletalAnimationState.prototype), "onPlay", this).call(this), 
            this._parent.useBakedAnimation) {
                this._sampleCurves = this._sampleCurvesBaked, this.duration = this._bakedDuration, 
                this._animInfoMgr.switchClip(this._animInfo, this._clip);
                for (var i = 0; i < this._comps.length; ++i) this._comps[i].uploadAnimation(this.clip);
            } else this._sampleCurves = _get(_getPrototypeOf(SkeletalAnimationState.prototype), "_sampleCurves", this), 
            this.duration = this._clip.duration, this._curvesInited || (this._curveLoaded = !1, 
            _get(_getPrototypeOf(SkeletalAnimationState.prototype), "initialize", this).call(this, this._targetNode), 
            this._curvesInited = !0);
        }
    }, {
        key: "rebuildSocketCurves",
        value: function rebuildSocketCurves(sockets) {
            if (this._sockets.length = 0, !this._targetNode) return null;
            for (var root = this._targetNode, i = 0; i < sockets.length; ++i) {
                var socket = sockets[i], targetNode = root.getChildByPath(socket.path);
                if (socket.target) {
                    for (var clipData = SkelAnimDataHub.getOrExtract(this.clip), animPath = socket.path, source = clipData.data[animPath], animNode = targetNode, downstream = void 0; !source; ) {
                        var idx = animPath.lastIndexOf("/");
                        if (animPath = animPath.substring(0, idx), source = clipData.data[animPath], animNode && (downstream || (downstream = Mat4.identity(m4_2$1)), 
                        Mat4.fromRTS(m4_1$6, animNode.rotation, animNode.position, animNode.scale), Mat4.multiply(downstream, m4_1$6, downstream), 
                        animNode = animNode.parent), idx < 0) break;
                    }
                    for (var curveData = source && source.worldMatrix.values, frames = clipData.info.frames, transforms = [], f = 0; f < frames; f++) {
                        var mat = void 0;
                        mat = curveData && downstream ? Mat4.multiply(m4_1$6, curveData[f], downstream) : curveData ? curveData[f] : downstream || Mat4.IDENTITY;
                        var tfm = {
                            pos: new Vec3,
                            rot: new Quat,
                            scale: new Vec3
                        };
                        Mat4.toRTS(mat, tfm.rot, tfm.pos, tfm.scale), transforms.push(tfm);
                    }
                    this._sockets.push({
                        target: socket.target,
                        frames: transforms
                    });
                }
            }
        }
    }, {
        key: "_sampleCurvesBaked",
        value: function _sampleCurvesBaked(ratio) {
            var info = this._animInfo, curFrame = ratio * this._frames + .5 | 0;
            if (curFrame !== info.data[0]) {
                info.data[0] = curFrame, info.dirty = !0;
                for (var i = 0; i < this._sockets.length; ++i) {
                    var _this$_sockets$i = this._sockets[i], target = _this$_sockets$i.target, _frames$curFrame = _this$_sockets$i.frames[curFrame], pos = _frames$curFrame.pos, rot = _frames$curFrame.rot, scale = _frames$curFrame.scale;
                    target.setRTS(rot, pos, scale);
                }
            }
        }
    } ]), SkeletalAnimationState;
}(), Socket = (_dec$12 = ccclass("cc.SkeletalAnimationComponent.Socket"), _dec2$G = property(Node$1), 
_dec$12((_descriptor$P = _applyDecoratedDescriptor((_class2$X = function Socket() {
    var path = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", target = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    _classCallCheck(this, Socket), _initializerDefineProperty(this, "path", _descriptor$P, this), 
    _initializerDefineProperty(this, "target", _descriptor2$D, this), this.path = path, 
    this.target = target;
}).prototype, "path", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor2$D = _applyDecoratedDescriptor(_class2$X.prototype, "target", [ _dec2$G ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$13 = _class2$X)) || _class$13), m4_1$7 = new Mat4, m4_2$2 = new Mat4;

function collectRecursively(node) {
    for (var prefix = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", out = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], i = 0; i < node.children.length; i++) {
        var child = node.children[i];
        if (child) {
            var path = prefix ? "".concat(prefix, "/").concat(child.name) : child.name;
            out.push(path), collectRecursively(child, path, out);
        }
    }
    return out;
}

var _class$14, _class2$Y, _class3$j, _class4$b, SkeletalAnimationComponent = (_dec3$r = ccclass("cc.SkeletalAnimationComponent"), 
_dec4$n = help("i18n:cc.SkeletalAnimationComponent"), _dec5$l = executionOrder(99), 
_dec6$j = menu("Components/SkeletalAnimation"), _dec7$f = property({
    type: [ Socket ],
    tooltip: "i18n:animation.sockets"
}), _dec8$d = property({
    tooltip: "i18n:animation.use_baked_animation"
}), _dec9$9 = property({
    type: [ Socket ]
}), _dec3$r(_class4$a = _dec4$n(_class4$a = _dec5$l(_class4$a = executeInEditMode(_class4$a = _dec6$j((_temp2$9 = _class6$2 = function(_AnimationComponent) {
    function SkeletalAnimationComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SkeletalAnimationComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SkeletalAnimationComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_useBakedAnimation", _descriptor3$w, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_sockets", _descriptor4$p, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(SkeletalAnimationComponent, exports.AnimationComponent), _createClass(SkeletalAnimationComponent, [ {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "onDestroy", this).call(this), 
            cc.director.root.dataPoolManager.jointAnimationInfo.destroy(this.node.uuid), cc.director.getAnimationManager().removeSockets(this.node, this._sockets);
        }
    }, {
        key: "start",
        value: function start() {
            this.sockets = this._sockets, this.useBakedAnimation = this._useBakedAnimation, 
            _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "start", this).call(this);
        }
    }, {
        key: "querySockets",
        value: function querySockets() {
            var animPaths = this._defaultClip && Object.keys(SkelAnimDataHub.getOrExtract(this._defaultClip).data).sort().reduce((function(acc, cur) {
                return cur.startsWith(acc[acc.length - 1]) || acc.push(cur), acc;
            }), []) || [];
            if (!animPaths.length) return [ "please specify a valid default animation clip first" ];
            for (var out = [], i = 0; i < animPaths.length; i++) {
                var path = animPaths[i], node = this.node.getChildByPath(path);
                node && (out.push(path), collectRecursively(node, path, out));
            }
            return out;
        }
    }, {
        key: "rebuildSocketAnimations",
        value: function rebuildSocketAnimations() {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._sockets); !(_step = _iterator()).done; ) {
                var socket = _step.value, joint = this.node.getChildByPath(socket.path), target = socket.target;
                joint && target && (target.name = "".concat(socket.path.substring(socket.path.lastIndexOf("/") + 1), " Socket"), 
                target.parent = this.node, getWorldTransformUntilRoot(joint, this.node, m4_1$7), 
                Mat4.fromRTS(m4_2$2, target.rotation, target.position, target.scale), Mat4.equals(m4_2$2, m4_1$7) || (target.matrix = m4_1$7));
            }
            for (var _i = 0, _Object$keys = Object.keys(this._nameToState); _i < _Object$keys.length; _i++) {
                var stateName = _Object$keys[_i];
                this._nameToState[stateName].rebuildSocketCurves(this._sockets);
            }
        }
    }, {
        key: "createSocket",
        value: function createSocket(path) {
            var socket = this._sockets.find((function(s) {
                return s.path === path;
            }));
            if (socket) return socket.target;
            if (!this.node.getChildByPath(path)) return console.warn("illegal socket path"), 
            null;
            var target = new Node$1;
            return target.parent = this.node, this._sockets.push(new Socket(path, target)), 
            this.rebuildSocketAnimations(), target;
        }
    }, {
        key: "_createState",
        value: function _createState(clip, name) {
            return new SkeletalAnimationState(clip, name);
        }
    }, {
        key: "_doCreateState",
        value: function _doCreateState(clip, name) {
            var state = _get(_getPrototypeOf(SkeletalAnimationComponent.prototype), "_doCreateState", this).call(this, clip, name);
            return state.rebuildSocketCurves(this._sockets), state;
        }
    }, {
        key: "sockets",
        get: function get() {
            return this._sockets;
        },
        set: function set(val) {
            if (!this._useBakedAnimation) {
                var animMgr = cc.director.getAnimationManager();
                animMgr.removeSockets(this.node, this._sockets), animMgr.addSockets(this.node, val);
            }
            this._sockets = val, this.rebuildSocketAnimations();
        }
    }, {
        key: "useBakedAnimation",
        get: function get() {
            return this._useBakedAnimation;
        },
        set: function set(val) {
            this._useBakedAnimation = val;
            for (var comps = this.node.getComponentsInChildren(SkinningModelComponent), i = 0; i < comps.length; ++i) {
                var comp = comps[i];
                comp.skinningRoot === this.node && comp.setUseBakedAnimation(this._useBakedAnimation);
            }
            this._useBakedAnimation ? cc.director.getAnimationManager().removeSockets(this.node, this._sockets) : cc.director.getAnimationManager().addSockets(this.node, this._sockets);
        }
    } ]), SkeletalAnimationComponent;
}(), _class6$2.Socket = Socket, _applyDecoratedDescriptor((_class5$9 = _temp2$9).prototype, "sockets", [ _dec7$f ], Object.getOwnPropertyDescriptor(_class5$9.prototype, "sockets"), _class5$9.prototype), 
_applyDecoratedDescriptor(_class5$9.prototype, "useBakedAnimation", [ _dec8$d ], Object.getOwnPropertyDescriptor(_class5$9.prototype, "useBakedAnimation"), _class5$9.prototype), 
_descriptor3$w = _applyDecoratedDescriptor(_class5$9.prototype, "_useBakedAnimation", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$p = _applyDecoratedDescriptor(_class5$9.prototype, "_sockets", [ _dec9$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _class4$a = _class5$9)) || _class4$a) || _class4$a) || _class4$a) || _class4$a) || _class4$a);

cc.SkeletalAnimationComponent = SkeletalAnimationComponent, cc.easing = easing;

var HierachyModifier = ccclass("cc.HierachyModifier")(_class$14 = function(_HierarchyPath) {
    function HierachyModifier() {
        return _classCallCheck(this, HierachyModifier), _possibleConstructorReturn(this, _getPrototypeOf(HierachyModifier).apply(this, arguments));
    }
    return _inherits(HierachyModifier, HierarchyPath), HierachyModifier;
}()) || _class$14;

cc.HierachyModifier = HierachyModifier;

var ComponentModifier = ccclass("cc.ComponentModifier")(_class2$Y = function(_ComponentPath) {
    function ComponentModifier() {
        return _classCallCheck(this, ComponentModifier), _possibleConstructorReturn(this, _getPrototypeOf(ComponentModifier).apply(this, arguments));
    }
    return _inherits(ComponentModifier, ComponentPath), ComponentModifier;
}()) || _class2$Y;

cc.ComponentModifier = ComponentModifier;

var CurveValueAdapter = ccclass("cc.CurveValueAdapter")(_class3$j = function() {
    function CurveValueAdapter() {
        _classCallCheck(this, CurveValueAdapter);
    }
    return _createClass(CurveValueAdapter, [ {
        key: "forTarget",
        value: function forTarget(target) {
            return {
                set: function set() {}
            };
        }
    } ]), CurveValueAdapter;
}()) || _class3$j;

cc.CurveValueAdapter = CurveValueAdapter;

var UniformCurveValueAdapter = ccclass("cc.UniformCurveValueAdapter")(_class4$b = function(_UniformProxyFactory) {
    function UniformCurveValueAdapter() {
        return _classCallCheck(this, UniformCurveValueAdapter), _possibleConstructorReturn(this, _getPrototypeOf(UniformCurveValueAdapter).apply(this, arguments));
    }
    return _inherits(UniformCurveValueAdapter, UniformProxyFactory), UniformCurveValueAdapter;
}()) || _class4$b;

function isPropertyModifier(path) {
    return "string" == typeof path;
}

function isElementModifier(path) {
    return "number" == typeof path;
}

function isCustomTargetModifier(path, constructor) {
    return path instanceof constructor;
}

cc.UniformCurveValueAdapter = UniformCurveValueAdapter, cc.isPropertyModifier = isPropertyModifier, 
cc.isElementModifier = isElementModifier, cc.isCustomTargetModifier = isCustomTargetModifier;

var _class$15, Counter = function() {
    function Counter(id, opts, now) {
        _classCallCheck(this, Counter), this._id = void 0, this._opts = void 0, this._accumStart = void 0, 
        this._total = 0, this._value = 0, this._averageValue = 0, this._accumValue = 0, 
        this._accumSamples = 0, this._id = id, this._opts = opts, this._accumStart = now;
    }
    return _createClass(Counter, [ {
        key: "value",
        get: function get() {
            return this._value;
        },
        set: function set(val) {
            this._value = val;
        }
    } ]), _createClass(Counter, [ {
        key: "sample",
        value: function sample(now) {
            this._average(this._value, now);
        }
    }, {
        key: "human",
        value: function human() {
            var _this$_opts = this._opts, average = _this$_opts.average, isInteger = _this$_opts.isInteger, v = average ? this._averageValue : this._value;
            return isInteger ? Math.round(v) : Math.round(100 * v) / 100;
        }
    }, {
        key: "alarm",
        value: function alarm() {
            return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
        }
    }, {
        key: "_average",
        value: function _average(v) {
            var now = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            if (this._opts.average) {
                this._accumValue += v, ++this._accumSamples;
                var t = now;
                t - this._accumStart >= this._opts.average && (this._averageValue = this._accumValue / this._accumSamples, 
                this._accumValue = 0, this._accumStart = t, this._accumSamples = 0);
            }
        }
    } ]), Counter;
}(), PerfCounter = ccclass("cc.PerfCounter")(_class$15 = function(_Counter) {
    function PerfCounter(id, opts, now) {
        var _this;
        return _classCallCheck(this, PerfCounter), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PerfCounter).call(this, id, opts, now)))._time = void 0, 
        _this._time = now, _this;
    }
    return _inherits(PerfCounter, Counter), _createClass(PerfCounter, [ {
        key: "start",
        value: function start() {
            var now = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            this._time = now;
        }
    }, {
        key: "end",
        value: function end() {
            var now = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            this._value = now - this._time, this._average(this._value);
        }
    }, {
        key: "tick",
        value: function tick() {
            this.end(), this.start();
        }
    }, {
        key: "frame",
        value: function frame(now) {
            var t = now, e = t - this._time;
            this._total++, e > (this._opts.average || 1e3) && (this._value = 1e3 * this._total / e, 
            this._total = 0, this._time = t, this._average(this._value));
        }
    } ]), PerfCounter;
}()) || _class$15, _string2offset = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    ".": 10
}, _profileInfo = {
    frame: {
        desc: "Frame time (ms)",
        min: 0,
        max: 50,
        average: 500
    },
    fps: {
        desc: "Framerate (FPS)",
        below: 30,
        average: 500,
        isInteger: !0
    },
    draws: {
        desc: "Draw call",
        isInteger: !0
    },
    instances: {
        desc: "Instance Count",
        isInteger: !0
    },
    tricount: {
        desc: "Triangle",
        isInteger: !0
    },
    logic: {
        desc: "Game Logic (ms)",
        min: 0,
        max: 50,
        average: 500,
        color: "#080"
    },
    physics: {
        desc: "Physics (ms)",
        min: 0,
        max: 50,
        average: 500
    },
    render: {
        desc: "Renderer (ms)",
        min: 0,
        max: 50,
        average: 500,
        color: "#f90"
    },
    textureMemory: {
        desc: "GFX Texture Mem(M)"
    },
    bufferMemory: {
        desc: "GFX Buffer Mem(M)"
    }
}, _constants_fontSize = 24, _constants_quadHeight = .18, _constants_segmentsPerLine = 8, _constants_textureWidth = 256, _constants_textureHeight = 256, Profiler = function() {
    function Profiler() {
        _classCallCheck(this, Profiler), this._stats = null, this.id = "__Profiler__", this._showFPS = !1, 
        this._rootNode = null, this._device = null, this._canvas = null, this._ctx = null, 
        this._texture = null, this._textureView = null, this._region = new GFXBufferTextureCopy, 
        this._canvasArr = [], this._regionArr = [ this._region ], this.digitsData = null, 
        this._canvasDone = !1, this._statsDone = !1, this._inited = !1, this._lineHeight = _constants_textureHeight / (Object.keys(_profileInfo).length + 1), 
        this._wordHeight = 0, this._eachNumWidth = 0, this._totalLines = 0, this.lastTime = 0, 
        this._uvOffset = [], this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d"), 
        this._region = new GFXBufferTextureCopy, this._canvasArr.push(this._canvas);
    }
    return _createClass(Profiler, [ {
        key: "isShowingStats",
        value: function isShowingStats() {
            return this._showFPS;
        }
    }, {
        key: "hideStats",
        value: function hideStats() {
            this._showFPS && (this._rootNode && (this._rootNode.active = !1), cc.game.off(cc.Game.EVENT_RESTART, this.generateNode, this), 
            cc.director.off(cc.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), 
            cc.director.off(cc.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), cc.director.off(cc.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), 
            cc.director.off(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), cc.director.off(cc.Director.EVENT_AFTER_DRAW, this.afterDraw, this), 
            this._showFPS = !1);
        }
    }, {
        key: "showStats",
        value: function showStats() {
            this._showFPS || (this._device || (this._device = cc.director.root.device), this.generateCanvas(), 
            this.generateStats(), cc.game.once(cc.Game.EVENT_ENGINE_INITED, this.generateNode, this), 
            cc.game.on(cc.Game.EVENT_RESTART, this.generateNode, this), this._rootNode && (this._rootNode.active = !0), 
            cc.director.on(cc.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this), cc.director.on(cc.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this), 
            cc.director.on(cc.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this), cc.director.on(cc.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this), 
            cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this), cc.director.on(cc.Director.EVENT_AFTER_DRAW, this.afterDraw, this), 
            this._showFPS = !0, this._canvasDone = !0, this._statsDone = !0);
        }
    }, {
        key: "generateCanvas",
        value: function generateCanvas() {
            if (!this._canvasDone) {
                var textureWidth = _constants_textureWidth, textureHeight = _constants_textureHeight;
                this._ctx && this._canvas && (this._canvas.width = textureWidth, this._canvas.height = textureHeight, 
                this._canvas.style.width = "".concat(this._canvas.width), this._canvas.style.height = "".concat(this._canvas.height), 
                this._ctx.font = "".concat(_constants_fontSize, "px Arial"), this._ctx.textBaseline = "top", 
                this._ctx.fillStyle = "#fff", this._texture = this._device.createTexture({
                    type: exports.GFXTextureType.TEX2D,
                    usage: exports.GFXTextureUsageBit.SAMPLED,
                    format: exports.GFXFormat.RGBA8,
                    width: textureWidth,
                    height: textureHeight,
                    mipLevel: 1
                }), this._textureView = this._device.createTextureView({
                    texture: this._texture,
                    type: exports.GFXTextureViewType.TV2D,
                    format: exports.GFXFormat.RGBA8
                }), this._region.texExtent.width = textureWidth, this._region.texExtent.height = textureHeight);
            }
        }
    }, {
        key: "generateStats",
        value: function generateStats() {
            if (!this._statsDone && this._ctx && this._canvas) {
                this._stats = null;
                var now = performance.now();
                this._ctx.textAlign = "left";
                var i = 0;
                for (var id in _profileInfo) {
                    var element = _profileInfo[id];
                    this._ctx.fillText(element.desc, 0, i * this._lineHeight), element.counter = new PerfCounter(id, element, now), 
                    i++;
                }
                this._totalLines = i, this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;
                var offsets = new Array;
                offsets[0] = 0;
                for (var j = 0; j < "0123456789. ".length; ++j) {
                    var offset = this._ctx.measureText("0123456789. "[j]).width;
                    this._eachNumWidth = Math.max(this._eachNumWidth, offset), offsets[j + 1] = offsets[j] + offset / this._canvas.width;
                }
                for (var _j = 0; _j < "0123456789. ".length; ++_j) this._ctx.fillText("0123456789. "[_j], _j * this._eachNumWidth, this._totalLines * this._lineHeight);
                this._eachNumWidth /= this._canvas.width;
                for (var len = Math.ceil(offsets.length / 4), _j2 = 0; _j2 < len; _j2++) this._uvOffset.push(new Vec4(offsets[4 * _j2], offsets[4 * _j2 + 1], offsets[4 * _j2 + 2], offsets[4 * _j2 + 3]));
                this._stats = _profileInfo, this._canvasArr[0] = this._canvas, this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
            }
        }
    }, {
        key: "generateNode",
        value: function generateNode() {
            if (!this._rootNode || !this._rootNode.isValid) {
                this._rootNode = new Node$1("PROFILER_NODE"), cc.game.addPersistRootNode(this._rootNode);
                var cameraNode = new Node$1("Profiler_Camera");
                cameraNode.setPosition(0, 0, 1), cameraNode.parent = this._rootNode;
                var camera = cameraNode.addComponent("cc.CameraComponent");
                camera.projection = exports.CameraComponent.ProjectionType.ORTHO, camera.near = 0, 
                camera.far = 0, camera.orthoHeight = this._device.height, camera.visibility = Layers.BitMask.PROFILER, 
                camera.clearFlags = exports.GFXClearFlag.NONE, camera.priority = 4294967295, camera.flows = [ "UIFlow" ];
                var managerNode = new Node$1("Profiler_Root");
                managerNode.parent = this._rootNode;
                for (var height = _constants_quadHeight, rowHeight = height / this._totalLines, lWidth = height / this._wordHeight, scale = rowHeight / _constants_fontSize, columnWidth = this._eachNumWidth * this._canvas.width * scale, vertexPos = [ 0, height, 0, lWidth, height, 0, lWidth, 0, 0, 0, 0, 0 ], vertexindices = [ 0, 2, 1, 0, 3, 2 ], vertexUV = [ 0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0 ], offset = 0, i = 0; i < this._totalLines; i++) for (var j = 0; j < _constants_segmentsPerLine; j++) {
                    vertexPos.push(lWidth + j * columnWidth, height - i * rowHeight, 0), vertexPos.push(lWidth + (j + 1) * columnWidth, height - i * rowHeight, 0), 
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - (i + 1) * rowHeight, 0), 
                    vertexPos.push(lWidth + j * columnWidth, height - (i + 1) * rowHeight, 0), offset = 4 * (i * _constants_segmentsPerLine + j + 1), 
                    vertexindices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
                    var idx = i * _constants_segmentsPerLine + j, z = Math.floor(idx / 4), w = idx - 4 * z;
                    vertexUV.push(0, this._wordHeight, z, w), vertexUV.push(this._eachNumWidth, this._wordHeight, z, w), 
                    vertexUV.push(this._eachNumWidth, 1, z, w), vertexUV.push(0, 1, z, w);
                }
                var modelCom = managerNode.addComponent("cc.ModelComponent");
                modelCom.mesh = createMesh({
                    positions: vertexPos,
                    indices: vertexindices,
                    colors: vertexUV
                });
                var _material = new Material;
                _material.initialize({
                    effectName: "util/profiler"
                }), _material.setProperty("offset", new Vec4(-.9, -.9, this._eachNumWidth, 0));
                var pass = _material.passes[0], handle = pass.getBinding("mainTexture"), binding = pass.getBinding("digits");
                pass.bindTextureView(handle, this._textureView), this.digitsData = pass.blocks[binding], 
                modelCom.material = _material, modelCom.node.layer = Layers.Enum.PROFILER, this._inited = !0;
            }
        }
    }, {
        key: "beforeUpdate",
        value: function beforeUpdate() {
            if (this._stats) {
                var now = performance.now();
                this._stats.frame.counter.end(now), this._stats.frame.counter.start(now), this._stats.logic.counter.start(now);
            }
        }
    }, {
        key: "afterUpdate",
        value: function afterUpdate() {
            if (this._stats) {
                var now = performance.now();
                cc.director.isPaused() ? this._stats.frame.counter.start(now) : this._stats.logic.counter.end(now);
            }
        }
    }, {
        key: "beforePhysics",
        value: function beforePhysics() {
            if (this._stats) {
                var now = performance.now();
                this._stats.physics.counter.start(now);
            }
        }
    }, {
        key: "afterPhysics",
        value: function afterPhysics() {
            if (this._stats) {
                var now = performance.now();
                this._stats.physics.counter.end(now);
            }
        }
    }, {
        key: "beforeDraw",
        value: function beforeDraw() {
            if (this._stats) {
                var now = performance.now();
                this._stats.render.counter.start(now);
            }
        }
    }, {
        key: "afterDraw",
        value: function afterDraw() {
            if (this._stats && this._inited) {
                var now = performance.now();
                if (this._stats.fps.counter.frame(now), this._stats.render.counter.end(now), !(now - this.lastTime < 500)) {
                    this.lastTime = now;
                    var device = this._device;
                    this._stats.draws.counter.value = device.numDrawCalls, this._stats.instances.counter.value = device.numInstances, 
                    this._stats.bufferMemory.counter.value = device.memoryStatus.bufferSize / 1048576, 
                    this._stats.textureMemory.counter.value = device.memoryStatus.textureSize / 1048576, 
                    this._stats.tricount.counter.value = device.numTris;
                    var i = 0, view = this.digitsData.view;
                    for (var id in this._stats) {
                        var stat = this._stats[id];
                        stat.counter.sample(now);
                        for (var result = stat.counter.human().toString(), j = _constants_segmentsPerLine - 1; j >= 0; j--) {
                            var index = i * _constants_segmentsPerLine + j, character = result[result.length - (_constants_segmentsPerLine - j)], offset = _string2offset[character];
                            void 0 === offset && (offset = 11), view[index] = offset;
                        }
                        i++;
                    }
                    this.digitsData.dirty = !0;
                }
            }
        }
    } ]), Profiler;
}(), profiler = new Profiler;

cc.profiler = profiler;

var vmath = {};

function createShader(gl, type, source) {
    var shader = gl.createShader(type);
    if (shader) {
        if (gl.shaderSource(shader, source), gl.compileShader(shader), gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
        console.error("compile shader error", shader), console.log(gl.getShaderInfoLog(shader)), 
        gl.deleteShader(shader);
    } else console.error("create shader error", source);
}

exports.replaceProperty(vmath, "vmath", [ {
    name: "vec2",
    newName: "Vec2",
    target: math,
    targetName: "math"
}, {
    name: "vec3",
    newName: "Vec3",
    target: math,
    targetName: "math"
}, {
    name: "vec4",
    newName: "Vec4",
    target: math,
    targetName: "math"
}, {
    name: "quat",
    newName: "Quat",
    target: math,
    targetName: "math"
}, {
    name: "mat3",
    newName: "Mat3",
    target: math,
    targetName: "math"
}, {
    name: "mat4",
    newName: "Mat4",
    target: math,
    targetName: "math"
}, {
    name: "color4",
    newName: "Color",
    target: math,
    targetName: "math"
}, {
    name: "rect",
    newName: "Rect",
    target: math,
    targetName: "math"
}, {
    name: "approx",
    newName: "approx",
    target: math,
    targetName: "math"
}, {
    name: "EPSILON",
    newName: "EPSILON",
    target: math,
    targetName: "math"
}, {
    name: "equals",
    newName: "equals",
    target: math,
    targetName: "math"
}, {
    name: "clamp",
    newName: "clamp",
    target: math,
    targetName: "math"
}, {
    name: "clamp01",
    newName: "clamp01",
    target: math,
    targetName: "math"
}, {
    name: "lerp",
    newName: "lerp",
    target: math,
    targetName: "math"
}, {
    name: "toRadian",
    newName: "toRadian",
    target: math,
    targetName: "math"
}, {
    name: "toDegree",
    newName: "toDegree",
    target: math,
    targetName: "math"
}, {
    name: "random",
    newName: "random",
    target: math,
    targetName: "math"
}, {
    name: "randomRange",
    newName: "randomRange",
    target: math,
    targetName: "math"
}, {
    name: "randomRangeInt",
    newName: "randomRangeInt",
    target: math,
    targetName: "math"
}, {
    name: "pseudoRandom",
    newName: "pseudoRandom",
    target: math,
    targetName: "math"
}, {
    name: "pseudoRandomRangeInt",
    newName: "pseudoRandomRangeInt",
    target: math,
    targetName: "math"
}, {
    name: "nextPow2",
    newName: "nextPow2",
    target: math,
    targetName: "math"
}, {
    name: "repeat",
    newName: "repeat",
    target: math,
    targetName: "math"
}, {
    name: "pingPong",
    newName: "pingPong",
    target: math,
    targetName: "math"
}, {
    name: "inverseLerp",
    newName: "inverseLerp",
    target: math,
    targetName: "math"
} ]), cc.vmath = vmath, exports.replaceProperty(Scheduler.prototype, "Scheduler.prototype", [ {
    name: "enableForTarget",
    newName: "enableForTarget",
    target: Scheduler,
    targetName: "Scheduler"
} ]), exports.replaceProperty(exports.CameraComponent.prototype, "CameraComponent.prototype", [ {
    name: "color",
    newName: "clearColor"
}, {
    name: "depth",
    newName: "clearDepth"
}, {
    name: "stencil",
    newName: "clearStencil"
} ]), exports.replaceProperty(EventTouch.prototype, "EventTouch.prototype", [ {
    name: "getUILocationInView",
    newName: "getLocationInView",
    target: EventTouch,
    targetName: "EventTouch"
} ]);

var SplashScreenWebgl = function() {
    function SplashScreenWebgl() {
        _classCallCheck(this, SplashScreenWebgl), this.logoImage = new Image, this.textImage = document.createElement("canvas"), 
        this.vertices = new Float32Array([ -1, -1, -1, 1, 1, -1, 1, -1, -1, 1, 1, 1 ]), 
        this.texcoords = new Float32Array([ 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1 ]), this.logoMat33 = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), 
        this.textMat33 = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]), this.callBack = null, 
        this.cancelAnimate = !1, this.handle = -1, this.startTime = -1, this.orientation = "", 
        this.cocosPlayVersion = 134, this._isStart = !1, this._directCall = !1, this._splashFinish = !1, 
        this._loadFinish = !1;
    }
    return _createClass(SplashScreenWebgl, [ {
        key: "_tryToStart",
        value: function _tryToStart() {
            this._splashFinish && this._loadFinish && this.callBack && (this.cancelAnimate = !0, 
            cancelAnimationFrame(this.handle), this.destroy(), this.callBack());
        }
    }, {
        key: "setOnFinish",
        value: function setOnFinish(cb) {
            if ((!this._isStart || this._directCall) && cb) return delete SplashScreenWebgl._ins, 
            cb();
            this.callBack = cb;
        }
    }, {
        key: "main",
        value: function main(canvas) {
            var ccSetting = globalThis._CCSettings;
            if (ccSetting && ccSetting.splashScreen ? (this.setting = ccSetting.splashScreen, 
            this.setting.totalTime = null != this.setting.totalTime ? this.setting.totalTime : 3e3, 
            this.setting.base64src = null != this.setting.base64src ? this.setting.base64src : "", 
            this.setting.effect = null != this.setting.effect ? this.setting.effect : "Fade-InOut", 
            this.setting.clearColor = null != this.setting.clearColor ? this.setting.clearColor : {
                r: .88,
                g: .88,
                b: .88,
                a: 1
            }, this.setting.displayRatio = null != this.setting.displayRatio ? this.setting.displayRatio : .4, 
            this.setting.displayWatermark = null == this.setting.displayWatermark || this.setting.displayWatermark, 
            this.orientation = ccSetting.orientation) : this.setting = {
                totalTime: 3e3,
                base64src: "",
                effect: "Fade-InOut",
                clearColor: {
                    r: .88,
                    g: .88,
                    b: .88,
                    a: 1
                },
                displayRatio: .4,
                displayWatermark: !0
            }, null == canvas || "" == this.setting.base64src || this.setting.totalTime <= 0) return this.callBack && this.callBack(), 
            this.callBack = null, this.setting = null, void (this._directCall = !0);
            cc.view.enableRetina(!0);
            var designRes = ccSetting.designResolution;
            designRes ? cc.view.setDesignResolutionSize(designRes.width, designRes.height, designRes.policy) : cc.view.setDesignResolutionSize(960, 640, 4);
            var useWebGL2 = !!globalThis.WebGL2RenderingContext, userAgent = globalThis.navigator.userAgent.toLowerCase();
            (-1 !== userAgent.indexOf("safari") && -1 === userAgent.indexOf("chrome") || sys.browserType === sys.BROWSER_TYPE_UC) && (useWebGL2 = !1);
            var webGLCtxAttribs = {
                alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                antialias: !0,
                depth: !0,
                stencil: !0,
                premultipliedAlpha: !0,
                preserveDrawingBuffer: !1,
                powerPreference: "default",
                failIfMajorPerformanceCaveat: !1
            }, gl = null, gl2 = null;
            if (useWebGL2 && cc.WebGL2GFXDevice ? null == (gl2 = canvas.getContext("webgl2", webGLCtxAttribs)) && (gl = canvas.getContext("webgl", webGLCtxAttribs)) : gl = canvas.getContext("webgl", webGLCtxAttribs), 
            null == gl && null == gl2) return console.error("this device does not support webgl");
            null != gl && (this.gl = gl), null != gl2 && (this.gl = gl2);
            var textImage = this.textImage;
            textImage.width = 330, textImage.height = 30, textImage.style.width = "".concat(textImage.width), 
            textImage.style.height = "".concat(textImage.height);
            var ctx = textImage.getContext("2d");
            ctx.font = "".concat(18, "px Arial"), ctx.textBaseline = "top", ctx.textAlign = "left", 
            ctx.fillStyle = "`#424242`";
            var text = "Powered by Cocos Creator 3D", textMetrics = ctx.measureText(text);
            ctx.fillText(text, (330 - textMetrics.width) / 2, 6), this.logoImage.onload = this.init.bind(this), 
            this.logoImage.src = this.setting.base64src, this._isStart = !0;
        }
    }, {
        key: "init",
        value: function init() {
            this.initMatrix(), this.initProgram(), this.initBuffer(), this.initTexture(), this.initState();
            var that = this;
            this.handle = requestAnimationFrame((function animate(time) {
                that.cancelAnimate || (void 0 === time && (time = performance.now()), that.frame(time), 
                requestAnimationFrame(animate));
            }));
        }
    }, {
        key: "initMatrix",
        value: function initMatrix() {
            var screenWidth = this.gl.canvas.width, screenHeight = this.gl.canvas.height, displayRatio = this.setting.displayRatio, logoW = this.logoImage.width / 2, logoH = this.logoImage.height / 2, textW = this.textImage.width / 2, textH = this.textImage.height / 2;
            screenWidth < screenHeight ? (logoH = (logoW = screenWidth / 2 * displayRatio) / (this.logoImage.width / this.logoImage.height), 
            textH = (textW = screenWidth / 2 * .5) / (this.textImage.width / this.textImage.height)) : (logoH = (logoW = screenHeight / 2 * displayRatio) / (this.logoImage.width / this.logoImage.height), 
            textH = (textW = screenHeight / 2 * .5) / (this.textImage.width / this.textImage.height)), 
            this.logoMat33[0] = logoW, this.logoMat33[4] = logoH, this.logoMat33[6] = screenWidth / 2, 
            this.logoMat33[7] = screenHeight / 2, this.textMat33[0] = textW, this.textMat33[4] = textH, 
            this.textMat33[6] = screenWidth / 2, this.textMat33[7] = .9 * screenHeight;
        }
    }, {
        key: "initProgram",
        value: function initProgram() {
            var gl = this.gl;
            this.vertexShader = createShader(gl, gl.VERTEX_SHADER, "precision mediump float;attribute vec2 a_position;attribute vec2 a_texCoord;uniform vec2 u_resolution;uniform mat3 u_worldMat;varying vec2 v_texCoord;void main() {vec3 wpos = u_worldMat * vec3(a_position, 1.0);vec2 clipSpace = wpos.xy / u_resolution * 2.0 - 1.0;gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);v_texCoord = a_texCoord;}"), 
            this.fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, "precision mediump float;uniform float u_alpha;uniform sampler2D u_image;varying vec2 v_texCoord;void main(){gl_FragColor = texture2D(u_image,v_texCoord);gl_FragColor.xyz *= clamp(u_alpha, 0.0, 1.0);}"), 
            this.program = function createProgram(gl, vertexShader, fragmentShader) {
                var program = gl.createProgram();
                if (program) {
                    gl.attachShader(program, vertexShader), gl.attachShader(program, fragmentShader), 
                    gl.linkProgram(program);
                    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
                    if (success) return program;
                    console.error("link program error", success), console.log(gl.getProgramInfoLog(program)), 
                    gl.deleteProgram(program);
                } else console.error("create program error");
            }(gl, this.vertexShader, this.fragmentShader);
        }
    }, {
        key: "initBuffer",
        value: function initBuffer() {
            var gl = this.gl;
            gl.useProgram(this.program), this.positionBuffer = gl.createBuffer(), gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer), 
            gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW), this.texcoordBuffer = gl.createBuffer(), 
            gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer), gl.bufferData(gl.ARRAY_BUFFER, this.texcoords, gl.STATIC_DRAW);
            var positionLocation = gl.getAttribLocation(this.program, "a_position");
            gl.enableVertexAttribArray(positionLocation), gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
            var size = 2, type = gl.FLOAT, normalize = !1, stride = 0, offset = 0;
            gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
            var texcoordLocation = gl.getAttribLocation(this.program, "a_texCoord");
            gl.enableVertexAttribArray(texcoordLocation), gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
            size = 2, type = gl.FLOAT, normalize = !1, stride = 0, offset = 0;
            gl.vertexAttribPointer(texcoordLocation, size, type, normalize, stride, offset);
        }
    }, {
        key: "initTexture",
        value: function initTexture() {
            var gl = this.gl;
            this.textureLogo = gl.createTexture(), gl.bindTexture(gl.TEXTURE_2D, this.textureLogo), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), 
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.logoImage), 
            this.textureText = gl.createTexture(), gl.bindTexture(gl.TEXTURE_2D, this.textureText), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE), 
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR), gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR), 
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.textImage);
        }
    }, {
        key: "initState",
        value: function initState() {
            var gl = this.gl;
            gl.useProgram(this.program);
            var resolutionLocation = gl.getUniformLocation(this.program, "u_resolution");
            gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height), gl.enable(gl.BLEND), 
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        }
    }, {
        key: "frame",
        value: function frame(time) {
            var gl = this.gl, program = this.program, textureLogo = this.textureLogo, textureText = this.textureText, clearColor = this.setting.clearColor, logoMat33 = this.logoMat33, textMat33 = this.textMat33;
            this.startTime < 0 && (this.startTime = time);
            var elapsedTime = time - this.startTime, alpha = cubicOut(clamp01(elapsedTime / this.setting.totalTime));
            gl.enable(gl.BLEND), gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height), gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), 
            gl.depthMask(!0), gl.clearDepth(1), gl.clearStencil(0), gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT), 
            gl.useProgram(this.program);
            var resolutionLocation = gl.getUniformLocation(this.program, "u_resolution");
            gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
            var location = gl.getUniformLocation(program, "u_alpha");
            gl.uniform1f(location, alpha), location = gl.getUniformLocation(program, "u_worldMat"), 
            gl.uniformMatrix3fv(location, !1, logoMat33), gl.bindTexture(gl.TEXTURE_2D, textureLogo), 
            gl.drawArrays(gl.TRIANGLES, 0, 6), this.setting.displayWatermark && (gl.uniformMatrix3fv(location, !1, textMat33), 
            gl.bindTexture(gl.TEXTURE_2D, textureText), gl.drawArrays(gl.TRIANGLES, 0, 6)), 
            elapsedTime > this.setting.totalTime && (this.splashFinish = !0);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            delete SplashScreenWebgl._ins, this.gl.deleteProgram(this.program), this.gl.deleteShader(this.vertexShader), 
            this.gl.deleteShader(this.fragmentShader), this.gl.deleteBuffer(this.positionBuffer), 
            this.gl.deleteBuffer(this.texcoordBuffer), this.gl.deleteTexture(this.textureLogo), 
            this.gl.deleteTexture(this.textureText);
            var device = game._gfxDevice;
            if (device && device.stateCache) for (var glTexUnits = device.stateCache.glTexUnits, i = 0; i < glTexUnits.length; i++) null != glTexUnits[i] && (glTexUnits[i].glTexture = null);
        }
    }, {
        key: "loadFinish",
        set: function set(v) {
            this._loadFinish = v, this._tryToStart();
        }
    }, {
        key: "splashFinish",
        set: function set(v) {
            this._splashFinish = v, this._tryToStart();
        }
    } ], [ {
        key: "instance",
        get: function get() {
            return null == SplashScreenWebgl._ins && (SplashScreenWebgl._ins = new SplashScreenWebgl), 
            SplashScreenWebgl._ins;
        }
    } ]), SplashScreenWebgl;
}();

SplashScreenWebgl._ins = void 0, cc.internal.SplashScreenWebgl = SplashScreenWebgl, 
cc.math = math, cc.geometry = geometry;

var _dec$15, _dec2$I, _class$16, _class2$Z, _descriptor$Q, _descriptor2$E, _class3$k, _temp$10, PrimitiveType$1, NodePool = function() {
    function NodePool(poolHandlerComp) {
        _classCallCheck(this, NodePool), this.poolHandlerComp = void 0, this._pool = void 0, 
        this.poolHandlerComp = poolHandlerComp, this._pool = [];
    }
    return _createClass(NodePool, [ {
        key: "size",
        value: function size() {
            return this._pool.length;
        }
    }, {
        key: "clear",
        value: function clear() {
            for (var count = this._pool.length, i = 0; i < count; ++i) this._pool[i].destroy();
            this._pool.length = 0;
        }
    }, {
        key: "put",
        value: function put(obj) {
            if (obj && -1 === this._pool.indexOf(obj)) {
                obj.removeFromParent();
                var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                handler && handler.unuse && handler.unuse(), this._pool.push(obj);
            }
        }
    }, {
        key: "get",
        value: function get() {
            var last = this._pool.length - 1;
            if (last < 0) return null;
            var obj = this._pool[last];
            this._pool.length = last;
            var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
            if (handler && handler.reuse) {
                for (var _handler$reuse, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                (_handler$reuse = handler.reuse).apply.apply(_handler$reuse, [ handler ].concat(args));
            }
            return obj;
        }
    } ]), NodePool;
}();

cc.NodePool = NodePool, function(PrimitiveType) {
    PrimitiveType[PrimitiveType.BOX = 0] = "BOX", PrimitiveType[PrimitiveType.SPHERE = 1] = "SPHERE", 
    PrimitiveType[PrimitiveType.CYLINDER = 2] = "CYLINDER", PrimitiveType[PrimitiveType.CONE = 3] = "CONE", 
    PrimitiveType[PrimitiveType.CAPSULE = 4] = "CAPSULE", PrimitiveType[PrimitiveType.TORUS = 5] = "TORUS", 
    PrimitiveType[PrimitiveType.PLANE = 6] = "PLANE", PrimitiveType[PrimitiveType.QUAD = 7] = "QUAD";
}(PrimitiveType$1 || (PrimitiveType$1 = {})), ccenum(PrimitiveType$1), exports.Primitive = (_dec$15 = ccclass("cc.Primitive"), 
_dec2$I = property({
    type: PrimitiveType$1
}), _dec$15((_temp$10 = _class3$k = function(_Mesh) {
    function Primitive() {
        var _this, type = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : PrimitiveType$1.BOX;
        return _classCallCheck(this, Primitive), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(Primitive).call(this)), "type", _descriptor$Q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "info", _descriptor2$E, _assertThisInitialized(_this)), 
        _this.type = type, _this;
    }
    return _inherits(Primitive, Mesh), _createClass(Primitive, [ {
        key: "onLoaded",
        value: function onLoaded() {
            createMesh(primitives[PrimitiveType$1[this.type].toLowerCase()](this.info), this);
        }
    } ]), Primitive;
}(), _class3$k.PrimitiveType = PrimitiveType$1, _descriptor$Q = _applyDecoratedDescriptor((_class2$Z = _temp$10).prototype, "type", [ _dec2$I ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return PrimitiveType$1.BOX;
    }
}), _descriptor2$E = _applyDecoratedDescriptor(_class2$Z.prototype, "info", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return {};
    }
}), _class$16 = _class2$Z)) || _class$16), exports.Primitive || (exports.Primitive = {}), 
cc.Primitive = exports.Primitive, cc.renderer = renderer;

var cclegacy = cc;

cc.primitives = primitives;

var WebGLEXT, WebGLGFXBindingLayout = function(_GFXBindingLayout) {
    function WebGLGFXBindingLayout() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXBindingLayout);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXBindingLayout)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuBindingLayout = null, 
        _this;
    }
    return _inherits(WebGLGFXBindingLayout, GFXBindingLayout), _createClass(WebGLGFXBindingLayout, [ {
        key: "initialize",
        value: function initialize(info) {
            this._bindingUnits = new Array(info.bindings.length);
            for (var i = 0; i < info.bindings.length; ++i) {
                var binding = info.bindings[i];
                this._bindingUnits[i] = {
                    binding: binding.binding,
                    type: binding.bindingType,
                    name: binding.name,
                    buffer: null,
                    texView: null,
                    sampler: null
                };
            }
            this._gpuBindingLayout = {
                gpuBindings: new Array(info.bindings.length)
            };
            for (var _i = 0; _i < info.bindings.length; ++_i) {
                var _binding = info.bindings[_i];
                this._gpuBindingLayout.gpuBindings[_i] = {
                    binding: _binding.binding,
                    type: _binding.bindingType,
                    name: _binding.name,
                    gpuBuffer: null,
                    gpuTexView: null,
                    gpuSampler: null
                };
            }
            return this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuBindingLayout = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "update",
        value: function update() {
            if (this._isDirty && this._gpuBindingLayout) {
                for (var i = 0; i < this._bindingUnits.length; ++i) {
                    var bindingUnit = this._bindingUnits[i];
                    switch (bindingUnit.type) {
                      case exports.GFXBindingType.UNIFORM_BUFFER:
                        bindingUnit.buffer && (this._gpuBindingLayout.gpuBindings[i].gpuBuffer = bindingUnit.buffer.gpuBuffer);
                        break;

                      case exports.GFXBindingType.SAMPLER:
                        bindingUnit.texView && (this._gpuBindingLayout.gpuBindings[i].gpuTexView = bindingUnit.texView.gpuTextureView), 
                        bindingUnit.sampler && (this._gpuBindingLayout.gpuBindings[i].gpuSampler = bindingUnit.sampler.gpuSampler);
                    }
                }
                this._isDirty = !1;
            }
        }
    }, {
        key: "gpuBindingLayout",
        get: function get() {
            return this._gpuBindingLayout;
        }
    } ]), WebGLGFXBindingLayout;
}();

function GFXFormatToWebGLType(format, gl) {
    switch (format) {
      case exports.GFXFormat.R8:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.R8SN:
        return gl.BYTE;

      case exports.GFXFormat.R8UI:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.R8I:
        return gl.BYTE;

      case exports.GFXFormat.R16F:
        return WebGLEXT.HALF_FLOAT_OES;

      case exports.GFXFormat.R16UI:
        return gl.UNSIGNED_SHORT;

      case exports.GFXFormat.R16I:
        return gl.SHORT;

      case exports.GFXFormat.R32F:
        return gl.FLOAT;

      case exports.GFXFormat.R32UI:
        return gl.UNSIGNED_INT;

      case exports.GFXFormat.R32I:
        return gl.INT;

      case exports.GFXFormat.RG8:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.RG8SN:
        return gl.BYTE;

      case exports.GFXFormat.RG8UI:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.RG8I:
        return gl.BYTE;

      case exports.GFXFormat.RG16F:
        return WebGLEXT.HALF_FLOAT_OES;

      case exports.GFXFormat.RG16UI:
        return gl.UNSIGNED_SHORT;

      case exports.GFXFormat.RG16I:
        return gl.SHORT;

      case exports.GFXFormat.RG32F:
        return gl.FLOAT;

      case exports.GFXFormat.RG32UI:
        return gl.UNSIGNED_INT;

      case exports.GFXFormat.RG32I:
        return gl.INT;

      case exports.GFXFormat.RGB8:
      case exports.GFXFormat.SRGB8:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.RGB8SN:
        return gl.BYTE;

      case exports.GFXFormat.RGB8UI:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.RGB8I:
        return gl.BYTE;

      case exports.GFXFormat.RGB16F:
        return WebGLEXT.HALF_FLOAT_OES;

      case exports.GFXFormat.RGB16UI:
        return gl.UNSIGNED_SHORT;

      case exports.GFXFormat.RGB16I:
        return gl.SHORT;

      case exports.GFXFormat.RGB32F:
        return gl.FLOAT;

      case exports.GFXFormat.RGB32UI:
        return gl.UNSIGNED_INT;

      case exports.GFXFormat.RGB32I:
        return gl.INT;

      case exports.GFXFormat.RGBA8:
      case exports.GFXFormat.SRGB8_A8:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.RGBA8SN:
        return gl.BYTE;

      case exports.GFXFormat.RGBA8UI:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.RGBA8I:
        return gl.BYTE;

      case exports.GFXFormat.RGBA16F:
        return WebGLEXT.HALF_FLOAT_OES;

      case exports.GFXFormat.RGBA16UI:
        return gl.UNSIGNED_SHORT;

      case exports.GFXFormat.RGBA16I:
        return gl.SHORT;

      case exports.GFXFormat.RGBA32F:
        return gl.FLOAT;

      case exports.GFXFormat.RGBA32UI:
        return gl.UNSIGNED_INT;

      case exports.GFXFormat.RGBA32I:
        return gl.INT;

      case exports.GFXFormat.R5G6B5:
        return gl.UNSIGNED_SHORT_5_6_5;

      case exports.GFXFormat.R11G11B10F:
        return gl.FLOAT;

      case exports.GFXFormat.RGB5A1:
        return gl.UNSIGNED_SHORT_5_5_5_1;

      case exports.GFXFormat.RGBA4:
        return gl.UNSIGNED_SHORT_4_4_4_4;

      case exports.GFXFormat.RGB10A2:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.RGB10A2UI:
        return gl.UNSIGNED_INT;

      case exports.GFXFormat.RGB9E5:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.D16:
        return gl.UNSIGNED_SHORT;

      case exports.GFXFormat.D16S8:
        return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

      case exports.GFXFormat.D24:
        return gl.UNSIGNED_INT;

      case exports.GFXFormat.D24S8:
        return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

      case exports.GFXFormat.D32F:
        return gl.FLOAT;

      case exports.GFXFormat.D32F_S8:
        return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

      case exports.GFXFormat.BC1:
      case exports.GFXFormat.BC1_SRGB:
      case exports.GFXFormat.BC2:
      case exports.GFXFormat.BC2_SRGB:
      case exports.GFXFormat.BC3:
      case exports.GFXFormat.BC3_SRGB:
      case exports.GFXFormat.BC4:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.BC4_SNORM:
        return gl.BYTE;

      case exports.GFXFormat.BC5:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.BC5_SNORM:
        return gl.BYTE;

      case exports.GFXFormat.BC6H_SF16:
      case exports.GFXFormat.BC6H_UF16:
        return gl.FLOAT;

      case exports.GFXFormat.BC7:
      case exports.GFXFormat.BC7_SRGB:
      case exports.GFXFormat.ETC_RGB8:
      case exports.GFXFormat.ETC2_RGB8:
      case exports.GFXFormat.ETC2_SRGB8:
      case exports.GFXFormat.ETC2_RGB8_A1:
      case exports.GFXFormat.ETC2_SRGB8_A1:
      case exports.GFXFormat.ETC2_RGB8:
      case exports.GFXFormat.ETC2_SRGB8:
      case exports.GFXFormat.EAC_R11:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.EAC_R11SN:
        return gl.BYTE;

      case exports.GFXFormat.EAC_RG11:
        return gl.UNSIGNED_BYTE;

      case exports.GFXFormat.EAC_RG11SN:
        return gl.BYTE;

      case exports.GFXFormat.PVRTC_RGB2:
      case exports.GFXFormat.PVRTC_RGBA2:
      case exports.GFXFormat.PVRTC_RGB4:
      case exports.GFXFormat.PVRTC_RGBA4:
      case exports.GFXFormat.PVRTC2_2BPP:
      case exports.GFXFormat.PVRTC2_4BPP:
      default:
        return gl.UNSIGNED_BYTE;
    }
}

function GFXFormatToWebGLInternalFormat(format, gl) {
    switch (format) {
      case exports.GFXFormat.A8:
        return gl.ALPHA;

      case exports.GFXFormat.L8:
        return gl.LUMINANCE;

      case exports.GFXFormat.LA8:
        return gl.LUMINANCE_ALPHA;

      case exports.GFXFormat.RGB8:
      case exports.GFXFormat.RGB16F:
      case exports.GFXFormat.RGB32F:
        return gl.RGB;

      case exports.GFXFormat.RGBA8:
      case exports.GFXFormat.RGBA16F:
      case exports.GFXFormat.RGBA32F:
        return gl.RGBA;

      case exports.GFXFormat.R5G6B5:
        return gl.RGB565;

      case exports.GFXFormat.RGB5A1:
        return gl.RGB5_A1;

      case exports.GFXFormat.RGBA4:
        return gl.RGBA4;

      case exports.GFXFormat.D16:
        return gl.DEPTH_COMPONENT;

      case exports.GFXFormat.D16S8:
        return gl.DEPTH_STENCIL;

      case exports.GFXFormat.D24:
        return gl.DEPTH_COMPONENT;

      case exports.GFXFormat.D24S8:
        return gl.DEPTH_STENCIL;

      case exports.GFXFormat.D32F:
        return gl.DEPTH_COMPONENT;

      case exports.GFXFormat.D32F_S8:
        return gl.DEPTH_STENCIL;

      case exports.GFXFormat.BC1:
        return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

      case exports.GFXFormat.BC1_ALPHA:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

      case exports.GFXFormat.BC1_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

      case exports.GFXFormat.BC1_SRGB_ALPHA:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

      case exports.GFXFormat.BC2:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

      case exports.GFXFormat.BC2_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

      case exports.GFXFormat.BC3:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

      case exports.GFXFormat.BC3_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

      case exports.GFXFormat.ETC_RGB8:
        return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

      case exports.GFXFormat.ETC2_RGB8:
        return WebGLEXT.COMPRESSED_RGB8_ETC2;

      case exports.GFXFormat.ETC2_SRGB8:
        return WebGLEXT.COMPRESSED_SRGB8_ETC2;

      case exports.GFXFormat.ETC2_RGB8_A1:
        return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

      case exports.GFXFormat.ETC2_SRGB8_A1:
        return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

      case exports.GFXFormat.ETC2_RGBA8:
        return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

      case exports.GFXFormat.ETC2_SRGB8_A8:
        return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

      case exports.GFXFormat.EAC_R11:
        return WebGLEXT.COMPRESSED_R11_EAC;

      case exports.GFXFormat.EAC_R11SN:
        return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

      case exports.GFXFormat.EAC_RG11:
        return WebGLEXT.COMPRESSED_RG11_EAC;

      case exports.GFXFormat.EAC_RG11SN:
        return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

      case exports.GFXFormat.PVRTC_RGB2:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

      case exports.GFXFormat.PVRTC_RGBA2:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

      case exports.GFXFormat.PVRTC_RGB4:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

      case exports.GFXFormat.PVRTC_RGBA4:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

      default:
        return console.error("Unsupported GFXFormat, convert to WebGL internal format failed."), 
        gl.RGBA;
    }
}

function GFXFormatToWebGLFormat(format, gl) {
    switch (format) {
      case exports.GFXFormat.A8:
        return gl.ALPHA;

      case exports.GFXFormat.L8:
        return gl.LUMINANCE;

      case exports.GFXFormat.LA8:
        return gl.LUMINANCE_ALPHA;

      case exports.GFXFormat.RGB8:
      case exports.GFXFormat.RGB16F:
      case exports.GFXFormat.RGB32F:
        return gl.RGB;

      case exports.GFXFormat.RGBA8:
      case exports.GFXFormat.RGBA16F:
      case exports.GFXFormat.RGBA32F:
        return gl.RGBA;

      case exports.GFXFormat.R5G6B5:
        return gl.RGB;

      case exports.GFXFormat.RGB5A1:
      case exports.GFXFormat.RGBA4:
        return gl.RGBA;

      case exports.GFXFormat.D16:
        return gl.DEPTH_COMPONENT;

      case exports.GFXFormat.D16S8:
        return gl.DEPTH_STENCIL;

      case exports.GFXFormat.D24:
        return gl.DEPTH_COMPONENT;

      case exports.GFXFormat.D24S8:
        return gl.DEPTH_STENCIL;

      case exports.GFXFormat.D32F:
        return gl.DEPTH_COMPONENT;

      case exports.GFXFormat.D32F_S8:
        return gl.DEPTH_STENCIL;

      case exports.GFXFormat.BC1:
        return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

      case exports.GFXFormat.BC1_ALPHA:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

      case exports.GFXFormat.BC1_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

      case exports.GFXFormat.BC1_SRGB_ALPHA:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

      case exports.GFXFormat.BC2:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

      case exports.GFXFormat.BC2_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

      case exports.GFXFormat.BC3:
        return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

      case exports.GFXFormat.BC3_SRGB:
        return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

      case exports.GFXFormat.ETC_RGB8:
        return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

      case exports.GFXFormat.ETC2_RGB8:
        return WebGLEXT.COMPRESSED_RGB8_ETC2;

      case exports.GFXFormat.ETC2_SRGB8:
        return WebGLEXT.COMPRESSED_SRGB8_ETC2;

      case exports.GFXFormat.ETC2_RGB8_A1:
        return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

      case exports.GFXFormat.ETC2_SRGB8_A1:
        return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

      case exports.GFXFormat.ETC2_RGBA8:
        return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

      case exports.GFXFormat.ETC2_SRGB8_A8:
        return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

      case exports.GFXFormat.EAC_R11:
        return WebGLEXT.COMPRESSED_R11_EAC;

      case exports.GFXFormat.EAC_R11SN:
        return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

      case exports.GFXFormat.EAC_RG11:
        return WebGLEXT.COMPRESSED_RG11_EAC;

      case exports.GFXFormat.EAC_RG11SN:
        return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

      case exports.GFXFormat.PVRTC_RGB2:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

      case exports.GFXFormat.PVRTC_RGBA2:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

      case exports.GFXFormat.PVRTC_RGB4:
        return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

      case exports.GFXFormat.PVRTC_RGBA4:
        return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

      default:
        return console.error("Unsupported GFXFormat, convert to WebGL format failed."), 
        gl.RGBA;
    }
}

function GFXTypeToWebGLType(type, gl) {
    switch (type) {
      case exports.GFXType.BOOL:
        return gl.BOOL;

      case exports.GFXType.BOOL2:
        return gl.BOOL_VEC2;

      case exports.GFXType.BOOL3:
        return gl.BOOL_VEC3;

      case exports.GFXType.BOOL4:
        return gl.BOOL_VEC4;

      case exports.GFXType.INT:
        return gl.INT;

      case exports.GFXType.INT2:
        return gl.INT_VEC2;

      case exports.GFXType.INT3:
        return gl.INT_VEC3;

      case exports.GFXType.INT4:
        return gl.INT_VEC4;

      case exports.GFXType.UINT:
        return gl.UNSIGNED_INT;

      case exports.GFXType.FLOAT:
        return gl.FLOAT;

      case exports.GFXType.FLOAT2:
        return gl.FLOAT_VEC2;

      case exports.GFXType.FLOAT3:
        return gl.FLOAT_VEC3;

      case exports.GFXType.FLOAT4:
        return gl.FLOAT_VEC4;

      case exports.GFXType.MAT2:
        return gl.FLOAT_MAT2;

      case exports.GFXType.MAT3:
        return gl.FLOAT_MAT3;

      case exports.GFXType.MAT4:
        return gl.FLOAT_MAT4;

      case exports.GFXType.SAMPLER2D:
        return gl.SAMPLER_2D;

      case exports.GFXType.SAMPLER_CUBE:
        return gl.SAMPLER_CUBE;

      default:
        return console.error("Unsupported GLType, convert to GL type failed."), exports.GFXType.UNKNOWN;
    }
}

function WebGLTypeToGFXType(glType, gl) {
    switch (glType) {
      case gl.BOOL:
        return exports.GFXType.BOOL;

      case gl.BOOL_VEC2:
        return exports.GFXType.BOOL2;

      case gl.BOOL_VEC3:
        return exports.GFXType.BOOL3;

      case gl.BOOL_VEC4:
        return exports.GFXType.BOOL4;

      case gl.INT:
        return exports.GFXType.INT;

      case gl.INT_VEC2:
        return exports.GFXType.INT2;

      case gl.INT_VEC3:
        return exports.GFXType.INT3;

      case gl.INT_VEC4:
        return exports.GFXType.INT4;

      case gl.UNSIGNED_INT:
        return exports.GFXType.UINT;

      case gl.FLOAT:
        return exports.GFXType.FLOAT;

      case gl.FLOAT_VEC2:
        return exports.GFXType.FLOAT2;

      case gl.FLOAT_VEC3:
        return exports.GFXType.FLOAT3;

      case gl.FLOAT_VEC4:
        return exports.GFXType.FLOAT4;

      case gl.FLOAT_MAT2:
        return exports.GFXType.MAT2;

      case gl.FLOAT_MAT3:
        return exports.GFXType.MAT3;

      case gl.FLOAT_MAT4:
        return exports.GFXType.MAT4;

      case gl.SAMPLER_2D:
        return exports.GFXType.SAMPLER2D;

      case gl.SAMPLER_CUBE:
        return exports.GFXType.SAMPLER_CUBE;

      default:
        return console.error("Unsupported GLType, convert to GFXType failed."), exports.GFXType.UNKNOWN;
    }
}

function WebGLGetTypeSize(glType, gl) {
    switch (glType) {
      case gl.BOOL:
        return 4;

      case gl.BOOL_VEC2:
        return 8;

      case gl.BOOL_VEC3:
        return 12;

      case gl.BOOL_VEC4:
        return 16;

      case gl.INT:
        return 4;

      case gl.INT_VEC2:
        return 8;

      case gl.INT_VEC3:
        return 12;

      case gl.INT_VEC4:
        return 16;

      case gl.UNSIGNED_INT:
      case gl.FLOAT:
        return 4;

      case gl.FLOAT_VEC2:
        return 8;

      case gl.FLOAT_VEC3:
        return 12;

      case gl.FLOAT_VEC4:
      case gl.FLOAT_MAT2:
        return 16;

      case gl.FLOAT_MAT3:
        return 36;

      case gl.FLOAT_MAT4:
        return 64;

      case gl.SAMPLER_2D:
      case gl.SAMPLER_CUBE:
        return 4;

      default:
        return console.error("Unsupported GLType, get type failed."), 0;
    }
}

function WebGLGetComponentCount(glType, gl) {
    switch (glType) {
      case gl.FLOAT_MAT2:
        return 2;

      case gl.FLOAT_MAT3:
        return 3;

      case gl.FLOAT_MAT4:
        return 4;

      default:
        return 1;
    }
}

!function(WebGLEXT) {
    WebGLEXT[WebGLEXT.RGBA16F_EXT = 34842] = "RGBA16F_EXT", WebGLEXT[WebGLEXT.RGB16F_EXT = 34843] = "RGB16F_EXT", 
    WebGLEXT[WebGLEXT.RGBA32F_EXT = 34836] = "RGBA32F_EXT", WebGLEXT[WebGLEXT.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT", 
    WebGLEXT[WebGLEXT.UNSIGNED_NORMALIZED_EXT = 35863] = "UNSIGNED_NORMALIZED_EXT", 
    WebGLEXT[WebGLEXT.UNSIGNED_INT_24_8_WEBGL = 34042] = "UNSIGNED_INT_24_8_WEBGL", 
    WebGLEXT[WebGLEXT.HALF_FLOAT_OES = 36193] = "HALF_FLOAT_OES", WebGLEXT[WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", 
    WebGLEXT[WebGLEXT.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", 
    WebGLEXT[WebGLEXT.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", WebGLEXT[WebGLEXT.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", 
    WebGLEXT[WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", 
    WebGLEXT[WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
}(WebGLEXT || (WebGLEXT = {}));

var WebGLCmd, WebGLCmpFuncs = [ 512, 513, 514, 515, 516, 517, 518, 519 ], WebGLStencilOps = [ 0, 7680, 7681, 7682, 7683, 5386, 34055, 34056 ], WebGLBlendOps = [ 32774, 32778, 32779, 32774, 32774 ], WebGLBlendFactors = [ 0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772 ];

!function(WebGLCmd) {
    WebGLCmd[WebGLCmd.BEGIN_RENDER_PASS = 0] = "BEGIN_RENDER_PASS", WebGLCmd[WebGLCmd.END_RENDER_PASS = 1] = "END_RENDER_PASS", 
    WebGLCmd[WebGLCmd.BIND_STATES = 2] = "BIND_STATES", WebGLCmd[WebGLCmd.DRAW = 3] = "DRAW", 
    WebGLCmd[WebGLCmd.UPDATE_BUFFER = 4] = "UPDATE_BUFFER", WebGLCmd[WebGLCmd.COPY_BUFFER_TO_TEXTURE = 5] = "COPY_BUFFER_TO_TEXTURE", 
    WebGLCmd[WebGLCmd.COUNT = 6] = "COUNT";
}(WebGLCmd || (WebGLCmd = {}));

var WebGLCmdObject = function WebGLCmdObject(type) {
    _classCallCheck(this, WebGLCmdObject), this.cmdType = void 0, this.refCount = 0, 
    this.cmdType = type;
}, WebGLCmdBeginRenderPass = function(_WebGLCmdObject) {
    function WebGLCmdBeginRenderPass() {
        var _this;
        return _classCallCheck(this, WebGLCmdBeginRenderPass), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBeginRenderPass).call(this, WebGLCmd.BEGIN_RENDER_PASS))).gpuFramebuffer = null, 
        _this.renderArea = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }, _this.clearFlag = exports.GFXClearFlag.NONE, _this.clearColors = [], _this.clearDepth = 1, 
        _this.clearStencil = 0, _this;
    }
    return _inherits(WebGLCmdBeginRenderPass, WebGLCmdObject), _createClass(WebGLCmdBeginRenderPass, [ {
        key: "clear",
        value: function clear() {
            this.gpuFramebuffer = null, this.clearColors.length = 0;
        }
    } ]), WebGLCmdBeginRenderPass;
}(), WebGLCmdBindStates = function(_WebGLCmdObject2) {
    function WebGLCmdBindStates() {
        var _this2;
        return _classCallCheck(this, WebGLCmdBindStates), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdBindStates).call(this, WebGLCmd.BIND_STATES))).gpuPipelineState = null, 
        _this2.gpuBindingLayout = null, _this2.gpuInputAssembler = null, _this2.viewport = null, 
        _this2.scissor = null, _this2.lineWidth = null, _this2.depthBias = null, _this2.blendConstants = null, 
        _this2.depthBounds = null, _this2.stencilWriteMask = null, _this2.stencilCompareMask = null, 
        _this2;
    }
    return _inherits(WebGLCmdBindStates, WebGLCmdObject), _createClass(WebGLCmdBindStates, [ {
        key: "clear",
        value: function clear() {
            this.gpuPipelineState = null, this.gpuBindingLayout = null, this.gpuInputAssembler = null, 
            this.viewport = null, this.scissor = null, this.lineWidth = null, this.depthBias = null, 
            this.blendConstants = null, this.depthBounds = null, this.stencilWriteMask = null, 
            this.stencilCompareMask = null;
        }
    } ]), WebGLCmdBindStates;
}(), WebGLCmdDraw = function(_WebGLCmdObject3) {
    function WebGLCmdDraw() {
        var _this3;
        return _classCallCheck(this, WebGLCmdDraw), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdDraw).call(this, WebGLCmd.DRAW))).drawInfo = {
            vertexCount: 0,
            firstVertex: 0,
            indexCount: 0,
            firstIndex: 0,
            vertexOffset: 0,
            instanceCount: 0,
            firstInstance: 0
        }, _this3;
    }
    return _inherits(WebGLCmdDraw, WebGLCmdObject), _createClass(WebGLCmdDraw, [ {
        key: "clear",
        value: function clear() {}
    } ]), WebGLCmdDraw;
}(), WebGLCmdUpdateBuffer = function(_WebGLCmdObject4) {
    function WebGLCmdUpdateBuffer() {
        var _this4;
        return _classCallCheck(this, WebGLCmdUpdateBuffer), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdUpdateBuffer).call(this, WebGLCmd.UPDATE_BUFFER))).gpuBuffer = null, 
        _this4.buffer = null, _this4.offset = 0, _this4.size = 0, _this4;
    }
    return _inherits(WebGLCmdUpdateBuffer, WebGLCmdObject), _createClass(WebGLCmdUpdateBuffer, [ {
        key: "clear",
        value: function clear() {
            this.gpuBuffer = null, this.buffer = null;
        }
    } ]), WebGLCmdUpdateBuffer;
}(), WebGLCmdCopyBufferToTexture = function(_WebGLCmdObject5) {
    function WebGLCmdCopyBufferToTexture() {
        var _this5;
        return _classCallCheck(this, WebGLCmdCopyBufferToTexture), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(WebGLCmdCopyBufferToTexture).call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE))).gpuBuffer = null, 
        _this5.gpuTexture = null, _this5.dstLayout = null, _this5.regions = [], _this5;
    }
    return _inherits(WebGLCmdCopyBufferToTexture, WebGLCmdObject), _createClass(WebGLCmdCopyBufferToTexture, [ {
        key: "clear",
        value: function clear() {
            this.gpuBuffer = null, this.gpuTexture = null, this.dstLayout = null, this.regions.length = 0;
        }
    } ]), WebGLCmdCopyBufferToTexture;
}(), WebGLCmdPackage = function() {
    function WebGLCmdPackage() {
        _classCallCheck(this, WebGLCmdPackage), this.cmds = new CachedArray(1), this.beginRenderPassCmds = new CachedArray(1), 
        this.bindStatesCmds = new CachedArray(1), this.drawCmds = new CachedArray(1), this.updateBufferCmds = new CachedArray(1), 
        this.copyBufferToTextureCmds = new CachedArray(1);
    }
    return _createClass(WebGLCmdPackage, [ {
        key: "clearCmds",
        value: function clearCmds(allocator) {
            this.beginRenderPassCmds.length && (allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds), 
            this.beginRenderPassCmds.clear()), this.bindStatesCmds.length && (allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds), 
            this.bindStatesCmds.clear()), this.drawCmds.length && (allocator.drawCmdPool.freeCmds(this.drawCmds), 
            this.drawCmds.clear()), this.updateBufferCmds.length && (allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds), 
            this.updateBufferCmds.clear()), this.copyBufferToTextureCmds.length && (allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds), 
            this.copyBufferToTextureCmds.clear()), this.cmds.clear();
        }
    } ]), WebGLCmdPackage;
}();

function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
    if (gpuBuffer.usage & exports.GFXBufferUsageBit.UNIFORM) ArrayBuffer.isView(buffer) ? gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT) : gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT); else if (gpuBuffer.usage & exports.GFXBufferUsageBit.INDIRECT) gpuBuffer.indirects = buffer.drawInfos; else {
        var buff = buffer, gl = device.gl, cache = device.stateCache;
        switch (gpuBuffer.glTarget) {
          case gl.ARRAY_BUFFER:
            device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
            cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
            device.stateCache.glArrayBuffer = gpuBuffer.glBuffer);
            break;

          case gl.ELEMENT_ARRAY_BUFFER:
            device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
            cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
            device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer);
            break;

          default:
            return void console.error("Unsupported GFXBufferType, update buffer failed.");
        }
        size === buff.byteLength ? gl.bufferSubData(gpuBuffer.glTarget, offset, buff) : gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
    }
}

var gfxStateCache = {
    gpuInputAssembler: null,
    gpuShader: null,
    glPrimitive: 0
};

function WebGLCmdFuncBeginRenderPass(device, gpuFramebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
    gfxStateCache.gpuInputAssembler = null, gfxStateCache.gpuShader = null;
    var gl = device.gl, cache = device.stateCache, clears = 0;
    if (gpuFramebuffer) {
        cache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
        cache.glFramebuffer = gpuFramebuffer.glFramebuffer), cache.viewport.left === renderArea.x && cache.viewport.top === renderArea.y && cache.viewport.width === renderArea.width && cache.viewport.height === renderArea.height || (gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height), 
        cache.viewport.left = renderArea.x, cache.viewport.top = renderArea.y, cache.viewport.width = renderArea.width, 
        cache.viewport.height = renderArea.height), cache.scissorRect.x === renderArea.x && cache.scissorRect.y === renderArea.y && cache.scissorRect.width === renderArea.width && cache.scissorRect.height === renderArea.height || (gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height), 
        cache.scissorRect.x = renderArea.x, cache.scissorRect.y = renderArea.y, cache.scissorRect.width = renderArea.width, 
        cache.scissorRect.height = renderArea.height);
        var curGPURenderPass = gpuFramebuffer.gpuRenderPass, clearCount = clearColors.length;
        device.WEBGL_draw_buffers || (clearCount = 1);
        for (var j = 0; j < clearCount; ++j) {
            var colorAttachment = curGPURenderPass.colorAttachments[j];
            if (colorAttachment.format !== exports.GFXFormat.UNKNOWN) switch (colorAttachment.loadOp) {
              case exports.GFXLoadOp.LOAD:
                break;

              case exports.GFXLoadOp.CLEAR:
                if (clearFlag & exports.GFXClearFlag.COLOR) {
                    cache.bs.targets[0].blendColorMask !== exports.GFXColorMask.ALL && gl.colorMask(!0, !0, !0, !0);
                    var clearColor = clearColors[0];
                    gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a), clears |= gl.COLOR_BUFFER_BIT;
                }
                break;

              case exports.GFXLoadOp.DISCARD:
            }
        }
        if (curGPURenderPass.depthStencilAttachment && curGPURenderPass.depthStencilAttachment.format !== exports.GFXFormat.UNKNOWN) {
            switch (curGPURenderPass.depthStencilAttachment.depthLoadOp) {
              case exports.GFXLoadOp.LOAD:
                break;

              case exports.GFXLoadOp.CLEAR:
                clearFlag & exports.GFXClearFlag.DEPTH && (cache.dss.depthWrite || gl.depthMask(!0), 
                gl.clearDepth(clearDepth), clears |= gl.DEPTH_BUFFER_BIT);
                break;

              case exports.GFXLoadOp.DISCARD:
            }
            if (GFXFormatInfos[curGPURenderPass.depthStencilAttachment.format].hasStencil) switch (curGPURenderPass.depthStencilAttachment.stencilLoadOp) {
              case exports.GFXLoadOp.LOAD:
                break;

              case exports.GFXLoadOp.CLEAR:
                clearFlag & exports.GFXClearFlag.STENCIL && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 65535), 
                cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 65535), gl.clearStencil(clearStencil), 
                clears |= gl.STENCIL_BUFFER_BIT);
                break;

              case exports.GFXLoadOp.DISCARD:
            }
        }
        if (clears && gl.clear(clears), clears & gl.COLOR_BUFFER_BIT) {
            var colorMask = cache.bs.targets[0].blendColorMask;
            if (colorMask !== exports.GFXColorMask.ALL) {
                var r = (colorMask & exports.GFXColorMask.R) !== exports.GFXColorMask.NONE, g = (colorMask & exports.GFXColorMask.G) !== exports.GFXColorMask.NONE, b = (colorMask & exports.GFXColorMask.B) !== exports.GFXColorMask.NONE, a = (colorMask & exports.GFXColorMask.A) !== exports.GFXColorMask.NONE;
                gl.colorMask(r, g, b, a);
            }
        }
        clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite && gl.depthMask(!1), clears & gl.STENCIL_BUFFER_BIT && (cache.dss.stencilWriteMaskFront || gl.stencilMaskSeparate(gl.FRONT, 0), 
        cache.dss.stencilWriteMaskBack || gl.stencilMaskSeparate(gl.BACK, 0));
    }
}

function WebGLCmdFuncBindStates(device, gpuPipelineState, gpuBindingLayout, gpuInputAssembler, viewport, scissor, lineWidth, depthBias, blendConstants, depthBounds, stencilWriteMask, stencilCompareMask) {
    var glWrapS, glWrapT, glMinFilter, gl = device.gl, cache = device.stateCache, isShaderChanged = !1, gpuShader = null;
    if (gpuPipelineState) {
        if (gfxStateCache.glPrimitive = gpuPipelineState.glPrimitive, gpuPipelineState.gpuShader) {
            var glProgram = gpuPipelineState.gpuShader.glProgram;
            cache.glProgram !== glProgram && (gl.useProgram(glProgram), cache.glProgram = glProgram, 
            isShaderChanged = !0), gfxStateCache.gpuShader = gpuShader = gpuPipelineState.gpuShader;
        }
        var rs = gpuPipelineState.rs;
        if (rs) {
            if (cache.rs.cullMode !== rs.cullMode) {
                switch (rs.cullMode) {
                  case exports.GFXCullMode.NONE:
                    gl.disable(gl.CULL_FACE);
                    break;

                  case exports.GFXCullMode.FRONT:
                    gl.enable(gl.CULL_FACE), gl.cullFace(gl.FRONT);
                    break;

                  case exports.GFXCullMode.BACK:
                    gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK);
                }
                cache.rs.cullMode = rs.cullMode;
            }
            var isFrontFaceCCW = device.reverseCW ? !rs.isFrontFaceCCW : rs.isFrontFaceCCW;
            cache.rs.isFrontFaceCCW !== isFrontFaceCCW && (gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW), 
            cache.rs.isFrontFaceCCW = isFrontFaceCCW), cache.rs.depthBias === rs.depthBias && cache.rs.depthBiasSlop === rs.depthBiasSlop || (gl.polygonOffset(rs.depthBias, rs.depthBiasSlop), 
            cache.rs.depthBias = rs.depthBias, cache.rs.depthBiasSlop = rs.depthBiasSlop), cache.rs.lineWidth !== rs.lineWidth && (gl.lineWidth(rs.lineWidth), 
            cache.rs.lineWidth = rs.lineWidth);
        }
        var dss = gpuPipelineState.dss;
        dss && (cache.dss.depthTest !== dss.depthTest && (dss.depthTest ? gl.enable(gl.DEPTH_TEST) : gl.disable(gl.DEPTH_TEST), 
        cache.dss.depthTest = dss.depthTest), cache.dss.depthWrite !== dss.depthWrite && (gl.depthMask(dss.depthWrite), 
        cache.dss.depthWrite = dss.depthWrite), cache.dss.depthFunc !== dss.depthFunc && (gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]), 
        cache.dss.depthFunc = dss.depthFunc), cache.dss.stencilTestFront === dss.stencilTestFront && cache.dss.stencilTestBack === dss.stencilTestBack || (dss.stencilTestFront || dss.stencilTestBack ? gl.enable(gl.STENCIL_TEST) : gl.disable(gl.STENCIL_TEST), 
        cache.dss.stencilTestFront = dss.stencilTestFront, cache.dss.stencilTestBack = dss.stencilTestBack), 
        cache.dss.stencilFuncFront === dss.stencilFuncFront && cache.dss.stencilRefFront === dss.stencilRefFront && cache.dss.stencilReadMaskFront === dss.stencilReadMaskFront || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront), 
        cache.dss.stencilFuncFront = dss.stencilFuncFront, cache.dss.stencilRefFront = dss.stencilRefFront, 
        cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront), cache.dss.stencilFailOpFront === dss.stencilFailOpFront && cache.dss.stencilZFailOpFront === dss.stencilZFailOpFront && cache.dss.stencilPassOpFront === dss.stencilPassOpFront || (gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]), 
        cache.dss.stencilFailOpFront = dss.stencilFailOpFront, cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront, 
        cache.dss.stencilPassOpFront = dss.stencilPassOpFront), cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront && (gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront), 
        cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront), cache.dss.stencilFuncBack === dss.stencilFuncBack && cache.dss.stencilRefBack === dss.stencilRefBack && cache.dss.stencilReadMaskBack === dss.stencilReadMaskBack || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack), 
        cache.dss.stencilFuncBack = dss.stencilFuncBack, cache.dss.stencilRefBack = dss.stencilRefBack, 
        cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack), cache.dss.stencilFailOpBack === dss.stencilFailOpBack && cache.dss.stencilZFailOpBack === dss.stencilZFailOpBack && cache.dss.stencilPassOpBack === dss.stencilPassOpBack || (gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]), 
        cache.dss.stencilFailOpBack = dss.stencilFailOpBack, cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack, 
        cache.dss.stencilPassOpBack = dss.stencilPassOpBack), cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack && (gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack), 
        cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack));
        var bs = gpuPipelineState.bs;
        if (bs) {
            cache.bs.isA2C !== bs.isA2C && (bs.isA2C ? gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
            cache.bs.isA2C = bs.isA2C), cache.bs.blendColor[0] === bs.blendColor[0] && cache.bs.blendColor[1] === bs.blendColor[1] && cache.bs.blendColor[2] === bs.blendColor[2] && cache.bs.blendColor[3] === bs.blendColor[3] || (gl.blendColor(bs.blendColor[0], bs.blendColor[1], bs.blendColor[2], bs.blendColor[3]), 
            cache.bs.blendColor[0] = bs.blendColor[0], cache.bs.blendColor[1] = bs.blendColor[1], 
            cache.bs.blendColor[2] = bs.blendColor[2], cache.bs.blendColor[3] = bs.blendColor[3]);
            var target0 = bs.targets[0], target0Cache = cache.bs.targets[0];
            target0Cache.blend !== target0.blend && (target0.blend ? gl.enable(gl.BLEND) : gl.disable(gl.BLEND), 
            target0Cache.blend = target0.blend), target0Cache.blendEq === target0.blendEq && target0Cache.blendAlphaEq === target0.blendAlphaEq || (gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]), 
            target0Cache.blendEq = target0.blendEq, target0Cache.blendAlphaEq = target0.blendAlphaEq), 
            target0Cache.blendSrc === target0.blendSrc && target0Cache.blendDst === target0.blendDst && target0Cache.blendSrcAlpha === target0.blendSrcAlpha && target0Cache.blendDstAlpha === target0.blendDstAlpha || (gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]), 
            target0Cache.blendSrc = target0.blendSrc, target0Cache.blendDst = target0.blendDst, 
            target0Cache.blendSrcAlpha = target0.blendSrcAlpha, target0Cache.blendDstAlpha = target0.blendDstAlpha), 
            target0Cache.blendColorMask !== target0.blendColorMask && (gl.colorMask((target0.blendColorMask & exports.GFXColorMask.R) !== exports.GFXColorMask.NONE, (target0.blendColorMask & exports.GFXColorMask.G) !== exports.GFXColorMask.NONE, (target0.blendColorMask & exports.GFXColorMask.B) !== exports.GFXColorMask.NONE, (target0.blendColorMask & exports.GFXColorMask.A) !== exports.GFXColorMask.NONE), 
            target0Cache.blendColorMask = target0.blendColorMask);
        }
    }
    if (gpuBindingLayout && gpuShader) for (var bindingLen = gpuBindingLayout.gpuBindings.length, j = 0; j < bindingLen; j++) {
        var gpuBinding = gpuBindingLayout.gpuBindings[j];
        switch (gpuBinding.type) {
          case exports.GFXBindingType.UNIFORM_BUFFER:
            if (gpuBinding.gpuBuffer && gpuBinding.gpuBuffer.buffer) {
                for (var glBlock = null, blockLen = gpuShader.glBlocks.length, k = 0; k < blockLen; k++) {
                    var block = gpuShader.glBlocks[k];
                    if (block.binding === gpuBinding.binding) {
                        glBlock = block;
                        break;
                    }
                }
                if (glBlock && gpuBinding.gpuBuffer.vf32) for (var uniformLen = glBlock.glActiveUniforms.length, _k4 = 0; _k4 < uniformLen; _k4++) {
                    var glUniform = glBlock.glActiveUniforms[_k4];
                    switch (glUniform.glType) {
                      case gl.BOOL:
                      case gl.INT:
                        for (var u = 0; u < glUniform.array.length; ++u) {
                            var idx = glUniform.begin + u;
                            if (gpuBinding.gpuBuffer.vf32[idx] !== glUniform.array[u]) {
                                for (var n = u, m = glUniform.begin + u; n < glUniform.array.length; ++n, ++m) glUniform.array[n] = gpuBinding.gpuBuffer.vf32[m];
                                gl.uniform1iv(glUniform.glLoc, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.BOOL_VEC2:
                      case gl.INT_VEC2:
                        for (var _u = 0; _u < glUniform.array.length; ++_u) {
                            var _idx = glUniform.begin + _u;
                            if (gpuBinding.gpuBuffer.vf32[_idx] !== glUniform.array[_u]) {
                                for (var _n = _u, _m = glUniform.begin + _u; _n < glUniform.array.length; ++_n, 
                                ++_m) glUniform.array[_n] = gpuBinding.gpuBuffer.vf32[_m];
                                gl.uniform2iv(glUniform.glLoc, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.BOOL_VEC3:
                      case gl.INT_VEC3:
                        for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                            var _idx2 = glUniform.begin + _u2;
                            if (gpuBinding.gpuBuffer.vf32[_idx2] !== glUniform.array[_u2]) {
                                for (var _n2 = _u2, _m2 = glUniform.begin + _u2; _n2 < glUniform.array.length; ++_n2, 
                                ++_m2) glUniform.array[_n2] = gpuBinding.gpuBuffer.vf32[_m2];
                                gl.uniform3iv(glUniform.glLoc, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.BOOL_VEC4:
                      case gl.INT_VEC4:
                        for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                            var _idx3 = glUniform.begin + _u3;
                            if (gpuBinding.gpuBuffer.vf32[_idx3] !== glUniform.array[_u3]) {
                                for (var _n3 = _u3, _m3 = glUniform.begin + _u3; _n3 < glUniform.array.length; ++_n3, 
                                ++_m3) glUniform.array[_n3] = gpuBinding.gpuBuffer.vf32[_m3];
                                gl.uniform4iv(glUniform.glLoc, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.FLOAT:
                        for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                            var _idx4 = glUniform.begin + _u4;
                            if (gpuBinding.gpuBuffer.vf32[_idx4] !== glUniform.array[_u4]) {
                                for (var _n4 = _u4, _m4 = glUniform.begin + _u4; _n4 < glUniform.array.length; ++_n4, 
                                ++_m4) glUniform.array[_n4] = gpuBinding.gpuBuffer.vf32[_m4];
                                gl.uniform1fv(glUniform.glLoc, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.FLOAT_VEC2:
                        for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                            var _idx5 = glUniform.begin + _u5;
                            if (gpuBinding.gpuBuffer.vf32[_idx5] !== glUniform.array[_u5]) {
                                for (var _n5 = _u5, _m5 = glUniform.begin + _u5; _n5 < glUniform.array.length; ++_n5, 
                                ++_m5) glUniform.array[_n5] = gpuBinding.gpuBuffer.vf32[_m5];
                                gl.uniform2fv(glUniform.glLoc, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.FLOAT_VEC3:
                        for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                            var _idx6 = glUniform.begin + _u6;
                            if (gpuBinding.gpuBuffer.vf32[_idx6] !== glUniform.array[_u6]) {
                                for (var _n6 = _u6, _m6 = glUniform.begin + _u6; _n6 < glUniform.array.length; ++_n6, 
                                ++_m6) glUniform.array[_n6] = gpuBinding.gpuBuffer.vf32[_m6];
                                gl.uniform3fv(glUniform.glLoc, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.FLOAT_VEC4:
                        for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                            var _idx7 = glUniform.begin + _u7;
                            if (gpuBinding.gpuBuffer.vf32[_idx7] !== glUniform.array[_u7]) {
                                for (var _n7 = _u7, _m7 = glUniform.begin + _u7; _n7 < glUniform.array.length; ++_n7, 
                                ++_m7) glUniform.array[_n7] = gpuBinding.gpuBuffer.vf32[_m7];
                                gl.uniform4fv(glUniform.glLoc, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.FLOAT_MAT2:
                        for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                            var _idx8 = glUniform.begin + _u8;
                            if (gpuBinding.gpuBuffer.vf32[_idx8] !== glUniform.array[_u8]) {
                                for (var _n8 = _u8, _m8 = glUniform.begin + _u8; _n8 < glUniform.array.length; ++_n8, 
                                ++_m8) glUniform.array[_n8] = gpuBinding.gpuBuffer.vf32[_m8];
                                gl.uniformMatrix2fv(glUniform.glLoc, !1, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.FLOAT_MAT3:
                        for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                            var _idx9 = glUniform.begin + _u9;
                            if (gpuBinding.gpuBuffer.vf32[_idx9] !== glUniform.array[_u9]) {
                                for (var _n9 = _u9, _m9 = glUniform.begin + _u9; _n9 < glUniform.array.length; ++_n9, 
                                ++_m9) glUniform.array[_n9] = gpuBinding.gpuBuffer.vf32[_m9];
                                gl.uniformMatrix3fv(glUniform.glLoc, !1, glUniform.array);
                                break;
                            }
                        }
                        break;

                      case gl.FLOAT_MAT4:
                        for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                            var _idx10 = glUniform.begin + _u10;
                            if (gpuBinding.gpuBuffer.vf32[_idx10] !== glUniform.array[_u10]) {
                                for (var _n10 = _u10, _m10 = glUniform.begin + _u10; _n10 < glUniform.array.length; ++_n10, 
                                ++_m10) glUniform.array[_n10] = gpuBinding.gpuBuffer.vf32[_m10];
                                gl.uniformMatrix4fv(glUniform.glLoc, !1, glUniform.array);
                                break;
                            }
                        }
                    }
                }
            }
            break;

          case exports.GFXBindingType.SAMPLER:
            if (gpuBinding.gpuSampler) {
                for (var glSampler = null, samplerLen = gpuShader.glSamplers.length, _k5 = 0; _k5 < samplerLen; _k5++) {
                    var sampler = gpuShader.glSamplers[_k5];
                    if (sampler.binding === gpuBinding.binding) {
                        glSampler = sampler;
                        break;
                    }
                }
                if (glSampler) for (var texUnitLen = glSampler.units.length, _k6 = 0; _k6 < texUnitLen; _k6++) {
                    var texUnit = glSampler.units[_k6];
                    if (gpuBinding.gpuTexView && gpuBinding.gpuTexView.gpuTexture.size > 0) {
                        var gpuTexture = gpuBinding.gpuTexView.gpuTexture, glTexUnit = cache.glTexUnits[texUnit];
                        glTexUnit.glTexture !== gpuTexture.glTexture && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                        cache.texUnit = texUnit), gpuTexture.glTexture ? gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture) : gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture), 
                        glTexUnit.glTexture = gpuTexture.glTexture);
                        var gpuSampler = gpuBinding.gpuSampler;
                        gpuTexture.isPowerOf2 ? (glWrapS = gpuSampler.glWrapS, glWrapT = gpuSampler.glWrapT) : (glWrapS = gl.CLAMP_TO_EDGE, 
                        glWrapT = gl.CLAMP_TO_EDGE), glMinFilter = gpuTexture.isPowerOf2 ? gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) ? gl.LINEAR : gpuSampler.glMinFilter : gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR ? gl.LINEAR : gl.NEAREST, 
                        gpuTexture.glWrapS !== glWrapS && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                        cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS), 
                        gpuTexture.glWrapS = glWrapS), gpuTexture.glWrapT !== glWrapT && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                        cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT), 
                        gpuTexture.glWrapT = glWrapT), gpuTexture.glMinFilter !== glMinFilter && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                        cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter), 
                        gpuTexture.glMinFilter = glMinFilter), gpuTexture.glMagFilter !== gpuSampler.glMagFilter && (cache.texUnit !== texUnit && (gl.activeTexture(gl.TEXTURE0 + texUnit), 
                        cache.texUnit = texUnit), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter), 
                        gpuTexture.glMagFilter = gpuSampler.glMagFilter);
                    }
                }
            } else error("Not found sampler on binding unit ".concat(gpuBinding.binding, ", name ").concat(gpuBinding.name));
        }
    }
    if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache.gpuInputAssembler !== gpuInputAssembler)) {
        gfxStateCache.gpuInputAssembler = gpuInputAssembler;
        var ia = device.ANGLE_instanced_arrays;
        if (device.useVAO) {
            var vao = device.OES_vertex_array_object, glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
            if (!glVAO) {
                var glAttrib;
                glVAO = vao.createVertexArrayOES(), gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO), 
                vao.bindVertexArrayOES(glVAO), gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                for (var inputLen = gpuShader.glInputs.length, _j2 = 0; _j2 < inputLen; _j2++) {
                    var glInput = gpuShader.glInputs[_j2];
                    glAttrib = null;
                    for (var attribLen = gpuInputAssembler.glAttribs.length, _k7 = 0; _k7 < attribLen; _k7++) {
                        var attrib = gpuInputAssembler.glAttribs[_k7];
                        if (attrib.name === glInput.name) {
                            glAttrib = attrib;
                            break;
                        }
                    }
                    if (glAttrib) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                            var glLoc = glInput.glLoc + c, attribOffset = glAttrib.offset + glAttrib.size * c;
                            gl.enableVertexAttribArray(glLoc), cache.glCurrentAttribLocs[glLoc] = !0, gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset), 
                            ia && ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                        }
                    }
                }
                var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                gpuBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), vao.bindVertexArrayOES(null), 
                gl.bindBuffer(gl.ARRAY_BUFFER, null), gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), 
                cache.glArrayBuffer = null, cache.glElementArrayBuffer = null;
            }
            cache.glVAO !== glVAO && (vao.bindVertexArrayOES(glVAO), cache.glVAO = glVAO);
        } else {
            for (var a = 0; a < device.maxVertexAttributes; ++a) cache.glCurrentAttribLocs[a] = !1;
            for (var _inputLen = gpuShader.glInputs.length, _j3 = 0; _j3 < _inputLen; _j3++) {
                for (var _glInput = gpuShader.glInputs[_j3], _glAttrib = null, _attribLen = gpuInputAssembler.glAttribs.length, _k8 = 0; _k8 < _attribLen; _k8++) {
                    var _attrib = gpuInputAssembler.glAttribs[_k8];
                    if (_attrib.name === _glInput.name) {
                        _glAttrib = _attrib;
                        break;
                    }
                }
                if (_glAttrib) {
                    cache.glArrayBuffer !== _glAttrib.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer), 
                    cache.glArrayBuffer = _glAttrib.glBuffer);
                    for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                        var _glLoc2 = _glInput.glLoc + _c, _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                        !cache.glEnabledAttribLocs[_glLoc2] && _glLoc2 >= 0 && (gl.enableVertexAttribArray(_glLoc2), 
                        cache.glEnabledAttribLocs[_glLoc2] = !0), cache.glCurrentAttribLocs[_glLoc2] = !0, 
                        gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset), 
                        ia && ia.vertexAttribDivisorANGLE(_glLoc2, _glAttrib.isInstanced ? 1 : 0);
                    }
                }
            }
            var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
            _gpuBuffer && cache.glElementArrayBuffer !== _gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer), 
            cache.glElementArrayBuffer = _gpuBuffer.glBuffer);
            for (var _a = 0; _a < device.maxVertexAttributes; ++_a) cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a] && (gl.disableVertexAttribArray(_a), 
            cache.glEnabledAttribLocs[_a] = !1);
        }
    }
    if (gpuPipelineState) for (var dsLen = gpuPipelineState.dynamicStates.length, _j4 = 0; _j4 < dsLen; _j4++) {
        switch (gpuPipelineState.dynamicStates[_j4]) {
          case exports.GFXDynamicState.VIEWPORT:
            viewport && (cache.viewport.left === viewport.left && cache.viewport.top === viewport.top && cache.viewport.width === viewport.width && cache.viewport.height === viewport.height || (gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height), 
            cache.viewport.left = viewport.left, cache.viewport.top = viewport.top, cache.viewport.width = viewport.width, 
            cache.viewport.height = viewport.height));
            break;

          case exports.GFXDynamicState.SCISSOR:
            scissor && (cache.scissorRect.x === scissor.x && cache.scissorRect.y === scissor.y && cache.scissorRect.width === scissor.width && cache.scissorRect.height === scissor.height || (gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height), 
            cache.scissorRect.x = scissor.x, cache.scissorRect.y = scissor.y, cache.scissorRect.width = scissor.width, 
            cache.scissorRect.height = scissor.height));
            break;

          case exports.GFXDynamicState.LINE_WIDTH:
            lineWidth && cache.rs.lineWidth !== lineWidth && (gl.lineWidth(lineWidth), cache.rs.lineWidth = lineWidth);
            break;

          case exports.GFXDynamicState.DEPTH_BIAS:
            depthBias && (cache.rs.depthBias === depthBias.constantFactor && cache.rs.depthBiasSlop === depthBias.slopeFactor || (gl.polygonOffset(depthBias.constantFactor, depthBias.slopeFactor), 
            cache.rs.depthBias = depthBias.constantFactor, cache.rs.depthBiasSlop = depthBias.slopeFactor));
            break;

          case exports.GFXDynamicState.BLEND_CONSTANTS:
            blendConstants && (cache.bs.blendColor[0] === blendConstants[0] && cache.bs.blendColor[1] === blendConstants[1] && cache.bs.blendColor[2] === blendConstants[2] && cache.bs.blendColor[3] === blendConstants[3] || (gl.blendColor(blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3]), 
            cache.bs.blendColor[0] = blendConstants[0], cache.bs.blendColor[1] = blendConstants[1], 
            cache.bs.blendColor[2] = blendConstants[2], cache.bs.blendColor[3] = blendConstants[3]));
            break;

          case exports.GFXDynamicState.STENCIL_WRITE_MASK:
            if (stencilWriteMask) switch (stencilWriteMask.face) {
              case exports.GFXStencilFace.FRONT:
                cache.dss.stencilWriteMaskFront !== stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.FRONT, stencilWriteMask.writeMask), 
                cache.dss.stencilWriteMaskFront = stencilWriteMask.writeMask);
                break;

              case exports.GFXStencilFace.BACK:
                cache.dss.stencilWriteMaskBack !== stencilWriteMask.writeMask && (gl.stencilMaskSeparate(gl.BACK, stencilWriteMask.writeMask), 
                cache.dss.stencilWriteMaskBack = stencilWriteMask.writeMask);
                break;

              case exports.GFXStencilFace.ALL:
                cache.dss.stencilWriteMaskFront === stencilWriteMask.writeMask && cache.dss.stencilWriteMaskBack === stencilWriteMask.writeMask || (gl.stencilMask(stencilWriteMask.writeMask), 
                cache.dss.stencilWriteMaskFront = stencilWriteMask.writeMask, cache.dss.stencilWriteMaskBack = stencilWriteMask.writeMask);
            }
            break;

          case exports.GFXDynamicState.STENCIL_COMPARE_MASK:
            if (stencilCompareMask) switch (stencilCompareMask.face) {
              case exports.GFXStencilFace.FRONT:
                cache.dss.stencilRefFront === stencilCompareMask.reference && cache.dss.stencilReadMaskFront === stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], stencilCompareMask.reference, stencilCompareMask.compareMask), 
                cache.dss.stencilRefFront = stencilCompareMask.reference, cache.dss.stencilReadMaskFront = stencilCompareMask.compareMask);
                break;

              case exports.GFXStencilFace.BACK:
                cache.dss.stencilRefBack === stencilCompareMask.reference && cache.dss.stencilReadMaskBack === stencilCompareMask.compareMask || (gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], stencilCompareMask.reference, stencilCompareMask.compareMask), 
                cache.dss.stencilRefBack = stencilCompareMask.reference, cache.dss.stencilReadMaskBack = stencilCompareMask.compareMask);
                break;

              case exports.GFXStencilFace.ALL:
                cache.dss.stencilRefFront === stencilCompareMask.reference && cache.dss.stencilReadMaskFront === stencilCompareMask.compareMask && cache.dss.stencilRefBack === stencilCompareMask.reference && cache.dss.stencilReadMaskBack === stencilCompareMask.compareMask || (gl.stencilFunc(WebGLCmpFuncs[cache.dss.stencilFuncBack], stencilCompareMask.reference, stencilCompareMask.compareMask), 
                cache.dss.stencilRefFront = stencilCompareMask.reference, cache.dss.stencilReadMaskFront = stencilCompareMask.compareMask, 
                cache.dss.stencilRefBack = stencilCompareMask.reference, cache.dss.stencilReadMaskBack = stencilCompareMask.compareMask);
            }
        }
    }
}

function WebGLCmdFuncDraw(device, drawInfo) {
    var gl = device.gl, ia = device.ANGLE_instanced_arrays, gpuInputAssembler = gfxStateCache.gpuInputAssembler, gpuShader = gfxStateCache.gpuShader, glPrimitive = gfxStateCache.glPrimitive;
    if (gpuInputAssembler && gpuShader) if (gpuInputAssembler.gpuIndirectBuffer) for (var diLen = gpuInputAssembler.gpuIndirectBuffer.indirects.length, j = 0; j < diLen; j++) {
        var subDrawInfo = gpuInputAssembler.gpuIndirectBuffer.indirects[j], gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
        if (subDrawInfo.instanceCount && ia) if (gpuBuffer && subDrawInfo.indexCount > -1) {
            var offset = subDrawInfo.firstIndex * gpuBuffer.stride;
            ia.drawElementsInstancedANGLE(glPrimitive, subDrawInfo.indexCount, gpuInputAssembler.glIndexType, offset, subDrawInfo.instanceCount);
        } else ia.drawArraysInstancedANGLE(glPrimitive, subDrawInfo.firstVertex, subDrawInfo.vertexCount, subDrawInfo.instanceCount); else if (gpuBuffer && subDrawInfo.indexCount > -1) {
            var _offset = subDrawInfo.firstIndex * gpuBuffer.stride;
            gl.drawElements(glPrimitive, subDrawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
        } else gl.drawArrays(glPrimitive, subDrawInfo.firstVertex, subDrawInfo.vertexCount);
    } else {
        var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
        if (drawInfo.instanceCount && ia) if (_gpuBuffer2 && drawInfo.indexCount > -1) {
            var _offset2 = drawInfo.firstIndex * _gpuBuffer2.stride;
            ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset2, drawInfo.instanceCount);
        } else ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount); else if (_gpuBuffer2 && drawInfo.indexCount > -1) {
            var _offset3 = drawInfo.firstIndex * _gpuBuffer2.stride;
            gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset3);
        } else gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
    }
}

var cmdIds = new Array(WebGLCmd.COUNT);

function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
    cmdIds.fill(0);
    for (var i = 0; i < cmdPackage.cmds.length; ++i) {
        var cmd = cmdPackage.cmds.array[i], cmdId = cmdIds[cmd]++;
        switch (cmd) {
          case WebGLCmd.BEGIN_RENDER_PASS:
            var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
            WebGLCmdFuncBeginRenderPass(device, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearFlag, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
            break;

          case WebGLCmd.BIND_STATES:
            var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
            WebGLCmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuBindingLayout, cmd2.gpuInputAssembler, cmd2.viewport, cmd2.scissor, cmd2.lineWidth, cmd2.depthBias, cmd2.blendConstants, cmd2.depthBounds, cmd2.stencilWriteMask, cmd2.stencilCompareMask);
            break;

          case WebGLCmd.DRAW:
            WebGLCmdFuncDraw(device, cmdPackage.drawCmds.array[cmdId].drawInfo);
            break;

          case WebGLCmd.UPDATE_BUFFER:
            var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
            WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
            break;

          case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
            var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
            WebGLCmdFuncCopyBuffersToTexture(device, [ cmd5.gpuBuffer.buffer ], cmd5.gpuTexture, cmd5.regions);
        }
    }
}

function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
    var gl = device.gl, glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
    glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture), 
    glTexUnit.glTexture = gpuTexture.glTexture);
    var m = 0, n = 0, w = 1, h = 1, f = 0, isCompressed = GFXFormatInfos[gpuTexture.format].isCompressed;
    switch (gpuTexture.glTarget) {
      case gl.TEXTURE_2D:
        for (var i = 0; i < regions.length; i++) {
            var region = regions[i];
            for (w = region.texExtent.width, h = region.texExtent.height, m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) {
                var pixels = buffers[n++];
                isCompressed ? gpuTexture.glInternalFmt === WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL || device.noCompressedTexSubImage2D ? gl.compressedTexImage2D(gl.TEXTURE_2D, m, gpuTexture.glInternalFmt, w, h, 0, pixels) : gl.compressedTexSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels) : gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels), 
                w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
            }
        }
        break;

      case gl.TEXTURE_CUBE_MAP:
        for (var _i12 = 0; _i12 < regions.length; _i12++) {
            var _region2 = regions[_i12], fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;
            for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                w = _region2.texExtent.width, h = _region2.texExtent.height;
                var mcount = _region2.texSubres.baseMipLevel + _region2.texSubres.levelCount;
                for (m = _region2.texSubres.baseMipLevel; m < mcount; ++m) {
                    var _pixels = buffers[n++];
                    isCompressed ? gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels) : gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, gpuTexture.glInternalFmt, w, h, 0, _pixels) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels), 
                    w = Math.max(1, w >> 1), h = Math.max(1, w >> 1);
                }
            }
        }
        break;

      default:
        console.error("Unsupported GL texture type, copy buffer to texture failed.");
    }
    gpuTexture.flags & exports.GFXTextureFlagBit.GEN_MIPMAP && gl.generateMipmap(gpuTexture.glTarget);
}

var WebGLGFXBuffer = function(_GFXBuffer) {
    function WebGLGFXBuffer() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXBuffer);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXBuffer)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuBuffer = null, 
        _this._uniformBuffer = null, _this;
    }
    return _inherits(WebGLGFXBuffer, GFXBuffer), _createClass(WebGLGFXBuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._usage = info.usage, this._memUsage = info.memUsage, this._size = info.size, 
            this._stride = Math.max(info.stride || this._size, 1), this._count = this._size / this._stride, 
            this._flags = void 0 !== info.flags ? info.flags : exports.GFXBufferFlagBit.NONE, 
            this._usage & exports.GFXBufferUsageBit.INDIRECT && (this._indirectBuffer = {
                drawInfos: []
            }), this._flags & exports.GFXBufferFlagBit.BAKUP_BUFFER && (this._bufferView = new Uint8Array(this._size), 
            this._device.memoryStatus.bufferSize += this._size), this._usage & exports.GFXBufferUsageBit.UNIFORM && this._size > 0 && (this._uniformBuffer = new Uint8Array(this._size)), 
            this._gpuBuffer = {
                usage: info.usage,
                memUsage: info.memUsage,
                size: info.size,
                stride: this._stride,
                buffer: this._bufferView,
                vf32: null,
                indirects: [],
                glTarget: 0,
                glBuffer: null
            }, info.usage & exports.GFXBufferUsageBit.INDIRECT && (this._gpuBuffer.indirects = this._indirectBuffer.drawInfos), 
            this._usage & exports.GFXBufferUsageBit.UNIFORM && (this._gpuBuffer.buffer = this._uniformBuffer), 
            function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
                var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & exports.GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                if (gpuBuffer.usage & exports.GFXBufferUsageBit.VERTEX) {
                    gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                    var glBuffer = gl.createBuffer();
                    glBuffer && (gpuBuffer.glBuffer = glBuffer, gpuBuffer.size > 0 && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    device.stateCache.glArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null));
                } else if (gpuBuffer.usage & exports.GFXBufferUsageBit.INDEX) {
                    gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;
                    var _glBuffer = gl.createBuffer();
                    _glBuffer && (gpuBuffer.glBuffer = _glBuffer, gpuBuffer.size > 0 && (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && (gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer), gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null));
                } else gpuBuffer.usage & exports.GFXBufferUsageBit.UNIFORM ? (gpuBuffer.glTarget = gl.NONE, 
                gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer))) : (gpuBuffer.usage & exports.GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & exports.GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & exports.GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                gpuBuffer.glTarget = gl.NONE);
            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize += this._size, 
            this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuBuffer && (!function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
                gpuBuffer.glBuffer && (device.gl.deleteBuffer(gpuBuffer.glBuffer), gpuBuffer.glBuffer = null);
            }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= this._size, 
            this._gpuBuffer = null), this._bufferView = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "resize",
        value: function resize(size) {
            var oldSize = this._size;
            if (oldSize !== size) {
                if (this._size = size, this._count = this._size / this._stride, this._bufferView) {
                    var oldView = this._bufferView;
                    this._bufferView = new Uint8Array(this._size), this._bufferView.set(oldView), this._device.memoryStatus.bufferSize -= oldSize, 
                    this._device.memoryStatus.bufferSize += size;
                }
                this._uniformBuffer && (this._uniformBuffer = new Uint8Array(size)), this._gpuBuffer && (this._uniformBuffer ? this._gpuBuffer.buffer = this._uniformBuffer : this._bufferView && (this._gpuBuffer.buffer = this._bufferView), 
                this._gpuBuffer.size = size, size > 0 && (!function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
                    var gl = device.gl, cache = device.stateCache, glUsage = gpuBuffer.memUsage & exports.GFXMemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
                    gpuBuffer.usage & exports.GFXBufferUsageBit.VERTEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    gpuBuffer.buffer ? gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage) : gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ARRAY_BUFFER, null), device.stateCache.glArrayBuffer = null) : gpuBuffer.usage & exports.GFXBufferUsageBit.INDEX ? (device.useVAO && cache.glVAO && (device.OES_vertex_array_object.bindVertexArrayOES(null), 
                    cache.glVAO = null), device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer), 
                    gpuBuffer.buffer ? gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage) : gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage), 
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null), device.stateCache.glElementArrayBuffer = null) : gpuBuffer.usage & exports.GFXBufferUsageBit.UNIFORM ? gpuBuffer.buffer && (gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer)) : (gpuBuffer.usage & exports.GFXBufferUsageBit.INDIRECT || gpuBuffer.usage & exports.GFXBufferUsageBit.TRANSFER_DST || gpuBuffer.usage & exports.GFXBufferUsageBit.TRANSFER_SRC || console.error("Unsupported GFXBufferType, create buffer failed."), 
                    gpuBuffer.glTarget = gl.NONE);
                }(this._device, this._gpuBuffer), this._device.memoryStatus.bufferSize -= oldSize, 
                this._device.memoryStatus.bufferSize += size));
            }
        }
    }, {
        key: "update",
        value: function update(buffer, offset, size) {
            var buffSize;
            if (buffSize = void 0 !== size ? size : this._usage & exports.GFXBufferUsageBit.INDIRECT ? 0 : buffer.byteLength, 
            this._bufferView && buffer !== this._bufferView.buffer) {
                var view = new Uint8Array(buffer, 0, size);
                this._bufferView.set(view, offset);
            }
            WebGLCmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, offset || 0, buffSize);
        }
    }, {
        key: "gpuBuffer",
        get: function get() {
            return this._gpuBuffer;
        }
    } ]), WebGLGFXBuffer;
}(), WebGLGFXCommandPool = function() {
    function WebGLGFXCommandPool(clazz, count) {
        _classCallCheck(this, WebGLGFXCommandPool), this._frees = void 0, this._freeIdx = 0, 
        this._freeCmds = void 0, this._frees = new Array(count), this._freeCmds = new CachedArray(count);
        for (var i = 0; i < count; ++i) this._frees[i] = new clazz;
        this._freeIdx = count - 1;
    }
    return _createClass(WebGLGFXCommandPool, [ {
        key: "alloc",
        value: function alloc(clazz) {
            if (this._freeIdx < 0) {
                var size = 2 * this._frees.length, temp = this._frees;
                this._frees = new Array(size);
                for (var increase = size - temp.length, i = 0; i < increase; ++i) this._frees[i] = new clazz;
                for (var _i = increase, j = 0; _i < size; ++_i, ++j) this._frees[_i] = temp[j];
                this._freeIdx += increase;
            }
            var cmd = this._frees[this._freeIdx];
            return this._frees[this._freeIdx--] = null, ++cmd.refCount, cmd;
        }
    }, {
        key: "free",
        value: function free(cmd) {
            0 == --cmd.refCount && this._freeCmds.push(cmd);
        }
    }, {
        key: "freeCmds",
        value: function freeCmds(cmds) {
            for (var i = 0; i < cmds.length; ++i) 0 == --cmds.array[i].refCount && this._freeCmds.push(cmds.array[i]);
        }
    }, {
        key: "release",
        value: function release() {
            for (var i = 0; i < this._freeCmds.length; ++i) {
                var cmd = this._freeCmds.array[i];
                cmd.clear(), this._frees[++this._freeIdx] = cmd;
            }
            this._freeCmds.clear();
        }
    } ]), WebGLGFXCommandPool;
}(), WebGLGFXCommandAllocator = function(_GFXCommandAllocator) {
    function WebGLGFXCommandAllocator(device) {
        var _this;
        return _classCallCheck(this, WebGLGFXCommandAllocator), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXCommandAllocator).call(this, device))).beginRenderPassCmdPool = void 0, 
        _this.bindStatesCmdPool = void 0, _this.drawCmdPool = void 0, _this.updateBufferCmdPool = void 0, 
        _this.copyBufferToTextureCmdPool = void 0, _this.beginRenderPassCmdPool = new WebGLGFXCommandPool(WebGLCmdBeginRenderPass, 1), 
        _this.bindStatesCmdPool = new WebGLGFXCommandPool(WebGLCmdBindStates, 1), _this.drawCmdPool = new WebGLGFXCommandPool(WebGLCmdDraw, 1), 
        _this.updateBufferCmdPool = new WebGLGFXCommandPool(WebGLCmdUpdateBuffer, 1), _this.copyBufferToTextureCmdPool = new WebGLGFXCommandPool(WebGLCmdCopyBufferToTexture, 1), 
        _this;
    }
    return _inherits(WebGLGFXCommandAllocator, GFXCommandAllocator), _createClass(WebGLGFXCommandAllocator, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "clearCmds",
        value: function clearCmds(cmdPackage) {
            cmdPackage.beginRenderPassCmds.length && (this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds), 
            cmdPackage.beginRenderPassCmds.clear()), cmdPackage.bindStatesCmds.length && (this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds), 
            cmdPackage.bindStatesCmds.clear()), cmdPackage.drawCmds.length && (this.drawCmdPool.freeCmds(cmdPackage.drawCmds), 
            cmdPackage.drawCmds.clear()), cmdPackage.updateBufferCmds.length && (this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds), 
            cmdPackage.updateBufferCmds.clear()), cmdPackage.copyBufferToTextureCmds.length && (this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds), 
            cmdPackage.copyBufferToTextureCmds.clear()), cmdPackage.cmds.clear();
        }
    }, {
        key: "releaseCmds",
        value: function releaseCmds() {
            this.beginRenderPassCmdPool.release(), this.bindStatesCmdPool.release(), this.drawCmdPool.release(), 
            this.updateBufferCmdPool.release(), this.copyBufferToTextureCmdPool.release();
        }
    } ]), WebGLGFXCommandAllocator;
}(), WebGLGFXCommandBuffer = function(_GFXCommandBuffer) {
    function WebGLGFXCommandBuffer() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXCommandBuffer);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXCommandBuffer)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).cmdPackage = new WebGLCmdPackage, 
        _this._webGLAllocator = null, _this._isInRenderPass = !1, _this._curGPUPipelineState = null, 
        _this._curGPUBindingLayout = null, _this._curGPUInputAssembler = null, _this._curViewport = null, 
        _this._curScissor = null, _this._curLineWidth = null, _this._curDepthBias = null, 
        _this._curBlendConstants = [], _this._curDepthBounds = null, _this._curStencilWriteMask = null, 
        _this._curStencilCompareMask = null, _this._isStateInvalied = !1, _this;
    }
    return _inherits(WebGLGFXCommandBuffer, GFXCommandBuffer), _createClass(WebGLGFXCommandBuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._allocator = info.allocator, this._type = info.type, this._webGLAllocator = this._allocator, 
            this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._webGLAllocator && (this._webGLAllocator.clearCmds(this.cmdPackage), this._webGLAllocator = null), 
            this._allocator = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "begin",
        value: function begin() {
            this._webGLAllocator.clearCmds(this.cmdPackage), this._curGPUPipelineState = null, 
            this._curGPUBindingLayout = null, this._curGPUInputAssembler = null, this._curViewport = null, 
            this._curScissor = null, this._curLineWidth = null, this._curDepthBias = null, this._curBlendConstants = [], 
            this._curDepthBounds = null, this._curStencilWriteMask = null, this._curStencilCompareMask = null, 
            this._numDrawCalls = 0, this._numInstances = 0, this._numTris = 0;
        }
    }, {
        key: "end",
        value: function end() {
            this._isStateInvalied && this.bindStates(), this._isInRenderPass = !1;
        }
    }, {
        key: "beginRenderPass",
        value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
            var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);
            cmd.gpuFramebuffer = framebuffer.gpuFramebuffer, cmd.renderArea = renderArea, cmd.clearFlag = clearFlag, 
            cmd.clearColors.length = clearColors.length;
            for (var i = 0; i < clearColors.length; ++i) cmd.clearColors[i] = clearColors[i];
            cmd.clearDepth = clearDepth, cmd.clearStencil = clearStencil, this.cmdPackage.beginRenderPassCmds.push(cmd), 
            this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS), this._isInRenderPass = !0;
        }
    }, {
        key: "endRenderPass",
        value: function endRenderPass() {
            this._isInRenderPass = !1;
        }
    }, {
        key: "bindPipelineState",
        value: function bindPipelineState(pipelineState) {
            var gpuPipelineState = pipelineState.gpuPipelineState;
            this._curGPUPipelineState = gpuPipelineState, this._isStateInvalied = !0;
        }
    }, {
        key: "bindBindingLayout",
        value: function bindBindingLayout(bindingLayout) {
            var gpuBindingLayout = bindingLayout.gpuBindingLayout;
            this._curGPUBindingLayout = gpuBindingLayout, this._isStateInvalied = !0;
        }
    }, {
        key: "bindInputAssembler",
        value: function bindInputAssembler(inputAssembler) {
            var gpuInputAssembler = inputAssembler.gpuInputAssembler;
            this._curGPUInputAssembler = gpuInputAssembler, this._isStateInvalied = !0;
        }
    }, {
        key: "setViewport",
        value: function setViewport(viewport) {
            this._curViewport ? this._curViewport.left === viewport.left && this._curViewport.top === viewport.top && this._curViewport.width === viewport.width && this._curViewport.height === viewport.height && this._curViewport.minDepth === viewport.minDepth && this._curViewport.maxDepth === viewport.maxDepth || (this._curViewport.left = viewport.left, 
            this._curViewport.top = viewport.top, this._curViewport.width = viewport.width, 
            this._curViewport.height = viewport.height, this._curViewport.minDepth = viewport.minDepth, 
            this._curViewport.maxDepth = viewport.maxDepth, this._isStateInvalied = !0) : this._curViewport = {
                left: viewport.left,
                top: viewport.top,
                width: viewport.width,
                height: viewport.height,
                minDepth: viewport.minDepth,
                maxDepth: viewport.maxDepth
            };
        }
    }, {
        key: "setScissor",
        value: function setScissor(scissor) {
            this._curScissor ? this._curScissor.x === scissor.x && this._curScissor.y === scissor.y && this._curScissor.width === scissor.width && this._curScissor.height === scissor.height || (this._curScissor.x = scissor.x, 
            this._curScissor.y = scissor.y, this._curScissor.width = scissor.width, this._curScissor.height = scissor.height, 
            this._isStateInvalied = !0) : this._curScissor = {
                x: scissor.x,
                y: scissor.y,
                width: scissor.width,
                height: scissor.height
            };
        }
    }, {
        key: "setLineWidth",
        value: function setLineWidth(lineWidth) {
            this._curLineWidth !== lineWidth && (this._curLineWidth = lineWidth, this._isStateInvalied = !0);
        }
    }, {
        key: "setDepthBias",
        value: function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
            this._curDepthBias ? this._curDepthBias.constantFactor === depthBiasConstantFactor && this._curDepthBias.clamp === depthBiasClamp && this._curDepthBias.slopeFactor === depthBiasSlopeFactor || (this._curDepthBias.constantFactor = depthBiasConstantFactor, 
            this._curDepthBias.clamp = depthBiasClamp, this._curDepthBias.slopeFactor = depthBiasSlopeFactor, 
            this._isStateInvalied = !0) : (this._curDepthBias = {
                constantFactor: depthBiasConstantFactor,
                clamp: depthBiasClamp,
                slopeFactor: depthBiasSlopeFactor
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setBlendConstants",
        value: function setBlendConstants(blendConstants) {
            (this._curBlendConstants || 4 !== blendConstants.length) && (4 !== blendConstants.length || this._curBlendConstants[0] === blendConstants[0] && this._curBlendConstants[1] === blendConstants[1] && this._curBlendConstants[2] === blendConstants[2] && this._curBlendConstants[3] === blendConstants[3]) || (this._curBlendConstants = [ blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3] ], 
            this._isStateInvalied = !0);
        }
    }, {
        key: "setDepthBound",
        value: function setDepthBound(minDepthBounds, maxDepthBounds) {
            this._curDepthBounds && this._curDepthBounds.minBounds === minDepthBounds && this._curDepthBounds.maxBounds === maxDepthBounds || (this._curDepthBounds = {
                minBounds: minDepthBounds,
                maxBounds: maxDepthBounds
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setStencilWriteMask",
        value: function setStencilWriteMask(face, writeMask) {
            this._curStencilWriteMask ? this._curStencilWriteMask.face === face && this._curStencilWriteMask.writeMask === writeMask || (this._curStencilWriteMask.face = face, 
            this._curStencilWriteMask.writeMask = writeMask, this._isStateInvalied = !0) : (this._curStencilWriteMask = {
                face: face,
                writeMask: writeMask
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "setStencilCompareMask",
        value: function setStencilCompareMask(face, reference, compareMask) {
            this._curStencilCompareMask ? this._curStencilCompareMask.face === face && this._curStencilCompareMask.reference === reference && this._curStencilCompareMask.compareMask === compareMask || (this._curStencilCompareMask.face = face, 
            this._curStencilCompareMask.reference = reference, this._curStencilCompareMask.compareMask = compareMask, 
            this._isStateInvalied = !0) : (this._curStencilCompareMask = {
                face: face,
                reference: reference,
                compareMask: compareMask
            }, this._isStateInvalied = !0);
        }
    }, {
        key: "draw",
        value: function draw(inputAssembler) {
            if (this._type === exports.GFXCommandBufferType.PRIMARY && this._isInRenderPass || this._type === exports.GFXCommandBufferType.SECONDARY) {
                this._isStateInvalied && this.bindStates();
                var cmd = this._allocator.drawCmdPool.alloc(WebGLCmdDraw);
                cmd.drawInfo.vertexCount = inputAssembler.vertexCount, cmd.drawInfo.firstVertex = inputAssembler.firstVertex, 
                cmd.drawInfo.indexCount = inputAssembler.indexCount, cmd.drawInfo.firstIndex = inputAssembler.firstIndex, 
                cmd.drawInfo.vertexOffset = inputAssembler.vertexOffset, cmd.drawInfo.instanceCount = inputAssembler.instanceCount, 
                cmd.drawInfo.firstInstance = inputAssembler.firstInstance, this.cmdPackage.drawCmds.push(cmd), 
                this.cmdPackage.cmds.push(WebGLCmd.DRAW), ++this._numDrawCalls, this._numInstances += inputAssembler.instanceCount;
                var indexCount = inputAssembler.indexCount || inputAssembler.vertexCount;
                if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                  case 4:
                    this._numTris += indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                    break;

                  case 5:
                  case 6:
                    this._numTris += (indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                }
            } else console.error("Command 'draw' must be recorded inside a render pass.");
        }
    }, {
        key: "updateBuffer",
        value: function updateBuffer(buffer, data, offset, size) {
            if (this._type === exports.GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === exports.GFXCommandBufferType.SECONDARY) {
                var gpuBuffer = buffer.gpuBuffer;
                if (gpuBuffer) {
                    var cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);
                    if (cmd) {
                        var buffSize;
                        buffSize = void 0 !== size ? size : buffer.usage & exports.GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength;
                        var buff = data;
                        cmd.gpuBuffer = gpuBuffer, cmd.buffer = buff, cmd.offset = void 0 !== offset ? offset : 0, 
                        cmd.size = buffSize, this.cmdPackage.updateBufferCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
                    }
                }
            } else console.error("Command 'updateBuffer' must be recorded outside a render pass.");
        }
    }, {
        key: "copyBufferToTexture",
        value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
            if (this._type === exports.GFXCommandBufferType.PRIMARY && !this._isInRenderPass || this._type === exports.GFXCommandBufferType.SECONDARY) {
                var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                if (gpuBuffer && gpuTexture) {
                    var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);
                    cmd && (cmd.gpuBuffer = gpuBuffer, cmd.gpuTexture = gpuTexture, cmd.dstLayout = dstLayout, 
                    cmd.regions = regions, this.cmdPackage.copyBufferToTextureCmds.push(cmd), this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE));
                }
            } else console.error("Command 'copyBufferToTexture' must be recorded outside a render pass.");
        }
    }, {
        key: "execute",
        value: function execute(cmdBuffs, count) {
            for (var i = 0; i < count; ++i) {
                for (var webGLCmdBuff = cmdBuffs[i], c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount, this.cmdPackage.beginRenderPassCmds.push(cmd);
                }
                for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                    var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                    ++_cmd.refCount, this.cmdPackage.bindStatesCmds.push(_cmd);
                }
                for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                    var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                    ++_cmd2.refCount, this.cmdPackage.drawCmds.push(_cmd2);
                }
                for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                    var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                    ++_cmd3.refCount, this.cmdPackage.updateBufferCmds.push(_cmd3);
                }
                for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                    var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                    ++_cmd4.refCount, this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                }
                this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds.array), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                this._numInstances += webGLCmdBuff._numInstances, this._numTris += webGLCmdBuff._numTris;
            }
        }
    }, {
        key: "bindStates",
        value: function bindStates() {
            var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);
            bindStatesCmd && (bindStatesCmd.gpuPipelineState = this._curGPUPipelineState, bindStatesCmd.gpuBindingLayout = this._curGPUBindingLayout, 
            bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler, bindStatesCmd.viewport = this._curViewport, 
            bindStatesCmd.scissor = this._curScissor, bindStatesCmd.lineWidth = this._curLineWidth, 
            bindStatesCmd.depthBias = this._curDepthBias, bindStatesCmd.blendConstants = this._curBlendConstants, 
            bindStatesCmd.depthBounds = this._curDepthBounds, bindStatesCmd.stencilWriteMask = this._curStencilWriteMask, 
            bindStatesCmd.stencilCompareMask = this._curStencilCompareMask, this.cmdPackage.bindStatesCmds.push(bindStatesCmd), 
            this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES), this._isStateInvalied = !1);
        }
    }, {
        key: "webGLDevice",
        get: function get() {
            return this._device;
        }
    } ]), WebGLGFXCommandBuffer;
}(), WebGLGFXFramebuffer = function(_GFXFramebuffer) {
    function WebGLGFXFramebuffer() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXFramebuffer);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXFramebuffer)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuFramebuffer = null, 
        _this;
    }
    return _inherits(WebGLGFXFramebuffer, GFXFramebuffer), _createClass(WebGLGFXFramebuffer, [ {
        key: "initialize",
        value: function initialize(info) {
            if (this._renderPass = info.renderPass, this._colorViews = info.colorViews || [], 
            this._depthStencilView = info.depthStencilView || null, this._isOffscreen = void 0 === info.isOffscreen || info.isOffscreen, 
            this._isOffscreen) {
                var gpuColorViews = [];
                if (void 0 !== info.colorViews) for (var _step, _iterator = _createForOfIteratorHelperLoose(info.colorViews); !(_step = _iterator()).done; ) {
                    var colorView = _step.value;
                    gpuColorViews.push(colorView.gpuTextureView);
                }
                var gpuDepthStencilView = null;
                info.depthStencilView && (gpuDepthStencilView = info.depthStencilView.gpuTextureView), 
                this._gpuFramebuffer = {
                    gpuRenderPass: info.renderPass.gpuRenderPass,
                    gpuColorViews: gpuColorViews,
                    gpuDepthStencilView: gpuDepthStencilView,
                    isOffscreen: this._isOffscreen,
                    glFramebuffer: null
                }, function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
                    if (gpuFramebuffer.isOffscreen) {
                        var gl = device.gl, attachments = [], glFramebuffer = gl.createFramebuffer();
                        if (glFramebuffer) {
                            gpuFramebuffer.glFramebuffer = glFramebuffer, device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
                            device.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
                            for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                                var cv = gpuFramebuffer.gpuColorViews[i];
                                cv && (cv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, cv.gpuTexture.glTarget, cv.gpuTexture.glTexture, cv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, cv.gpuTexture.glRenderbuffer), 
                                attachments.push(gl.COLOR_ATTACHMENT0 + i));
                            }
                            var dsv = gpuFramebuffer.gpuDepthStencilView;
                            if (dsv) {
                                var glAttachment = GFXFormatInfos[dsv.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                                dsv.gpuTexture.glTexture ? gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dsv.gpuTexture.glTarget, dsv.gpuTexture.glTexture, dsv.baseLevel) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dsv.gpuTexture.glRenderbuffer);
                            }
                            device.WEBGL_draw_buffers && device.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
                            if (status !== gl.FRAMEBUFFER_COMPLETE) switch (status) {
                              case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                                break;

                              case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                                break;

                              case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                                break;

                              case gl.FRAMEBUFFER_UNSUPPORTED:
                                console.error("glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED");
                            }
                        }
                    }
                }(this._device, this._gpuFramebuffer);
            } else this._gpuFramebuffer = {
                gpuRenderPass: info.renderPass.gpuRenderPass,
                gpuColorViews: [],
                gpuDepthStencilView: null,
                isOffscreen: !1,
                glFramebuffer: null
            };
            return this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._isOffscreen && this._gpuFramebuffer && function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
                gpuFramebuffer.glFramebuffer && (device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer), 
                gpuFramebuffer.glFramebuffer = null);
            }(this._device, this._gpuFramebuffer), this._gpuFramebuffer = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "gpuFramebuffer",
        get: function get() {
            return this._gpuFramebuffer;
        }
    } ]), WebGLGFXFramebuffer;
}(), WebGLGFXInputAssembler = function(_GFXInputAssembler) {
    function WebGLGFXInputAssembler() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXInputAssembler);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXInputAssembler)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuInputAssembler = null, 
        _this;
    }
    return _inherits(WebGLGFXInputAssembler, GFXInputAssembler), _createClass(WebGLGFXInputAssembler, [ {
        key: "initialize",
        value: function initialize(info) {
            if (0 === info.vertexBuffers.length) return console.error("GFXInputAssemblerInfo.vertexBuffers is null."), 
            !1;
            if (this._attributes = info.attributes, this._vertexBuffers = info.vertexBuffers, 
            void 0 !== info.indexBuffer) this._indexBuffer = info.indexBuffer, this._indexCount = this._indexBuffer.size / this._indexBuffer.stride; else {
                var vertBuff = this._vertexBuffers[0];
                this._vertexCount = vertBuff.size / vertBuff.stride;
            }
            this._indirectBuffer = info.indirectBuffer || null;
            for (var gpuVertexBuffers = new Array(info.vertexBuffers.length), i = 0; i < info.vertexBuffers.length; ++i) {
                var vb = info.vertexBuffers[i];
                vb.gpuBuffer && (gpuVertexBuffers[i] = vb.gpuBuffer);
            }
            var gpuIndexBuffer = null, glIndexType = 0;
            if (info.indexBuffer && (gpuIndexBuffer = info.indexBuffer.gpuBuffer)) switch (gpuIndexBuffer.stride) {
              case 1:
                glIndexType = 5121;
                break;

              case 2:
                glIndexType = 5123;
                break;

              case 4:
                glIndexType = 5125;
                break;

              default:
                console.error("Error index buffer stride.");
            }
            var gpuIndirectBuffer = null;
            return void 0 !== info.indirectBuffer && (gpuIndirectBuffer = info.indirectBuffer.gpuBuffer), 
            this._gpuInputAssembler = {
                attributes: info.attributes,
                gpuVertexBuffers: gpuVertexBuffers,
                gpuIndexBuffer: gpuIndexBuffer,
                gpuIndirectBuffer: gpuIndirectBuffer,
                glAttribs: [],
                glIndexType: glIndexType,
                glVAOs: new Map
            }, function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
                var gl = device.gl;
                gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
                for (var offsets = [ 0, 0, 0, 0, 0, 0, 0, 0 ], i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                    var attrib = gpuInputAssembler.attributes[i], stream = void 0 !== attrib.stream ? attrib.stream : 0, gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream], glType = GFXFormatToWebGLType(attrib.format, gl), size = GFXFormatInfos[attrib.format].size;
                    gpuInputAssembler.glAttribs[i] = {
                        name: attrib.name,
                        glBuffer: gpuBuffer.glBuffer,
                        glType: glType,
                        size: size,
                        count: GFXFormatInfos[attrib.format].count,
                        stride: gpuBuffer.stride,
                        componentCount: WebGLGetComponentCount(glType, gl),
                        isNormalized: void 0 !== attrib.isNormalized && attrib.isNormalized,
                        isInstanced: void 0 !== attrib.isInstanced && attrib.isInstanced,
                        offset: offsets[stream]
                    }, offsets[stream] += size;
                }
            }(this._device, this._gpuInputAssembler), this._status = exports.GFXStatus.SUCCESS, 
            !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            var webglDev = this._device;
            this._gpuInputAssembler && webglDev.useVAO && function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
                for (var it = gpuInputAssembler.glVAOs.values(), res = it.next(); !res.done; ) device.OES_vertex_array_object.deleteVertexArrayOES(res.value), 
                res = it.next();
                gpuInputAssembler.glVAOs.clear();
            }(webglDev, this._gpuInputAssembler), this._gpuInputAssembler = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "gpuInputAssembler",
        get: function get() {
            return this._gpuInputAssembler;
        }
    } ]), WebGLGFXInputAssembler;
}(), WebGLGFXPipelineLayout = function(_GFXPipelineLayout) {
    function WebGLGFXPipelineLayout() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXPipelineLayout);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXPipelineLayout)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuPipelineLayout = null, 
        _this;
    }
    return _inherits(WebGLGFXPipelineLayout, GFXPipelineLayout), _createClass(WebGLGFXPipelineLayout, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._layouts = info.layouts, this._pushConstantsRanges = info.pushConstantsRanges || [], 
            this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "gpuPipelineLayout",
        get: function get() {
            return this._gpuPipelineLayout;
        }
    } ]), WebGLGFXPipelineLayout;
}(), WebGLPrimitives = [ 0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0 ], WebGLGFXPipelineState = function(_GFXPipelineState) {
    function WebGLGFXPipelineState() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXPipelineState);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXPipelineState)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuPipelineState = null, 
        _this;
    }
    return _inherits(WebGLGFXPipelineState, GFXPipelineState), _createClass(WebGLGFXPipelineState, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._primitive = info.primitive, this._shader = info.shader, this._is = info.inputState, 
            this._rs = info.rasterizerState, this._dss = info.depthStencilState, this._bs = info.blendState, 
            this._dynamicStates = info.dynamicStates || [], this._hash = info.hash, this._layout = info.layout, 
            this._renderPass = info.renderPass, this._gpuPipelineState = {
                glPrimitive: WebGLPrimitives[info.primitive],
                gpuShader: info.shader.gpuShader,
                rs: info.rasterizerState,
                dss: info.depthStencilState,
                bs: info.blendState,
                dynamicStates: void 0 !== info.dynamicStates ? info.dynamicStates : [],
                gpuLayout: info.layout.gpuPipelineLayout,
                gpuRenderPass: info.renderPass.gpuRenderPass
            }, this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuPipelineState = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "gpuPipelineState",
        get: function get() {
            return this._gpuPipelineState;
        }
    } ]), WebGLGFXPipelineState;
}(), _buffers = [], WebGLGFXPrimaryCommandBuffer = function(_WebGLGFXCommandBuffe) {
    function WebGLGFXPrimaryCommandBuffer() {
        return _classCallCheck(this, WebGLGFXPrimaryCommandBuffer), _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXPrimaryCommandBuffer).apply(this, arguments));
    }
    return _inherits(WebGLGFXPrimaryCommandBuffer, WebGLGFXCommandBuffer), _createClass(WebGLGFXPrimaryCommandBuffer, [ {
        key: "beginRenderPass",
        value: function beginRenderPass(framebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil) {
            WebGLCmdFuncBeginRenderPass(this._device, framebuffer.gpuFramebuffer, renderArea, clearFlag, clearColors, clearDepth, clearStencil), 
            this._isInRenderPass = !0;
        }
    }, {
        key: "draw",
        value: function draw(inputAssembler) {
            if (this._isInRenderPass) {
                this._isStateInvalied && this.bindStates(), WebGLCmdFuncDraw(this._device, inputAssembler), 
                ++this._numDrawCalls, this._numInstances += inputAssembler.instanceCount;
                var indexCount = inputAssembler.indexCount || inputAssembler.vertexCount;
                if (this._curGPUPipelineState) switch (this._curGPUPipelineState.glPrimitive) {
                  case 4:
                    this._numTris += indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                    break;

                  case 5:
                  case 6:
                    this._numTris += (indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                }
            } else console.error("Command 'draw' must be recorded inside a render pass.");
        }
    }, {
        key: "updateBuffer",
        value: function updateBuffer(buffer, data, offset, size) {
            if (this._isInRenderPass) console.error("Command 'updateBuffer' must be recorded outside a render pass."); else {
                var buffSize, gpuBuffer = buffer.gpuBuffer;
                if (gpuBuffer) void 0 === offset && (offset = 0), buffSize = void 0 !== size ? size : buffer.usage & exports.GFXBufferUsageBit.INDIRECT ? 0 : data.byteLength, 
                WebGLCmdFuncUpdateBuffer(this._device, gpuBuffer, data, offset, buffSize);
            }
        }
    }, {
        key: "copyBufferToTexture",
        value: function copyBufferToTexture(srcBuff, dstTex, dstLayout, regions) {
            if (this._isInRenderPass) console.error("Command 'copyBufferToTexture' must be recorded outside a render pass."); else {
                var gpuBuffer = srcBuff.gpuBuffer, gpuTexture = dstTex.gpuTexture;
                gpuBuffer && gpuTexture && (_buffers[0] = gpuBuffer.buffer, WebGLCmdFuncCopyBuffersToTexture(this._device, _buffers, gpuTexture, regions));
            }
        }
    }, {
        key: "execute",
        value: function execute(cmdBuffs, count) {
            for (var i = 0; i < count; ++i) {
                var webGLCmdBuff = cmdBuffs[i];
                WebGLCmdFuncExecuteCmds(this._device, webGLCmdBuff.cmdPackage), this._numDrawCalls += webGLCmdBuff._numDrawCalls, 
                this._numInstances += webGLCmdBuff._numInstances, this._numTris += webGLCmdBuff._numTris;
            }
        }
    }, {
        key: "bindStates",
        value: function bindStates() {
            WebGLCmdFuncBindStates(this._device, this._curGPUPipelineState, this._curGPUBindingLayout, this._curGPUInputAssembler, this._curViewport, this._curScissor, this._curLineWidth, this._curDepthBias, this._curBlendConstants, this._curDepthBounds, this._curStencilWriteMask, this._curStencilCompareMask), 
            this._isStateInvalied = !1;
        }
    } ]), WebGLGFXPrimaryCommandBuffer;
}(), WebGLGFXQueue = function(_GFXQueue) {
    function WebGLGFXQueue() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXQueue);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXQueue)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).numDrawCalls = 0, 
        _this.numInstances = 0, _this.numTris = 0, _this._isAsync = !1, _this;
    }
    return _inherits(WebGLGFXQueue, GFXQueue), _createClass(WebGLGFXQueue, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._type = info.type, this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "submit",
        value: function submit(cmdBuffs, fence) {
            if (!this._isAsync) for (var len = cmdBuffs.length, i = 0; i < len; i++) {
                var cmdBuff = cmdBuffs[i];
                this.numDrawCalls += cmdBuff.numDrawCalls, this.numInstances += cmdBuff.numInstances, 
                this.numTris += cmdBuff.numTris;
            }
        }
    }, {
        key: "clear",
        value: function clear() {
            this.numDrawCalls = 0, this.numInstances = 0, this.numTris = 0;
        }
    } ]), WebGLGFXQueue;
}(), WebGLGFXRenderPass = function(_GFXRenderPass) {
    function WebGLGFXRenderPass() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXRenderPass);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXRenderPass)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuRenderPass = null, 
        _this;
    }
    return _inherits(WebGLGFXRenderPass, GFXRenderPass), _createClass(WebGLGFXRenderPass, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._colorInfos = info.colorAttachments || [], this._depthStencilInfo = info.depthStencilAttachment || null, 
            this._gpuRenderPass = {
                colorAttachments: this._colorInfos,
                depthStencilAttachment: this._depthStencilInfo
            }, this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuRenderPass = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "gpuRenderPass",
        get: function get() {
            return this._gpuRenderPass;
        }
    } ]), WebGLGFXRenderPass;
}(), WebGLWraps = [ 10497, 33648, 33071, 33071 ], WebGLGFXSampler = function(_GFXSampler) {
    function WebGLGFXSampler() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXSampler);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXSampler)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuSampler = null, 
        _this;
    }
    return _inherits(WebGLGFXSampler, GFXSampler), _createClass(WebGLGFXSampler, [ {
        key: "initialize",
        value: function initialize(info) {
            void 0 !== info.name && (this._state.name = info.name), void 0 !== info.minFilter && (this._state.minFilter = info.minFilter), 
            void 0 !== info.magFilter && (this._state.magFilter = info.magFilter), void 0 !== info.mipFilter && (this._state.mipFilter = info.mipFilter), 
            void 0 !== info.addressU && (this._state.addressU = info.addressU), void 0 !== info.addressV && (this._state.addressV = info.addressV), 
            void 0 !== info.addressW && (this._state.addressW = info.addressW), void 0 !== info.maxAnisotropy && (this._state.maxAnisotropy = info.maxAnisotropy), 
            void 0 !== info.cmpFunc && (this._state.cmpFunc = info.cmpFunc), void 0 !== info.borderColor && (this._state.borderColor = info.borderColor), 
            void 0 !== info.minLOD && (this._state.minLOD = info.minLOD), void 0 !== info.maxLOD && (this._state.maxLOD = info.maxLOD), 
            void 0 !== info.mipLODBias && (this._state.mipLODBias = info.mipLODBias);
            var glMinFilter = 0, glMagFilter = 0, minFilter = this._state.minFilter, magFilter = this._state.magFilter, mipFilter = this._state.mipFilter;
            glMinFilter = minFilter === exports.GFXFilter.LINEAR || minFilter === exports.GFXFilter.ANISOTROPIC ? mipFilter === exports.GFXFilter.LINEAR || mipFilter === exports.GFXFilter.ANISOTROPIC ? 9987 : mipFilter === exports.GFXFilter.POINT ? 9985 : 9729 : mipFilter === exports.GFXFilter.LINEAR || mipFilter === exports.GFXFilter.ANISOTROPIC ? 9986 : mipFilter === exports.GFXFilter.POINT ? 9984 : 9728, 
            glMagFilter = magFilter === exports.GFXFilter.LINEAR || magFilter === exports.GFXFilter.ANISOTROPIC ? 9729 : 9728;
            var glWrapS = WebGLWraps[this._state.addressU], glWrapT = WebGLWraps[this._state.addressV], glWrapR = WebGLWraps[this._state.addressW];
            return this._gpuSampler = {
                glMinFilter: glMinFilter,
                glMagFilter: glMagFilter,
                glWrapS: glWrapS,
                glWrapT: glWrapT,
                glWrapR: glWrapR
            }, this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuSampler = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "gpuSampler",
        get: function get() {
            return this._gpuSampler;
        }
    } ]), WebGLGFXSampler;
}(), WebGLGFXShader = function(_GFXShader) {
    function WebGLGFXShader() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXShader);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXShader)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuShader = null, 
        _this;
    }
    return _inherits(WebGLGFXShader, GFXShader), _createClass(WebGLGFXShader, [ {
        key: "initialize",
        value: function initialize(info) {
            this._name = info.name, this._stages = info.stages, void 0 !== info.blocks && (this._blocks = info.blocks), 
            void 0 !== info.samplers && (this._samplers = info.samplers), this._gpuShader = {
                name: info.name ? info.name : "",
                blocks: void 0 !== info.blocks ? info.blocks : [],
                samplers: void 0 !== info.samplers ? info.samplers : [],
                gpuStages: new Array(info.stages.length),
                glProgram: null,
                glInputs: [],
                glUniforms: [],
                glBlocks: [],
                glSamplers: []
            };
            for (var i = 0; i < info.stages.length; ++i) {
                var stage = info.stages[i];
                this._gpuShader.gpuStages[i] = {
                    type: stage.type,
                    source: stage.source,
                    macros: stage.macros ? stage.macros : [],
                    glShader: null
                };
            }
            return function WebGLCmdFuncCreateShader(device, gpuShader) {
                for (var gl = device.gl, _loop = function _loop(k) {
                    var gpuStage = gpuShader.gpuStages[k], glShaderType = 0, shaderTypeStr = "", lineNumber = 1;
                    switch (gpuStage.type) {
                      case exports.GFXShaderType.VERTEX:
                        shaderTypeStr = "VertexShader", glShaderType = gl.VERTEX_SHADER;
                        break;

                      case exports.GFXShaderType.FRAGMENT:
                        shaderTypeStr = "FragmentShader", glShaderType = gl.FRAGMENT_SHADER;
                        break;

                      default:
                        return console.error("Unsupported GFXShaderType."), {
                            v: void 0
                        };
                    }
                    var glShader = gl.createShader(glShaderType);
                    if (glShader && (gpuStage.glShader = glShader, gl.shaderSource(gpuStage.glShader, gpuStage.source), 
                    gl.compileShader(gpuStage.glShader), !gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS))) {
                        console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed."), 
                        console.error("Shader source dump:", gpuStage.source.replace(/^|\n/g, (function() {
                            return "\n".concat(lineNumber++, " ");
                        }))), console.error(gl.getShaderInfoLog(gpuStage.glShader));
                        for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                            var stage = gpuShader.gpuStages[k];
                            stage.glShader && (gl.deleteShader(stage.glShader), stage.glShader = null);
                        }
                        return {
                            v: void 0
                        };
                    }
                }, k = 0; k < gpuShader.gpuStages.length; k++) {
                    var _ret = _loop(k);
                    if ("object" === _typeof(_ret)) return _ret.v;
                }
                var glProgram = gl.createProgram();
                if (glProgram) {
                    gpuShader.glProgram = glProgram;
                    for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
                        var gpuStage = gpuShader.gpuStages[_k];
                        gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
                    }
                    if (gl.linkProgram(gpuShader.glProgram), device.destroyShadersImmediately) for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
                        var _gpuStage = gpuShader.gpuStages[_k2];
                        _gpuStage.glShader && (gl.detachShader(gpuShader.glProgram, _gpuStage.glShader), 
                        gl.deleteShader(_gpuStage.glShader), _gpuStage.glShader = null);
                    }
                    if (!gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) return console.error("Failed to link shader '" + gpuShader.name + "'."), 
                    void console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                    console.info("Shader '" + gpuShader.name + "' compilation succeeded.");
                    var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
                    gpuShader.glInputs = new Array(activeAttribCount);
                    for (var i = 0; i < activeAttribCount; ++i) {
                        var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                        if (attribInfo) {
                            var varName = void 0, nameOffset = attribInfo.name.indexOf("[");
                            varName = -1 !== nameOffset ? attribInfo.name.substr(0, nameOffset) : attribInfo.name;
                            var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName), type = WebGLTypeToGFXType(attribInfo.type, gl), stride = WebGLGetTypeSize(attribInfo.type, gl);
                            gpuShader.glInputs[i] = {
                                binding: glLoc,
                                name: varName,
                                type: type,
                                stride: stride,
                                count: attribInfo.size,
                                size: stride * attribInfo.size,
                                glType: attribInfo.type,
                                glLoc: glLoc
                            };
                        }
                    }
                    if (gpuShader.blocks.length > 0) {
                        gpuShader.glBlocks = new Array(gpuShader.blocks.length);
                        for (var _i7 = 0; _i7 < gpuShader.blocks.length; ++_i7) {
                            var block = gpuShader.blocks[_i7], glBlock = {
                                binding: block.binding,
                                name: block.name,
                                size: 0,
                                glUniforms: new Array(block.members.length),
                                glActiveUniforms: [],
                                isUniformPackage: !0
                            };
                            gpuShader.glBlocks[_i7] = glBlock;
                            for (var u = 0; u < block.members.length; ++u) {
                                var uniform = block.members[u], glType = GFXTypeToWebGLType(uniform.type, gl), _stride = WebGLGetTypeSize(glType, gl), size = _stride * uniform.count, begin = glBlock.size / 4, array = new Array(size / 4);
                                array.fill(0), glBlock.glUniforms[u] = {
                                    binding: -1,
                                    name: uniform.name,
                                    type: uniform.type,
                                    stride: _stride,
                                    count: uniform.count,
                                    size: size,
                                    offset: glBlock.size,
                                    glType: glType,
                                    glLoc: -1,
                                    array: array,
                                    begin: begin
                                }, glBlock.size += size;
                            }
                        }
                    }
                    if (gpuShader.samplers.length > 0) {
                        gpuShader.glSamplers = new Array(gpuShader.samplers.length);
                        for (var _i8 = 0; _i8 < gpuShader.samplers.length; ++_i8) {
                            var sampler = gpuShader.samplers[_i8];
                            gpuShader.glSamplers[_i8] = {
                                binding: sampler.binding,
                                name: sampler.name,
                                type: sampler.type,
                                units: [],
                                glType: GFXTypeToWebGLType(sampler.type, gl),
                                glLoc: -1
                            };
                        }
                    }
                    for (var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS), unitIdx = 0, glActiveSamplers = [], _i9 = 0; _i9 < activeUniformCount; ++_i9) {
                        var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i9);
                        if (uniformInfo) {
                            var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                            if (null !== _glLoc) {
                                var _varName = void 0, _nameOffset = uniformInfo.name.indexOf("[");
                                if (_varName = -1 !== _nameOffset ? uniformInfo.name.substr(0, _nameOffset) : uniformInfo.name, 
                                uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE) for (var _j = 0; _j < gpuShader.glSamplers.length; _j++) {
                                    var glSampler = gpuShader.glSamplers[_j];
                                    if (glSampler.name === _varName) {
                                        for (var t = 0; t < uniformInfo.size; ++t) glSampler.units.push(unitIdx + t);
                                        glSampler.glLoc = _glLoc, unitIdx += uniformInfo.size, glActiveSamplers.push(glSampler);
                                        break;
                                    }
                                } else for (var j = 0; j < gpuShader.glBlocks.length; j++) for (var _glBlock = gpuShader.glBlocks[j], _k3 = 0; _k3 < _glBlock.glUniforms.length; _k3++) {
                                    var glUniform = _glBlock.glUniforms[_k3];
                                    if (glUniform.name === _varName) {
                                        glUniform.glLoc = _glLoc, _glBlock.glActiveUniforms.push(glUniform);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (glActiveSamplers.length) {
                        device.stateCache.glProgram !== gpuShader.glProgram && (gl.useProgram(gpuShader.glProgram), 
                        device.stateCache.glProgram = gpuShader.glProgram);
                        for (var _i10 = 0; _i10 < glActiveSamplers.length; _i10++) {
                            var _glSampler = glActiveSamplers[_i10];
                            gl.uniform1iv(_glSampler.glLoc, _glSampler.units);
                        }
                    }
                }
            }(this._device, this._gpuShader), this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuShader && (!function WebGLCmdFuncDestroyShader(device, gpuShader) {
                var gl = device.gl;
                if (gpuShader.glProgram) {
                    if (!device.destroyShadersImmediately) for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                        var gpuStage = gpuShader.gpuStages[k];
                        gpuStage.glShader && (gl.detachShader(gpuShader.glProgram, gpuStage.glShader), gl.deleteShader(gpuStage.glShader), 
                        gpuStage.glShader = null);
                    }
                    gl.deleteProgram(gpuShader.glProgram), gpuShader.glProgram = null;
                }
            }(this._device, this._gpuShader), this._gpuShader = null), this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "gpuShader",
        get: function get() {
            return this._gpuShader;
        }
    } ]), WebGLGFXShader;
}(), WebGLStateCache = function WebGLStateCache() {
    _classCallCheck(this, WebGLStateCache), this.glArrayBuffer = null, this.glElementArrayBuffer = null, 
    this.glVAO = null, this.texUnit = 0, this.glTexUnits = void 0, this.glRenderbuffer = null, 
    this.glFramebuffer = null, this.viewport = void 0, this.scissorRect = void 0, this.rs = void 0, 
    this.dss = void 0, this.bs = void 0, this.glProgram = null, this.glEnabledAttribLocs = void 0, 
    this.glCurrentAttribLocs = void 0, this.glTexUnits = new Array(16), this.viewport = {
        left: 0,
        top: 0,
        width: 0,
        height: 0,
        minDepth: 0,
        maxDepth: 0
    }, this.scissorRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    }, this.rs = new GFXRasterizerState, this.dss = new GFXDepthStencilState, this.bs = new GFXBlendState, 
    this.glEnabledAttribLocs = new Array(16), this.glCurrentAttribLocs = new Array(16), 
    this.glEnabledAttribLocs.fill(!1), this.glCurrentAttribLocs.fill(!1);
    for (var i = 0; i < 16; ++i) this.glTexUnits[i] = {
        glTexture: null
    };
}, WebGLGFXTexture = function(_GFXTexture) {
    function WebGLGFXTexture() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXTexture);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXTexture)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuTexture = null, 
        _this;
    }
    return _inherits(WebGLGFXTexture, GFXTexture), _createClass(WebGLGFXTexture, [ {
        key: "initialize",
        value: function initialize(info) {
            var viewType;
            switch (this._type = info.type, this._usage = info.usage, this._format = info.format, 
            this._width = info.width, this._height = info.height, void 0 !== info.depth && (this._depth = info.depth), 
            void 0 !== info.arrayLayer && (this._arrayLayer = info.arrayLayer), void 0 !== info.mipLevel && (this._mipLevel = info.mipLevel), 
            void 0 !== info.samples && (this._samples = info.samples), void 0 !== info.flags && (this._flags = info.flags), 
            this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height), this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
            this._flags & exports.GFXTextureFlagBit.BAKUP_BUFFER && (this._buffer = new ArrayBuffer(this._size)), 
            info.type) {
              case exports.GFXTextureType.TEX1D:
                viewType = info.arrayLayer ? info.arrayLayer <= 1 ? exports.GFXTextureViewType.TV1D : exports.GFXTextureViewType.TV1D_ARRAY : exports.GFXTextureViewType.TV1D;
                break;

              case exports.GFXTextureType.TEX2D:
                var flags = exports.GFXTextureFlagBit.NONE;
                info.flags && (flags = info.flags), viewType = info.arrayLayer ? info.arrayLayer <= 1 ? exports.GFXTextureViewType.TV2D : flags & exports.GFXTextureFlagBit.CUBEMAP ? exports.GFXTextureViewType.CUBE : exports.GFXTextureViewType.TV2D_ARRAY : exports.GFXTextureViewType.TV2D;
                break;

              case exports.GFXTextureType.TEX3D:
                viewType = exports.GFXTextureViewType.TV3D;
                break;

              default:
                viewType = exports.GFXTextureViewType.TV2D;
            }
            return this._gpuTexture = {
                type: this._type,
                viewType: viewType,
                format: this._format,
                usage: this._usage,
                width: this._width,
                height: this._height,
                depth: this._depth,
                size: this._size,
                arrayLayer: this._arrayLayer,
                mipLevel: this._mipLevel,
                samples: this._samples,
                flags: this._flags,
                isPowerOf2: this._isPowerOf2,
                glTarget: 0,
                glInternalFmt: 0,
                glFormat: 0,
                glType: 0,
                glUsage: 0,
                glTexture: null,
                glRenderbuffer: null,
                glWrapS: 0,
                glWrapT: 0,
                glMinFilter: 0,
                glMagFilter: 0
            }, function WebGLCmdFuncCreateTexture(device, gpuTexture) {
                var gl = device.gl;
                gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl), 
                gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
                var w = gpuTexture.width, h = gpuTexture.height;
                switch (gpuTexture.viewType) {
                  case exports.GFXTextureViewType.TV2D:
                    gpuTexture.viewType = exports.GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);
                    if (maxSize > device.maxTextureSize && errorID(9100, maxSize, device.maxTextureSize), 
                    !device.WEBGL_depth_texture && GFXFormatInfos[gpuTexture.format].hasDepth) {
                        var glRenderbuffer = gl.createRenderbuffer();
                        glRenderbuffer && gpuTexture.size > 0 && (gpuTexture.glRenderbuffer = glRenderbuffer, 
                        device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer), 
                        device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer), gpuTexture.glInternalFmt === gl.DEPTH_COMPONENT && (gpuTexture.glInternalFmt = gl.DEPTH_COMPONENT16), 
                        gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h));
                    } else if (gpuTexture.samples === exports.GFXSampleCount.X1) {
                        var glTexture = gl.createTexture();
                        if (glTexture && gpuTexture.size > 0) {
                            gpuTexture.glTexture = glTexture;
                            var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                            if (glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                            glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                                var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternalFmt, w, h, 0, view), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            } else {
                                var _imgSize = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view = new Uint8Array(_imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, 0, gpuTexture.glInternalFmt, 2, 2, 0, _view);
                            } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = gl.REPEAT, gpuTexture.glWrapT = gl.REPEAT) : (gpuTexture.glWrapS = gl.CLAMP_TO_EDGE, 
                            gpuTexture.glWrapT = gl.CLAMP_TO_EDGE), gpuTexture.glMinFilter = gl.LINEAR, gpuTexture.glMagFilter = gl.LINEAR, 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                            gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                        } else gl.deleteTexture(glTexture);
                    }
                    break;

                  case exports.GFXTextureViewType.CUBE:
                    gpuTexture.viewType = exports.GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    var _maxSize = Math.max(w, h);
                    _maxSize > device.maxCubeMapTextureSize && errorID(9100, _maxSize, device.maxTextureSize);
                    var _glTexture = gl.createTexture();
                    if (_glTexture && gpuTexture.size > 0) {
                        gpuTexture.glTexture = _glTexture;
                        var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                        if (_glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                        _glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f = 0; _f < 6; ++_f) {
                            w = gpuTexture.width, h = gpuTexture.height;
                            for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                                var _imgSize2 = GFXFormatSize(gpuTexture.format, w, h, 1), _view2 = new Uint8Array(_imgSize2);
                                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternalFmt, w, h, 0, _view2), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            }
                        } else for (var _f2 = 0; _f2 < 6; ++_f2) {
                            var _imgSize3 = GFXFormatSize(gpuTexture.format, 2, 2, 1), _view3 = new Uint8Array(_imgSize3);
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternalFmt, 2, 2, 0, _view3);
                        } else for (var f = 0; f < 6; ++f) {
                            w = gpuTexture.width, h = gpuTexture.height;
                            for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                            w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                        }
                        gpuTexture.isPowerOf2 ? (gpuTexture.glWrapS = gl.REPEAT, gpuTexture.glWrapT = gl.REPEAT) : (gpuTexture.glWrapS = gl.CLAMP_TO_EDGE, 
                        gpuTexture.glWrapT = gl.CLAMP_TO_EDGE), gpuTexture.glMinFilter = gl.LINEAR, gpuTexture.glMagFilter = gl.LINEAR, 
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS), gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT), 
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter), 
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                    }
                    break;

                  default:
                    console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = exports.GFXTextureViewType.TV2D, 
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                }
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize += this._size, 
            this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuTexture && (!function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
                gpuTexture.glTexture && (device.gl.deleteTexture(gpuTexture.glTexture), gpuTexture.glTexture = null), 
                gpuTexture.glRenderbuffer && (device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer), 
                gpuTexture.glRenderbuffer = null);
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= this._size, 
            this._gpuTexture = null), this._buffer = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            var oldSize = this._size;
            this._width = width, this._height = height, this._size = GFXFormatSurfaceSize(this._format, this.width, this.height, this.depth, this.mipLevel) * this._arrayLayer, 
            this._gpuTexture && (this._gpuTexture.width = width, this._gpuTexture.height = height, 
            this._gpuTexture.size = this._size, function WebGLCmdFuncResizeTexture(device, gpuTexture) {
                var gl = device.gl;
                gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl), 
                gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl), gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
                var w = gpuTexture.width, h = gpuTexture.height;
                switch (gpuTexture.viewType) {
                  case exports.GFXTextureViewType.TV2D:
                    gpuTexture.viewType = exports.GFXTextureViewType.TV2D, gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);
                    if (maxSize > device.maxTextureSize && errorID(9100, maxSize, device.maxTextureSize), 
                    gpuTexture.samples === exports.GFXSampleCount.X1) {
                        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                        if (glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture), 
                        glTexUnit.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                            if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                                var imgSize = GFXFormatSize(gpuTexture.format, w, h, 1), view = new Uint8Array(imgSize);
                                gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternalFmt, w, h, 0, view), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            }
                        } else for (var i = 0; i < gpuTexture.mipLevel; ++i) gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                        w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                    }
                    break;

                  case exports.GFXTextureViewType.CUBE:
                    gpuTexture.viewType = exports.GFXTextureViewType.CUBE, gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;
                    var _maxSize2 = Math.max(w, h);
                    _maxSize2 > device.maxCubeMapTextureSize && errorID(9100, _maxSize2, device.maxTextureSize);
                    var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];
                    if (_glTexUnit2.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture), 
                    _glTexUnit2.glTexture = gpuTexture.glTexture), GFXFormatInfos[gpuTexture.format].isCompressed) {
                        if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) for (var _f3 = 0; _f3 < 6; ++_f3) {
                            w = gpuTexture.width, h = gpuTexture.height;
                            for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                                var _imgSize4 = GFXFormatSize(gpuTexture.format, w, h, 1), _view4 = new Uint8Array(_imgSize4);
                                gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternalFmt, w, h, 0, _view4), 
                                w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                            }
                        }
                    } else for (var f = 0; f < 6; ++f) {
                        w = gpuTexture.width, h = gpuTexture.height;
                        for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null), 
                        w = Math.max(1, w >> 1), h = Math.max(1, h >> 1);
                    }
                    break;

                  default:
                    console.error("Unsupported GFXTextureType, create texture failed."), gpuTexture.viewType = exports.GFXTextureViewType.TV2D, 
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                }
            }(this._device, this._gpuTexture), this._device.memoryStatus.textureSize -= oldSize, 
            this._device.memoryStatus.textureSize += this._size);
        }
    }, {
        key: "gpuTexture",
        get: function get() {
            return this._gpuTexture;
        }
    } ]), WebGLGFXTexture;
}(), WebGLGFXTextureView = function(_GFXTextureView) {
    function WebGLGFXTextureView() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WebGLGFXTextureView);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WebGLGFXTextureView)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._gpuTextureView = null, 
        _this;
    }
    return _inherits(WebGLGFXTextureView, GFXTextureView), _createClass(WebGLGFXTextureView, [ {
        key: "initialize",
        value: function initialize(info) {
            return this._texture = info.texture, this._type = info.type, this._format = info.format, 
            void 0 !== info.baseLevel && (this._baseLevel = info.baseLevel), void 0 !== info.levelCount && (this._levelCount = info.levelCount), 
            void 0 !== info.baseLayer && (this._baseLayer = info.baseLayer), void 0 !== info.layerCount && (this._layerCount = info.layerCount), 
            this._gpuTextureView = {
                gpuTexture: info.texture.gpuTexture,
                type: info.type,
                format: info.format,
                baseLevel: info.baseLevel ? info.baseLevel : 0,
                levelCount: info.levelCount ? info.levelCount : 1
            }, this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._gpuTextureView = null, this._texture = null, this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "gpuTextureView",
        get: function get() {
            return this._gpuTextureView;
        }
    } ]), WebGLGFXTextureView;
}(), WebGLGFXWindow = function(_GFXWindow) {
    function WebGLGFXWindow() {
        return _classCallCheck(this, WebGLGFXWindow), _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXWindow).apply(this, arguments));
    }
    return _inherits(WebGLGFXWindow, GFXWindow), _createClass(WebGLGFXWindow, [ {
        key: "initialize",
        value: function initialize(info) {
            void 0 !== info.title && (this._title = info.title), void 0 !== info.left && (this._left = info.left), 
            void 0 !== info.top && (this._top = info.top), void 0 !== info.isOffscreen && (this._isOffscreen = info.isOffscreen), 
            this._width = info.width, this._height = info.height, this._nativeWidth = this._width, 
            this._nativeHeight = this._height, this._colorFmt = info.colorFmt, this._depthStencilFmt = info.depthStencilFmt, 
            this._renderPass = this._device.createRenderPass({
                colorAttachments: [ {
                    format: this._colorFmt,
                    loadOp: exports.GFXLoadOp.CLEAR,
                    storeOp: exports.GFXStoreOp.STORE,
                    sampleCount: 1,
                    beginLayout: exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL,
                    endLayout: exports.GFXTextureLayout.PRESENT_SRC
                } ],
                depthStencilAttachment: {
                    format: this._depthStencilFmt,
                    depthLoadOp: exports.GFXLoadOp.CLEAR,
                    depthStoreOp: exports.GFXStoreOp.STORE,
                    stencilLoadOp: exports.GFXLoadOp.CLEAR,
                    stencilStoreOp: exports.GFXStoreOp.STORE,
                    sampleCount: 1,
                    beginLayout: exports.GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
                    endLayout: exports.GFXTextureLayout.PRESENT_SRC
                }
            });
            var colorViews = [];
            return this._isOffscreen && (this._colorFmt !== exports.GFXFormat.UNKNOWN && (this._colorTex = this._device.createTexture({
                type: exports.GFXTextureType.TEX2D,
                usage: exports.GFXTextureUsageBit.COLOR_ATTACHMENT | exports.GFXTextureUsageBit.SAMPLED,
                format: this._colorFmt,
                width: this._width,
                height: this._height,
                depth: 1,
                arrayLayer: 1,
                mipLevel: 1,
                flags: exports.GFXTextureFlagBit.NONE
            }), this._colorTexView = this._device.createTextureView({
                texture: this._colorTex,
                type: exports.GFXTextureViewType.TV2D,
                format: this._colorFmt,
                baseLevel: 0,
                levelCount: 1,
                baseLayer: 0,
                layerCount: 1
            }), colorViews.push(this._colorTexView)), this._depthStencilFmt !== exports.GFXFormat.UNKNOWN && (this._depthStencilTex = this._device.createTexture({
                type: exports.GFXTextureType.TEX2D,
                usage: exports.GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                format: this._depthStencilFmt,
                width: this._width,
                height: this._height,
                depth: 1,
                arrayLayer: 1,
                mipLevel: 1,
                flags: exports.GFXTextureFlagBit.NONE
            }), this._depthStencilTexView = this._device.createTextureView({
                texture: this._depthStencilTex,
                type: exports.GFXTextureViewType.TV2D,
                format: this._depthStencilFmt,
                baseLevel: 0,
                levelCount: 1,
                baseLayer: 0,
                layerCount: 1
            }))), this._framebuffer = this._device.createFramebuffer({
                renderPass: this._renderPass,
                colorViews: colorViews,
                depthStencilView: this._depthStencilTexView,
                isOffscreen: this._isOffscreen
            }), this._status = exports.GFXStatus.SUCCESS, !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this._depthStencilTexView && (this._depthStencilTexView.destroy(), this._depthStencilTexView = null), 
            this._depthStencilTex && (this._depthStencilTex.destroy(), this._depthStencilTex = null), 
            this._colorTexView && (this._colorTexView.destroy(), this._colorTexView = null), 
            this._colorTex && (this._colorTex.destroy(), this._colorTex = null), this._framebuffer && (this._framebuffer.destroy(), 
            this._framebuffer = null), this._renderPass && (this._renderPass.destroy(), this._renderPass = null), 
            this._status = exports.GFXStatus.UNREADY;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._width = width, this._height = height, (width > this._nativeWidth || height > this._nativeHeight) && (this._nativeWidth = width, 
            this._nativeHeight = height, this._depthStencilTex && (this._depthStencilTex.resize(width, height), 
            this._depthStencilTexView.destroy(), this._depthStencilTexView.initialize({
                texture: this._depthStencilTex,
                type: exports.GFXTextureViewType.TV2D,
                format: this._depthStencilFmt
            })), this._colorTex && (this._colorTex.resize(width, height), this._colorTexView.destroy(), 
            this._colorTexView.initialize({
                texture: this._colorTex,
                type: exports.GFXTextureViewType.TV2D,
                format: this._colorFmt
            })), this._framebuffer && this._framebuffer.isOffscreen && (this._framebuffer.destroy(), 
            this._framebuffer.initialize({
                renderPass: this._renderPass,
                colorViews: [ this._colorTexView ],
                depthStencilView: this._depthStencilTexView
            })));
        }
    } ]), WebGLGFXWindow;
}(), WebGLGFXDevice = function(_GFXDevice) {
    function WebGLGFXDevice() {
        var _this;
        return _classCallCheck(this, WebGLGFXDevice), (_this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLGFXDevice).call(this))).stateCache = new WebGLStateCache, 
        _this.nullTex2D = null, _this.nullTexCube = null, _this._webGLRC = null, _this._isAntialias = !0, 
        _this._isPremultipliedAlpha = !0, _this._useVAO = !1, _this._destroyShadersImmediately = !0, 
        _this._noCompressedTexSubImage2D = !1, _this._extensions = null, _this._EXT_texture_filter_anisotropic = null, 
        _this._EXT_frag_depth = null, _this._EXT_shader_texture_lod = null, _this._EXT_sRGB = null, 
        _this._OES_vertex_array_object = null, _this._EXT_color_buffer_half_float = null, 
        _this._WEBGL_color_buffer_float = null, _this._WEBGL_compressed_texture_etc1 = null, 
        _this._WEBGL_compressed_texture_etc = null, _this._WEBGL_compressed_texture_pvrtc = null, 
        _this._WEBGL_compressed_texture_astc = null, _this._WEBGL_compressed_texture_s3tc = null, 
        _this._WEBGL_compressed_texture_s3tc_srgb = null, _this._WEBGL_debug_shaders = null, 
        _this._WEBGL_draw_buffers = null, _this._WEBGL_lose_context = null, _this._WEBGL_depth_texture = null, 
        _this._WEBGL_debug_renderer_info = null, _this._OES_texture_half_float = null, _this._OES_texture_half_float_linear = null, 
        _this._OES_texture_float = null, _this._OES_texture_float_linear = null, _this._OES_standard_derivatives = null, 
        _this._OES_element_index_uint = null, _this._ANGLE_instanced_arrays = null, _this;
    }
    return _inherits(WebGLGFXDevice, GFXDevice), _createClass(WebGLGFXDevice, [ {
        key: "gl",
        get: function get() {
            return this._webGLRC;
        }
    }, {
        key: "webGLQueue",
        get: function get() {
            return this._queue;
        }
    }, {
        key: "isAntialias",
        get: function get() {
            return this._isAntialias;
        }
    }, {
        key: "isPremultipliedAlpha",
        get: function get() {
            return this._isPremultipliedAlpha;
        }
    }, {
        key: "useVAO",
        get: function get() {
            return this._useVAO;
        }
    }, {
        key: "destroyShadersImmediately",
        get: function get() {
            return this._destroyShadersImmediately;
        }
    }, {
        key: "noCompressedTexSubImage2D",
        get: function get() {
            return this._noCompressedTexSubImage2D;
        }
    }, {
        key: "EXT_texture_filter_anisotropic",
        get: function get() {
            return this._EXT_texture_filter_anisotropic;
        }
    }, {
        key: "EXT_frag_depth",
        get: function get() {
            return this._EXT_frag_depth;
        }
    }, {
        key: "EXT_shader_texture_lod",
        get: function get() {
            return this._EXT_shader_texture_lod;
        }
    }, {
        key: "EXT_sRGB",
        get: function get() {
            return this._EXT_sRGB;
        }
    }, {
        key: "OES_vertex_array_object",
        get: function get() {
            return this._OES_vertex_array_object;
        }
    }, {
        key: "WEBGL_color_buffer_float",
        get: function get() {
            return this._WEBGL_color_buffer_float;
        }
    }, {
        key: "WEBGL_compressed_texture_etc1",
        get: function get() {
            return this._WEBGL_compressed_texture_etc1;
        }
    }, {
        key: "WEBGL_compressed_texture_pvrtc",
        get: function get() {
            return this._WEBGL_compressed_texture_pvrtc;
        }
    }, {
        key: "WEBGL_compressed_texture_astc",
        get: function get() {
            return this._WEBGL_compressed_texture_astc;
        }
    }, {
        key: "WEBGL_compressed_texture_s3tc",
        get: function get() {
            return this._WEBGL_compressed_texture_s3tc;
        }
    }, {
        key: "WEBGL_compressed_texture_s3tc_srgb",
        get: function get() {
            return this._WEBGL_compressed_texture_s3tc_srgb;
        }
    }, {
        key: "WEBGL_debug_shaders",
        get: function get() {
            return this._WEBGL_debug_shaders;
        }
    }, {
        key: "WEBGL_draw_buffers",
        get: function get() {
            return this._WEBGL_draw_buffers;
        }
    }, {
        key: "WEBGL_lose_context",
        get: function get() {
            return this._WEBGL_lose_context;
        }
    }, {
        key: "WEBGL_depth_texture",
        get: function get() {
            return this._WEBGL_depth_texture;
        }
    }, {
        key: "WEBGL_debug_renderer_info",
        get: function get() {
            return this._WEBGL_debug_renderer_info;
        }
    }, {
        key: "OES_texture_half_float",
        get: function get() {
            return this._OES_texture_half_float;
        }
    }, {
        key: "OES_texture_half_float_linear",
        get: function get() {
            return this._OES_texture_half_float_linear;
        }
    }, {
        key: "OES_texture_float",
        get: function get() {
            return this._OES_texture_float;
        }
    }, {
        key: "OES_standard_derivatives",
        get: function get() {
            return this._OES_standard_derivatives;
        }
    }, {
        key: "OES_element_index_uint",
        get: function get() {
            return this._OES_element_index_uint;
        }
    }, {
        key: "ANGLE_instanced_arrays",
        get: function get() {
            return this._ANGLE_instanced_arrays;
        }
    } ]), _createClass(WebGLGFXDevice, [ {
        key: "initialize",
        value: function initialize(info) {
            this._canvas = info.canvasElm, this._isAntialias = void 0 === info.isAntialias || info.isAntialias, 
            this._isPremultipliedAlpha = void 0 === info.isPremultipliedAlpha || info.isPremultipliedAlpha;
            try {
                var webGLCtxAttribs = {
                    alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                    antialias: this._isAntialias,
                    depth: !0,
                    stencil: !0,
                    premultipliedAlpha: this._isPremultipliedAlpha,
                    preserveDrawingBuffer: !1,
                    powerPreference: "default",
                    failIfMajorPerformanceCaveat: !1
                };
                this._webGLRC = this._canvas.getContext("webgl", webGLCtxAttribs);
            } catch (err) {
                return console.error(err), !1;
            }
            if (!this._webGLRC) return console.error("This device does not support WebGL."), 
            !1;
            this._canvas2D = document.createElement("canvas"), console.info("WebGL device initialized."), 
            this._gfxAPI = exports.GFXAPI.WEBGL, this._deviceName = "WebGL";
            var gl = this._webGLRC;
            this._WEBGL_debug_renderer_info = this.getExtension("WEBGL_debug_renderer_info"), 
            this._WEBGL_debug_renderer_info ? (this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL), 
            this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL)) : (this._renderer = gl.getParameter(gl.RENDERER), 
            this._vendor = gl.getParameter(gl.VENDOR)), this._version = gl.getParameter(gl.VERSION), 
            this._maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS), this._maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS), 
            this._maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS), 
            this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), this._maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS), 
            this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE), this._maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE), 
            this._depthBits = gl.getParameter(gl.DEPTH_BITS), this._stencilBits = gl.getParameter(gl.STENCIL_BITS), 
            this._devicePixelRatio = info.devicePixelRatio || 1, this._width = this._canvas.width, 
            this._height = this._canvas.height, this._nativeWidth = Math.max(info.nativeWidth || this._width, 0), 
            this._nativeHeight = Math.max(info.nativeHeight || this._height, 0), this._colorFmt = exports.GFXFormat.RGBA8, 
            24 === this._depthBits ? 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D24S8 : this._depthStencilFmt = exports.GFXFormat.D24 : 8 === this._stencilBits ? this._depthStencilFmt = exports.GFXFormat.D16S8 : this._depthStencilFmt = exports.GFXFormat.D16, 
            this._extensions = gl.getSupportedExtensions();
            var extensions = "";
            if (this._extensions) {
                for (var _step, _iterator = _createForOfIteratorHelperLoose(this._extensions); !(_step = _iterator()).done; ) {
                    extensions += _step.value + " ";
                }
                console.debug("EXTENSIONS: " + extensions);
            }
            this._EXT_texture_filter_anisotropic = this.getExtension("EXT_texture_filter_anisotropic"), 
            this._EXT_frag_depth = this.getExtension("EXT_frag_depth"), this._EXT_shader_texture_lod = this.getExtension("EXT_shader_texture_lod"), 
            this._EXT_sRGB = this.getExtension("EXT_sRGB"), this._OES_vertex_array_object = this.getExtension("OES_vertex_array_object"), 
            this._EXT_color_buffer_half_float = this.getExtension("EXT_color_buffer_half_float"), 
            this._WEBGL_color_buffer_float = this.getExtension("WEBGL_color_buffer_float"), 
            this._WEBGL_compressed_texture_etc1 = this.getExtension("WEBGL_compressed_texture_etc1"), 
            this._WEBGL_compressed_texture_etc = this.getExtension("WEBGL_compressed_texture_etc"), 
            this._WEBGL_compressed_texture_pvrtc = this.getExtension("WEBGL_compressed_texture_pvrtc"), 
            this._WEBGL_compressed_texture_astc = this.getExtension("WEBGL_compressed_texture_astc"), 
            this._WEBGL_compressed_texture_s3tc = this.getExtension("WEBGL_compressed_texture_s3tc"), 
            this._WEBGL_compressed_texture_s3tc_srgb = this.getExtension("WEBGL_compressed_texture_s3tc_srgb"), 
            this._WEBGL_debug_shaders = this.getExtension("WEBGL_debug_shaders"), this._WEBGL_draw_buffers = this.getExtension("WEBGL_draw_buffers"), 
            this._WEBGL_lose_context = this.getExtension("WEBGL_lose_context"), this._WEBGL_depth_texture = this.getExtension("WEBGL_depth_texture"), 
            this._OES_texture_half_float = this.getExtension("OES_texture_half_float"), this._OES_texture_half_float_linear = this.getExtension("OES_texture_half_float_linear"), 
            this._OES_texture_float = this.getExtension("OES_texture_float"), this._OES_texture_float_linear = this.getExtension("OES_texture_float_linear"), 
            this._OES_standard_derivatives = this.getExtension("OES_standard_derivatives"), 
            this._OES_element_index_uint = this.getExtension("OES_element_index_uint"), this._ANGLE_instanced_arrays = this.getExtension("ANGLE_instanced_arrays"), 
            sys.browserType === sys.BROWSER_TYPE_UC && (this._ANGLE_instanced_arrays = null), 
            (sys.os === sys.OS_IOS && sys.osMainVersion <= 10 || sys.platform === sys.WECHAT_GAME && sys.os === sys.OS_ANDROID) && (this._destroyShadersImmediately = !1), 
            this._noCompressedTexSubImage2D = !0, this._features.fill(!1), this._WEBGL_color_buffer_float && (this._features[exports.GFXFeature.COLOR_FLOAT] = !0), 
            this._EXT_color_buffer_half_float && (this._features[exports.GFXFeature.COLOR_HALF_FLOAT] = !0), 
            this._OES_texture_float && (this._features[exports.GFXFeature.TEXTURE_FLOAT] = !0), 
            this._OES_texture_half_float && (this._features[exports.GFXFeature.TEXTURE_HALF_FLOAT] = !0), 
            this._OES_texture_float_linear && (this._features[exports.GFXFeature.TEXTURE_FLOAT_LINEAR] = !0), 
            this._OES_texture_half_float_linear && (this._features[exports.GFXFeature.TEXTURE_HALF_FLOAT_LINEAR] = !0), 
            this._WEBGL_depth_texture && (this._features[exports.GFXFeature.FORMAT_D24S8] = !0), 
            this._OES_element_index_uint && (this._features[exports.GFXFeature.ELEMENT_INDEX_UINT] = !0), 
            this._ANGLE_instanced_arrays && (this._features[exports.GFXFeature.INSTANCED_ARRAYS] = !0);
            var compressedFormat = "";
            this._WEBGL_compressed_texture_etc1 && (this._features[exports.GFXFeature.FORMAT_ETC1] = !0, 
            compressedFormat += "etc1 "), this._WEBGL_compressed_texture_etc && (this._features[exports.GFXFeature.FORMAT_ETC2] = !0, 
            compressedFormat += "etc2 "), this._WEBGL_compressed_texture_s3tc && (this._features[exports.GFXFeature.FORMAT_DXT] = !0, 
            compressedFormat += "dxt "), this._WEBGL_compressed_texture_pvrtc && (this._features[exports.GFXFeature.FORMAT_PVRTC] = !0, 
            compressedFormat += "pvrtc "), this._WEBGL_compressed_texture_astc && (this._features[exports.GFXFeature.FORMAT_ASTC] = !0, 
            compressedFormat += "astc "), this._features[exports.GFXFeature.MSAA] = !1, this._OES_vertex_array_object && (this._useVAO = !0), 
            console.info("RENDERER: " + this._renderer), console.info("VENDOR: " + this._vendor), 
            console.info("VERSION: " + this._version), console.info("DPR: " + this._devicePixelRatio), 
            console.info("SCREEN_SIZE: " + this._width + " x " + this._height), console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight), 
            console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors), console.info("DEPTH_BITS: " + this._depthBits), 
            console.info("STENCIL_BITS: " + this._stencilBits), this._EXT_texture_filter_anisotropic && console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 
            console.info("USE_VAO: " + this._useVAO), console.info("COMPRESSED_FORMAT: " + compressedFormat), 
            this.initStates(gl), this._queue = this.createQueue({
                type: exports.GFXQueueType.GRAPHICS
            });
            var canvas = this._webGLRC.canvas;
            this._mainWindow = this.createWindow({
                title: canvas.title || "",
                left: canvas.offsetLeft || 0,
                top: canvas.offsetTop || 0,
                width: this._webGLRC.drawingBufferWidth,
                height: this._webGLRC.drawingBufferHeight,
                colorFmt: this._colorFmt,
                depthStencilFmt: this._depthStencilFmt
            }), this._cmdAllocator = this.createCommandAllocator({}), this.nullTex2D = new WebGLGFXTexture(this), 
            this.nullTex2D.initialize({
                type: exports.GFXTextureType.TEX2D,
                usage: exports.GFXTextureUsageBit.SAMPLED,
                format: exports.GFXFormat.RGBA8,
                width: 2,
                height: 2,
                flags: exports.GFXTextureFlagBit.GEN_MIPMAP
            }), this.nullTexCube = new WebGLGFXTexture(this), this.nullTexCube.initialize({
                type: exports.GFXTextureType.TEX2D,
                usage: exports.GFXTextureUsageBit.SAMPLED,
                format: exports.GFXFormat.RGBA8,
                width: 2,
                height: 2,
                arrayLayer: 6,
                flags: exports.GFXTextureFlagBit.CUBEMAP | exports.GFXTextureFlagBit.GEN_MIPMAP
            });
            var nullTexRegion = {
                buffOffset: 0,
                buffStride: 0,
                buffTexHeight: 0,
                texOffset: {
                    x: 0,
                    y: 0,
                    z: 0
                },
                texExtent: {
                    width: 2,
                    height: 2,
                    depth: 1
                },
                texSubres: {
                    baseMipLevel: 0,
                    levelCount: 1,
                    baseArrayLayer: 0,
                    layerCount: 1
                }
            }, nullTexBuff = new Uint8Array(this.nullTex2D.size);
            return nullTexBuff.fill(0), this.copyBuffersToTexture([ nullTexBuff ], this.nullTex2D, [ nullTexRegion ]), 
            nullTexRegion.texSubres.layerCount = 6, this.copyBuffersToTexture([ nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff ], this.nullTexCube, [ nullTexRegion ]), 
            !0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.nullTex2D && (this.nullTex2D.destroy(), this.nullTex2D = null), this.nullTexCube && (this.nullTexCube.destroy(), 
            this.nullTexCube = null), this._mainWindow && (this._mainWindow.destroy(), this._mainWindow = null), 
            this._cmdAllocator && (this._cmdAllocator.destroy(), this._cmdAllocator = null), 
            this._queue && (this._queue.destroy(), this._queue = null), this._webGLRC = null;
        }
    }, {
        key: "resize",
        value: function resize(width, height) {
            this._width === width && this._height === height || (console.info("Resizing device: " + width + "x" + height), 
            this._canvas.width = width, this._canvas.height = height, this._width = width, this._height = height);
        }
    }, {
        key: "createBuffer",
        value: function createBuffer(info) {
            var buffer = new WebGLGFXBuffer(this);
            return buffer.initialize(info), buffer;
        }
    }, {
        key: "createTexture",
        value: function createTexture(info) {
            var texture = new WebGLGFXTexture(this);
            return texture.initialize(info), texture;
        }
    }, {
        key: "createTextureView",
        value: function createTextureView(info) {
            var texView = new WebGLGFXTextureView(this);
            return texView.initialize(info), texView;
        }
    }, {
        key: "createSampler",
        value: function createSampler(info) {
            var sampler = new WebGLGFXSampler(this);
            return sampler.initialize(info), sampler;
        }
    }, {
        key: "createBindingLayout",
        value: function createBindingLayout(info) {
            var bindingLayout = new WebGLGFXBindingLayout(this);
            return bindingLayout.initialize(info), bindingLayout;
        }
    }, {
        key: "createShader",
        value: function createShader(info) {
            var shader = new WebGLGFXShader(this);
            return shader.initialize(info), shader;
        }
    }, {
        key: "createInputAssembler",
        value: function createInputAssembler(info) {
            var inputAssembler = new WebGLGFXInputAssembler(this);
            return inputAssembler.initialize(info), inputAssembler;
        }
    }, {
        key: "createRenderPass",
        value: function createRenderPass(info) {
            var renderPass = new WebGLGFXRenderPass(this);
            return renderPass.initialize(info), renderPass;
        }
    }, {
        key: "createFramebuffer",
        value: function createFramebuffer(info) {
            var framebuffer = new WebGLGFXFramebuffer(this);
            return framebuffer.initialize(info), framebuffer;
        }
    }, {
        key: "createPipelineLayout",
        value: function createPipelineLayout(info) {
            var pipelineLayout = new WebGLGFXPipelineLayout(this);
            return pipelineLayout.initialize(info), pipelineLayout;
        }
    }, {
        key: "createPipelineState",
        value: function createPipelineState(info) {
            var pipelineState = new WebGLGFXPipelineState(this);
            return pipelineState.initialize(info), pipelineState;
        }
    }, {
        key: "createCommandAllocator",
        value: function createCommandAllocator(info) {
            var cmdAllocator = new WebGLGFXCommandAllocator(this);
            return cmdAllocator.initialize(info), cmdAllocator;
        }
    }, {
        key: "createCommandBuffer",
        value: function createCommandBuffer(info) {
            var cmdBuff = new (info.type === exports.GFXCommandBufferType.PRIMARY ? WebGLGFXPrimaryCommandBuffer : WebGLGFXCommandBuffer)(this);
            return cmdBuff.initialize(info), cmdBuff;
        }
    }, {
        key: "createQueue",
        value: function createQueue(info) {
            var queue = new WebGLGFXQueue(this);
            return queue.initialize(info), queue;
        }
    }, {
        key: "createWindow",
        value: function createWindow(info) {
            var window = new WebGLGFXWindow(this);
            return window.initialize(info), window;
        }
    }, {
        key: "present",
        value: function present() {
            this._cmdAllocator.releaseCmds();
            var queue = this._queue;
            this._numDrawCalls = queue.numDrawCalls, this._numInstances = queue.numInstances, 
            this._numTris = queue.numTris, queue.clear();
        }
    }, {
        key: "copyBuffersToTexture",
        value: function copyBuffersToTexture(buffers, texture, regions) {
            WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
        }
    }, {
        key: "copyTexImagesToTexture",
        value: function copyTexImagesToTexture(texImages, texture, regions) {
            !function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
                var gl = device.gl, glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];
                glTexUnit.glTexture !== gpuTexture.glTexture && (gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture), 
                glTexUnit.glTexture = gpuTexture.glTexture);
                var m = 0, n = 0, f = 0;
                switch (gpuTexture.glTarget) {
                  case gl.TEXTURE_2D:
                    for (var i = 0; i < regions.length; i++) {
                        var region = regions[i];
                        for (m = region.texSubres.baseMipLevel; m < region.texSubres.levelCount; ++m) gl.texSubImage2D(gl.TEXTURE_2D, m, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }
                    break;

                  case gl.TEXTURE_CUBE_MAP:
                    for (var _i11 = 0; _i11 < regions.length; _i11++) {
                        var _region = regions[_i11], fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;
                        for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                            var mcount = _region.texSubres.baseMipLevel + _region.texSubres.levelCount;
                            for (m = _region.texSubres.baseMipLevel; m < mcount; ++m) gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, m, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                        }
                    }
                    break;

                  default:
                    console.error("Unsupported GL texture type, copy buffer to texture failed.");
                }
                gpuTexture.flags & exports.GFXTextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2 && gl.generateMipmap(gpuTexture.glTarget);
            }(this, texImages, texture.gpuTexture, regions);
        }
    }, {
        key: "copyFramebufferToBuffer",
        value: function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
            var gl = this._webGLRC, gpuFramebuffer = srcFramebuffer.gpuFramebuffer, format = gpuFramebuffer.gpuColorViews[0].format, glFormat = GFXFormatToWebGLFormat(format, gl), glType = GFXFormatToWebGLType(format, gl), ctor = getTypedArrayConstructor(GFXFormatInfos[format]), curFBO = this.stateCache.glFramebuffer;
            this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer && (gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer), 
            this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer);
            for (var _step2, view = new ctor(dstBuffer), _iterator2 = _createForOfIteratorHelperLoose(regions); !(_step2 = _iterator2()).done; ) {
                var region = _step2.value, buffOffset = region.buffOffset + region.buffTexHeight * region.buffStride, w = region.texExtent.width, h = region.texExtent.height, memSize = GFXFormatSize(format, w, h, 1), data = view.subarray(buffOffset, buffOffset + memSize);
                gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, glFormat, glType, data);
            }
            this.stateCache.glFramebuffer !== curFBO && (gl.bindFramebuffer(gl.FRAMEBUFFER, curFBO), 
            this.stateCache.glFramebuffer = curFBO);
        }
    }, {
        key: "blitFramebuffer",
        value: function blitFramebuffer(src, dst, srcRect, dstRect, filter) {}
    }, {
        key: "getExtension",
        value: function getExtension(ext) {
            for (var prefixes = [ "", "WEBKIT_", "MOZ_" ], i = 0; i < prefixes.length; ++i) {
                var _ext = this._webGLRC.getExtension(prefixes[i] + ext);
                if (_ext) return _ext;
            }
            return null;
        }
    }, {
        key: "initStates",
        value: function initStates(gl) {
            gl.activeTexture(gl.TEXTURE0), gl.pixelStorei(gl.PACK_ALIGNMENT, 1), gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1), 
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), 
            gl.disable(gl.SCISSOR_TEST), gl.enable(gl.CULL_FACE), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), 
            gl.disable(gl.POLYGON_OFFSET_FILL), gl.polygonOffset(0, 0), gl.enable(gl.DEPTH_TEST), 
            gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.depthRange(0, 1), gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 65535), 
            gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP), gl.stencilMaskSeparate(gl.FRONT, 65535), 
            gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 65535), gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP), 
            gl.stencilMaskSeparate(gl.BACK, 65535), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), 
            gl.disable(gl.BLEND), gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), 
            gl.colorMask(!0, !0, !0, !0), gl.blendColor(0, 0, 0, 0);
        }
    } ]), WebGLGFXDevice;
}();

cc.WebGLGFXDevice = WebGLGFXDevice;

var _dec$16, _dec2$J, _dec3$t, _dec4$p, _dec5$m, _dec6$k, _dec7$g, _dec8$e, _dec9$a, _dec10$7, _dec11$7, _dec12$6, _dec13$5, _dec14$4, _dec15$3, _dec16$3, _dec17$2, _dec18$2, _dec19$2, _class$17, _class2$_, _descriptor$R, _descriptor2$F, _descriptor3$x, _descriptor4$q, _descriptor5$k, _descriptor6$b, _descriptor7$a, _descriptor8$8, _descriptor9$8, _descriptor10$7, _descriptor11$3, _descriptor12$3, _descriptor13$3, _descriptor14$3, _class3$l, _temp$11, vec3_temp = new Vec3, _worldMatrix$1 = new Mat4;

function fillMeshVertices3D(node, renderer, renderData, color) {
    var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
    buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
    vertexCount = 0, indiceOffset = 0, vertexId = 0);
    var vbuf = buffer.vData, ibuf = buffer.iData;
    node.getWorldMatrix(_worldMatrix$1);
    for (var i = 0; i < vertexCount; i++) {
        var vert = datas[i];
        Vec3.set(vec3_temp, vert.x, vert.y, 0), Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1), 
        vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
        vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
        vertexOffset += 4;
    }
    for (var _i2 = 0, count = vertexCount / 4; _i2 < count; _i2++) {
        var start = vertexId + 4 * _i2;
        ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 2, 
        ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 3, ibuf[indiceOffset++] = start + 2;
    }
}

var Transition, State, EventType$2, _tempColor = new Color;

!function(Transition) {
    Transition[Transition.NONE = 0] = "NONE", Transition[Transition.COLOR = 1] = "COLOR", 
    Transition[Transition.SPRITE = 2] = "SPRITE", Transition[Transition.SCALE = 3] = "SCALE";
}(Transition || (Transition = {})), ccenum(Transition), function(State) {
    State.NORMAL = "normal", State.HOVER = "hover", State.PRESSED = "pressed", State.DISABLED = "disabled";
}(State || (State = {})), (EventType$2 || (EventType$2 = {})).CLICK = "click";

var ButtonComponent = (_dec$16 = ccclass("cc.ButtonComponent"), _dec2$J = help("i18n:cc.ButtonComponent"), 
_dec3$t = executionOrder(110), _dec4$p = menu("UI/Button"), _dec5$m = requireComponent(UITransformComponent), 
_dec6$k = property({
    type: Node$1,
    displayOrder: 0,
    tooltip: "指定 Button 背景节点，Button 状态改变时会修改此节点的 Color 或 Sprite 属性"
}), _dec7$g = property({
    displayOrder: 1,
    tooltip: "按钮是否可交互，这一项未选中时，按钮处在禁用状态"
}), _dec8$e = property({
    type: Transition,
    displayOrder: 2,
    tooltip: "按钮状态变化时的过渡类型"
}), _dec9$a = property({
    tooltip: "普通状态的按钮背景颜色"
}), _dec10$7 = property({
    tooltip: "按下状态的按钮背景颜色"
}), _dec11$7 = property({
    tooltip: "悬停状态的按钮背景颜色"
}), _dec12$6 = property({
    tooltip: "禁用状态的按钮背景颜色"
}), _dec13$5 = property({
    min: 0,
    max: 10,
    tooltip: "按钮颜色变化或者缩放变化的过渡时间"
}), _dec14$4 = property({
    tooltip: "当用户点击按钮后，按钮会缩放到一个值，这个值等于 Button 原始 scale * zoomScale。"
}), _dec15$3 = property({
    type: SpriteFrame,
    tooltip: "普通状态的按钮背景图资源"
}), _dec16$3 = property({
    type: SpriteFrame,
    tooltip: "按下状态的按钮背景图资源"
}), _dec17$2 = property({
    type: SpriteFrame,
    tooltip: "悬停状态的按钮背景图资源"
}), _dec18$2 = property({
    type: SpriteFrame,
    tooltip: "禁用状态的按钮背景图资源"
}), _dec19$2 = property({
    type: [ EventHandler ],
    displayOrder: 20,
    tooltip: "按钮点击事件的列表。先将数量改为1或更多，就可以为每个点击事件设置接受者和处理方法"
}), _dec$16(_class$17 = _dec2$J(_class$17 = _dec3$t(_class$17 = _dec4$p(_class$17 = _dec5$m((_temp$11 = _class3$l = function(_Component) {
    function ButtonComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ButtonComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ButtonComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "clickEvents", _descriptor$R, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_interactable", _descriptor2$F, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_transition", _descriptor3$x, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_normalColor", _descriptor4$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_hoverColor", _descriptor5$k, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_pressColor", _descriptor6$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_disabledColor", _descriptor7$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_normalSprite", _descriptor8$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_hoverSprite", _descriptor9$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_pressedSprite", _descriptor10$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_disabledSprite", _descriptor11$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_duration", _descriptor12$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_zoomScale", _descriptor13$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_target", _descriptor14$3, _assertThisInitialized(_this)), 
        _this._pressed = !1, _this._hovered = !1, _this._fromColor = new Color, _this._toColor = new Color, 
        _this._time = 0, _this._transitionFinished = !0, _this._fromScale = new Vec3, _this._toScale = new Vec3, 
        _this._originalScale = new Vec3, _this._sprite = null, _this._targetScale = new Vec3, 
        _this;
    }
    return _inherits(ButtonComponent, Component), _createClass(ButtonComponent, [ {
        key: "__preload",
        value: function __preload() {
            this.target || (this.target = this.node);
            var sprite = this.node.getComponent(SpriteComponent);
            sprite && (this._normalSprite = sprite.spriteFrame), this._applyTarget(), this._updateState();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._registerEvent();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._resetState(), this.node.off(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), 
            this.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMove, this), this.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), 
            this.node.off(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), 
            this.node.off(exports.SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.off(exports.SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
        }
    }, {
        key: "update",
        value: function update(dt) {
            var target = this._target ? this._target : this.node;
            if (!this._transitionFinished && (this._transition === Transition.COLOR || this._transition === Transition.SCALE)) {
                this._time += dt;
                var ratio = 1;
                this._duration > 0 && (ratio = this._time / this._duration), ratio >= 1 && (ratio = 1, 
                this._transitionFinished = !0);
                var renderComp = target.getComponent(UIRenderComponent);
                renderComp && (this._transition === Transition.COLOR ? (Color.lerp(_tempColor, this._fromColor, this._toColor, ratio), 
                renderComp.color = _tempColor) : this.transition === Transition.SCALE && (target.getScale(this._targetScale), 
                this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio), this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio), 
                target.setScale(this._targetScale)));
            }
        }
    }, {
        key: "_resizeNodeToTargetNode",
        value: function _resizeNodeToTargetNode() {}
    }, {
        key: "_resetState",
        value: function _resetState() {
            this._pressed = !1, this._hovered = !1;
            var target = this._target;
            if (target) {
                var renderComp = target.getComponent(UIRenderComponent);
                if (renderComp) {
                    var transition = this._transition;
                    transition === Transition.COLOR && this._interactable ? renderComp.color = this._normalColor : transition === Transition.SCALE && target.setScale(this._originalScale), 
                    this._transitionFinished = !0;
                }
            }
        }
    }, {
        key: "_registerEvent",
        value: function _registerEvent() {
            this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMove, this), 
            this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.on(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this), 
            this.node.on(exports.SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this), this.node.on(exports.SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
        }
    }, {
        key: "_getTargetSprite",
        value: function _getTargetSprite(target) {
            var sprite = null;
            return target && (sprite = target.getComponent(SpriteComponent)), sprite;
        }
    }, {
        key: "_applyTarget",
        value: function _applyTarget() {
            this._sprite = this._getTargetSprite(this._target), this._target && Vec3.copy(this._originalScale, this._target.getScale());
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event) {
            this._interactable && this.enabledInHierarchy && (this._pressed = !0, this._updateState(), 
            event && (event.propagationStopped = !0));
        }
    }, {
        key: "_onTouchMove",
        value: function _onTouchMove(event) {
            if (this._interactable && this.enabledInHierarchy && this._pressed) {
                if (!event) return !1;
                var touch = event.touch;
                if (!touch) return !1;
                var state, hit = this.node._uiProps.uiTransformComp.isHit(touch.getUILocation());
                if (this._transition === Transition.SCALE && this._target) hit ? (Vec3.copy(this._fromScale, this._originalScale), 
                Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), this._transitionFinished = !1) : (this._time = 0, 
                this._transitionFinished = !0, this._target && this._target.setScale(this._originalScale)); else state = hit ? State.PRESSED : State.NORMAL, 
                this._applyTransition(state);
                event && (event.propagationStopped = !0);
            }
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event) {
            this._interactable && this.enabledInHierarchy && (this._pressed && (EventHandler.emitEvents(this.clickEvents, event), 
            this.node.emit(EventType$2.CLICK, this)), this._pressed = !1, this._updateState(), 
            event && (event.propagationStopped = !0));
        }
    }, {
        key: "_onTouchCancel",
        value: function _onTouchCancel(event) {
            this._interactable && this.enabledInHierarchy && (this._pressed = !1, this._updateState());
        }
    }, {
        key: "_onMouseMoveIn",
        value: function _onMouseMoveIn(event) {
            !this._pressed && this.interactable && this.enabledInHierarchy && (this._transition !== Transition.SPRITE || this._hoverSprite) && (this._hovered || (this._hovered = !0, 
            this._updateState()));
        }
    }, {
        key: "_onMouseMoveOut",
        value: function _onMouseMoveOut(event) {
            this._hovered && (this._hovered = !1, this._updateState());
        }
    }, {
        key: "_updateState",
        value: function _updateState() {
            var state = this._getButtonState();
            this._applyTransition(state);
        }
    }, {
        key: "_getButtonState",
        value: function _getButtonState() {
            var state = State.NORMAL;
            return this._interactable ? this._pressed ? state = State.PRESSED : this._hovered && (state = State.HOVER) : state = State.DISABLED, 
            state.toString();
        }
    }, {
        key: "_updateColorTransition",
        value: function _updateColorTransition(state) {
            var color = this[state + "Color"], target = this._target;
            if (target) {
                var renderComp = target.getComponent(UIRenderComponent);
                renderComp && (state === State.DISABLED ? renderComp.color = color : (this._fromColor = renderComp.color.clone(), 
                this._toColor = color, this._time = 0, this._transitionFinished = !1));
            }
        }
    }, {
        key: "_updateSpriteTransition",
        value: function _updateSpriteTransition(state) {
            var sprite = this[state + "Sprite"];
            this._sprite && sprite && (this._sprite.spriteFrame = sprite);
        }
    }, {
        key: "_updateScaleTransition",
        value: function _updateScaleTransition(state) {
            this._interactable && (state === State.PRESSED ? this._zoomUp() : this._zoomBack());
        }
    }, {
        key: "_zoomUp",
        value: function _zoomUp() {
            Vec3.copy(this._fromScale, this._originalScale), Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale), 
            this._time = 0, this._transitionFinished = !1;
        }
    }, {
        key: "_zoomBack",
        value: function _zoomBack() {
            this._target && (Vec3.copy(this._fromScale, this._target.getScale()), Vec3.copy(this._toScale, this._originalScale), 
            this._time = 0, this._transitionFinished = !1);
        }
    }, {
        key: "_applyTransition",
        value: function _applyTransition(state) {
            var transition = this._transition;
            transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
        }
    }, {
        key: "target",
        get: function get() {
            return this._target;
        },
        set: function set(value) {
            this._target !== value && (this._target = value, this._applyTarget());
        }
    }, {
        key: "interactable",
        get: function get() {
            return this._interactable;
        },
        set: function set(value) {
            this._interactable = value, this._updateState(), this._interactable || this._resetState();
        }
    }, {
        key: "_resizeToTarget",
        set: function set(value) {
            value && this._resizeNodeToTargetNode();
        }
    }, {
        key: "transition",
        get: function get() {
            return this._transition;
        },
        set: function set(value) {
            this._transition !== value && (this._transition = value);
        }
    }, {
        key: "normalColor",
        get: function get() {
            return this._normalColor;
        },
        set: function set(value) {
            this._normalColor !== value && (this._normalColor.set(value), this._updateState());
        }
    }, {
        key: "pressedColor",
        get: function get() {
            return this._pressColor;
        },
        set: function set(value) {
            this._pressColor !== value && this._pressColor.set(value);
        }
    }, {
        key: "hoverColor",
        get: function get() {
            return this._hoverColor;
        },
        set: function set(value) {
            this._hoverColor !== value && this._hoverColor.set(value);
        }
    }, {
        key: "disabledColor",
        get: function get() {
            return this._disabledColor;
        },
        set: function set(value) {
            this._disabledColor !== value && (this._disabledColor.set(value), this._updateState());
        }
    }, {
        key: "duration",
        get: function get() {
            return this._duration;
        },
        set: function set(value) {
            this._duration !== value && (this._duration = value);
        }
    }, {
        key: "zoomScale",
        get: function get() {
            return this._zoomScale;
        },
        set: function set(value) {
            this._zoomScale !== value && (this._zoomScale = value);
        }
    }, {
        key: "normalSprite",
        get: function get() {
            return this._normalSprite;
        },
        set: function set(value) {
            if (this._normalSprite !== value) {
                this._normalSprite = value;
                var sprite = this.node.getComponent(SpriteComponent);
                sprite && (sprite.spriteFrame = value), this._updateState();
            }
        }
    }, {
        key: "pressedSprite",
        get: function get() {
            return this._pressedSprite;
        },
        set: function set(value) {
            this._pressedSprite !== value && (this._pressedSprite = value, this._updateState());
        }
    }, {
        key: "hoverSprite",
        get: function get() {
            return this._hoverSprite;
        },
        set: function set(value) {
            this._hoverSprite !== value && (this._hoverSprite = value, this._updateState());
        }
    }, {
        key: "disabledSprite",
        get: function get() {
            return this._disabledSprite;
        },
        set: function set(value) {
            this._disabledSprite !== value && (this._disabledSprite = value, this._updateState());
        }
    } ]), ButtonComponent;
}(), _class3$l.Transition = Transition, _class3$l.EventType = EventType$2, _applyDecoratedDescriptor((_class2$_ = _temp$11).prototype, "target", [ _dec6$k ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "target"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "interactable", [ _dec7$g ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "interactable"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "transition", [ _dec8$e ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "transition"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "normalColor", [ _dec9$a ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "normalColor"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "pressedColor", [ _dec10$7 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "pressedColor"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "hoverColor", [ _dec11$7 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "hoverColor"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "disabledColor", [ _dec12$6 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "disabledColor"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "duration", [ _dec13$5 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "duration"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "zoomScale", [ _dec14$4 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "zoomScale"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "normalSprite", [ _dec15$3 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "normalSprite"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "pressedSprite", [ _dec16$3 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "pressedSprite"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "hoverSprite", [ _dec17$2 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "hoverSprite"), _class2$_.prototype), 
_applyDecoratedDescriptor(_class2$_.prototype, "disabledSprite", [ _dec18$2 ], Object.getOwnPropertyDescriptor(_class2$_.prototype, "disabledSprite"), _class2$_.prototype), 
_descriptor$R = _applyDecoratedDescriptor(_class2$_.prototype, "clickEvents", [ _dec19$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$F = _applyDecoratedDescriptor(_class2$_.prototype, "_interactable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor3$x = _applyDecoratedDescriptor(_class2$_.prototype, "_transition", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Transition.NONE;
    }
}), _descriptor4$q = _applyDecoratedDescriptor(_class2$_.prototype, "_normalColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(214, 214, 214, 255);
    }
}), _descriptor5$k = _applyDecoratedDescriptor(_class2$_.prototype, "_hoverColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(211, 211, 211, 255);
    }
}), _descriptor6$b = _applyDecoratedDescriptor(_class2$_.prototype, "_pressColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor7$a = _applyDecoratedDescriptor(_class2$_.prototype, "_disabledColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(124, 124, 124, 255);
    }
}), _descriptor8$8 = _applyDecoratedDescriptor(_class2$_.prototype, "_normalSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor9$8 = _applyDecoratedDescriptor(_class2$_.prototype, "_hoverSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor10$7 = _applyDecoratedDescriptor(_class2$_.prototype, "_pressedSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor11$3 = _applyDecoratedDescriptor(_class2$_.prototype, "_disabledSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor12$3 = _applyDecoratedDescriptor(_class2$_.prototype, "_duration", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor13$3 = _applyDecoratedDescriptor(_class2$_.prototype, "_zoomScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1.2;
    }
}), _descriptor14$3 = _applyDecoratedDescriptor(_class2$_.prototype, "_target", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$17 = _class2$_)) || _class$17) || _class$17) || _class$17) || _class$17) || _class$17);

cc.ButtonComponent = ButtonComponent;

var _dec$17, _dec2$K, _dec3$u, _dec4$q, _dec5$n, _dec6$l, _dec7$h, _dec8$f, _dec9$b, _dec10$8, _dec11$8, _dec12$7, _dec13$6, _dec14$5, _dec15$4, _dec16$4, _dec17$3, _dec18$3, _dec19$3, _class$18, _class2$$, _descriptor$S, _descriptor2$G, _descriptor3$y, _descriptor4$r, _descriptor5$l, _descriptor6$c, _descriptor7$b, _descriptor8$9, _descriptor9$9, _descriptor10$8, _descriptor11$4, _descriptor12$4, _descriptor13$4, _descriptor14$4, _descriptor15$2, _descriptor16$2, _class3$m, _temp$12, HorizontalTextAlignment, CacheMode, CanvasPool = function() {
    function CanvasPool() {
        _classCallCheck(this, CanvasPool), this.pool = [];
    }
    return _createClass(CanvasPool, [ {
        key: "get",
        value: function get() {
            var data = this.pool.pop();
            if (!data) {
                var canvas = document.createElement("canvas"), context = canvas.getContext("2d");
                data = {
                    canvas: canvas,
                    context: context
                };
            }
            return data;
        }
    }, {
        key: "put",
        value: function put(canvas) {
            this.pool.length >= 32 || this.pool.push(canvas);
        }
    } ]), CanvasPool;
}();

(HorizontalTextAlignment = exports.HorizontalTextAlignment || (exports.HorizontalTextAlignment = {}))[HorizontalTextAlignment.LEFT = 0] = "LEFT", 
HorizontalTextAlignment[HorizontalTextAlignment.CENTER = 1] = "CENTER", HorizontalTextAlignment[HorizontalTextAlignment.RIGHT = 2] = "RIGHT", 
ccenum(exports.HorizontalTextAlignment), function(VerticalTextAlignment) {
    VerticalTextAlignment[VerticalTextAlignment.TOP = 0] = "TOP", VerticalTextAlignment[VerticalTextAlignment.CENTER = 1] = "CENTER", 
    VerticalTextAlignment[VerticalTextAlignment.BOTTOM = 2] = "BOTTOM";
}(exports.VerticalTextAlignment || (exports.VerticalTextAlignment = {})), ccenum(exports.VerticalTextAlignment), 
function(Overflow) {
    Overflow[Overflow.NONE = 0] = "NONE", Overflow[Overflow.CLAMP = 1] = "CLAMP", Overflow[Overflow.SHRINK = 2] = "SHRINK", 
    Overflow[Overflow.RESIZE_HEIGHT = 3] = "RESIZE_HEIGHT";
}(exports.Overflow || (exports.Overflow = {})), ccenum(exports.Overflow), function(CacheMode) {
    CacheMode[CacheMode.NONE = 0] = "NONE", CacheMode[CacheMode.BITMAP = 1] = "BITMAP", 
    CacheMode[CacheMode.CHAR = 2] = "CHAR";
}(CacheMode || (CacheMode = {})), ccenum(CacheMode);

var LabelComponent = (_dec$17 = ccclass("cc.LabelComponent"), _dec2$K = help("i18n:cc.LabelComponent"), 
_dec3$u = executionOrder(110), _dec4$q = menu("UI/Render/Label"), _dec5$n = property({
    displayOrder: 4,
    multiline: !0,
    tooltip: "Label 显示的文本内容字符串"
}), _dec6$l = property({
    type: exports.HorizontalTextAlignment,
    displayOrder: 5,
    tooltip: "文字水平对齐模式"
}), _dec7$h = property({
    type: exports.VerticalTextAlignment,
    displayOrder: 6,
    tooltip: "文字垂直对齐模式"
}), _dec8$f = property({
    readonly: !0,
    displayName: "Actual Font Size",
    visible: !1
}), _dec9$b = property({
    displayOrder: 7,
    tooltip: "文字尺寸，以 point 为单位"
}), _dec10$8 = property({
    displayOrder: 8,
    tooltip: "文字字体名字"
}), _dec11$8 = property({
    displayOrder: 8,
    tooltip: "文字行高，以 point 为单位"
}), _dec12$7 = property({
    type: exports.Overflow,
    displayOrder: 9,
    tooltip: "文字排版模式，包括以下三种：\n 1. CLAMP: 节点约束框之外的文字会被截断 \n 2. SHRINK: 自动根据节点约束框缩小文字\n 3. RESIZE_HEIGHT: 根据文本内容自动更新节点的 height 属性."
}), _dec13$6 = property({
    displayOrder: 10,
    tooltip: "自动换行"
}), _dec14$5 = property({
    type: Font,
    displayOrder: 11,
    tooltip: "Label 使用的字体资源"
}), _dec15$4 = property({
    displayOrder: 12,
    tooltip: "是否使用系统默认字体"
}), _dec16$4 = property({
    type: CacheMode,
    displayOrder: 13,
    tooltip: "文本缓存模式，包括以下三种：\n 1. NONE: 不做任何缓存，文本内容进行一次绘制 \n 2. BITMAP: 将文本作为静态图像加入动态图集进行批次合并，但是不能频繁动态修改文本内容 \n 3. CHAR: 将文本拆分为字符并且把字符纹理缓存到一张字符图集中进行复用，适用于字符内容重复并且频繁更新的文本内容"
}), _dec17$3 = property({
    displayOrder: 15,
    tooltip: "字体加粗"
}), _dec18$3 = property({
    displayOrder: 16,
    tooltip: "字体倾斜"
}), _dec19$3 = property({
    displayOrder: 17,
    tooltip: "字体加下划线"
}), _dec$17(_class$18 = _dec2$K(_class$18 = _dec3$u(_class$18 = _dec4$q((_temp$12 = _class3$m = function(_UIRenderComponent) {
    function LabelComponent() {
        var _this;
        return _classCallCheck(this, LabelComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LabelComponent).call(this)), "_useOriginalSize", _descriptor$S, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_string", _descriptor2$G, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_verticalAlign", _descriptor4$r, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_actualFontSize", _descriptor5$l, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fontSize", _descriptor6$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fontFamily", _descriptor7$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lineHeight", _descriptor8$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_overflow", _descriptor9$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_enableWrapText", _descriptor10$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_font", _descriptor11$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor12$4, _assertThisInitialized(_this)), 
        _this._spacingX = 0, _initializerDefineProperty(_this, "_isItalic", _descriptor13$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isBold", _descriptor14$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isUnderline", _descriptor15$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_cacheMode", _descriptor16$2, _assertThisInitialized(_this)), 
        _this._N$file = null, _this._texture = null, _this._ttfSpriteFrame = null, _this._userDefinedFont = null, 
        _this._assemblerData = null, _this._fontAtlas = null, _this._letterTexture = null, 
        _this._ttfSpriteFrame = null, _this;
    }
    return _inherits(LabelComponent, UIRenderComponent), _createClass(LabelComponent, [ {
        key: "string",
        get: function get() {
            return this._string;
        },
        set: function set(value) {
            value = value.toString(), this._string !== value && (this._string = value, this.updateRenderData());
        }
    }, {
        key: "horizontalAlign",
        get: function get() {
            return this._horizontalAlign;
        },
        set: function set(value) {
            this._horizontalAlign !== value && (this._horizontalAlign = value, this.updateRenderData());
        }
    }, {
        key: "verticalAlign",
        get: function get() {
            return this._verticalAlign;
        },
        set: function set(value) {
            this._verticalAlign !== value && (this._verticalAlign = value, this.updateRenderData());
        }
    }, {
        key: "actualFontSize",
        get: function get() {
            return this._actualFontSize;
        },
        set: function set(value) {
            this._actualFontSize = value;
        }
    }, {
        key: "fontSize",
        get: function get() {
            return this._fontSize;
        },
        set: function set(value) {
            this._fontSize !== value && (this._fontSize = value, this.updateRenderData());
        }
    }, {
        key: "fontFamily",
        get: function get() {
            return this._fontFamily;
        },
        set: function set(value) {
            this._fontFamily !== value && (this._fontFamily = value, this.updateRenderData());
        }
    }, {
        key: "lineHeight",
        get: function get() {
            return this._lineHeight;
        },
        set: function set(value) {
            this._lineHeight !== value && (this._lineHeight = value, this.updateRenderData());
        }
    }, {
        key: "overflow",
        get: function get() {
            return this._overflow;
        },
        set: function set(value) {
            this._overflow !== value && (this._overflow = value, this.updateRenderData());
        }
    }, {
        key: "enableWrapText",
        get: function get() {
            return this._enableWrapText;
        },
        set: function set(value) {
            this._enableWrapText !== value && (this._enableWrapText = value, this.updateRenderData());
        }
    }, {
        key: "font",
        get: function get() {
            return this._font;
        },
        set: function set(value) {
            this._font !== value && (this._isSystemFontUsed = !value, this._font = value, "string" == typeof value && warnID(4e3), 
            this._renderData && (this.destroyRenderData(), this._renderData = null), this._fontAtlas = null, 
            this.updateRenderData(!0));
        }
    }, {
        key: "useSystemFont",
        get: function get() {
            return this._isSystemFontUsed;
        },
        set: function set(value) {
            this._isSystemFontUsed !== value && (this.destroyRenderData(), this._renderData = null, 
            this._isSystemFontUsed = !!value, value && (this.font = null, this._flushAssembler(), 
            this.updateRenderData()));
        }
    }, {
        key: "cacheMode",
        get: function get() {
            return this._cacheMode;
        },
        set: function set(value) {
            this._cacheMode !== value && (this._cacheMode === CacheMode.CHAR && (this._ttfSpriteFrame = null), 
            this._cacheMode = value, this.updateRenderData(!0));
        }
    }, {
        key: "spriteFrame",
        get: function get() {
            return this._texture;
        }
    }, {
        key: "isBold",
        get: function get() {
            return this._isBold;
        },
        set: function set(value) {
            this._isBold !== value && (this._isBold = value, this.updateRenderData());
        }
    }, {
        key: "isItalic",
        get: function get() {
            return this._isItalic;
        },
        set: function set(value) {
            this._isItalic !== value && (this._isItalic = value, this.updateRenderData());
        }
    }, {
        key: "isUnderline",
        get: function get() {
            return this._isUnderline;
        },
        set: function set(value) {
            this._isUnderline !== value && (this._isUnderline = value, this.updateRenderData());
        }
    }, {
        key: "assemblerData",
        get: function get() {
            return this._assemblerData;
        }
    }, {
        key: "fontAtlas",
        get: function get() {
            return this._fontAtlas;
        },
        set: function set(value) {
            this._fontAtlas = value;
        }
    }, {
        key: "spacingX",
        get: function get() {
            return this._spacingX;
        },
        set: function set(value) {
            this._spacingX !== value && (this._spacingX = value, this.updateRenderData());
        }
    }, {
        key: "_bmFontOriginalSize",
        get: function get() {
            return this._font instanceof BitmapFont ? this._font.fontSize : -1;
        }
    } ]), _createClass(LabelComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(LabelComponent.prototype), "onEnable", this).call(this), this._font || this._isSystemFontUsed || (this.useSystemFont = !0), 
            this._isSystemFontUsed && !this._fontFamily && (this.fontFamily = "Arial"), this.updateRenderData(!0);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(LabelComponent.prototype), "onDisable", this).call(this);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            if (this._assembler && this._assembler.resetAssemblerData && this._assembler.resetAssemblerData(this._assemblerData), 
            this._assemblerData = null, this._ttfSpriteFrame) {
                var tex = this._ttfSpriteFrame.texture;
                if (tex) {
                    var tex2d = tex;
                    tex2d.image && tex2d.image.destroy(), tex.destroy();
                }
                this._ttfSpriteFrame = null;
            }
            this._letterTexture = null, _get(_getPrototypeOf(LabelComponent.prototype), "onDestroy", this).call(this);
        }
    }, {
        key: "updateRenderData",
        value: function updateRenderData() {
            var force = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            this.markForUpdateRenderData(), force && (this._flushAssembler(), this._applyFontTexture());
        }
    }, {
        key: "_render",
        value: function _render(render) {
            render.commitComp(this, this._texture.getGFXTextureView(), this._assembler, this._texture.getGFXSampler());
        }
    }, {
        key: "_updateColor",
        value: function _updateColor() {
            this._font instanceof BitmapFont ? _get(_getPrototypeOf(LabelComponent.prototype), "_updateColor", this).call(this) : this.updateRenderData(!1);
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            if (!_get(_getPrototypeOf(LabelComponent.prototype), "_canRender", this).call(this) || !this._string) return !1;
            var font = this._font;
            if (font && font instanceof BitmapFont) {
                var spriteFrame = font.spriteFrame;
                if (!spriteFrame || !spriteFrame.textureLoaded()) return !1;
            }
            return !0;
        }
    }, {
        key: "_flushAssembler",
        value: function _flushAssembler() {
            var assembler = LabelComponent.Assembler.getAssembler(this);
            this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
            this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
            this._renderData.material = this._material);
        }
    }, {
        key: "_flushMaterial",
        value: function _flushMaterial() {
            this._updateMaterial(this._material);
        }
    }, {
        key: "_applyFontTexture",
        value: function _applyFontTexture() {
            var _this2 = this, font = this._font;
            if (font instanceof BitmapFont) {
                var spriteFrame = font.spriteFrame, onBMFontTextureLoaded = function onBMFontTextureLoaded() {
                    _this2._texture = spriteFrame, _this2._flushMaterial(), _this2._assembler && _this2._assembler.updateRenderData(_this2);
                };
                spriteFrame && (spriteFrame.loaded || spriteFrame.textureLoaded ? onBMFontTextureLoaded() : spriteFrame.once("load", onBMFontTextureLoaded, this));
            } else {
                if (this.cacheMode === CacheMode.CHAR) this._letterTexture = this._assembler.getAssemblerData(), 
                this._texture = this._letterTexture; else if (!this._ttfSpriteFrame) {
                    this._ttfSpriteFrame = new SpriteFrame, this._assemblerData = this._assembler.getAssemblerData();
                    var tex = new ImageAsset(this._assemblerData.canvas)._texture;
                    this._ttfSpriteFrame.texture = tex;
                }
                this.cacheMode !== CacheMode.CHAR && (this._texture = this._ttfSpriteFrame), this._flushMaterial(), 
                this._assembler && this._assembler.updateRenderData(this);
            }
        }
    } ]), LabelComponent;
}(), _class3$m.HorizontalAlign = exports.HorizontalTextAlignment, _class3$m.VerticalAlign = exports.VerticalTextAlignment, 
_class3$m.Overflow = exports.Overflow, _class3$m.CacheMode = CacheMode, _class3$m._canvasPool = new CanvasPool, 
_applyDecoratedDescriptor((_class2$$ = _temp$12).prototype, "string", [ _dec5$n ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "string"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "horizontalAlign", [ _dec6$l ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "horizontalAlign"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "verticalAlign", [ _dec7$h ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "verticalAlign"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "actualFontSize", [ _dec8$f ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "actualFontSize"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "fontSize", [ _dec9$b ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "fontSize"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "fontFamily", [ _dec10$8 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "fontFamily"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "lineHeight", [ _dec11$8 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "lineHeight"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "overflow", [ _dec12$7 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "overflow"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "enableWrapText", [ _dec13$6 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "enableWrapText"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "font", [ _dec14$5 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "font"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "useSystemFont", [ _dec15$4 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "useSystemFont"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "cacheMode", [ _dec16$4 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "cacheMode"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "isBold", [ _dec17$3 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isBold"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "isItalic", [ _dec18$3 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isItalic"), _class2$$.prototype), 
_applyDecoratedDescriptor(_class2$$.prototype, "isUnderline", [ _dec19$3 ], Object.getOwnPropertyDescriptor(_class2$$.prototype, "isUnderline"), _class2$$.prototype), 
_descriptor$S = _applyDecoratedDescriptor(_class2$$.prototype, "_useOriginalSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor2$G = _applyDecoratedDescriptor(_class2$$.prototype, "_string", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "label";
    }
}), _descriptor3$y = _applyDecoratedDescriptor(_class2$$.prototype, "_horizontalAlign", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.HorizontalTextAlignment.CENTER;
    }
}), _descriptor4$r = _applyDecoratedDescriptor(_class2$$.prototype, "_verticalAlign", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.VerticalTextAlignment.CENTER;
    }
}), _descriptor5$l = _applyDecoratedDescriptor(_class2$$.prototype, "_actualFontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$c = _applyDecoratedDescriptor(_class2$$.prototype, "_fontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor7$b = _applyDecoratedDescriptor(_class2$$.prototype, "_fontFamily", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "Arial";
    }
}), _descriptor8$9 = _applyDecoratedDescriptor(_class2$$.prototype, "_lineHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor9$9 = _applyDecoratedDescriptor(_class2$$.prototype, "_overflow", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.Overflow.NONE;
    }
}), _descriptor10$8 = _applyDecoratedDescriptor(_class2$$.prototype, "_enableWrapText", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor11$4 = _applyDecoratedDescriptor(_class2$$.prototype, "_font", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor12$4 = _applyDecoratedDescriptor(_class2$$.prototype, "_isSystemFontUsed", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor13$4 = _applyDecoratedDescriptor(_class2$$.prototype, "_isItalic", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor14$4 = _applyDecoratedDescriptor(_class2$$.prototype, "_isBold", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor15$2 = _applyDecoratedDescriptor(_class2$$.prototype, "_isUnderline", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor16$2 = _applyDecoratedDescriptor(_class2$$.prototype, "_cacheMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return CacheMode.NONE;
    }
}), _class$18 = _class2$$)) || _class$18) || _class$18) || _class$18) || _class$18);

cc.LabelComponent = LabelComponent;

var KeyboardReturnType, InputMode, InputFlag, tabIndexUtil = function() {
    function tabIndexUtil() {
        _classCallCheck(this, tabIndexUtil);
    }
    return _createClass(tabIndexUtil, null, [ {
        key: "add",
        value: function add(editBoxImpl) {
            var list = this._tabIndexList;
            -1 === list.indexOf(editBoxImpl) && list.push(editBoxImpl);
        }
    }, {
        key: "remove",
        value: function remove(editBoxImpl) {
            var list = this._tabIndexList, index = list.indexOf(editBoxImpl);
            -1 !== index && list.splice(index, 1);
        }
    }, {
        key: "resort",
        value: function resort() {
            this._tabIndexList.sort((function(a, b) {
                return a._delegate.tabIndex - b._delegate.tabIndex;
            }));
        }
    }, {
        key: "next",
        value: function next(editBoxImpl) {
            var list = this._tabIndexList, index = list.indexOf(editBoxImpl);
            if (editBoxImpl.setFocus(!1), -1 !== index) {
                var nextImpl = list[index + 1];
                nextImpl && nextImpl._delegate.tabIndex >= 0 && nextImpl.setFocus(!0);
            }
        }
    } ]), tabIndexUtil;
}();

tabIndexUtil._tabIndexList = [], function(KeyboardReturnType) {
    KeyboardReturnType[KeyboardReturnType.DEFAULT = 0] = "DEFAULT", KeyboardReturnType[KeyboardReturnType.DONE = 1] = "DONE", 
    KeyboardReturnType[KeyboardReturnType.SEND = 2] = "SEND", KeyboardReturnType[KeyboardReturnType.SEARCH = 3] = "SEARCH", 
    KeyboardReturnType[KeyboardReturnType.GO = 4] = "GO", KeyboardReturnType[KeyboardReturnType.NEXT = 5] = "NEXT";
}(KeyboardReturnType || (KeyboardReturnType = {})), Enum(KeyboardReturnType), function(InputMode) {
    InputMode[InputMode.ANY = 0] = "ANY", InputMode[InputMode.EMAIL_ADDR = 1] = "EMAIL_ADDR", 
    InputMode[InputMode.NUMERIC = 2] = "NUMERIC", InputMode[InputMode.PHONE_NUMBER = 3] = "PHONE_NUMBER", 
    InputMode[InputMode.URL = 4] = "URL", InputMode[InputMode.DECIMAL = 5] = "DECIMAL", 
    InputMode[InputMode.SINGLE_LINE = 6] = "SINGLE_LINE";
}(InputMode || (InputMode = {})), Enum(InputMode), function(InputFlag) {
    InputFlag[InputFlag.PASSWORD = 0] = "PASSWORD", InputFlag[InputFlag.SENSITIVE = 1] = "SENSITIVE", 
    InputFlag[InputFlag.INITIAL_CAPS_WORD = 2] = "INITIAL_CAPS_WORD", InputFlag[InputFlag.INITIAL_CAPS_SENTENCE = 3] = "INITIAL_CAPS_SENTENCE", 
    InputFlag[InputFlag.INITIAL_CAPS_ALL_CHARACTERS = 4] = "INITIAL_CAPS_ALL_CHARACTERS", 
    InputFlag[InputFlag.DEFAULT = 5] = "DEFAULT";
}(InputFlag || (InputFlag = {})), Enum(InputFlag);

var EditBoxImplBase = function() {
    function EditBoxImplBase() {
        _classCallCheck(this, EditBoxImplBase), this._editing = !1, this._delegate = null;
    }
    return _createClass(EditBoxImplBase, [ {
        key: "init",
        value: function init(delegate) {}
    }, {
        key: "onEnable",
        value: function onEnable() {}
    }, {
        key: "update",
        value: function update() {}
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._editing && this.endEditing();
        }
    }, {
        key: "clear",
        value: function clear() {
            this._delegate = null;
        }
    }, {
        key: "setTabIndex",
        value: function setTabIndex(index) {}
    }, {
        key: "setSize",
        value: function setSize(width, height) {}
    }, {
        key: "setFocus",
        value: function setFocus(value) {
            value ? this.beginEditing() : this.endEditing();
        }
    }, {
        key: "isFocused",
        value: function isFocused() {
            return this._editing;
        }
    }, {
        key: "beginEditing",
        value: function beginEditing() {}
    }, {
        key: "endEditing",
        value: function endEditing() {}
    } ]), EditBoxImplBase;
}(), _matrix$1 = new Mat4, _matrix_temp = new Mat4, _vec3$1 = new Vec3, _currentEditBoxImpl = null, _domCount = 0, polyfill = {
    zoomInvalid: !1
};

sys.OS_ANDROID !== sys.os || sys.browserType !== sys.BROWSER_TYPE_SOUGOU && sys.browserType !== sys.BROWSER_TYPE_360 || (polyfill.zoomInvalid = !0);

var _dec$18, _dec2$L, _dec3$v, _dec4$r, _dec5$o, _dec6$m, _dec7$i, _dec8$g, _dec9$c, _dec10$9, _dec11$9, _dec12$8, _dec13$7, _dec14$6, _dec15$5, _dec16$5, _dec17$4, _dec18$4, _dec19$4, _dec20$2, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _class$19, _class2$10, _descriptor$T, _descriptor2$H, _descriptor3$z, _descriptor4$s, _descriptor5$m, _descriptor6$d, _descriptor7$c, _descriptor8$a, _descriptor9$a, _descriptor10$9, _descriptor11$5, _descriptor12$5, _descriptor13$5, _descriptor14$5, _class3$n, _temp$13, EventType$3, EditBoxImpl = function(_EditBoxImplBase) {
    function EditBoxImpl() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, EditBoxImpl);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditBoxImpl)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._delegate = null, 
        _this._inputMode = InputMode.ANY, _this._inputFlag = InputFlag.DEFAULT, _this._returnType = KeyboardReturnType.DEFAULT, 
        _this._maxLength = 50, _this._placeholderText = "", _this._alwaysOnTop = !1, _this._size = new Size, 
        _this._node = null, _this._editing = !1, _this.__eventListeners = {}, _this.__fullscreen = !1, 
        _this.__autoResize = !1, _this.__rotateScreen = !1, _this.__orientationChanged = void 0, 
        _this._edTxt = null, _this._textColor = Color.WHITE.clone(), _this._edFontSize = 14, 
        _this._isTextArea = !1, _this._textLabelFont = null, _this._textLabelFontSize = null, 
        _this._textLabelFontColor = null, _this._textLabelAlign = null, _this._placeholderLabelFont = null, 
        _this._placeholderLabelFontSize = null, _this._placeholderLabelFontColor = null, 
        _this._placeholderLabelAlign = null, _this._placeholderLineHeight = null, _this._placeholderStyleSheet = null, 
        _this._domId = "EditBoxId_".concat(++_domCount), _this;
    }
    return _inherits(EditBoxImpl, EditBoxImplBase), _createClass(EditBoxImpl, [ {
        key: "init",
        value: function init(delegate) {
            delegate && (this._delegate = delegate, delegate.inputMode === InputMode.ANY ? this._createTextArea() : this._createInput(), 
            tabIndexUtil.add(this), this.setTabIndex(delegate.tabIndex), this._initStyleSheet(), 
            this._registerEventListeners(), this._addDomToGameContainer(), this.__fullscreen = view.isAutoFullScreenEnabled(), 
            this.__autoResize = view._resizeWithBrowserSize);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {}
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._editing && this._edTxt && this._edTxt.blur();
        }
    }, {
        key: "clear",
        value: function clear() {
            this._removeEventListeners(), this._removeDomFromGameContainer(), tabIndexUtil.remove(this), 
            _currentEditBoxImpl === this && (_currentEditBoxImpl = null), this._delegate = null;
        }
    }, {
        key: "update",
        value: function update() {
            this._updateMatrix();
        }
    }, {
        key: "setTabIndex",
        value: function setTabIndex(index) {
            this._edTxt.tabIndex = index, tabIndexUtil.resort();
        }
    }, {
        key: "setSize",
        value: function setSize(width, height) {
            var elem = this._edTxt;
            elem && (elem.style.width = width + "px", elem.style.height = height + "px");
        }
    }, {
        key: "setFocus",
        value: function setFocus(value) {
            value ? this.beginEditing() : this._edTxt.blur();
        }
    }, {
        key: "isFocused",
        value: function isFocused() {
            return this._editing;
        }
    }, {
        key: "beginEditing",
        value: function beginEditing() {
            _currentEditBoxImpl && _currentEditBoxImpl !== this && _currentEditBoxImpl.setFocus(!1), 
            this._editing = !0, _currentEditBoxImpl = this, this._showDom(), this._edTxt && this._delegate && (this._edTxt.focus(), 
            this._delegate._editBoxEditingDidBegan());
        }
    }, {
        key: "endEditing",
        value: function endEditing() {}
    }, {
        key: "_createInput",
        value: function _createInput() {
            this._isTextArea = !1, this._edTxt = document.createElement("input");
        }
    }, {
        key: "_createTextArea",
        value: function _createTextArea() {
            this._isTextArea = !0, this._edTxt = document.createElement("textarea");
        }
    }, {
        key: "_addDomToGameContainer",
        value: function _addDomToGameContainer() {
            game.container && this._edTxt && (game.container.appendChild(this._edTxt), document.head.appendChild(this._placeholderStyleSheet));
        }
    }, {
        key: "_removeDomFromGameContainer",
        value: function _removeDomFromGameContainer() {
            contains$1(game.container, this._edTxt) && this._edTxt && game.container.removeChild(this._edTxt), 
            contains$1(document.head, this._placeholderStyleSheet) && document.head.removeChild(this._placeholderStyleSheet), 
            delete this._edTxt, delete this._placeholderStyleSheet;
        }
    }, {
        key: "_showDom",
        value: function _showDom() {
            this._updateMaxLength(), this._updateInputType(), this._updateStyleSheet(), this._edTxt && this._delegate && (this._edTxt.style.display = "", 
            this._delegate._hideLabels()), sys.isMobile && this._showDomOnMobile();
        }
    }, {
        key: "_hideDom",
        value: function _hideDom() {
            var elem = this._edTxt;
            elem && this._delegate && (elem.style.display = "none", this._delegate._showLabels()), 
            sys.isMobile && this._hideDomOnMobile();
        }
    }, {
        key: "_showDomOnMobile",
        value: function _showDomOnMobile() {
            sys.os === sys.OS_ANDROID && (this.__fullscreen && (view.enableAutoFullScreen(!1), 
            screen$1.exitFullScreen()), this.__autoResize && view.resizeWithBrowserSize(!1), 
            this._adjustWindowScroll());
        }
    }, {
        key: "_hideDomOnMobile",
        value: function _hideDomOnMobile() {
            var _this2 = this;
            sys.os === sys.OS_ANDROID && setTimeout((function() {
                _currentEditBoxImpl || (_this2.__fullscreen && view.enableAutoFullScreen(!0), _this2.__autoResize && view.resizeWithBrowserSize(!0));
            }), 400), this._scrollBackWindow();
        }
    }, {
        key: "_adjustWindowScroll",
        value: function _adjustWindowScroll() {
            var self = this;
            setTimeout((function() {
                window.scrollY < 40 && self._edTxt.scrollIntoView({
                    block: "start",
                    inline: "nearest",
                    behavior: "smooth"
                });
            }), 400);
        }
    }, {
        key: "_scrollBackWindow",
        value: function _scrollBackWindow() {
            setTimeout((function() {
                sys.browserType !== sys.BROWSER_TYPE_WECHAT || sys.os !== sys.OS_IOS ? window.scrollTo(0, 0) : window.top && window.top.scrollTo(0, 0);
            }), 400);
        }
    }, {
        key: "_updateMatrix",
        value: function _updateMatrix() {
            if (this._edTxt) {
                var node = this._delegate.node, scaleX = view.getScaleX(), scaleY = view.getScaleY(), viewport = view.getViewportRect(), dpr = view.getDevicePixelRatio();
                node.getWorldMatrix(_matrix$1);
                var transform = node._uiProps.uiTransformComp;
                if (transform && Vec3.set(_vec3$1, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3$1.z), 
                Mat4.transform(_matrix$1, _matrix$1, _vec3$1), !node._uiProps.uiTransformComp) return !1;
                var canvas = director.root.ui.getScreen(node._uiProps.uiTransformComp.visibility);
                if (canvas) {
                    canvas.node.getWorldRT(_matrix_temp);
                    var m12 = _matrix_temp.m12, m13 = _matrix_temp.m13, center = visibleRect.center;
                    _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13), 
                    _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13), 
                    Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1), scaleX /= dpr, scaleY /= dpr;
                    var container = game.container, a = _matrix_temp.m00 * scaleX, b = _matrix$1.m01, c = _matrix$1.m04, d = _matrix_temp.m05 * scaleY, offsetX = parseInt(container && container.style.paddingLeft || "0");
                    offsetX += viewport.x / dpr;
                    var offsetY = parseInt(container && container.style.paddingBottom || "0");
                    offsetY += viewport.y / dpr;
                    var tx = _matrix_temp.m12 * scaleX + offsetX, ty = _matrix_temp.m13 * scaleY + offsetY;
                    polyfill.zoomInvalid && (this.setSize(this._size.width * a, this._size.height * d), 
                    a = 1, d = 1);
                    var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                    this._edTxt.style.transform = matrix, this._edTxt.style["-webkit-transform"] = matrix, 
                    this._edTxt.style["transform-origin"] = "0px 100% 0px", this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px";
                }
            }
        }
    }, {
        key: "_updateInputType",
        value: function _updateInputType() {
            var delegate = this._delegate, inputMode = delegate.inputMode, inputFlag = delegate.inputFlag, returnType = delegate.returnType, elem = this._edTxt;
            if (this._inputMode !== inputMode || this._inputFlag !== inputFlag || this._returnType !== returnType) {
                if (this._inputMode = inputMode, this._inputFlag = inputFlag, this._returnType = returnType, 
                this._isTextArea) {
                    var _textTransform = "none";
                    return inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? _textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (_textTransform = "capitalize"), 
                    void (elem.style.textTransform = _textTransform);
                }
                if (elem = elem, inputFlag !== InputFlag.PASSWORD) {
                    var type = elem.type;
                    inputMode === InputMode.EMAIL_ADDR ? type = "email" : inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL ? type = "number" : inputMode === InputMode.PHONE_NUMBER ? (type = "number", 
                    elem.pattern = "[0-9]*") : inputMode === InputMode.URL ? type = "url" : (type = "text", 
                    returnType === KeyboardReturnType.SEARCH && (type = "search")), elem.type = type;
                    var textTransform = "none";
                    inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize"), 
                    elem.style.textTransform = textTransform;
                } else elem.type = "password";
            }
        }
    }, {
        key: "_updateMaxLength",
        value: function _updateMaxLength() {
            var maxLength = this._delegate.maxLength;
            maxLength < 0 && (maxLength = 65535), this._edTxt.maxLength = maxLength;
        }
    }, {
        key: "_initStyleSheet",
        value: function _initStyleSheet() {
            if (this._edTxt) {
                var elem = this._edTxt;
                elem.style.fontSize = this._edFontSize + "px", elem.style.color = "#000000", elem.style.border = "0px", 
                elem.style.background = "transparent", elem.style.width = "100%", elem.style.height = "100%", 
                elem.style.outline = "medium", elem.style.padding = "0", elem.style.textTransform = "uppercase", 
                elem.style.display = "none", elem.style.position = "absolute", elem.style.bottom = "0px", 
                elem.style.left = "2px", elem.className = "cocosEditBox", elem.style.fontFamily = "Arial", 
                elem.id = this._domId, this._isTextArea ? (elem.style.resize = "none", elem.style.overflowY = "scroll") : ((elem = elem).type = "text", 
                elem.style["-moz-appearance"] = "textfield"), this._placeholderStyleSheet = document.createElement("style");
            }
        }
    }, {
        key: "_updateStyleSheet",
        value: function _updateStyleSheet() {
            var delegate = this._delegate, elem = this._edTxt;
            elem && delegate && (elem.value = delegate.string, elem.placeholder = delegate.placeholder, 
            this._updateTextLabel(delegate.textLabel), this._updatePlaceholderLabel(delegate.placeholderLabel));
        }
    }, {
        key: "_updateTextLabel",
        value: function _updateTextLabel(textLabel) {
            if (textLabel) {
                var font = textLabel.font;
                if (font = !font || font instanceof BitmapFont ? textLabel.fontFamily : font._fontFamily, 
                (this._textLabelFont !== font || this._textLabelFontSize !== textLabel.fontSize || this._textLabelFontColor !== textLabel.fontColor || this._textLabelAlign !== textLabel.horizontalAlign) && (this._textLabelFont = font, 
                this._textLabelFontSize = textLabel.fontSize, this._textLabelFontColor = textLabel.fontColor, 
                this._textLabelAlign = textLabel.horizontalAlign, this._edTxt)) {
                    var elem = this._edTxt;
                    switch (elem.style.fontSize = "".concat(textLabel.fontSize, "px"), elem.style.color = textLabel.color.toCSS("rgba"), 
                    elem.style.fontFamily = font, textLabel.horizontalAlign) {
                      case LabelComponent.HorizontalAlign.LEFT:
                        elem.style.textAlign = "left";
                        break;

                      case LabelComponent.HorizontalAlign.CENTER:
                        elem.style.textAlign = "center";
                        break;

                      case LabelComponent.HorizontalAlign.RIGHT:
                        elem.style.textAlign = "right";
                    }
                }
            }
        }
    }, {
        key: "_updatePlaceholderLabel",
        value: function _updatePlaceholderLabel(placeholderLabel) {
            if (placeholderLabel) {
                var font = placeholderLabel.font;
                if (font = !font || font instanceof BitmapFont ? placeholderLabel.fontFamily : placeholderLabel.font._fontFamily, 
                this._placeholderLabelFont !== font || this._placeholderLabelFontSize !== placeholderLabel.fontSize || this._placeholderLabelFontColor !== placeholderLabel.fontColor || this._placeholderLabelAlign !== placeholderLabel.horizontalAlign || this._placeholderLineHeight !== placeholderLabel.fontSize) {
                    this._placeholderLabelFont = font, this._placeholderLabelFontSize = placeholderLabel.fontSize, 
                    this._placeholderLabelFontColor = placeholderLabel.fontColor, this._placeholderLabelAlign = placeholderLabel.horizontalAlign, 
                    this._placeholderLineHeight = placeholderLabel.fontSize;
                    var styleEl = this._placeholderStyleSheet, fontSize = placeholderLabel.fontSize, fontColor = placeholderLabel.color.toCSS("rgba"), lineHeight = placeholderLabel.fontSize, horizontalAlign = "";
                    switch (placeholderLabel.horizontalAlign) {
                      case LabelComponent.HorizontalAlign.LEFT:
                        horizontalAlign = "left";
                        break;

                      case LabelComponent.HorizontalAlign.CENTER:
                        horizontalAlign = "center";
                        break;

                      case LabelComponent.HorizontalAlign.RIGHT:
                        horizontalAlign = "right";
                    }
                    styleEl.innerHTML = "\n            #".concat(this._domId, "::-webkit-input-placeholder {\n                text-transform: initial;\n                font-family: ").concat(font, ";\n                font-size: ").concat(fontSize, "px;\n                color: ").concat(fontColor, ";\n                line-height: ").concat(lineHeight, "px;\n                text-align: ").concat(horizontalAlign, ";\n            }\n            #").concat(this._domId, "::-moz-placeholder {\n                text-transform: initial;\n                font-family: ").concat(font, ";\n                font-size: ").concat(fontSize, "px;\n                color: ").concat(fontColor, ";\n                line-height: ").concat(lineHeight, "px;\n                text-align: ").concat(horizontalAlign, ";\n            }\n            #").concat(this._domId, ":-ms-input-placeholder {\n                text-transform: initial;\n                font-family: ").concat(font, ";\n                font-size: ").concat(fontSize, "px;\n                color: ").concat(fontColor, ";\n                line-height: ").concat(lineHeight, "px;\n                text-align: ").concat(horizontalAlign, ";\n            }\n        ");
                }
            }
        }
    }, {
        key: "_registerEventListeners",
        value: function _registerEventListeners() {
            if (this._edTxt) {
                var impl = this, elem = this._edTxt, inputLock = !1, cbs = this.__eventListeners;
                cbs.compositionStart = function() {
                    inputLock = !0;
                }, cbs.compositionEnd = function() {
                    inputLock = !1, impl._delegate._editBoxTextChanged(elem.value);
                }, cbs.onInput = function() {
                    inputLock || impl._delegate._editBoxTextChanged(elem.value);
                }, cbs.onClick = function() {
                    impl._editing && sys.isMobile && impl._adjustWindowScroll();
                }, cbs.onKeydown = function(e) {
                    e.keyCode === macro.KEY.enter ? (e.propagationStopped = !0, impl._delegate._editBoxEditingReturn(), 
                    impl._isTextArea || elem.blur()) : e.keyCode === macro.KEY.tab && (e.propagationStopped = !0, 
                    e.preventDefault(), tabIndexUtil.next(impl));
                }, cbs.onBlur = function() {
                    impl._editing = !1, _currentEditBoxImpl = null, impl._hideDom(), impl._delegate._editBoxEditingDidEnded();
                }, elem.addEventListener("compositionstart", cbs.compositionStart), elem.addEventListener("compositionend", cbs.compositionEnd), 
                elem.addEventListener("input", cbs.onInput), elem.addEventListener("keydown", cbs.onKeydown), 
                elem.addEventListener("blur", cbs.onBlur), elem.addEventListener("touchstart", cbs.onClick);
            }
        }
    }, {
        key: "_removeEventListeners",
        value: function _removeEventListeners() {
            if (this._edTxt) {
                var elem = this._edTxt, cbs = this.__eventListeners;
                elem.removeEventListener("compositionstart", cbs.compositionStart), elem.removeEventListener("compositionend", cbs.compositionEnd), 
                elem.removeEventListener("input", cbs.onInput), elem.removeEventListener("keydown", cbs.onKeydown), 
                elem.removeEventListener("blur", cbs.onBlur), elem.removeEventListener("touchstart", cbs.onClick), 
                cbs.compositionStart = null, cbs.compositionEnd = null, cbs.onInput = null, cbs.onKeydown = null, 
                cbs.onBlur = null, cbs.onClick = null;
            }
        }
    } ]), EditBoxImpl;
}();

function capitalize(str) {
    return str.replace(/(?:^|\s)\S/g, (function(a) {
        return a.toUpperCase();
    }));
}

function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

!function(EventType) {
    EventType.EDITING_DID_BEGAN = "editing-did-began", EventType.EDITING_DID_ENDED = "editing-did-ended", 
    EventType.TEXT_CHANGED = "text-changed", EventType.EDITING_RETURN = "editing-return";
}(EventType$3 || (EventType$3 = {}));

var _dec$19, _dec2$M, _dec3$w, _dec4$s, _dec5$p, _dec6$n, _dec7$j, _dec8$h, _dec9$d, _dec10$a, _dec11$a, _dec12$9, _dec13$8, _dec14$7, _dec15$6, _dec16$6, _dec17$5, _dec18$5, _dec19$5, _class$1a, _class2$11, _descriptor$U, _descriptor2$I, _descriptor3$A, _descriptor4$t, _descriptor5$n, _descriptor6$e, _descriptor7$d, _descriptor8$b, _descriptor9$b, _descriptor10$a, _descriptor11$6, _descriptor12$6, _descriptor13$6, _descriptor14$6, _class3$o, _temp$14, EditBoxComponent = (_dec$18 = ccclass("cc.EditBoxComponent"), 
_dec2$L = help("i18n:cc.EditBoxComponent"), _dec3$v = executionOrder(100), _dec4$r = menu("UI/EditBox"), 
_dec5$o = property({
    tooltip: "输入框的初始输入内容，如果为空则会显示占位符的文本",
    displayOrder: 1
}), _dec6$m = property({
    tooltip: "输入框文本的字体大小",
    displayOrder: 2
}), _dec7$i = property({
    type: Color,
    tooltip: "输入框文本的颜色",
    displayOrder: 3
}), _dec8$g = property({
    type: InputFlag,
    tooltip: "指定输入标志位，可以指定输入方式为密码或者单词首字母大写",
    displayOrder: 4
}), _dec9$c = property({
    type: InputMode,
    tooltip: "指定输入模式: ANY 表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式",
    displayOrder: 5
}), _dec10$9 = property({
    type: KeyboardReturnType,
    tooltip: "指定移动设备上面回车按钮的样式",
    displayOrder: 6
}), _dec11$9 = property({
    tooltip: "输入框最大允许输入的字符个数",
    displayOrder: 7
}), _dec12$8 = property({
    tooltip: "输入框文本的行高",
    displayOrder: 8
}), _dec13$7 = property({
    type: SpriteFrame,
    tooltip: "输入框的背景图片",
    displayOrder: 10
}), _dec14$6 = property({
    tooltip: "输入框输入文本节点上挂载的 Label 组件对象",
    type: LabelComponent,
    displayOrder: 11
}), _dec15$5 = property({
    tooltip: "输入框占位符节点上挂载的 Label 组件对象",
    type: LabelComponent,
    displayOrder: 12
}), _dec16$5 = property({
    tooltip: "输入框占位符的文本内容",
    displayOrder: 13
}), _dec17$4 = property({
    tooltip: "输入框占位符的字体大小",
    displayOrder: 14
}), _dec18$4 = property({
    tooltip: "输入框占位符的字体颜色",
    displayOrder: 15
}), _dec19$4 = property({
    tooltip: "输入框总是可见，并且永远在游戏视图的上面（这个属性只有在 Web 上面修改有意义）",
    displayOrder: 21
}), _dec20$2 = property({
    tooltip: "修改 DOM 输入元素的 tabIndex（这个属性只有在 Web 上面修改有意义）",
    displayOrder: 22
}), _dec21$1 = property({
    type: [ EventHandler ],
    tooltip: "该事件在用户点击输入框获取焦点的时候被触发",
    displayOrder: 31
}), _dec22$1 = property({
    type: [ EventHandler ],
    tooltip: "编辑文本输入框时触发的事件回调",
    displayOrder: 32
}), _dec23$1 = property({
    type: [ EventHandler ],
    tooltip: "在单行模式下面，一般是在用户按下回车或者点击屏幕输入框以外的地方调用该函数。 如果是多行输入，一般是在用户点击屏幕输入框以外的地方调用该函数",
    displayOrder: 33
}), _dec24$1 = property({
    type: [ EventHandler ],
    tooltip: "该事件在用户按下回车键的时候被触发, 如果是单行输入框，按回车键还会使输入框失去焦点",
    displayOrder: 34
}), _dec$18(_class$19 = _dec2$L(_class$19 = _dec3$v(_class$19 = _dec4$r(_class$19 = executeInEditMode((_temp$13 = _class3$n = function(_Component) {
    function EditBoxComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, EditBoxComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EditBoxComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "editingDidBegan", _descriptor$T, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "textChanged", _descriptor2$H, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "editingDidEnded", _descriptor3$z, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "editingReturn", _descriptor4$s, _assertThisInitialized(_this)), 
        _this._impl = null, _this._background = null, _initializerDefineProperty(_this, "_textLabel", _descriptor5$m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_placeholderLabel", _descriptor6$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_returnType", _descriptor7$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_useOriginalSize", _descriptor8$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_string", _descriptor9$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_tabIndex", _descriptor10$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_backgroundImage", _descriptor11$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_inputFlag", _descriptor12$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_inputMode", _descriptor13$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_maxLength", _descriptor14$5, _assertThisInitialized(_this)), 
        _this._isLabelVisible = !1, _this;
    }
    return _inherits(EditBoxComponent, Component), _createClass(EditBoxComponent, [ {
        key: "__preload",
        value: function __preload() {
            this._init();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._registerEvent(), this._impl && this._impl.onEnable();
        }
    }, {
        key: "update",
        value: function update() {
            this._impl && this._impl.update();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._unregisterEvent(), this._impl && this._impl.onDisable();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._impl && this._impl.clear();
        }
    }, {
        key: "setFocus",
        value: function setFocus() {
            this._impl && this._impl.setFocus(!0);
        }
    }, {
        key: "focus",
        value: function focus() {
            this._impl && this._impl.setFocus(!0);
        }
    }, {
        key: "blur",
        value: function blur() {
            this._impl && this._impl.setFocus(!1);
        }
    }, {
        key: "isFocused",
        value: function isFocused() {
            return !!this._impl && this._impl.isFocused();
        }
    }, {
        key: "_editBoxEditingDidBegan",
        value: function _editBoxEditingDidBegan() {
            EventHandler.emitEvents(this.editingDidBegan, this), this.node.emit(EventType$3.EDITING_DID_BEGAN, this);
        }
    }, {
        key: "_editBoxEditingDidEnded",
        value: function _editBoxEditingDidEnded() {
            EventHandler.emitEvents(this.editingDidEnded, this), this.node.emit(EventType$3.EDITING_DID_ENDED, this);
        }
    }, {
        key: "_editBoxTextChanged",
        value: function _editBoxTextChanged(text) {
            text = this._updateLabelStringStyle(text, !0), this.string = text, EventHandler.emitEvents(this.textChanged, text, this), 
            this.node.emit(EventType$3.TEXT_CHANGED, this);
        }
    }, {
        key: "_editBoxEditingReturn",
        value: function _editBoxEditingReturn() {
            EventHandler.emitEvents(this.editingReturn, this), this.node.emit(EventType$3.EDITING_RETURN, this);
        }
    }, {
        key: "_showLabels",
        value: function _showLabels() {
            this._isLabelVisible = !0, this._updateLabels();
        }
    }, {
        key: "_hideLabels",
        value: function _hideLabels() {
            this._isLabelVisible = !1, this._textLabel && (this._textLabel.node.active = !1), 
            this._placeholderLabel && (this._placeholderLabel.node.active = !1);
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event) {
            event.propagationStopped = !0;
        }
    }, {
        key: "_onTouchCancel",
        value: function _onTouchCancel(event) {
            event.propagationStopped = !0;
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event) {
            this._impl && this._impl.beginEditing(), event.propagationStopped = !0;
        }
    }, {
        key: "_init",
        value: function _init() {
            this._createBackgroundSprite(), this._updatePlaceholderLabel(), this._updateTextLabel(), 
            this._isLabelVisible = !0, this.node.on(exports.SystemEventType.SIZE_CHANGED, this._resizeChildNodes, this), 
            (this._impl = new EditBoxComponent._EditBoxImpl).init(this), this._updateString(this._string), 
            this._syncSize();
        }
    }, {
        key: "_createBackgroundSprite",
        value: function _createBackgroundSprite() {
            this._background || (this._background = this.node.getComponent(SpriteComponent), 
            this._background || (this._background = this.node.addComponent(SpriteComponent))), 
            this._background.type = SpriteComponent.Type.SLICED, this._background.spriteFrame = this._backgroundImage;
        }
    }, {
        key: "_updateTextLabel",
        value: function _updateTextLabel() {
            var textLabel = this._textLabel;
            if (!textLabel) {
                var node = this.node.getChildByName("TEXT_LABEL");
                node || (node = new Node$1("TEXT_LABEL")), (textLabel = node.getComponent(LabelComponent)) || (textLabel = node.addComponent(LabelComponent)), 
                node.parent = this.node, this._textLabel = textLabel;
            }
            this._textLabel.node._uiProps.uiTransformComp.setAnchorPoint(0, 1), textLabel.overflow = LabelComponent.Overflow.CLAMP, 
            this._inputMode === InputMode.ANY ? (textLabel.verticalAlign = exports.VerticalTextAlignment.TOP, 
            textLabel.enableWrapText = !0) : (textLabel.verticalAlign = exports.VerticalTextAlignment.CENTER, 
            textLabel.enableWrapText = !1), textLabel.string = this._updateLabelStringStyle(this._string);
        }
    }, {
        key: "_updatePlaceholderLabel",
        value: function _updatePlaceholderLabel() {
            var placeholderLabel = this._placeholderLabel;
            if (!placeholderLabel) {
                var node = this.node.getChildByName("PLACEHOLDER_LABEL");
                node || (node = new Node$1("PLACEHOLDER_LABEL")), (placeholderLabel = node.getComponent(LabelComponent)) || (placeholderLabel = node.addComponent(LabelComponent)), 
                node.parent = this.node, this._placeholderLabel = placeholderLabel;
            }
            this._placeholderLabel.node._uiProps.uiTransformComp.setAnchorPoint(0, 1), placeholderLabel.overflow = LabelComponent.Overflow.CLAMP, 
            this._inputMode === InputMode.ANY ? (placeholderLabel.verticalAlign = exports.VerticalTextAlignment.TOP, 
            placeholderLabel.enableWrapText = !0) : (placeholderLabel.verticalAlign = exports.VerticalTextAlignment.CENTER, 
            placeholderLabel.enableWrapText = !1), placeholderLabel.string = this.placeholder;
        }
    }, {
        key: "_syncSize",
        value: function _syncSize() {
            var size = this.node.getContentSize();
            this._background && (this._background.node._uiProps.uiTransformComp.anchorPoint = this.node._uiProps.uiTransformComp.anchorPoint, 
            this._background.node.setContentSize(size)), this._updateLabelPosition(size), this._impl && this._impl.setSize(size.width, size.height);
        }
    }, {
        key: "_updateLabels",
        value: function _updateLabels() {
            if (this._isLabelVisible) {
                var content = this._string;
                this._textLabel && (this._textLabel.node.active = "" !== content), this._placeholderLabel && (this._placeholderLabel.node.active = "" === content);
            }
        }
    }, {
        key: "_updateString",
        value: function _updateString(text) {
            var textLabel = this._textLabel;
            if (textLabel) {
                var displayText = text;
                displayText && (displayText = this._updateLabelStringStyle(displayText)), textLabel.string = displayText, 
                this._updateLabels();
            }
        }
    }, {
        key: "_updateLabelStringStyle",
        value: function _updateLabelStringStyle(text) {
            var ignorePassword = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], inputFlag = this._inputFlag;
            if (ignorePassword || inputFlag !== InputFlag.PASSWORD) inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? text = text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? text = capitalize(text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (text = capitalizeFirstLetter(text)); else {
                for (var passwordString = "", len = text.length, i = 0; i < len; ++i) passwordString += "●";
                text = passwordString;
            }
            return text;
        }
    }, {
        key: "_registerEvent",
        value: function _registerEvent() {
            this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this);
        }
    }, {
        key: "_unregisterEvent",
        value: function _unregisterEvent() {
            this.node.off(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this);
        }
    }, {
        key: "_updateLabelPosition",
        value: function _updateLabelPosition(size) {
            var node = this.node, offX = -node.anchorX * node.width, offY = -node.anchorY * node.height, placeholderLabel = this._placeholderLabel, textLabel = this._textLabel;
            textLabel && (textLabel.node.setContentSize(size.width - 2, size.height), textLabel.node.position = new Vec3(offX + 2, offY + size.height, textLabel.node.position.z), 
            textLabel.verticalAlign = this._inputMode === InputMode.ANY ? exports.VerticalTextAlignment.TOP : exports.VerticalTextAlignment.CENTER, 
            textLabel.enableWrapText = this._inputMode === InputMode.ANY), placeholderLabel && (placeholderLabel.node.setContentSize(size.width - 2, size.height), 
            placeholderLabel.lineHeight = size.height, placeholderLabel.node.position = new Vec3(offX + 2, offY + size.height, placeholderLabel.node.position.z), 
            placeholderLabel.verticalAlign = this._inputMode === InputMode.ANY ? exports.VerticalTextAlignment.TOP : exports.VerticalTextAlignment.CENTER, 
            placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY);
        }
    }, {
        key: "_resizeChildNodes",
        value: function _resizeChildNodes() {
            var textLabelNode = this._textLabel && this._textLabel.node;
            textLabelNode && (textLabelNode.position = new Vec3(-this.node.width / 2, this.node.height / 2, textLabelNode.position.z), 
            textLabelNode.width = this.node.width, textLabelNode.height = this.node.height);
            var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;
            placeholderLabelNode && (placeholderLabelNode.position = new Vec3(-this.node.width / 2, this.node.height / 2, placeholderLabelNode.position.z), 
            placeholderLabelNode.width = this.node.width, placeholderLabelNode.height = this.node.height);
            var backgroundNode = this._background && this._background.node;
            backgroundNode && (backgroundNode.width = this.node.width, backgroundNode.height = this.node.height);
        }
    }, {
        key: "string",
        get: function get() {
            return this._string;
        },
        set: function set(value) {
            this._maxLength >= 0 && value.length >= this._maxLength && (value = value.slice(0, this._maxLength)), 
            this._string = value, this._updateString(value);
        }
    }, {
        key: "fontSize",
        get: function get() {
            return this._textLabel ? this._textLabel.fontSize : 20;
        },
        set: function set(value) {
            this._textLabel && (this._textLabel.fontSize = value);
        }
    }, {
        key: "fontColor",
        get: function get() {
            return this._textLabel ? this._textLabel.color : Color.WHITE.clone();
        },
        set: function set(value) {
            this._textLabel && (this._textLabel.color = value);
        }
    }, {
        key: "inputFlag",
        get: function get() {
            return this._inputFlag;
        },
        set: function set(value) {
            this._inputFlag = value, this._updateString(this._string);
        }
    }, {
        key: "inputMode",
        get: function get() {
            return this._inputMode;
        },
        set: function set(oldValue) {
            this._inputMode !== oldValue && (this._inputMode = oldValue, this._updateTextLabel(), 
            this._updatePlaceholderLabel());
        }
    }, {
        key: "returnType",
        get: function get() {
            return this._returnType;
        },
        set: function set(value) {
            this._returnType = value;
        }
    }, {
        key: "maxLength",
        get: function get() {
            return this._maxLength;
        },
        set: function set(value) {
            this._maxLength = value;
        }
    }, {
        key: "lineHeight",
        get: function get() {
            return this._textLabel ? this._textLabel.lineHeight : 40;
        },
        set: function set(value) {
            this._textLabel && (this._textLabel.lineHeight = value);
        }
    }, {
        key: "backgroundImage",
        get: function get() {
            return this._backgroundImage;
        },
        set: function set(value) {
            this._backgroundImage !== value && (this._backgroundImage = value, this._createBackgroundSprite());
        }
    }, {
        key: "textLabel",
        get: function get() {
            return this._textLabel;
        },
        set: function set(oldValue) {
            this._textLabel !== oldValue && (this._textLabel = oldValue, this._textLabel && (this._updateTextLabel(), 
            this._updateLabels()));
        }
    }, {
        key: "placeholderLabel",
        get: function get() {
            return this._placeholderLabel;
        },
        set: function set(oldValue) {
            this._placeholderLabel !== oldValue && (this._placeholderLabel = oldValue, this._placeholderLabel && (this._updatePlaceholderLabel(), 
            this._updateLabels()));
        }
    }, {
        key: "placeholder",
        get: function get() {
            return this._placeholderLabel ? this._placeholderLabel.string : "";
        },
        set: function set(value) {
            this._placeholderLabel && (this._placeholderLabel.string = value);
        }
    }, {
        key: "placeholderFontSize",
        get: function get() {
            return this._placeholderLabel ? this._placeholderLabel.fontSize : 20;
        },
        set: function set(value) {
            this._placeholderLabel && (this._placeholderLabel.fontSize = value);
        }
    }, {
        key: "placeholderFontColor",
        get: function get() {
            return this._placeholderLabel ? this._placeholderLabel.color : Color.GRAY.clone();
        },
        set: function set(value) {
            this._placeholderLabel && (this._placeholderLabel.color = value);
        }
    }, {
        key: "stayOnTop",
        get: function get() {},
        set: function set(value) {
            console.warn("stayOnTop is removed.");
        }
    }, {
        key: "tabIndex",
        get: function get() {
            return this._tabIndex;
        },
        set: function set(value) {
            this._tabIndex !== value && (this._tabIndex = value, this._impl && this._impl.setTabIndex(value));
        }
    } ]), EditBoxComponent;
}(), _class3$n._EditBoxImpl = EditBoxImplBase, _class3$n.KeyboardReturnType = KeyboardReturnType, 
_class3$n.InputFlag = InputFlag, _class3$n.InputMode = InputMode, _class3$n.EventType = EventType$3, 
_applyDecoratedDescriptor((_class2$10 = _temp$13).prototype, "string", [ _dec5$o ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "string"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "fontSize", [ _dec6$m ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "fontSize"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "fontColor", [ _dec7$i ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "fontColor"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "inputFlag", [ _dec8$g ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "inputFlag"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "inputMode", [ _dec9$c ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "inputMode"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "returnType", [ _dec10$9 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "returnType"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "maxLength", [ _dec11$9 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "maxLength"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "lineHeight", [ _dec12$8 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "lineHeight"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "backgroundImage", [ _dec13$7 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "backgroundImage"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "textLabel", [ _dec14$6 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "textLabel"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "placeholderLabel", [ _dec15$5 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "placeholderLabel"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "placeholder", [ _dec16$5 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "placeholder"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "placeholderFontSize", [ _dec17$4 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "placeholderFontSize"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "placeholderFontColor", [ _dec18$4 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "placeholderFontColor"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "stayOnTop", [ _dec19$4 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "stayOnTop"), _class2$10.prototype), 
_applyDecoratedDescriptor(_class2$10.prototype, "tabIndex", [ _dec20$2 ], Object.getOwnPropertyDescriptor(_class2$10.prototype, "tabIndex"), _class2$10.prototype), 
_descriptor$T = _applyDecoratedDescriptor(_class2$10.prototype, "editingDidBegan", [ _dec21$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$H = _applyDecoratedDescriptor(_class2$10.prototype, "textChanged", [ _dec22$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor3$z = _applyDecoratedDescriptor(_class2$10.prototype, "editingDidEnded", [ _dec23$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor4$s = _applyDecoratedDescriptor(_class2$10.prototype, "editingReturn", [ _dec24$1 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor5$m = _applyDecoratedDescriptor(_class2$10.prototype, "_textLabel", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor6$d = _applyDecoratedDescriptor(_class2$10.prototype, "_placeholderLabel", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor7$c = _applyDecoratedDescriptor(_class2$10.prototype, "_returnType", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return KeyboardReturnType.DEFAULT;
    }
}), _descriptor8$a = _applyDecoratedDescriptor(_class2$10.prototype, "_useOriginalSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor9$a = _applyDecoratedDescriptor(_class2$10.prototype, "_string", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _descriptor10$9 = _applyDecoratedDescriptor(_class2$10.prototype, "_tabIndex", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11$5 = _applyDecoratedDescriptor(_class2$10.prototype, "_backgroundImage", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor12$5 = _applyDecoratedDescriptor(_class2$10.prototype, "_inputFlag", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return InputFlag.DEFAULT;
    }
}), _descriptor13$5 = _applyDecoratedDescriptor(_class2$10.prototype, "_inputMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return InputMode.ANY;
    }
}), _descriptor14$5 = _applyDecoratedDescriptor(_class2$10.prototype, "_maxLength", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 20;
    }
}), _class$19 = _class2$10)) || _class$19) || _class$19) || _class$19) || _class$19) || _class$19);

sys.isBrowser && (EditBoxComponent._EditBoxImpl = EditBoxImpl), cc.EditBoxComponent = EditBoxComponent;

var Type, ResizeMode, AxisDirection, VerticalDirection, HorizontalDirection, NodeEvent = exports.SystemEventType;

!function(Type) {
    Type[Type.NONE = 0] = "NONE", Type[Type.HORIZONTAL = 1] = "HORIZONTAL", Type[Type.VERTICAL = 2] = "VERTICAL", 
    Type[Type.GRID = 3] = "GRID";
}(Type || (Type = {})), ccenum(Type), function(ResizeMode) {
    ResizeMode[ResizeMode.NONE = 0] = "NONE", ResizeMode[ResizeMode.CONTAINER = 1] = "CONTAINER", 
    ResizeMode[ResizeMode.CHILDREN = 2] = "CHILDREN";
}(ResizeMode || (ResizeMode = {})), ccenum(ResizeMode), function(AxisDirection) {
    AxisDirection[AxisDirection.HORIZONTAL = 0] = "HORIZONTAL", AxisDirection[AxisDirection.VERTICAL = 1] = "VERTICAL";
}(AxisDirection || (AxisDirection = {})), ccenum(AxisDirection), function(VerticalDirection) {
    VerticalDirection[VerticalDirection.BOTTOM_TO_TOP = 0] = "BOTTOM_TO_TOP", VerticalDirection[VerticalDirection.TOP_TO_BOTTOM = 1] = "TOP_TO_BOTTOM";
}(VerticalDirection || (VerticalDirection = {})), ccenum(VerticalDirection), function(HorizontalDirection) {
    HorizontalDirection[HorizontalDirection.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", HorizontalDirection[HorizontalDirection.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT";
}(HorizontalDirection || (HorizontalDirection = {})), ccenum(HorizontalDirection);

var LineCap, LineJoin, PointFlags, _dec$1a, _dec2$N, _dec3$x, _dec4$t, _dec5$q, _dec6$o, _dec7$k, _dec8$i, _dec9$e, _dec10$b, _class$1b, _class2$12, _descriptor$V, _descriptor2$J, _descriptor3$B, _descriptor4$u, _descriptor5$o, _descriptor6$f, _class3$p, _temp$15, _tempPos = new Vec3, _tempScale = new Vec3, LayoutComponent = (_dec$19 = ccclass("cc.LayoutComponent"), 
_dec2$M = help("i18n:cc.LayoutComponent"), _dec3$w = executionOrder(110), _dec4$s = menu("UI/Layout"), 
_dec5$p = requireComponent(UITransformComponent), _dec6$n = property({
    type: Type,
    tooltip: "自动布局模式，包括：\n 1. NONE，不会对子节点进行自动布局 \n 2. HORIZONTAL，横向自动排布子物体 \n 3. VERTICAL，垂直自动排布子物体\n 4. GRID, 采用网格方式对子物体自动进行布局"
}), _dec7$j = property({
    type: ResizeMode,
    tooltip: "缩放模式，包括：\n 1. NONE，不会对子节点和容器进行大小缩放 \n 2. CONTAINER, 对容器的大小进行缩放 \n 3. CHILDREN, 对子节点的大小进行缩放"
}), _dec8$h = property({
    tooltip: "每个格子的大小，只有布局类型为 GRID 的时候才有效"
}), _dec9$d = property({
    type: AxisDirection,
    tooltip: "起始轴方向类型，可进行水平和垂直布局排列，只有布局类型为 GRID 的时候才有效"
}), _dec10$a = property({
    tooltip: "容器内左边距，只会在一个布局方向上生效"
}), _dec11$a = property({
    tooltip: "容器内右边距，只会在一个布局方向上生效"
}), _dec12$9 = property({
    tooltip: "容器内上边距，只会在一个布局方向上生效"
}), _dec13$8 = property({
    tooltip: "容器内下边距，只会在一个布局方向上生效"
}), _dec14$7 = property({
    tooltip: "子节点之间的水平间距"
}), _dec15$6 = property({
    tooltip: "子节点之间的垂直间距"
}), _dec16$6 = property({
    type: VerticalDirection,
    tooltip: "垂直排列子节点的方向"
}), _dec17$5 = property({
    type: HorizontalDirection,
    tooltip: "水平排列子节点的方向"
}), _dec18$5 = property({
    tooltip: "容器内边距，该属性会在四个布局方向上生效"
}), _dec19$5 = property({
    tooltip: "子节点缩放比例是否影响布局"
}), _dec$19(_class$1a = _dec2$M(_class$1a = _dec3$w(_class$1a = _dec4$s(_class$1a = _dec5$p(_class$1a = executeInEditMode((_temp$14 = _class3$o = function(_Component) {
    function LayoutComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, LayoutComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LayoutComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_resizeMode", _descriptor$U, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_N$layoutType", _descriptor2$I, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_N$padding", _descriptor3$A, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_cellSize", _descriptor4$t, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_startAxis", _descriptor5$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_paddingLeft", _descriptor6$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_paddingRight", _descriptor7$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_paddingTop", _descriptor8$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_paddingBottom", _descriptor9$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_spacingX", _descriptor10$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_spacingY", _descriptor11$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_verticalDirection", _descriptor12$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalDirection", _descriptor13$6, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_affectedByScale", _descriptor14$6, _assertThisInitialized(_this)), 
        _this._layoutSize = new Size(300, 200), _this._layoutDirty = !0, _this._isAlign = !1, 
        _this;
    }
    return _inherits(LayoutComponent, Component), _createClass(LayoutComponent, [ {
        key: "updateLayout",
        value: function updateLayout() {
            this._layoutDirty && this.node.children.length > 0 && (this._doLayout(), this._layoutDirty = !1);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._addEventListeners(), this.node.getContentSize().equals(new Size) && this.node.setContentSize(this._layoutSize), 
            0 !== this._N$padding && this._migratePaddingData(), this._doLayoutDirty();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._removeEventListeners();
        }
    }, {
        key: "_migratePaddingData",
        value: function _migratePaddingData() {
            this._paddingLeft = this._N$padding, this._paddingRight = this._N$padding, this._paddingTop = this._N$padding, 
            this._paddingBottom = this._N$padding, this._N$padding = 0;
        }
    }, {
        key: "_addEventListeners",
        value: function _addEventListeners() {
            director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this), 
            this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this), 
            this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._addChildrenEventListeners();
        }
    }, {
        key: "_removeEventListeners",
        value: function _removeEventListeners() {
            director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this), this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this), 
            this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this), 
            this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this), this._removeChildrenEventListeners();
        }
    }, {
        key: "_addChildrenEventListeners",
        value: function _addChildrenEventListeners() {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this.node.children); !(_step = _iterator()).done; ) {
                var child = _step.value;
                child.on(NodeEvent.TRANSFORM_CHANGED, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
            }
        }
    }, {
        key: "_removeChildrenEventListeners",
        value: function _removeChildrenEventListeners() {
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this.node.children); !(_step2 = _iterator2()).done; ) {
                var child = _step2.value;
                child.off(NodeEvent.TRANSFORM_CHANGED, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
                child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
                child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
            }
        }
    }, {
        key: "_childAdded",
        value: function _childAdded(child) {
            child.on(NodeEvent.TRANSFORM_CHANGED, this._doScaleDirty, this), child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
            child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
            child.on("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
        }
    }, {
        key: "_childRemoved",
        value: function _childRemoved(child) {
            child.off(NodeEvent.TRANSFORM_CHANGED, this._doScaleDirty, this), child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this), 
            child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this), child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this), 
            child.off("active-in-hierarchy-changed", this._doLayoutDirty, this), this._doLayoutDirty();
        }
    }, {
        key: "_resized",
        value: function _resized() {
            this._layoutSize = this.node.getContentSize(), this._doLayoutDirty();
        }
    }, {
        key: "_doLayoutHorizontally",
        value: function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
            var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign = 1, paddingX = this._paddingLeft, startPos = -layoutAnchor.x * baseWidth;
            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, startPos = (1 - layoutAnchor.x) * baseWidth, 
            paddingX = this._paddingRight);
            for (var _step3, nextX = startPos + sign * paddingX - sign * this._spacingX, rowMaxHeight = 0, tempMaxHeight = 0, secondMaxHeight = 0, row = 0, containerResizeBoundary = 0, maxHeightChildAnchorY = 0, activeChildCount = 0, _iterator3 = _createForOfIteratorHelperLoose(children); !(_step3 = _iterator3()).done; ) {
                _step3.value.activeInHierarchy && activeChildCount++;
            }
            var newChildWidth = this._cellSize.width;
            this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this._paddingLeft + this._paddingRight) - (activeChildCount - 1) * this._spacingX) / activeChildCount);
            for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(children); !(_step4 = _iterator4()).done; ) {
                var _child = _step4.value;
                if (_child.activeInHierarchy) {
                    _child.getScale(_tempScale);
                    var childScaleX = this._getUsedScaleValue(_tempScale.x), childScaleY = this._getUsedScaleValue(_tempScale.y);
                    this._resizeMode === ResizeMode.CHILDREN && (_child.width = newChildWidth / childScaleX, 
                    this._N$layoutType === Type.GRID && (_child.height = this._cellSize.height / childScaleY));
                    var anchorX = _child.anchorX, childBoundingBoxWidth = _child.width * childScaleX, childBoundingBoxHeight = _child.height * childScaleY;
                    secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight), childBoundingBoxHeight >= tempMaxHeight && (secondMaxHeight = tempMaxHeight, 
                    tempMaxHeight = childBoundingBoxHeight, maxHeightChildAnchorY = _child.getAnchorPoint().y), 
                    this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - _child.anchorX), 
                    nextX = nextX + sign * anchorX * childBoundingBoxWidth + sign * this._spacingX;
                    var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
                    if (rowBreak) {
                        var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft), leftToRightRowBreak = !1;
                        this._horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth && (leftToRightRowBreak = !0);
                        var rightToLeftRowBreak = !1;
                        this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth && (rightToLeftRowBreak = !0), 
                        (leftToRightRowBreak || rightToLeftRowBreak) && (childBoundingBoxHeight >= tempMaxHeight ? (0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight), 
                        rowMaxHeight += secondMaxHeight, secondMaxHeight = tempMaxHeight) : (rowMaxHeight += tempMaxHeight, 
                        secondMaxHeight = childBoundingBoxHeight, tempMaxHeight = 0), nextX = startPos + sign * (paddingX + anchorX * childBoundingBoxWidth), 
                        row++);
                    }
                    var finalPositionY = fnPositionY(_child, rowMaxHeight, row);
                    baseWidth >= childBoundingBoxWidth + this._paddingLeft + this._paddingRight && applyChildren && (_child.getPosition(_tempPos), 
                    _child.setPosition(nextX, finalPositionY, _tempPos.z));
                    var signX = 1, tempFinalPositionY = void 0, topMargin = 0 === tempMaxHeight ? childBoundingBoxHeight : tempMaxHeight;
                    this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM ? (containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().height, 
                    (tempFinalPositionY = finalPositionY + (signX = -1) * (topMargin * maxHeightChildAnchorY + this._paddingBottom)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().height, 
                    (tempFinalPositionY = finalPositionY + signX * (topMargin * maxHeightChildAnchorY + this._paddingTop)) > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY)), 
                    nextX += rightBoundaryOfChild;
                }
            }
            return containerResizeBoundary;
        }
    }, {
        key: "_doLayoutVertically",
        value: function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
            var layoutAnchor = this.node.getAnchorPoint(), children = this.node.children, sign = 1, paddingY = this._paddingBottom, bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight, 
            paddingY = this._paddingTop);
            for (var _step5, nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this._spacingY, columnMaxWidth = 0, tempMaxWidth = 0, secondMaxWidth = 0, column = 0, containerResizeBoundary = 0, maxWidthChildAnchorX = 0, activeChildCount = 0, _iterator5 = _createForOfIteratorHelperLoose(children); !(_step5 = _iterator5()).done; ) {
                _step5.value.activeInHierarchy && activeChildCount++;
            }
            var newChildHeight = this._cellSize.height;
            this._N$layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this._paddingTop + this._paddingBottom) - (activeChildCount - 1) * this._spacingY) / activeChildCount);
            for (var _step6, _iterator6 = _createForOfIteratorHelperLoose(children); !(_step6 = _iterator6()).done; ) {
                var _child2 = _step6.value;
                if (_child2) {
                    var scale = _child2.getScale(), childScaleX = this._getUsedScaleValue(scale.x), childScaleY = this._getUsedScaleValue(scale.y);
                    if (_child2.activeInHierarchy) {
                        this._resizeMode === ResizeMode.CHILDREN && (_child2.height = newChildHeight / childScaleY, 
                        this._N$layoutType === Type.GRID && (_child2.width = this._cellSize.width / childScaleX));
                        var anchorY = _child2.anchorY, childBoundingBoxWidth = _child2.width * childScaleX, childBoundingBoxHeight = _child2.height * childScaleY;
                        secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth), childBoundingBoxWidth >= tempMaxWidth && (secondMaxWidth = tempMaxWidth, 
                        tempMaxWidth = childBoundingBoxWidth, maxWidthChildAnchorX = _child2.getAnchorPoint().x), 
                        this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - _child2.anchorY), 
                        nextY = nextY + sign * anchorY * childBoundingBoxHeight + sign * this._spacingY;
                        var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
                        if (columnBreak) {
                            var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom), bottomToTopColumnBreak = !1;
                            this._verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight && (bottomToTopColumnBreak = !0);
                            var topToBottomColumnBreak = !1;
                            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight && (topToBottomColumnBreak = !0), 
                            (bottomToTopColumnBreak || topToBottomColumnBreak) && (childBoundingBoxWidth >= tempMaxWidth ? (0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth), 
                            columnMaxWidth += secondMaxWidth, secondMaxWidth = tempMaxWidth) : (columnMaxWidth += tempMaxWidth, 
                            secondMaxWidth = childBoundingBoxWidth, tempMaxWidth = 0), nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * childBoundingBoxHeight), 
                            column++);
                        }
                        var finalPositionX = fnPositionX(_child2, columnMaxWidth, column);
                        baseHeight >= childBoundingBoxHeight + (this._paddingTop + this._paddingBottom) && applyChildren && (_child2.getPosition(_tempPos), 
                        _child2.setPosition(finalPositionX, nextY, _tempPos.z));
                        var signX = 1, tempFinalPositionX = void 0, rightMargin = 0 === tempMaxWidth ? childBoundingBoxWidth : tempMaxWidth;
                        this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT ? (signX = -1, containerResizeBoundary = containerResizeBoundary || this.node.getContentSize().width, 
                        (tempFinalPositionX = finalPositionX + signX * (rightMargin * maxWidthChildAnchorX + this._paddingLeft)) < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX)) : (containerResizeBoundary = containerResizeBoundary || -this.node.getContentSize().width, 
                        (tempFinalPositionX = finalPositionX + signX * (rightMargin * maxWidthChildAnchorX + this._paddingRight)) > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX)), 
                        nextY += topBoundaryOfChild;
                    }
                }
            }
            return containerResizeBoundary;
        }
    }, {
        key: "_doLayoutBasic",
        value: function _doLayoutBasic() {
            for (var _step7, allChildrenBoundingBox = null, _iterator7 = _createForOfIteratorHelperLoose(this.node.children); !(_step7 = _iterator7()).done; ) {
                var child = _step7.value, childTransform = child.getComponent(UITransformComponent);
                childTransform && (child.activeInHierarchy && (allChildrenBoundingBox ? Rect.union(allChildrenBoundingBox, allChildrenBoundingBox, childTransform.getBoundingBoxToWorld()) : allChildrenBoundingBox = childTransform.getBoundingBoxToWorld()));
            }
            if (allChildrenBoundingBox) {
                var parentTransform = this.node.parent.getComponent(UITransformComponent);
                if (!parentTransform) return;
                Vec3.set(_tempPos, allChildrenBoundingBox.x, allChildrenBoundingBox.y, 0);
                var leftBottomInParentSpace = new Vec3;
                parentTransform.convertToNodeSpaceAR(_tempPos, leftBottomInParentSpace), Vec3.set(leftBottomInParentSpace, leftBottomInParentSpace.x - this._paddingLeft, leftBottomInParentSpace.y - this._paddingBottom, leftBottomInParentSpace.z), 
                Vec3.set(_tempPos, allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height, 0);
                var rightTopInParentSpace = new Vec3;
                parentTransform.convertToNodeSpaceAR(_tempPos, rightTopInParentSpace), Vec3.set(rightTopInParentSpace, rightTopInParentSpace.x + this._paddingRight, rightTopInParentSpace.y + this._paddingTop, rightTopInParentSpace.z);
                var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
                if (this.node.getPosition(_tempPos), 0 !== newSize.width) {
                    var newAnchorX = (_tempPos.x - leftBottomInParentSpace.x) / newSize.width;
                    this.node.anchorX = parseFloat(newAnchorX.toFixed(2));
                }
                if (0 !== newSize.height) {
                    var newAnchorY = (_tempPos.y - leftBottomInParentSpace.y) / newSize.height;
                    this.node.anchorY = parseFloat(newAnchorY.toFixed(2));
                }
                this.node.setContentSize(newSize);
            }
        }
    }, {
        key: "_doLayoutGridAxisHorizontal",
        value: function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
            var _this2 = this, baseWidth = layoutSize.width, sign = 1, bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height, paddingY = this._paddingBottom;
            this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height, 
            paddingY = this._paddingTop);
            var self = this, fnPositionY = function fnPositionY(child, topOffset, row) {
                return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height * self._getUsedScaleValue(child.getScale().y) + paddingY + row * _this2._spacingY);
            }, newHeight = 0;
            if (this._resizeMode === ResizeMode.CONTAINER) {
                var boundary = this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !1);
                (newHeight = bottomBoundaryOfLayout - boundary) < 0 && (newHeight *= -1), bottomBoundaryOfLayout = -layoutAnchor.y * newHeight, 
                this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (sign = -1, bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight);
            }
            this._doLayoutHorizontally(baseWidth, !0, fnPositionY, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
        }
    }, {
        key: "_doLayoutGridAxisVertical",
        value: function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
            var _this3 = this, baseHeight = layoutSize.height, sign = 1, leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width, paddingX = this._paddingLeft;
            this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width, 
            paddingX = this._paddingRight);
            var self = this, fnPositionX = function fnPositionX(child, leftOffset, column) {
                return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width * self._getUsedScaleValue(child.getScale().x) + paddingX + column * _this3._spacingX);
            }, newWidth = 0;
            if (this._resizeMode === ResizeMode.CONTAINER) {
                var boundary = this._doLayoutVertically(baseHeight, !0, fnPositionX, !1);
                (newWidth = leftBoundaryOfLayout - boundary) < 0 && (newWidth *= -1), leftBoundaryOfLayout = -layoutAnchor.x * newWidth, 
                this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (sign = -1, leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth);
            }
            this._doLayoutVertically(baseHeight, !0, fnPositionX, !0), this._resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
        }
    }, {
        key: "_doLayoutGrid",
        value: function _doLayoutGrid() {
            var layoutAnchor = this.node.getAnchorPoint(), layoutSize = this.node.getContentSize();
            this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
        }
    }, {
        key: "_getHorizontalBaseWidth",
        value: function _getHorizontalBaseWidth(children) {
            var newWidth = 0, activeChildCount = 0;
            if (this._resizeMode === ResizeMode.CONTAINER) {
                for (var _step8, _iterator8 = _createForOfIteratorHelperLoose(children); !(_step8 = _iterator8()).done; ) {
                    var child = _step8.value;
                    child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newWidth += child.width * this._getUsedScaleValue(_tempScale.x));
                }
                newWidth += (activeChildCount - 1) * this._spacingX + this._paddingLeft + this._paddingRight;
            } else newWidth = this.node.getContentSize().width;
            return newWidth;
        }
    }, {
        key: "_getVerticalBaseHeight",
        value: function _getVerticalBaseHeight(children) {
            var newHeight = 0, activeChildCount = 0;
            if (this._resizeMode === ResizeMode.CONTAINER) {
                for (var _step9, _iterator9 = _createForOfIteratorHelperLoose(children); !(_step9 = _iterator9()).done; ) {
                    var child = _step9.value;
                    child.getScale(_tempScale), child.activeInHierarchy && (activeChildCount++, newHeight += child.height * this._getUsedScaleValue(_tempScale.y));
                }
                newHeight += (activeChildCount - 1) * this._spacingY + this._paddingBottom + this._paddingTop;
            } else newHeight = this.node.getContentSize().height;
            return newHeight;
        }
    }, {
        key: "_doLayout",
        value: function _doLayout() {
            var _this4 = this;
            if (this._N$layoutType === Type.HORIZONTAL) {
                var newWidth = this._getHorizontalBaseWidth(this.node.children);
                this._doLayoutHorizontally(newWidth, !1, (function fnPositionY(child) {
                    return (_this4._isAlign ? Vec3.ZERO : child.position).y;
                }), !0), this._isAlign = !1, this.node.width = newWidth;
            } else if (this._N$layoutType === Type.VERTICAL) {
                var newHeight = this._getVerticalBaseHeight(this.node.children);
                this._doLayoutVertically(newHeight, !1, (function fnPositionX(child) {
                    return (_this4._isAlign ? Vec3.ZERO : child.position).x;
                }), !0), this._isAlign = !1, this.node.height = newHeight;
            } else this._N$layoutType === Type.NONE ? this._resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this._N$layoutType === Type.GRID && this._doLayoutGrid();
        }
    }, {
        key: "_getUsedScaleValue",
        value: function _getUsedScaleValue(value) {
            return this._affectedByScale ? Math.abs(value) : 1;
        }
    }, {
        key: "_transformDirty",
        value: function _transformDirty(type) {
            type & TransformBit.POSITION && this._doLayoutDirty();
        }
    }, {
        key: "_doLayoutDirty",
        value: function _doLayoutDirty() {
            this._layoutDirty = !0;
        }
    }, {
        key: "_doScaleDirty",
        value: function _doScaleDirty(type) {
            type & TransformBit.SCALE && (this._layoutDirty = this._layoutDirty || this._affectedByScale);
        }
    }, {
        key: "type",
        get: function get() {
            return this._N$layoutType;
        },
        set: function set(value) {
            this._N$layoutType = value, this._isAlign = !0, this._doLayoutDirty();
        }
    }, {
        key: "resizeMode",
        get: function get() {
            return this._resizeMode;
        },
        set: function set(value) {
            this._N$layoutType === Type.NONE && value === ResizeMode.CHILDREN || (this._resizeMode = value, 
            this._doLayoutDirty());
        }
    }, {
        key: "cellSize",
        get: function get() {
            return this._cellSize;
        },
        set: function set(value) {
            this._cellSize !== value && (this._cellSize.set(value), this._doLayoutDirty());
        }
    }, {
        key: "startAxis",
        get: function get() {
            return this._startAxis;
        },
        set: function set(value) {
            this._startAxis !== value && (this._startAxis = value, this._doLayoutDirty());
        }
    }, {
        key: "paddingLeft",
        get: function get() {
            return this._paddingLeft;
        },
        set: function set(value) {
            this._paddingLeft !== value && (this._paddingLeft = value, this._doLayoutDirty());
        }
    }, {
        key: "paddingRight",
        get: function get() {
            return this._paddingRight;
        },
        set: function set(value) {
            this._paddingRight !== value && (this._paddingRight = value, this._doLayoutDirty());
        }
    }, {
        key: "paddingTop",
        get: function get() {
            return this._paddingTop;
        },
        set: function set(value) {
            this._paddingTop !== value && (this._paddingTop = value, this._doLayoutDirty());
        }
    }, {
        key: "paddingBottom",
        get: function get() {
            return this._paddingBottom;
        },
        set: function set(value) {
            this._paddingBottom !== value && (this._paddingBottom = value, this._doLayoutDirty());
        }
    }, {
        key: "spacingX",
        get: function get() {
            return this._spacingX;
        },
        set: function set(value) {
            this._spacingX !== value && (this._spacingX = value, this._doLayoutDirty());
        }
    }, {
        key: "spacingY",
        get: function get() {
            return this._spacingY;
        },
        set: function set(value) {
            this._spacingY !== value && (this._spacingY = value, this._doLayoutDirty());
        }
    }, {
        key: "verticalDirection",
        get: function get() {
            return this._verticalDirection;
        },
        set: function set(value) {
            this._verticalDirection !== value && (this._verticalDirection = value, this._doLayoutDirty());
        }
    }, {
        key: "horizontalDirection",
        get: function get() {
            return this._horizontalDirection;
        },
        set: function set(value) {
            this._horizontalDirection !== value && (this._horizontalDirection = value, this._doLayoutDirty());
        }
    }, {
        key: "padding",
        get: function get() {
            return this._paddingLeft;
        },
        set: function set(value) {
            this._N$padding = value, this._migratePaddingData(), this._doLayoutDirty();
        }
    }, {
        key: "affectedByScale",
        get: function get() {
            return this._affectedByScale;
        },
        set: function set(value) {
            this._affectedByScale = value, this._doLayoutDirty();
        }
    } ]), LayoutComponent;
}(), _class3$o.Type = Type, _class3$o.VerticalDirection = VerticalDirection, _class3$o.HorizontalDirection = HorizontalDirection, 
_class3$o.ResizeMode = ResizeMode, _class3$o.AxisDirection = AxisDirection, _applyDecoratedDescriptor((_class2$11 = _temp$14).prototype, "type", [ _dec6$n ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "type"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "resizeMode", [ _dec7$j ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "resizeMode"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "cellSize", [ _dec8$h ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "cellSize"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "startAxis", [ _dec9$d ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "startAxis"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "paddingLeft", [ _dec10$a ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "paddingLeft"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "paddingRight", [ _dec11$a ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "paddingRight"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "paddingTop", [ _dec12$9 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "paddingTop"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "paddingBottom", [ _dec13$8 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "paddingBottom"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "spacingX", [ _dec14$7 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "spacingX"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "spacingY", [ _dec15$6 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "spacingY"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "verticalDirection", [ _dec16$6 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "verticalDirection"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "horizontalDirection", [ _dec17$5 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "horizontalDirection"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "padding", [ _dec18$5 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "padding"), _class2$11.prototype), 
_applyDecoratedDescriptor(_class2$11.prototype, "affectedByScale", [ _dec19$5 ], Object.getOwnPropertyDescriptor(_class2$11.prototype, "affectedByScale"), _class2$11.prototype), 
_descriptor$U = _applyDecoratedDescriptor(_class2$11.prototype, "_resizeMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ResizeMode.NONE;
    }
}), _descriptor2$I = _applyDecoratedDescriptor(_class2$11.prototype, "_N$layoutType", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Type.NONE;
    }
}), _descriptor3$A = _applyDecoratedDescriptor(_class2$11.prototype, "_N$padding", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor4$t = _applyDecoratedDescriptor(_class2$11.prototype, "_cellSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Size(40, 40);
    }
}), _descriptor5$n = _applyDecoratedDescriptor(_class2$11.prototype, "_startAxis", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return AxisDirection.HORIZONTAL;
    }
}), _descriptor6$e = _applyDecoratedDescriptor(_class2$11.prototype, "_paddingLeft", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$d = _applyDecoratedDescriptor(_class2$11.prototype, "_paddingRight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$b = _applyDecoratedDescriptor(_class2$11.prototype, "_paddingTop", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor9$b = _applyDecoratedDescriptor(_class2$11.prototype, "_paddingBottom", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor10$a = _applyDecoratedDescriptor(_class2$11.prototype, "_spacingX", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11$6 = _applyDecoratedDescriptor(_class2$11.prototype, "_spacingY", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor12$6 = _applyDecoratedDescriptor(_class2$11.prototype, "_verticalDirection", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return VerticalDirection.TOP_TO_BOTTOM;
    }
}), _descriptor13$6 = _applyDecoratedDescriptor(_class2$11.prototype, "_horizontalDirection", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return HorizontalDirection.LEFT_TO_RIGHT;
    }
}), _descriptor14$6 = _applyDecoratedDescriptor(_class2$11.prototype, "_affectedByScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$1a = _class2$11)) || _class$1a) || _class$1a) || _class$1a) || _class$1a) || _class$1a) || _class$1a);

cc.LayoutComponent = LayoutComponent, function(LineCap) {
    LineCap[LineCap.BUTT = 0] = "BUTT", LineCap[LineCap.ROUND = 1] = "ROUND", LineCap[LineCap.SQUARE = 2] = "SQUARE";
}(LineCap || (LineCap = {})), ccenum(LineCap), function(LineJoin) {
    LineJoin[LineJoin.BEVEL = 0] = "BEVEL", LineJoin[LineJoin.ROUND = 1] = "ROUND", 
    LineJoin[LineJoin.MITER = 2] = "MITER";
}(LineJoin || (LineJoin = {})), ccenum(LineJoin), function(PointFlags) {
    PointFlags[PointFlags.PT_CORNER = 1] = "PT_CORNER", PointFlags[PointFlags.PT_LEFT = 2] = "PT_LEFT", 
    PointFlags[PointFlags.PT_BEVEL = 4] = "PT_BEVEL", PointFlags[PointFlags.PT_INNERBEVEL = 8] = "PT_INNERBEVEL";
}(PointFlags || (PointFlags = {})), ccenum(PointFlags);

var _dec$1b, _dec2$O, _dec3$y, _dec4$u, _dec5$r, _dec6$p, _dec7$l, _dec8$j, _dec9$f, _class$1c, _class2$13, _descriptor$W, _descriptor2$K, _descriptor3$C, _class3$q, _temp$16, _matInsInfo$2 = {
    parent: null,
    owner: null,
    subModelIdx: 0
}, GraphicsComponent = (_dec$1a = ccclass("cc.GraphicsComponent"), _dec2$N = help("i18n:cc.GraphicsComponent"), 
_dec3$x = executionOrder(110), _dec4$t = menu("UI/Render/Graphics"), _dec5$q = property({
    type: LineJoin,
    tooltip: "两条线相交时，所创建的拐角类型"
}), _dec6$o = property({
    type: LineCap,
    tooltip: "线条的结束端点样式"
}), _dec7$k = property({
    tooltip: "笔触的颜色"
}), _dec8$i = property({
    tooltip: "填充绘画的颜色"
}), _dec9$e = property({
    tooltip: "最大斜接长度"
}), _dec10$b = property({
    override: !0,
    visible: !1
}), _dec$1a(_class$1b = _dec2$N(_class$1b = _dec3$x(_class$1b = _dec4$t((_temp$15 = _class3$p = function(_UIRenderComponent) {
    function GraphicsComponent() {
        var _this;
        return _classCallCheck(this, GraphicsComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(GraphicsComponent).call(this))).impl = null, 
        _this.model = null, _initializerDefineProperty(_this, "_lineWidth", _descriptor$V, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_strokeColor", _descriptor2$J, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lineJoin", _descriptor3$B, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lineCap", _descriptor4$u, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fillColor", _descriptor5$o, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_miterLimit", _descriptor6$f, _assertThisInitialized(_this)), 
        _this._instanceMaterialType = exports.InstanceMaterialType.ADDCOLOR, _this;
    }
    return _inherits(GraphicsComponent, UIRenderComponent), _createClass(GraphicsComponent, [ {
        key: "lineWidth",
        get: function get() {
            return this._lineWidth;
        },
        set: function set(value) {
            this._lineWidth = value, this.impl && (this.impl.lineWidth = value);
        }
    }, {
        key: "lineJoin",
        get: function get() {
            return this._lineJoin;
        },
        set: function set(value) {
            this._lineJoin = value, this.impl && (this.impl.lineJoin = value);
        }
    }, {
        key: "lineCap",
        get: function get() {
            return this._lineCap;
        },
        set: function set(value) {
            this._lineCap = value, this.impl && (this.impl.lineCap = value);
        }
    }, {
        key: "strokeColor",
        get: function get() {
            return this._strokeColor;
        },
        set: function set(value) {
            this.impl && (this._strokeColor.set(value), this.impl.strokeColor = this._strokeColor);
        }
    }, {
        key: "fillColor",
        get: function get() {
            return this._fillColor;
        },
        set: function set(value) {
            this.impl && (this._fillColor.set(value), this.impl.fillColor = this._fillColor);
        }
    }, {
        key: "miterLimit",
        get: function get() {
            return this._miterLimit;
        },
        set: function set(value) {
            this._miterLimit = value;
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(value) {
            this._color !== value && (this._color.set(value), this._updateColor(), this.markForUpdateRenderData());
        }
    } ]), _createClass(GraphicsComponent, [ {
        key: "onRestore",
        value: function onRestore() {
            this.impl || this._flushAssembler();
        }
    }, {
        key: "__preload",
        value: function __preload() {
            _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this) && _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this).call(this), 
            this.impl = this._assembler && this._assembler.createImpl(this);
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            this._sceneGetter = director.root.ui.getRenderSceneGetter(), this.model || (this.model = director.root.createModel(Model));
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(GraphicsComponent.prototype), "onEnable", this).call(this), 
            this._activateMaterial();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._detachFromScene();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(GraphicsComponent.prototype), "onDestroy", this).call(this), 
            this._sceneGetter = null, this.model && (this.model.destroy(), director.root.destroyModel(this.model), 
            this.model = null), this.impl && (this.impl.clear(), this.impl = null);
        }
    }, {
        key: "_activateMaterial",
        value: function _activateMaterial() {
            this._material && this._updateMaterial(this._material);
        }
    }, {
        key: "moveTo",
        value: function moveTo(x, y) {
            this.impl && this.impl.moveTo(x, y);
        }
    }, {
        key: "lineTo",
        value: function lineTo(x, y) {
            this.impl && this.impl.lineTo(x, y);
        }
    }, {
        key: "bezierCurveTo",
        value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
            this.impl && this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
        }
    }, {
        key: "quadraticCurveTo",
        value: function quadraticCurveTo(cx, cy, x, y) {
            this.impl && this.impl.quadraticCurveTo(cx, cy, x, y);
        }
    }, {
        key: "arc",
        value: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
            this.impl && this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
        }
    }, {
        key: "ellipse",
        value: function ellipse(cx, cy, rx, ry) {
            this.impl && this.impl.ellipse(cx, cy, rx, ry);
        }
    }, {
        key: "circle",
        value: function circle(cx, cy, r) {
            this.impl && this.impl.circle(cx, cy, r);
        }
    }, {
        key: "rect",
        value: function rect(x, y, w, h) {
            this.impl && this.impl.rect(x, y, w, h);
        }
    }, {
        key: "roundRect",
        value: function roundRect(x, y, w, h, r) {
            this.impl && this.impl.roundRect(x, y, w, h, r);
        }
    }, {
        key: "fillRect",
        value: function fillRect(x, y, w, h) {
            this.rect(x, y, w, h), this.fill();
        }
    }, {
        key: "clear",
        value: function clear() {
            var clean = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            this.impl && (this.impl.clear(clean), this._detachFromScene(), this.model && this.model.destroy(), 
            this.markForUpdateRenderData());
        }
    }, {
        key: "close",
        value: function close() {
            this.impl && this.impl.close();
        }
    }, {
        key: "stroke",
        value: function stroke() {
            this._assembler.stroke(this), this._attachToScene();
        }
    }, {
        key: "fill",
        value: function fill() {
            this._assembler.fill(this), this._attachToScene();
        }
    }, {
        key: "helpInstanceMaterial",
        value: function helpInstanceMaterial() {
            var mat = null;
            _matInsInfo$2.owner = new RenderableComponent, this._sharedMaterial ? (_matInsInfo$2.parent = this._sharedMaterial, 
            mat = new MaterialInstance(_matInsInfo$2)) : (_matInsInfo$2.parent = builtinResMgr.get("ui-base-material"), 
            (mat = new MaterialInstance(_matInsInfo$2)).recompileShaders({
                USE_LOCAL: !0
            })), this._updateMaterial(mat), this.impl || (this._flushAssembler(), this.impl = this._assembler && this._assembler.createImpl(this));
        }
    }, {
        key: "_render",
        value: function _render(render) {
            render.commitModel(this, this.model, this._material);
        }
    }, {
        key: "_instanceMaterial",
        value: function _instanceMaterial() {
            this.helpInstanceMaterial();
        }
    }, {
        key: "_flushAssembler",
        value: function _flushAssembler() {
            var assembler = GraphicsComponent.Assembler.getAssembler(this);
            this._assembler !== assembler && (this._assembler = assembler);
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            return !!_get(_getPrototypeOf(GraphicsComponent.prototype), "_canRender", this).call(this) && (!!this.model && this.model.inited);
        }
    }, {
        key: "_attachToScene",
        value: function _attachToScene() {
            var scene = director.root.ui.renderScene;
            this.model && this.model.scene !== scene && (null !== this.model.scene && this._detachFromScene(), 
            scene.addModel(this.model));
        }
    }, {
        key: "_detachFromScene",
        value: function _detachFromScene() {
            this.model && this.model.scene && (this.model.scene.removeModel(this.model), this.model.scene = null);
        }
    } ]), GraphicsComponent;
}(), _class3$p.LineJoin = LineJoin, _class3$p.LineCap = LineCap, _applyDecoratedDescriptor((_class2$12 = _temp$15).prototype, "lineWidth", [ property ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "lineWidth"), _class2$12.prototype), 
_applyDecoratedDescriptor(_class2$12.prototype, "lineJoin", [ _dec5$q ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "lineJoin"), _class2$12.prototype), 
_applyDecoratedDescriptor(_class2$12.prototype, "lineCap", [ _dec6$o ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "lineCap"), _class2$12.prototype), 
_applyDecoratedDescriptor(_class2$12.prototype, "strokeColor", [ _dec7$k ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "strokeColor"), _class2$12.prototype), 
_applyDecoratedDescriptor(_class2$12.prototype, "fillColor", [ _dec8$i ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "fillColor"), _class2$12.prototype), 
_applyDecoratedDescriptor(_class2$12.prototype, "miterLimit", [ _dec9$e ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "miterLimit"), _class2$12.prototype), 
_applyDecoratedDescriptor(_class2$12.prototype, "color", [ _dec10$b ], Object.getOwnPropertyDescriptor(_class2$12.prototype, "color"), _class2$12.prototype), 
_descriptor$V = _applyDecoratedDescriptor(_class2$12.prototype, "_lineWidth", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor2$J = _applyDecoratedDescriptor(_class2$12.prototype, "_strokeColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.BLACK.clone();
    }
}), _descriptor3$B = _applyDecoratedDescriptor(_class2$12.prototype, "_lineJoin", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return LineJoin.MITER;
    }
}), _descriptor4$u = _applyDecoratedDescriptor(_class2$12.prototype, "_lineCap", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return LineCap.BUTT;
    }
}), _descriptor5$o = _applyDecoratedDescriptor(_class2$12.prototype, "_fillColor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor6$f = _applyDecoratedDescriptor(_class2$12.prototype, "_miterLimit", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 10;
    }
}), _class$1b = _class2$12)) || _class$1b) || _class$1b) || _class$1b) || _class$1b);

cc.GraphicsComponent = GraphicsComponent;

var MaskType, _worldMatrix$2 = new Mat4, _vec2_temp = new Vec2, _mat4_temp$1 = new Mat4, _circlePoints = [];

!function(MaskType) {
    MaskType[MaskType.RECT = 0] = "RECT", MaskType[MaskType.ELLIPSE = 1] = "ELLIPSE", 
    MaskType[MaskType.GRAPHICS_STENCIL = 2] = "GRAPHICS_STENCIL";
}(MaskType || (MaskType = {})), ccenum(MaskType);

var _dec$1c, _dec2$P, _dec3$z, _dec4$v, _dec5$s, _dec6$q, _dec7$m, _dec8$k, _dec9$g, _class$1d, _class2$14, _descriptor$X, _descriptor2$L, _descriptor3$D, _descriptor4$v, _descriptor5$p, _class3$r, _temp$17, Mode, MaskComponent = (_dec$1b = ccclass("cc.MaskComponent"), 
_dec2$O = help("i18n:cc.MaskComponent"), _dec3$y = executionOrder(110), _dec4$u = menu("UI/Render/Mask"), 
_dec5$r = property({
    type: MaskType,
    displayOrder: 4,
    tooltip: "遮罩类型"
}), _dec6$p = property({
    tooltip: "反向遮罩"
}), _dec7$l = property({
    visible: !1,
    override: !0
}), _dec8$j = property({
    visible: !1,
    override: !0
}), _dec9$f = property({
    visible: !1,
    override: !0
}), _dec$1b(_class$1c = _dec2$O(_class$1c = _dec3$y(_class$1c = _dec4$u((_temp$16 = _class3$q = function(_UIRenderComponent) {
    function MaskComponent() {
        var _this;
        return _classCallCheck(this, MaskComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MaskComponent).call(this)), "_type", _descriptor$W, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_inverted", _descriptor2$K, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_segments", _descriptor3$C, _assertThisInitialized(_this)), 
        _this._graphics = null, _this._clearGraphics = null, _this._instanceMaterialType = exports.InstanceMaterialType.ADDCOLOR, 
        _this;
    }
    return _inherits(MaskComponent, UIRenderComponent), _createClass(MaskComponent, [ {
        key: "type",
        get: function get() {
            return this._type;
        },
        set: function set(value) {
            this._type !== value && (this._type = value, this._updateGraphics(), this._renderData && (this.destroyRenderData(), 
            this._renderData = null));
        }
    }, {
        key: "inverted",
        get: function get() {
            return this._inverted;
        },
        set: function set(value) {
            cc.game.renderType !== Game.RENDER_TYPE_CANVAS ? this._inverted = value : cc.warnID(4202);
        }
    }, {
        key: "segments",
        get: function get() {
            return this._segments;
        },
        set: function set(value) {
            this._segments !== value && (this._segments = clamp(value, 3, 1e4), this._updateGraphics());
        }
    }, {
        key: "graphics",
        get: function get() {
            return this._graphics;
        }
    }, {
        key: "clearGraphics",
        get: function get() {
            return this._clearGraphics;
        }
    }, {
        key: "dstBlendFactor",
        get: function get() {
            return this._dstBlendFactor;
        },
        set: function set(value) {
            this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "srcBlendFactor",
        get: function get() {
            return this._srcBlendFactor;
        },
        set: function set(value) {
            this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(value) {
            this._color !== value && (this._color.set(value), this.markForUpdateRenderData());
        }
    } ]), _createClass(MaskComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._createGraphics(), this._clearGraphics && this._clearGraphics.onLoad(), this._graphics && this._graphics.onLoad();
        }
    }, {
        key: "onRestore",
        value: function onRestore() {
            this._createGraphics(), this._updateGraphics();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(MaskComponent.prototype), "onEnable", this).call(this), this._enableGraphics(), 
            view.on("design-resolution-changed", this._updateClearGraphics, this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(MaskComponent.prototype), "onDisable", this).call(this), this._disableGraphics(), 
            view.off("design-resolution-changed", this._updateClearGraphics);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(MaskComponent.prototype), "onDestroy", this).call(this), this._removeGraphics();
        }
    }, {
        key: "isHit",
        value: function isHit(cameraPt) {
            var node = this.node, size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
            this.node.getWorldMatrix(_worldMatrix$2), Mat4.invert(_mat4_temp$1, _worldMatrix$2), 
            Vec2.transformMat4(testPt, cameraPt, _mat4_temp$1);
            var ap = node.getAnchorPoint();
            testPt.x += ap.x * w, testPt.y += ap.y * h;
            var result = !1;
            if (this.type === MaskType.RECT || this.type === MaskType.GRAPHICS_STENCIL) result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h; else if (this.type === MaskType.ELLIPSE) {
                var rx = w / 2, ry = h / 2, px = testPt.x - .5 * w, py = testPt.y - .5 * h;
                result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
            }
            return this._inverted && (result = !result), result;
        }
    }, {
        key: "_render",
        value: function _render(render) {
            render.commitComp(this, null, this._assembler);
        }
    }, {
        key: "_postRender",
        value: function _postRender(render) {
            this._postAssembler && render.commitComp(this, null, this._postAssembler);
        }
    }, {
        key: "_nodeStateChange",
        value: function _nodeStateChange(type) {
            _get(_getPrototypeOf(MaskComponent.prototype), "_nodeStateChange", this).call(this, type), 
            this._updateGraphics();
        }
    }, {
        key: "_resolutionChanged",
        value: function _resolutionChanged() {
            this._updateClearGraphics();
        }
    }, {
        key: "_canRender",
        value: function _canRender() {
            return !!_get(_getPrototypeOf(MaskComponent.prototype), "_canRender", this).call(this) && (null !== this._clearGraphics && null !== this._graphics);
        }
    }, {
        key: "_flushAssembler",
        value: function _flushAssembler() {
            var assembler = MaskComponent.Assembler.getAssembler(this), posAssembler = MaskComponent.PostAssembler.getAssembler(this);
            this._assembler !== assembler && (this.destroyRenderData(), this._assembler = assembler), 
            this._postAssembler !== posAssembler && (this._postAssembler = posAssembler), this._renderData || this._assembler && this._assembler.createData && (this._renderData = this._assembler.createData(this), 
            this._renderData.material = this.sharedMaterial, this.markForUpdateRenderData());
        }
    }, {
        key: "_createGraphics",
        value: function _createGraphics() {
            if (!this._clearGraphics) {
                var node = new Node$1("clear-graphics"), clearGraphics = this._clearGraphics = node.addComponent(GraphicsComponent);
                clearGraphics.delegateSrc = this.node, clearGraphics.helpInstanceMaterial(), clearGraphics.lineWidth = 0;
                var color = Color.WHITE.clone();
                color.a = 0, clearGraphics.fillColor = color;
            }
            if (!this._graphics) {
                var graphics = this._graphics = new GraphicsComponent;
                graphics.node = this.node, graphics.node.getWorldMatrix(), graphics.helpInstanceMaterial(), 
                graphics.lineWidth = 0;
                var _color = Color.WHITE.clone();
                _color.a = 0, graphics.fillColor = _color;
            }
        }
    }, {
        key: "_updateClearGraphics",
        value: function _updateClearGraphics() {
            if (this._clearGraphics) {
                var size = visibleRect;
                this._clearGraphics.node.setWorldPosition(size.width / 2, size.height / 2, 0), this._clearGraphics.clear(), 
                this._clearGraphics.rect(-size.width / 2, -size.height / 2, size.width, size.height), 
                this._clearGraphics.fill();
            }
        }
    }, {
        key: "_updateGraphics",
        value: function _updateGraphics() {
            if (this._graphics) {
                var node = this.node, graphics = this._graphics;
                graphics.clear();
                var size = node.getContentSize(), width = size.width, height = size.height, ap = node.getAnchorPoint(), x = -width * ap.x, y = -height * ap.y;
                if (this._type === MaskType.RECT) graphics.rect(x, y, width, height); else if (this._type === MaskType.ELLIPSE) {
                    for (var points = function _calculateCircle(center, radius, segments) {
                        _circlePoints.length = 0;
                        for (var anglePerStep = 2 * Math.PI / segments, step = 0; step < segments; ++step) _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
                        return _circlePoints;
                    }(new Vec3(x + width / 2, y + height / 2, 0), new Vec3(width / 2, height / 2, 0), this._segments), i = 0; i < points.length; ++i) {
                        var point = points[i];
                        0 === i ? graphics.moveTo(point.x, point.y) : graphics.lineTo(point.x, point.y);
                    }
                    graphics.close();
                }
                graphics.fill();
            }
        }
    }, {
        key: "_enableGraphics",
        value: function _enableGraphics() {
            this._clearGraphics && (this._clearGraphics.onEnable(), this._updateClearGraphics()), 
            this._graphics && (this._graphics.onEnable(), this._updateGraphics());
        }
    }, {
        key: "_disableGraphics",
        value: function _disableGraphics() {
            this._graphics && this._graphics.onDisable(), this._clearGraphics && this._clearGraphics.onDisable();
        }
    }, {
        key: "_removeGraphics",
        value: function _removeGraphics() {
            this._graphics && this._graphics.destroy(), this._clearGraphics && this._clearGraphics.destroy();
        }
    } ]), MaskComponent;
}(), _class3$q.Type = MaskType, _applyDecoratedDescriptor((_class2$13 = _temp$16).prototype, "type", [ _dec5$r ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "type"), _class2$13.prototype), 
_applyDecoratedDescriptor(_class2$13.prototype, "inverted", [ _dec6$p ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "inverted"), _class2$13.prototype), 
_applyDecoratedDescriptor(_class2$13.prototype, "segments", [ property ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "segments"), _class2$13.prototype), 
_applyDecoratedDescriptor(_class2$13.prototype, "dstBlendFactor", [ _dec7$l ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "dstBlendFactor"), _class2$13.prototype), 
_applyDecoratedDescriptor(_class2$13.prototype, "srcBlendFactor", [ _dec8$j ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "srcBlendFactor"), _class2$13.prototype), 
_applyDecoratedDescriptor(_class2$13.prototype, "color", [ _dec9$f ], Object.getOwnPropertyDescriptor(_class2$13.prototype, "color"), _class2$13.prototype), 
_descriptor$W = _applyDecoratedDescriptor(_class2$13.prototype, "_type", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return MaskType.RECT;
    }
}), _descriptor2$K = _applyDecoratedDescriptor(_class2$13.prototype, "_inverted", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$C = _applyDecoratedDescriptor(_class2$13.prototype, "_segments", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 64;
    }
}), _class$1c = _class2$13)) || _class$1c) || _class$1c) || _class$1c) || _class$1c);

cc.MaskComponent = MaskComponent, function(Mode) {
    Mode[Mode.HORIZONTAL = 0] = "HORIZONTAL", Mode[Mode.VERTICAL = 1] = "VERTICAL", 
    Mode[Mode.FILLED = 2] = "FILLED";
}(Mode || (Mode = {})), Enum(Mode);

var _dec$1d, _dec2$Q, _dec3$A, _dec4$w, _dec5$t, _dec6$r, _class$1e, _class2$15, _descriptor$Y, _descriptor2$M, ProgressBarComponent = (_dec$1c = ccclass("cc.ProgressBarComponent"), 
_dec2$P = help("i18n:cc.ProgressBarComponent"), _dec3$z = executionOrder(110), _dec4$v = menu("UI/ProgressBar"), 
_dec5$s = property({
    type: SpriteComponent,
    tooltip: "进度条显示用的 Sprite 节点，可以动态改变尺寸"
}), _dec6$q = property({
    type: Mode,
    tooltip: "进度条显示模式，目前支持水平和垂直两种"
}), _dec7$m = property({
    tooltip: "进度条在 progress 为 1 时的最大长度"
}), _dec8$k = property({
    range: [ 0, 1, .1 ],
    slide: !0,
    tooltip: "当前进度指示，范围从 0 到 1"
}), _dec9$g = property({
    tooltip: "是否反向驱动进度条"
}), _dec$1c(_class$1d = _dec2$P(_class$1d = _dec3$z(_class$1d = _dec4$v((_temp$17 = _class3$r = function(_Component) {
    function ProgressBarComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ProgressBarComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ProgressBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_barSprite", _descriptor$X, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_mode", _descriptor2$L, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_totalLength", _descriptor3$D, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_progress", _descriptor4$v, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_reverse", _descriptor5$p, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(ProgressBarComponent, Component), _createClass(ProgressBarComponent, [ {
        key: "_initBarSprite",
        value: function _initBarSprite() {
            if (this._barSprite) {
                var entity = this._barSprite.node;
                if (!entity) return;
                var nodeSize = this.node.getContentSize(), nodeAnchor = this.node.getAnchorPoint(), barSpriteSize = entity.getContentSize();
                if (this._barSprite.fillType === SpriteComponent.FillType.RADIAL && (this._mode = Mode.FILLED), 
                this._mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this._mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this._barSprite.fillRange, 
                entity.parent === this.node) {
                    var x = -nodeSize.width * nodeAnchor.x;
                    entity.setPosition(x, 0, 0);
                }
            }
        }
    }, {
        key: "_updateBarStatus",
        value: function _updateBarStatus() {
            if (this._barSprite) {
                var entity = this._barSprite.node;
                if (!entity) return;
                var entityAnchorPoint = entity.getAnchorPoint(), entitySize = entity.getContentSize(), entityPosition = entity.getPosition(), anchorPoint = new Vec2(0, .5), progress = clamp01(this._progress), actualLenth = this._totalLength * progress, finalContentSize = entitySize, totalWidth = 0, totalHeight = 0;
                switch (this._mode) {
                  case Mode.HORIZONTAL:
                    this._reverse && (anchorPoint = new Vec2(1, .5)), finalContentSize = new Size(actualLenth, entitySize.height), 
                    totalWidth = this._totalLength, totalHeight = entitySize.height;
                    break;

                  case Mode.VERTICAL:
                    anchorPoint = this._reverse ? new Vec2(.5, 1) : new Vec2(.5, 0), finalContentSize = new Size(entitySize.width, actualLenth), 
                    totalWidth = entitySize.width, totalHeight = this._totalLength;
                }
                if (this._mode === Mode.FILLED) this._barSprite.type !== SpriteComponent.Type.FILLED ? warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!") : (this._reverse && (actualLenth *= -1), 
                this._barSprite.fillRange = actualLenth); else if (this._barSprite.type !== SpriteComponent.Type.FILLED) {
                    var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x, anchorOffsetY = anchorPoint.y - entityAnchorPoint.y, finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
                    entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z), 
                    entity.setAnchorPoint(anchorPoint), entity.setContentSize(finalContentSize);
                } else warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
            }
        }
    }, {
        key: "barSprite",
        get: function get() {
            return this._barSprite;
        },
        set: function set(value) {
            this._barSprite !== value && (this._barSprite = value, this._initBarSprite());
        }
    }, {
        key: "mode",
        get: function get() {
            return this._mode;
        },
        set: function set(value) {
            if (this._mode !== value && (this._mode = value, this._barSprite)) {
                var entity = this._barSprite.node;
                if (!entity) return;
                var entitySize = entity.getContentSize();
                this._mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this._mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this._mode === Mode.FILLED && (this.totalLength = this._barSprite.fillRange);
            }
        }
    }, {
        key: "totalLength",
        get: function get() {
            return this._totalLength;
        },
        set: function set(value) {
            this._mode === Mode.FILLED && (value = clamp01(value)), this._totalLength = value, 
            this._updateBarStatus();
        }
    }, {
        key: "progress",
        get: function get() {
            return this._progress;
        },
        set: function set(value) {
            this._progress !== value && (this._progress = value, this._updateBarStatus());
        }
    }, {
        key: "reverse",
        get: function get() {
            return this._reverse;
        },
        set: function set(value) {
            this._reverse !== value && (this._reverse = value, this._barSprite && (this._barSprite.fillStart = 1 - this._barSprite.fillStart), 
            this._updateBarStatus());
        }
    } ]), ProgressBarComponent;
}(), _class3$r.Mode = Mode, _applyDecoratedDescriptor((_class2$14 = _temp$17).prototype, "barSprite", [ _dec5$s ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "barSprite"), _class2$14.prototype), 
_applyDecoratedDescriptor(_class2$14.prototype, "mode", [ _dec6$q ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "mode"), _class2$14.prototype), 
_applyDecoratedDescriptor(_class2$14.prototype, "totalLength", [ _dec7$m ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "totalLength"), _class2$14.prototype), 
_applyDecoratedDescriptor(_class2$14.prototype, "progress", [ _dec8$k ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "progress"), _class2$14.prototype), 
_applyDecoratedDescriptor(_class2$14.prototype, "reverse", [ _dec9$g ], Object.getOwnPropertyDescriptor(_class2$14.prototype, "reverse"), _class2$14.prototype), 
_descriptor$X = _applyDecoratedDescriptor(_class2$14.prototype, "_barSprite", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$L = _applyDecoratedDescriptor(_class2$14.prototype, "_mode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode.HORIZONTAL;
    }
}), _descriptor3$D = _applyDecoratedDescriptor(_class2$14.prototype, "_totalLength", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor4$v = _applyDecoratedDescriptor(_class2$14.prototype, "_progress", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor5$p = _applyDecoratedDescriptor(_class2$14.prototype, "_reverse", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _class$1d = _class2$14)) || _class$1d) || _class$1d) || _class$1d) || _class$1d);

cc.ProgressBarComponent = ProgressBarComponent;

var _dec$1e, _dec2$R, _dec3$B, _dec4$x, _dec5$u, _dec6$s, _dec7$n, _dec8$l, _dec9$h, _dec10$c, _dec11$b, _dec12$a, _class$1f, _class2$16, _descriptor$Z, _descriptor2$N, _descriptor3$E, _descriptor4$w, _descriptor5$q, _descriptor6$g, _descriptor7$e, _descriptor8$c, _class3$s, _temp$19, LabelOutlineComponent = (_dec$1d = ccclass("cc.LabelOutlineComponent"), 
_dec2$Q = help("i18n:cc.LabelOutlineComponent"), _dec3$A = executionOrder(110), 
_dec4$w = menu("UI/LabelOutline"), _dec5$t = property({
    tooltip: "描边的颜色"
}), _dec6$r = property({
    tooltip: "描边的宽度"
}), _dec$1d(_class$1e = _dec2$Q(_class$1e = _dec3$A(_class$1e = _dec4$w((_descriptor$Y = _applyDecoratedDescriptor((_class2$15 = function(_Component) {
    function LabelOutlineComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, LabelOutlineComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LabelOutlineComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_color", _descriptor$Y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_width", _descriptor2$M, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(LabelOutlineComponent, Component), _createClass(LabelOutlineComponent, [ {
        key: "_updateRenderData",
        value: function _updateRenderData() {
            var label = this.node.getComponent(LabelComponent);
            label && label.updateRenderData(!0);
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(value) {
            this._color !== value && (this._color.set(value), this._updateRenderData());
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(value) {
            this._width !== value && (this._width = value, this._updateRenderData());
        }
    } ]), LabelOutlineComponent;
}()).prototype, "_color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Color(255, 255, 255, 255);
    }
}), _descriptor2$M = _applyDecoratedDescriptor(_class2$15.prototype, "_width", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _applyDecoratedDescriptor(_class2$15.prototype, "color", [ _dec5$t ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "color"), _class2$15.prototype), 
_applyDecoratedDescriptor(_class2$15.prototype, "width", [ _dec6$r ], Object.getOwnPropertyDescriptor(_class2$15.prototype, "width"), _class2$15.prototype), 
_class$1e = _class2$15)) || _class$1e) || _class$1e) || _class$1e) || _class$1e);

cc.LabelOutlineComponent = LabelOutlineComponent;

var _htmlTextParser = new HtmlTextParser, pool$2 = new Pool((function(labelSeg) {
    return !!cc.isValid(labelSeg.node) && !labelSeg.node.getComponent(LabelOutlineComponent);
}), 20);

pool$2.get = function(str, richtext) {
    var labelSeg = this._get();
    labelSeg || (labelSeg = {
        node: new PrivateNode("RICHTEXT_CHILD"),
        comp: null,
        lineCount: 0,
        styleIndex: 0,
        clickHandler: ""
    });
    var labelNode = labelSeg.node;
    labelNode || (labelNode = new PrivateNode("RICHTEXT_CHILD"));
    var labelComponent = labelNode.getComponent(LabelComponent);
    return labelComponent || (labelComponent = labelNode.addComponent(LabelComponent)), 
    labelComponent = labelComponent, labelNode.setPosition(0, 0, 0), labelNode.setAnchorPoint(.5, .5), 
    labelNode.setContentSize(128, 128), "string" != typeof str && (str = "" + str), 
    richtext.font instanceof Font ? labelComponent.font = richtext.font : labelComponent.fontFamily = "Arial", 
    labelComponent.string = str, labelComponent.horizontalAlign = exports.HorizontalTextAlignment.LEFT, 
    labelComponent.verticalAlign = exports.VerticalTextAlignment.TOP, labelComponent.fontSize = richtext.fontSize || 40, 
    labelComponent.overflow = 0, labelComponent.enableWrapText = !0, labelComponent.lineHeight = 40, 
    labelComponent.isBold = !1, labelComponent.isItalic = !1, labelComponent.isUnderline = !1, 
    {
        node: labelNode,
        comp: labelComponent,
        lineCount: 0,
        clickHandler: "",
        styleIndex: 0
    };
};

var _dec$1f, _dec2$S, _dec3$C, _dec4$y, _dec5$v, _dec6$t, _dec7$o, _dec8$m, _class$1g, _class2$17, _descriptor$_, _descriptor2$O, _descriptor3$F, _descriptor4$x, _descriptor5$r, _class3$t, _temp$1a, RichTextComponent = (_dec$1e = ccclass("cc.RichTextComponent"), 
_dec2$R = help("i18n:cc.RichTextComponent"), _dec3$B = executionOrder(110), _dec4$x = menu("UI/Render/RichText"), 
_dec5$u = property({
    multiline: !0,
    tooltip: "富文本显示的文本内容"
}), _dec6$s = property({
    type: exports.HorizontalTextAlignment,
    tooltip: "文本内容的水平对齐方式"
}), _dec7$n = property({
    tooltip: "富文本字体大小"
}), _dec8$l = property({
    type: Font,
    tooltip: "富文本定制字体"
}), _dec9$h = property({
    tooltip: "富文本的最大宽度"
}), _dec10$c = property({
    tooltip: "富文本行高"
}), _dec11$b = property({
    type: SpriteAtlas,
    tooltip: "对于 img 标签里面的 src 属性名称，都需要在 imageAtlas 里面找到一个有效的 spriteFrame，否则 img tag 会判定为无效"
}), _dec12$a = property({
    tooltip: "选中此选项后，RichText 将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点"
}), _dec$1e(_class$1f = _dec2$R(_class$1f = _dec3$B(_class$1f = _dec4$x(_class$1f = executeInEditMode((_temp$19 = _class3$s = function(_UIComponent) {
    function RichTextComponent() {
        var _this;
        return _classCallCheck(this, RichTextComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(RichTextComponent).call(this)), "_lineHeight", _descriptor$Z, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_string", _descriptor2$N, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$E, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fontSize", _descriptor4$w, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_maxWidth", _descriptor5$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_font", _descriptor6$g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_imageAtlas", _descriptor7$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_handleTouchEvent", _descriptor8$c, _assertThisInitialized(_this)), 
        _this._textArray = [], _this._labelSegments = [], _this._labelSegmentsCache = [], 
        _this._linesWidth = [], _this._lineCount = 1, _this._labelWidth = 0, _this._labelHeight = 0, 
        _this._layoutDirty = !0, _this._lineOffsetX = 0, _this._updateRichTextStatus = void 0, 
        _this._updateRichTextStatus = _this._updateRichText, _this;
    }
    return _inherits(RichTextComponent, UIComponent), _createClass(RichTextComponent, [ {
        key: "string",
        get: function get() {
            return this._string;
        },
        set: function set(value) {
            this._string !== value && (this._string = value, this._updateRichTextStatus());
        }
    }, {
        key: "horizontalAlign",
        get: function get() {
            return this._horizontalAlign;
        },
        set: function set(value) {
            this.horizontalAlign !== value && (this._horizontalAlign = value, this._layoutDirty = !0, 
            this._updateRichTextStatus());
        }
    }, {
        key: "fontSize",
        get: function get() {
            return this._fontSize;
        },
        set: function set(value) {
            this._fontSize !== value && (this._fontSize = value, this._layoutDirty = !0, this._updateRichTextStatus());
        }
    }, {
        key: "font",
        get: function get() {
            return this._font;
        },
        set: function set(value) {
            this._font !== value && (value instanceof BitmapFont ? console.warn("RichText only accepts TTF fonts, but you are trying to use a bitmap font.") : (this._font = value, 
            this._layoutDirty = !0, this._font && this._onTTFLoaded(), this._updateRichTextStatus()));
        }
    }, {
        key: "maxWidth",
        get: function get() {
            return this._maxWidth;
        },
        set: function set(value) {
            this._maxWidth !== value && (this._maxWidth = value, this._layoutDirty = !0, this._updateRichTextStatus());
        }
    }, {
        key: "lineHeight",
        get: function get() {
            return this._lineHeight;
        },
        set: function set(value) {
            this._lineHeight !== value && (this._lineHeight = value, this._layoutDirty = !0, 
            this._updateRichTextStatus());
        }
    }, {
        key: "imageAtlas",
        get: function get() {
            return this._imageAtlas;
        },
        set: function set(value) {
            this._imageAtlas !== value && (this._imageAtlas = value, this._layoutDirty = !0, 
            this._updateRichTextStatus());
        }
    }, {
        key: "handleTouchEvent",
        get: function get() {
            return this._handleTouchEvent;
        },
        set: function set(value) {
            this._handleTouchEvent !== value && (this._handleTouchEvent = value, this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners()));
        }
    } ]), _createClass(RichTextComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this.handleTouchEvent && this._addEventListeners(), this._updateRichText(), this._activateChildren(!0);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.handleTouchEvent && this._removeEventListeners(), this._activateChildren(!1);
        }
    }, {
        key: "start",
        value: function start() {
            this._onTTFLoaded(), this.node.on(Node$1.EventType.ANCHOR_CHANGED, this._anchorChanged, this);
        }
    }, {
        key: "onRestore",
        value: function onRestore() {}
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._labelSegments); !(_step = _iterator()).done; ) {
                var seg = _step.value;
                seg.node.removeFromParent(), pool$2.put(seg);
            }
            this.node.off(Node$1.EventType.ANCHOR_CHANGED, this._anchorChanged);
        }
    }, {
        key: "_addEventListeners",
        value: function _addEventListeners() {
            this.node.on(Node$1.EventType.TOUCH_END, this._onTouchEnded, this);
        }
    }, {
        key: "_removeEventListeners",
        value: function _removeEventListeners() {
            this.node.off(Node$1.EventType.TOUCH_END, this._onTouchEnded, this);
        }
    }, {
        key: "_updateLabelSegmentTextAttributes",
        value: function _updateLabelSegmentTextAttributes() {
            var _this2 = this;
            this._labelSegments.forEach((function(item) {
                _this2._applyTextAttribute(item);
            }));
        }
    }, {
        key: "_createFontLabel",
        value: function _createFontLabel(str) {
            return pool$2.get(str, this);
        }
    }, {
        key: "_onTTFLoaded",
        value: function _onTTFLoaded() {
            if (this._font instanceof TTFFont) if (this._font._nativeAsset) this._layoutDirty = !0, 
            this._updateRichText(); else {
                var self = this;
                loader.load(this._font.nativeUrl, (function(err, fontFamily) {
                    self._layoutDirty = !0, self._updateRichText();
                }));
            } else this._layoutDirty = !0, this._updateRichText();
        }
    }, {
        key: "_measureText",
        value: function _measureText(styleIndex, string) {
            var self = this, func = function func(s) {
                var label;
                return 0 === self._labelSegmentsCache.length ? (label = self._createFontLabel(s), 
                self._labelSegmentsCache.push(label)) : (label = self._labelSegmentsCache[0]).node.getComponent(LabelComponent).string = s, 
                label.styleIndex = styleIndex, self._applyTextAttribute(label), label.node.getContentSize().width;
            };
            return string ? func(string) : func;
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event) {
            for (var _step2, _this3 = this, components = this.node.getComponents(UIComponent), self = this, _loop = function _loop() {
                var seg = _step2.value, clickHandler = seg.clickHandler;
                clickHandler && _this3._containsTouchLocation(seg, event.touch.getUILocation()) && (components.forEach((function(component) {
                    var func = component[clickHandler];
                    component.enabledInHierarchy && func && func.call(self, event);
                })), event.propagationStopped = !0);
            }, _iterator2 = _createForOfIteratorHelperLoose(this._labelSegments); !(_step2 = _iterator2()).done; ) _loop();
        }
    }, {
        key: "_containsTouchLocation",
        value: function _containsTouchLocation(label, point) {
            var comp = label.node.getComponent(UITransformComponent);
            return !!comp && comp.getBoundingBoxToWorld().contains(point);
        }
    }, {
        key: "_resetState",
        value: function _resetState() {
            for (var _this4 = this, children = this.node.children, _loop2 = function _loop2(i) {
                var child = children[i];
                if (("RICHTEXT_CHILD" === child.name || "RICHTEXT_Image_CHILD" === child.name) && (child.parent === _this4.node ? child.parent = null : children.splice(i, 1), 
                "RICHTEXT_CHILD" === child.name)) {
                    var index = _this4._labelSegments.findIndex((function(seg) {
                        return seg.node === child;
                    }));
                    -1 !== index && pool$2.put(_this4._labelSegments[index]);
                }
            }, i = children.length - 1; i >= 0; i--) _loop2(i);
            this._labelSegments.length = 0, this._labelSegmentsCache.length = 0, this._linesWidth.length = 0, 
            this._lineOffsetX = 0, this._lineCount = 1, this._labelWidth = 0, this._labelHeight = 0, 
            this._layoutDirty = !0;
        }
    }, {
        key: "_activateChildren",
        value: function _activateChildren(active) {
            for (var i = this.node.children.length - 1; i >= 0; i--) {
                var child = this.node.children[i];
                "RICHTEXT_CHILD" !== child.name && "RICHTEXT_Image_CHILD" !== child.name || (child.active = active);
            }
        }
    }, {
        key: "_addLabelSegment",
        value: function _addLabelSegment(stringToken, styleIndex) {
            var labelSegment;
            if (0 === this._labelSegmentsCache.length) labelSegment = this._createFontLabel(stringToken); else {
                var label = (labelSegment = this._labelSegmentsCache.pop()).node.getComponent(LabelComponent);
                label && (label.string = stringToken);
            }
            return labelSegment.styleIndex = styleIndex, labelSegment.lineCount = this._lineCount, 
            labelSegment.node.setAnchorPoint(0, 0), this._applyTextAttribute(labelSegment), 
            this.node.addChild(labelSegment.node), this._labelSegments.push(labelSegment), labelSegment;
        }
    }, {
        key: "_updateRichTextWithMaxWidth",
        value: function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
            var fragmentWidth = labelWidth;
            if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this.maxWidth) for (var checkStartIndex = 0; this._lineOffsetX <= this.maxWidth; ) {
                var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length), checkString = labelString.substr(checkStartIndex, checkEndIndex), checkStringWidth = this._measureText(styleIndex, checkString);
                if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
                    if (checkStartIndex > 0) {
                        var remainingString = labelString.substr(0, checkStartIndex);
                        this._addLabelSegment(remainingString, styleIndex), labelString = labelString.substr(checkStartIndex, labelString.length), 
                        fragmentWidth = this._measureText(styleIndex, labelString);
                    }
                    this._updateLineInfo();
                    break;
                }
                this._lineOffsetX += checkStringWidth, checkStartIndex += checkEndIndex;
            }
            if (fragmentWidth > this.maxWidth) for (var fragments = fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex)), k = 0; k < fragments.length; ++k) {
                var splitString = fragments[k], labelSize = this._addLabelSegment(splitString, styleIndex).node.getContentSize();
                this._lineOffsetX += labelSize.width, fragments.length > 1 && k < fragments.length - 1 && this._updateLineInfo();
            } else this._lineOffsetX += fragmentWidth, this._addLabelSegment(labelString, styleIndex);
        }
    }, {
        key: "_isLastComponentCR",
        value: function _isLastComponentCR(stringToken) {
            return stringToken.length - 1 === stringToken.lastIndexOf("\n");
        }
    }, {
        key: "_updateLineInfo",
        value: function _updateLineInfo() {
            this._linesWidth.push(this._lineOffsetX), this._lineOffsetX = 0, this._lineCount++;
        }
    }, {
        key: "_needsUpdateTextLayout",
        value: function _needsUpdateTextLayout(newTextArray) {
            if (this._layoutDirty || !this._textArray || !newTextArray) return !0;
            if (this._textArray.length !== newTextArray.length) return !0;
            for (var i = 0; i < this._textArray.length; i++) {
                var oldItem = this._textArray[i], newItem = newTextArray[i];
                if (oldItem.text !== newItem.text) return !0;
                if (oldItem.style) {
                    if (newItem.style) {
                        if (!!newItem.style.outline != !!oldItem.style.outline) return !0;
                        if (oldItem.style.size !== newItem.style.size || oldItem.style.italic !== newItem.style.italic || oldItem.style.isImage !== newItem.style.isImage) return !0;
                        if (oldItem.style.isImage === newItem.style.isImage && oldItem.style.src !== newItem.style.src) return !0;
                    } else if (oldItem.style.size || oldItem.style.italic || oldItem.style.isImage || oldItem.style.outline) return !0;
                } else if (newItem.style && (newItem.style.size || newItem.style.italic || newItem.style.isImage || newItem.style.outline)) return !0;
            }
            return !1;
        }
    }, {
        key: "_addRichTextImageElement",
        value: function _addRichTextImageElement(richTextElement) {
            if (richTextElement.style) {
                var spriteFrameName = richTextElement.style.src, spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);
                if (spriteFrame) {
                    var spriteNode = new PrivateNode("RICHTEXT_Image_CHILD"), spriteComponent = spriteNode.addComponent(SpriteComponent);
                    spriteNode.setAnchorPoint(0, 0), spriteComponent.type = SpriteComponent.Type.SLICED, 
                    spriteComponent.sizeMode = SpriteComponent.SizeMode.CUSTOM, this.node.addChild(spriteNode);
                    var obj = {
                        node: spriteNode,
                        comp: spriteComponent,
                        lineCount: 0,
                        clickHandler: "",
                        styleIndex: 0
                    };
                    this._labelSegments.push(obj);
                    var spriteRect = spriteFrame.getRect(), scaleFactor = 1, spriteWidth = spriteRect.width, spriteHeight = spriteRect.height, expectWidth = richTextElement.style.imageWidth, expectHeight = richTextElement.style.imageHeight;
                    if (void 0 !== expectHeight && expectHeight > 0 && expectHeight < this.lineHeight ? (spriteWidth *= scaleFactor = expectHeight / spriteHeight, 
                    spriteHeight *= scaleFactor) : (spriteWidth *= scaleFactor = this.lineHeight / spriteHeight, 
                    spriteHeight *= scaleFactor), void 0 !== expectWidth && expectWidth > 0 && (spriteWidth = expectWidth), 
                    this.maxWidth > 0 ? (this._lineOffsetX + spriteWidth > this.maxWidth && this._updateLineInfo(), 
                    this._lineOffsetX += spriteWidth) : (this._lineOffsetX += spriteWidth, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX)), 
                    spriteComponent.spriteFrame = spriteFrame, spriteNode.setContentSize(spriteWidth, spriteHeight), 
                    obj.lineCount = this._lineCount, richTextElement.style.event) {
                        var c = "click";
                        richTextElement.style.event[c] && (obj.clickHandler = richTextElement.style.event[c]);
                    }
                } else warnID(4400);
            }
        }
    }, {
        key: "_updateRichText",
        value: function _updateRichText() {
            if (this.enabled) {
                var newTextArray = _htmlTextParser.parse(this._string);
                if (!this._needsUpdateTextLayout(newTextArray)) return this._textArray = newTextArray.slice(), 
                void this._updateLabelSegmentTextAttributes();
                this._textArray = newTextArray.slice(), this._resetState();
                for (var labelSize, lastEmptyLine = !1, i = 0; i < this._textArray.length; ++i) {
                    var richTextElement = this._textArray[i], text = richTextElement.text;
                    if (void 0 !== text) {
                        if ("" === text) {
                            if (richTextElement.style && richTextElement.style.isNewLine) {
                                this._updateLineInfo();
                                continue;
                            }
                            if (richTextElement.style && richTextElement.style.isImage && this.imageAtlas) {
                                this._addRichTextImageElement(richTextElement);
                                continue;
                            }
                        }
                        for (var multilineTexts = text.split("\n"), j = 0; j < multilineTexts.length; ++j) {
                            var labelString = multilineTexts[j];
                            if ("" !== labelString) if (lastEmptyLine = !1, this.maxWidth > 0) {
                                var labelWidth = this._measureText(i, labelString);
                                this._updateRichTextWithMaxWidth(labelString, labelWidth, i), multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
                            } else labelSize = this._addLabelSegment(labelString, i).node.getContentSize(), 
                            this._lineOffsetX += labelSize.width, this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX), 
                            multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo(); else {
                                if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) continue;
                                this._updateLineInfo(), lastEmptyLine = !0;
                            }
                        }
                    }
                }
                lastEmptyLine || this._linesWidth.push(this._lineOffsetX), this.maxWidth > 0 && (this._labelWidth = this.maxWidth), 
                this._labelHeight = (this._lineCount + .26) * this.lineHeight, this.node.setContentSize(this._labelWidth, this._labelHeight), 
                this._updateRichTextPosition(), this._layoutDirty = !1;
            }
        }
    }, {
        key: "_getFirstWordLen",
        value: function _getFirstWordLen(text, startIndex, textLen) {
            var character = text.charAt(startIndex);
            if (isUnicodeCJK(character) || isUnicodeSpace(character)) return 1;
            for (var len = 1, index = startIndex + 1; index < textLen && (!isUnicodeSpace(character = text.charAt(index)) && !isUnicodeCJK(character)); ++index) len++;
            return len;
        }
    }, {
        key: "_updateRichTextPosition",
        value: function _updateRichTextPosition() {
            for (var _step3, nextTokenX = 0, nextLineIndex = 1, totalLineCount = this._lineCount, _iterator3 = _createForOfIteratorHelperLoose(this._labelSegments); !(_step3 = _iterator3()).done; ) {
                var label = _step3.value, lineCount = label.lineCount;
                lineCount > nextLineIndex && (nextTokenX = 0, nextLineIndex = lineCount);
                var anchorX = this.node.anchorX, lineOffsetX = this._labelWidth * (.5 * this.horizontalAlign - anchorX);
                switch (this.horizontalAlign) {
                  case exports.HorizontalTextAlignment.LEFT:
                    break;

                  case exports.HorizontalTextAlignment.CENTER:
                    lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                    break;

                  case exports.HorizontalTextAlignment.RIGHT:
                    lineOffsetX -= this._linesWidth[lineCount - 1];
                }
                var pos = label.node.position, anchorY = this.node.anchorY;
                label.node.setPosition(nextTokenX + lineOffsetX, this.lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z), 
                lineCount === nextLineIndex && (nextTokenX += label.node.width);
            }
        }
    }, {
        key: "_convertLiteralColorValue",
        value: function _convertLiteralColorValue(color) {
            var colorValue = color.toUpperCase();
            return Color[colorValue] ? Color[colorValue] : (new Color).fromHEX(color);
        }
    }, {
        key: "_applyTextAttribute",
        value: function _applyTextAttribute(labelSeg) {
            var labelComponent = labelSeg.node.getComponent(LabelComponent);
            if (labelComponent) {
                var textStyle, index = labelSeg.styleIndex;
                labelComponent.lineHeight = this.lineHeight, labelComponent.horizontalAlign = exports.HorizontalTextAlignment.LEFT, 
                labelComponent.verticalAlign = exports.VerticalTextAlignment.CENTER, this._textArray[index] && (textStyle = this._textArray[index].style);
                var labelComp = labelSeg.node.getComponent(LabelComponent);
                if (labelComp && (textStyle && textStyle.color ? labelComp.color = this._convertLiteralColorValue(textStyle.color) : labelComp.color = this._convertLiteralColorValue("white")), 
                labelComponent.isBold = !(!textStyle || !textStyle.bold), labelComponent.isItalic = !(!textStyle || !textStyle.italic), 
                labelComponent.isUnderline = !(!textStyle || !textStyle.underline), textStyle && textStyle.outline) {
                    var labelOutlineComponent = labelSeg.node.getComponent(LabelOutlineComponent);
                    labelOutlineComponent || (labelOutlineComponent = labelSeg.node.addComponent(LabelOutlineComponent)), 
                    labelOutlineComponent.color = this._convertLiteralColorValue(textStyle.outline.color), 
                    labelOutlineComponent.width = textStyle.outline.width;
                }
                if (textStyle && textStyle.size ? labelComponent.fontSize = textStyle.size : labelComponent.fontSize = this._fontSize, 
                labelComponent.updateRenderData(!0), textStyle && textStyle.event) {
                    var c = "click";
                    textStyle.event[c] && (labelSeg.clickHandler = textStyle.event[c]);
                }
            }
        }
    }, {
        key: "_anchorChanged",
        value: function _anchorChanged() {
            this._updateRichTextPosition();
        }
    } ]), RichTextComponent;
}(), _class3$s.HorizontalAlign = exports.HorizontalTextAlignment, _class3$s.VerticalAlign = exports.VerticalTextAlignment, 
_applyDecoratedDescriptor((_class2$16 = _temp$19).prototype, "string", [ _dec5$u ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "string"), _class2$16.prototype), 
_applyDecoratedDescriptor(_class2$16.prototype, "horizontalAlign", [ _dec6$s ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "horizontalAlign"), _class2$16.prototype), 
_applyDecoratedDescriptor(_class2$16.prototype, "fontSize", [ _dec7$n ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "fontSize"), _class2$16.prototype), 
_applyDecoratedDescriptor(_class2$16.prototype, "font", [ _dec8$l ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "font"), _class2$16.prototype), 
_applyDecoratedDescriptor(_class2$16.prototype, "maxWidth", [ _dec9$h ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "maxWidth"), _class2$16.prototype), 
_applyDecoratedDescriptor(_class2$16.prototype, "lineHeight", [ _dec10$c ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "lineHeight"), _class2$16.prototype), 
_applyDecoratedDescriptor(_class2$16.prototype, "imageAtlas", [ _dec11$b ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "imageAtlas"), _class2$16.prototype), 
_applyDecoratedDescriptor(_class2$16.prototype, "handleTouchEvent", [ _dec12$a ], Object.getOwnPropertyDescriptor(_class2$16.prototype, "handleTouchEvent"), _class2$16.prototype), 
_descriptor$Z = _applyDecoratedDescriptor(_class2$16.prototype, "_lineHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor2$N = _applyDecoratedDescriptor(_class2$16.prototype, "_string", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "<color=#00ff00>Rich</c><color=#0fffff>Text</color>";
    }
}), _descriptor3$E = _applyDecoratedDescriptor(_class2$16.prototype, "_horizontalAlign", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.HorizontalTextAlignment.LEFT;
    }
}), _descriptor4$w = _applyDecoratedDescriptor(_class2$16.prototype, "_fontSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 40;
    }
}), _descriptor5$q = _applyDecoratedDescriptor(_class2$16.prototype, "_maxWidth", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$g = _applyDecoratedDescriptor(_class2$16.prototype, "_font", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor7$e = _applyDecoratedDescriptor(_class2$16.prototype, "_imageAtlas", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor8$c = _applyDecoratedDescriptor(_class2$16.prototype, "_handleTouchEvent", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _class$1f = _class2$16)) || _class$1f) || _class$1f) || _class$1f) || _class$1f) || _class$1f);

cc.RichTextComponent = RichTextComponent;

var Direction, ZERO = new Vec3, _tempPos_1 = new Vec3, _tempPos_2 = new Vec3, defaultAnchor = (new Size, 
new Vec2, new Vec2), _tempColor$1 = new Color;

!function(Direction) {
    Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
}(Direction || (Direction = {})), ccenum(Direction);

var _class$1h, ScrollBarComponent = (_dec$1f = ccclass("cc.ScrollBarComponent"), 
_dec2$S = help("i18n:cc.ScrollBarComponent"), _dec3$C = executionOrder(110), _dec4$y = menu("UI/ScrollBar"), 
_dec5$v = property({
    type: SpriteComponent,
    tooltip: "作为当前滚动区域位置显示的滑块 Sprite",
    displayOrder: 0
}), _dec6$t = property({
    type: Direction,
    tooltip: "ScrollBar 的滚动方向",
    displayOrder: 1
}), _dec7$o = property({
    tooltip: "是否在没有滚动动作时自动隐藏 ScrollBar",
    displayOrder: 2
}), _dec8$m = property({
    tooltip: "没有滚动动作后经过多久会自动隐藏。\n注意：只要当 “enableAutoHide” 为 true 时，才有效。",
    displayOrder: 3
}), _dec$1f(_class$1g = _dec2$S(_class$1g = _dec3$C(_class$1g = _dec4$y((_temp$1a = _class3$t = function(_Component) {
    function ScrollBarComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ScrollBarComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollBarComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_scrollView", _descriptor$_, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_handle", _descriptor2$O, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor3$F, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_enableAutoHide", _descriptor4$x, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_autoHideTime", _descriptor5$r, _assertThisInitialized(_this)), 
        _this._touching = !1, _this._opacity = 255, _this._autoHideRemainingTime = 0, _this;
    }
    return _inherits(ScrollBarComponent, Component), _createClass(ScrollBarComponent, [ {
        key: "hide",
        value: function hide() {
            this._autoHideRemainingTime = 0, this._setOpacity(0);
        }
    }, {
        key: "show",
        value: function show() {
            this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity);
        }
    }, {
        key: "onScroll",
        value: function onScroll(outOfBoundary) {
            if (this._scrollView) {
                var content = this._scrollView.content;
                if (content) {
                    var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize(), barSize = this.node.getContentSize();
                    if (!this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                        this._enableAutoHide && (this._autoHideRemainingTime = this._autoHideTime, this._setOpacity(this._opacity));
                        var contentMeasure = 0, scrollViewMeasure = 0, outOfBoundaryValue = 0, contentPosition = 0, handleNodeMeasure = 0;
                        this._direction === Direction.HORIZONTAL ? (contentMeasure = contentSize.width, 
                        scrollViewMeasure = scrollViewSize.width, handleNodeMeasure = barSize.width, outOfBoundaryValue = outOfBoundary.x, 
                        contentPosition = -this._convertToScrollViewSpace(content).x) : this._direction === Direction.VERTICAL && (contentMeasure = contentSize.height, 
                        scrollViewMeasure = scrollViewSize.height, handleNodeMeasure = barSize.height, outOfBoundaryValue = outOfBoundary.y, 
                        contentPosition = -this._convertToScrollViewSpace(content).y);
                        var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue), position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
                        this._updateLength(length), this._updateHandlerPosition(position);
                    }
                }
            }
        }
    }, {
        key: "setScrollView",
        value: function setScrollView(scrollView) {
            this._scrollView = scrollView;
        }
    }, {
        key: "onTouchBegan",
        value: function onTouchBegan() {
            this._enableAutoHide && (this._touching = !0);
        }
    }, {
        key: "onTouchEnded",
        value: function onTouchEnded() {
            if (this._enableAutoHide && (this._touching = !1, !(this._autoHideTime <= 0))) {
                if (this._scrollView) {
                    var content = this._scrollView.content;
                    if (content) {
                        var contentSize = content.getContentSize(), scrollViewSize = this._scrollView.node.getContentSize();
                        if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
                    }
                }
                this._autoHideRemainingTime = this._autoHideTime;
            }
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            var renderComp = this.node.getComponent(SpriteComponent);
            renderComp && (this._opacity = renderComp.color.a);
        }
    }, {
        key: "start",
        value: function start() {
            this._enableAutoHide && this._setOpacity(0);
        }
    }, {
        key: "update",
        value: function update(dt) {
            this._processAutoHide(dt);
        }
    }, {
        key: "_convertToScrollViewSpace",
        value: function _convertToScrollViewSpace(content) {
            if (!this._scrollView) return ZERO;
            var scrollTrans = this._scrollView.node._uiProps.uiTransformComp, contentTrans = content._uiProps.uiTransformComp;
            if (!scrollTrans || !contentTrans) return ZERO;
            _tempPos_1.set(-content.anchorX * content.width, -content.anchorY * content.height, 0), 
            contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
            var scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
            return scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width, scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height, 
            scrollViewSpacePos;
        }
    }, {
        key: "_setOpacity",
        value: function _setOpacity(opacity) {
            if (this._handle) {
                var renderComp = this.node.getComponent(SpriteComponent);
                renderComp && (_tempColor$1.set(renderComp.color), _tempColor$1.a = opacity, renderComp.color = _tempColor$1), 
                (renderComp = this._handle.getComponent(SpriteComponent)) && (_tempColor$1.set(renderComp.color), 
                _tempColor$1.a = opacity, renderComp.color = _tempColor$1);
            }
        }
    }, {
        key: "_updateHandlerPosition",
        value: function _updateHandlerPosition(position) {
            if (this._handle) {
                var oldPosition = this._fixupHandlerPosition();
                this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
            }
        }
    }, {
        key: "_fixupHandlerPosition",
        value: function _fixupHandlerPosition() {
            var barSize = this.node.getContentSize(), barAnchor = this.node.getAnchorPoint(), handleSize = this.handle.node.getContentSize(), handleParent = this.handle.node.parent;
            Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);
            var leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2), fixupPosition = new Vec3;
            return handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition), 
            this.direction === Direction.HORIZONTAL ? fixupPosition = new Vec3(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, 0) : this.direction === Direction.VERTICAL && (fixupPosition = new Vec3(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, 0)), 
            this.handle.node.setPosition(fixupPosition), fixupPosition;
        }
    }, {
        key: "_conditionalDisableScrollBar",
        value: function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
            return contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL || contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL;
        }
    }, {
        key: "_calculateLength",
        value: function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
            var denominatorValue = contentMeasure;
            return outOfBoundary && (denominatorValue += 20 * (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary)), 
            handleNodeMeasure * (scrollViewMeasure / denominatorValue);
        }
    }, {
        key: "_calculatePosition",
        value: function _calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
            var denominatorValue = contentMeasure - scrollViewMeasure;
            outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
            var positionRatio = 0;
            denominatorValue && (positionRatio = clamp01(positionRatio = contentPosition / denominatorValue));
            var position = (handleNodeMeasure - actualLenth) * positionRatio;
            return this._direction === Direction.VERTICAL ? new Vec3(0, position, 0) : new Vec3(position, 0, 0);
        }
    }, {
        key: "_updateLength",
        value: function _updateLength(length) {
            if (this._handle) {
                var handleNode = this._handle.node, handleNodeSize = handleNode.getContentSize(), anchor = handleNode.getAnchorPoint();
                anchor.x === defaultAnchor.x && anchor.y === defaultAnchor.y || handleNode.setAnchorPoint(defaultAnchor), 
                this._direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
            }
        }
    }, {
        key: "_processAutoHide",
        value: function _processAutoHide(deltaTime) {
            if (this._enableAutoHide && !(this._autoHideRemainingTime <= 0) && !this._touching && (this._autoHideRemainingTime -= deltaTime, 
            this._autoHideRemainingTime <= this._autoHideTime)) {
                this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);
                this._setOpacity(opacity);
            }
        }
    }, {
        key: "handle",
        get: function get() {
            return this._handle;
        },
        set: function set(value) {
            this._handle !== value && (this._handle = value, this.onScroll(new Vec3(0, 0, 0)));
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction !== value && (this._direction = value, this.onScroll(new Vec3));
        }
    }, {
        key: "enableAutoHide",
        get: function get() {
            return this._enableAutoHide;
        },
        set: function set(value) {
            this._enableAutoHide !== value && (this._enableAutoHide = value, this._enableAutoHide && this._setOpacity(0));
        }
    }, {
        key: "autoHideTime",
        get: function get() {
            return this._autoHideTime;
        },
        set: function set(value) {
            this._autoHideTime !== value && (this._autoHideTime = value);
        }
    } ]), ScrollBarComponent;
}(), _class3$t.Direction = Direction, _applyDecoratedDescriptor((_class2$17 = _temp$1a).prototype, "handle", [ _dec5$v ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "handle"), _class2$17.prototype), 
_applyDecoratedDescriptor(_class2$17.prototype, "direction", [ _dec6$t ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "direction"), _class2$17.prototype), 
_applyDecoratedDescriptor(_class2$17.prototype, "enableAutoHide", [ _dec7$o ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "enableAutoHide"), _class2$17.prototype), 
_applyDecoratedDescriptor(_class2$17.prototype, "autoHideTime", [ _dec8$m ], Object.getOwnPropertyDescriptor(_class2$17.prototype, "autoHideTime"), _class2$17.prototype), 
_descriptor$_ = _applyDecoratedDescriptor(_class2$17.prototype, "_scrollView", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$O = _applyDecoratedDescriptor(_class2$17.prototype, "_handle", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$F = _applyDecoratedDescriptor(_class2$17.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Direction.HORIZONTAL;
    }
}), _descriptor4$x = _applyDecoratedDescriptor(_class2$17.prototype, "_enableAutoHide", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5$r = _applyDecoratedDescriptor(_class2$17.prototype, "_autoHideTime", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _class$1g = _class2$17)) || _class$1g) || _class$1g) || _class$1g) || _class$1g);

cc.ScrollBarComponent = ScrollBarComponent;

var _dec$1h, _dec2$U, _dec3$D, _dec4$z, _dec5$w, _dec6$u, _dec7$p, _dec8$n, _dec9$i, _dec10$d, _dec11$c, _dec12$b, _dec13$9, _dec14$8, _dec15$7, _class$1i, _class2$18, _descriptor$$, _descriptor2$P, _descriptor3$G, _descriptor4$y, _descriptor5$s, _descriptor6$h, _descriptor7$f, _descriptor8$d, _descriptor9$c, _descriptor10$b, _descriptor11$7, _class3$u, _temp$1b, ViewGroupComponent = ccclass("cc.ViewGroupComponent")(_class$1h = executionOrder(110)(_class$1h = function(_Component) {
    function ViewGroupComponent() {
        return _classCallCheck(this, ViewGroupComponent), _possibleConstructorReturn(this, _getPrototypeOf(ViewGroupComponent).apply(this, arguments));
    }
    return _inherits(ViewGroupComponent, Component), ViewGroupComponent;
}()) || _class$1h) || _class$1h;

cc.ViewGroupComponent = ViewGroupComponent;

var EventType$4, ZERO$1 = new Vec3, _tempVec3$1 = new Vec3, _tempVec3_1 = new Vec3, _tempVec2$1 = new Vec2, _tempVec2_1 = new Vec2, getTimeInMilliseconds = function getTimeInMilliseconds() {
    return (new Date).getMilliseconds();
}, eventMap = {
    "scroll-to-top": 0,
    "scroll-to-bottom": 1,
    "scroll-to-left": 2,
    "scroll-to-right": 3,
    scrolling: 4,
    "bounce-bottom": 6,
    "bounce-left": 7,
    "bounce-right": 8,
    "bounce-top": 5,
    "scroll-ended": 9,
    "touch-up": 10,
    "scroll-ended-with-threshold": 11,
    "scroll-began": 12
};

!function(EventType) {
    EventType.SCROLL_TO_TOP = "scroll-to-top", EventType.SCROLL_TO_BOTTOM = "scroll-to-bottom", 
    EventType.SCROLL_TO_LEFT = "scroll-to-left", EventType.SCROLL_TO_RIGHT = "scroll-to-right", 
    EventType.SCROLL_BEGAN = "scroll-began", EventType.SCROLL_ENDED = "scroll-ended", 
    EventType.BOUNCE_TOP = "bounce-top", EventType.BOUNCE_BOTTOM = "bounce-bottom", 
    EventType.BOUNCE_LEFT = "bounce-left", EventType.BOUNCE_RIGHT = "bounce-right", 
    EventType.SCROLLING = "scrolling", EventType.SCROLL_ENG_WITH_THRESHOLD = "scroll-ended-with-threshold", 
    EventType.TOUCH_UP = "touch-up";
}(EventType$4 || (EventType$4 = {}));

var _dec$1i, _dec2$V, _dec3$E, _dec4$A, _dec5$x, _dec6$v, _dec7$q, _dec8$o, _class$1j, _class2$19, _descriptor$10, _descriptor2$Q, _descriptor3$H, _descriptor4$z, _class3$v, _temp$1c, ScrollViewComponent = (_dec$1h = ccclass("cc.ScrollViewComponent"), 
_dec2$U = help("i18n:cc.ScrollViewComponent"), _dec3$D = executionOrder(110), _dec4$z = menu("UI/ScrollView"), 
_dec5$w = property({
    range: [ 0, 10 ],
    tooltip: "回弹持续的时间，0 表示将立即反弹",
    displayOrder: 0
}), _dec6$u = property({
    range: [ 0, 1, .1 ],
    tooltip: "开启惯性后，在用户停止触摸后滚动多快停止，0 表示永不停止，1 表示立刻停止",
    displayOrder: 1
}), _dec7$p = property({
    tooltip: "是否允许滚动内容超过边界，并在停止触摸后回弹",
    displayOrder: 2
}), _dec8$n = property({
    tooltip: "是否开启滚动惯性",
    displayOrder: 3
}), _dec9$i = property({
    type: Node$1,
    tooltip: "可滚动展示内容的节点",
    displayOrder: 4
}), _dec10$d = property({
    tooltip: "是否开启水平滚动",
    displayOrder: 5
}), _dec11$c = property({
    type: ScrollBarComponent,
    tooltip: "水平滚动的 ScrollBar",
    displayOrder: 6
}), _dec12$b = property({
    tooltip: "是否开启垂直滚动",
    displayOrder: 7
}), _dec13$9 = property({
    type: ScrollBarComponent,
    tooltip: "垂直滚动的 ScrollBar",
    displayOrder: 8
}), _dec14$8 = property({
    tooltip: "滚动行为是否会取消子节点上注册的触摸事件",
    displayOrder: 9
}), _dec15$7 = property({
    type: [ EventHandler ],
    tooltip: "滚动视图的事件回调函数",
    displayOrder: 10
}), _dec$1h(_class$1i = _dec2$U(_class$1i = _dec3$D(_class$1i = _dec4$z((_temp$1b = _class3$u = function(_ViewGroupComponent) {
    function ScrollViewComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ScrollViewComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ScrollViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "bounceDuration", _descriptor$$, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "brake", _descriptor2$P, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "elastic", _descriptor3$G, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "inertia", _descriptor4$y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "horizontal", _descriptor5$s, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "vertical", _descriptor6$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor7$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "scrollEvents", _descriptor8$d, _assertThisInitialized(_this)), 
        _this._autoScrolling = !1, _this._scrolling = !1, _initializerDefineProperty(_this, "_content", _descriptor9$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalScrollBar", _descriptor10$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_verticalScrollBar", _descriptor11$7, _assertThisInitialized(_this)), 
        _this._topBoundary = 0, _this._bottomBoundary = 0, _this._leftBoundary = 0, _this._rightBoundary = 0, 
        _this._touchMoveDisplacements = [], _this._touchMoveTimeDeltas = [], _this._touchMovePreviousTimestamp = 0, 
        _this._touchMoved = !1, _this._autoScrollAttenuate = !1, _this._autoScrollStartPosition = new Vec3, 
        _this._autoScrollTargetDelta = new Vec3, _this._autoScrollTotalTime = 0, _this._autoScrollAccumulatedTime = 0, 
        _this._autoScrollCurrentlyOutOfBoundary = !1, _this._autoScrollBraking = !1, _this._autoScrollBrakingStartPosition = new Vec3, 
        _this._outOfBoundaryAmount = new Vec3, _this._outOfBoundaryAmountDirty = !0, _this._stopMouseWheel = !1, 
        _this._mouseWheelEventElapsedTime = 0, _this._isScrollEndedWithThresholdEventFired = !1, 
        _this._scrollEventEmitMask = 0, _this._isBouncing = !1, _this._contentPos = new Vec3, 
        _this._deltaPos = new Vec3, _this;
    }
    return _inherits(ScrollViewComponent, ViewGroupComponent), _createClass(ScrollViewComponent, [ {
        key: "scrollToBottom",
        value: function scrollToBottom(timeInSecond) {
            var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 0),
                applyToHorizontal: !1,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta, !0);
        }
    }, {
        key: "scrollToTop",
        value: function scrollToTop(timeInSecond) {
            var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 1),
                applyToHorizontal: !1,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToLeft",
        value: function scrollToLeft(timeInSecond) {
            var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 0),
                applyToHorizontal: !0,
                applyToVertical: !1
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToRight",
        value: function scrollToRight(timeInSecond) {
            var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(1, 0),
                applyToHorizontal: !0,
                applyToVertical: !1
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToTopLeft",
        value: function scrollToTopLeft(timeInSecond) {
            var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 1),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToTopRight",
        value: function scrollToTopRight(timeInSecond) {
            var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(1, 1),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToBottomLeft",
        value: function scrollToBottomLeft(timeInSecond) {
            var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, 0),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToBottomRight",
        value: function scrollToBottomRight(timeInSecond) {
            var attenuated = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(1, 0),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToOffset",
        value: function scrollToOffset(offset, timeInSecond) {
            var attenuated = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], maxScrollOffset = this.getMaxScrollOffset(), anchor = new Vec2(0, 0);
            0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x, 
            0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y, 
            this.scrollTo(anchor, timeInSecond, attenuated);
        }
    }, {
        key: "getScrollOffset",
        value: function getScrollOffset() {
            var topDelta = this._getContentTopBoundary() - this._topBoundary, leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
            return new Vec3(leftDelta, topDelta, 0);
        }
    }, {
        key: "getMaxScrollOffset",
        value: function getMaxScrollOffset() {
            var scrollSize = this.node._uiProps.uiTransformComp.contentSize, contentSize = this._content._uiProps.uiTransformComp.contentSize, horizontalMaximizeOffset = contentSize.width - scrollSize.width, verticalMaximizeOffset = contentSize.height - scrollSize.height;
            return new Vec3(horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0, verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0, 0);
        }
    }, {
        key: "scrollToPercentHorizontal",
        value: function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(percent, 0),
                applyToHorizontal: !0,
                applyToVertical: !1
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, !1 !== attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollTo",
        value: function scrollTo(anchor, timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(anchor),
                applyToHorizontal: !0,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "scrollToPercentVertical",
        value: function scrollToPercentVertical(percent, timeInSecond, attenuated) {
            var moveDelta = this._calculateMovePercentDelta({
                anchor: new Vec2(0, percent),
                applyToHorizontal: !1,
                applyToVertical: !0
            });
            timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, attenuated) : this._moveContent(moveDelta);
        }
    }, {
        key: "stopAutoScroll",
        value: function stopAutoScroll() {
            this._autoScrolling = !1, this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
        }
    }, {
        key: "setContentPosition",
        value: function setContentPosition(position) {
            var contentPos = this.getContentPosition();
            Math.abs(position.x - contentPos.x) < 1e-4 && Math.abs(position.y - contentPos.y) < 1e-4 || (this._content.setPosition(position), 
            this._outOfBoundaryAmountDirty = !0);
        }
    }, {
        key: "getContentPosition",
        value: function getContentPosition() {
            return this._content ? (this._contentPos.set(this._content.position), this._contentPos) : ZERO$1;
        }
    }, {
        key: "isScrolling",
        value: function isScrolling() {
            return this._scrolling;
        }
    }, {
        key: "isAutoScrolling",
        value: function isAutoScrolling() {
            return this._autoScrolling;
        }
    }, {
        key: "getScrollEndedEventTiming",
        value: function getScrollEndedEventTiming() {
            return 1e-4;
        }
    }, {
        key: "start",
        value: function start() {
            this._calculateBoundary(), this._content && director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._registerEvent(), this.content && (this.content.on(Node$1.EventType.SIZE_CHANGED, this._calculateBoundary, this), 
            this.content.on(Node$1.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), this.view && (this.view.on(Node$1.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), 
            this.view.on(Node$1.EventType.SIZE_CHANGED, this._calculateBoundary, this))), this._calculateBoundary(), 
            this._showScrollBar();
        }
    }, {
        key: "update",
        value: function update(dt) {
            this._autoScrolling && this._processAutoScrolling(dt);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._unregisterEvent(), this.content && (this.content.off(Node$1.EventType.SIZE_CHANGED, this._calculateBoundary, this), 
            this.content.off(Node$1.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), 
            this.view && (this.view.off(Node$1.EventType.TRANSFORM_CHANGED, this._scaleChanged, this), 
            this.view.off(Node$1.EventType.SIZE_CHANGED, this._calculateBoundary, this))), this._hideScrollBar(), 
            this.stopAutoScroll();
        }
    }, {
        key: "_registerEvent",
        value: function _registerEvent() {
            this.node.on(Node$1.EventType.TOUCH_START, this._onTouchBegan, this, !0), this.node.on(Node$1.EventType.TOUCH_MOVE, this._onTouchMoved, this, !0), 
            this.node.on(Node$1.EventType.TOUCH_END, this._onTouchEnded, this, !0), this.node.on(Node$1.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
            this.node.on(Node$1.EventType.MOUSE_WHEEL, this._onMouseWheel, this, !0);
        }
    }, {
        key: "_unregisterEvent",
        value: function _unregisterEvent() {
            this.node.off(Node$1.EventType.TOUCH_START, this._onTouchBegan, this, !0), this.node.off(Node$1.EventType.TOUCH_MOVE, this._onTouchMoved, this, !0), 
            this.node.off(Node$1.EventType.TOUCH_END, this._onTouchEnded, this, !0), this.node.off(Node$1.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, !0), 
            this.node.off(Node$1.EventType.MOUSE_WHEEL, this._onMouseWheel, this, !0);
        }
    }, {
        key: "_onMouseWheel",
        value: function _onMouseWheel(event, captureListeners) {
            if (this.enabledInHierarchy && !this._hasNestedViewGroup(event, captureListeners)) {
                var deltaMove = new Vec3, scrollY = event.getScrollY();
                this.vertical ? deltaMove.set(0, -.1 * scrollY, 0) : this.horizontal && deltaMove.set(-.1 * scrollY, 0, 0), 
                this._mouseWheelEventElapsedTime = 0, this._processDeltaMove(deltaMove), this._stopMouseWheel || (this._handlePressLogic(), 
                this.schedule(this._checkMouseWheel, 1 / 60, NaN, 0), this._stopMouseWheel = !0), 
                this._stopPropagationIfTargetIsMe(event);
            }
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event, captureListeners) {
            this.enabledInHierarchy && this._content && (this._hasNestedViewGroup(event, captureListeners) || (this._content && this._handlePressLogic(), 
            this._touchMoved = !1, this._stopPropagationIfTargetIsMe(event)));
        }
    }, {
        key: "_onTouchMoved",
        value: function _onTouchMoved(event, captureListeners) {
            if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners)) {
                var touch = event.touch;
                if (this._content && this._handleMoveLogic(touch), this.cancelInnerEvents) {
                    var deltaMove = touch.getUILocation(_tempVec2$1);
                    if (deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1)), deltaMove.length() > 7 && !this._touchMoved && event.target !== this.node) {
                        var cancelEvent = new EventTouch(event.getTouches(), event.bubbles);
                        cancelEvent.type = Node$1.EventType.TOUCH_CANCEL, cancelEvent.touch = event.touch, 
                        cancelEvent.simulate = !0, event.target.dispatchEvent(cancelEvent), this._touchMoved = !0;
                    }
                    this._stopPropagationIfTargetIsMe(event);
                }
            }
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event, captureListeners) {
            if (this.enabledInHierarchy && this._content && event && !this._hasNestedViewGroup(event, captureListeners)) {
                this._dispatchEvent(EventType$4.TOUCH_UP);
                var touch = event.touch;
                this._content && this._handleReleaseLogic(touch), this._touchMoved ? event.propagationStopped = !0 : this._stopPropagationIfTargetIsMe(event);
            }
        }
    }, {
        key: "_onTouchCancelled",
        value: function _onTouchCancelled(event, captureListeners) {
            if (this.enabledInHierarchy && this._content && !this._hasNestedViewGroup(event, captureListeners)) {
                if (event && !event.simulate) {
                    var touch = event.touch;
                    this._content && this._handleReleaseLogic(touch);
                }
                this._stopPropagationIfTargetIsMe(event);
            }
        }
    }, {
        key: "_calculateBoundary",
        value: function _calculateBoundary() {
            if (this.content) {
                var layout = this.content.getComponent(LayoutComponent);
                layout && layout.enabledInHierarchy && layout.updateLayout();
                var viewSize = this.view._uiProps.uiTransformComp.contentSize, anchorX = viewSize.width * this.view.anchorX, anchorY = viewSize.height * this.view.anchorY;
                this._leftBoundary = -anchorX, this._bottomBoundary = -anchorY, this._rightBoundary = this._leftBoundary + viewSize.width, 
                this._topBoundary = this._bottomBoundary + viewSize.height, this._moveContentToTopLeft(viewSize);
            }
        }
    }, {
        key: "_hasNestedViewGroup",
        value: function _hasNestedViewGroup(event, captureListeners) {
            if (event && event.eventPhase === Event.CAPTURING_PHASE) {
                if (captureListeners) for (var _step, _iterator = _createForOfIteratorHelperLoose(captureListeners); !(_step = _iterator()).done; ) {
                    var item = _step.value;
                    if (this.node === item) return !(!event.target || !event.target.getComponent(ViewGroupComponent));
                    if (item.getComponent(ViewGroupComponent)) return !0;
                }
                return !1;
            }
        }
    }, {
        key: "_startInertiaScroll",
        value: function _startInertiaScroll(touchMoveVelocity) {
            var inertiaTotalMovement = new Vec3(touchMoveVelocity);
            inertiaTotalMovement.multiplyScalar(.7), this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
        }
    }, {
        key: "_calculateAttenuatedFactor",
        value: function _calculateAttenuatedFactor(distance) {
            return this.brake <= 0 ? 1 - this.brake : (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
        }
    }, {
        key: "_startAttenuatingAutoScroll",
        value: function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
            var time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length()), targetDelta = new Vec3(deltaMove);
            targetDelta.normalize();
            var contentSize = this._content._uiProps.uiTransformComp.contentSize, scrollViewSize = this.node._uiProps.uiTransformComp.contentSize, totalMoveWidth = contentSize.width - scrollViewSize.width, totalMoveHeight = contentSize.height - scrollViewSize.height, attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth), attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
            targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, 
            targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake), 
            targetDelta.z = 0;
            var originalMoveLength = deltaMove.length(), factor = targetDelta.length() / originalMoveLength;
            if (targetDelta.add(deltaMove), this.brake > 0 && factor > 7) {
                factor = Math.sqrt(factor);
                var a = new Vec3(deltaMove);
                a.multiplyScalar(factor), targetDelta.set(a), targetDelta.add(deltaMove);
            }
            this.brake > 0 && factor > 3 && (time *= factor = 3), 0 === this.brake && factor > 1 && (time *= factor), 
            this._startAutoScroll(targetDelta, time, !0);
        }
    }, {
        key: "_calculateAutoScrollTimeByInitialSpeed",
        value: function _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
            return Math.sqrt(Math.sqrt(initialSpeed / 5));
        }
    }, {
        key: "_startAutoScroll",
        value: function _startAutoScroll(deltaMove, timeInSecond) {
            var attenuated = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
            this._autoScrolling = !0, this._autoScrollTargetDelta = adjustedDeltaMove, this._autoScrollAttenuate = attenuated, 
            Vec3.copy(this._autoScrollStartPosition, this.getContentPosition()), this._autoScrollTotalTime = timeInSecond, 
            this._autoScrollAccumulatedTime = 0, this._autoScrollBraking = !1, this._isScrollEndedWithThresholdEventFired = !1, 
            this._autoScrollBrakingStartPosition = new Vec3;
            var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
            currentOutOfBoundary.equals(ZERO$1, 1e-4) || (this._autoScrollCurrentlyOutOfBoundary = !0);
        }
    }, {
        key: "_calculateTouchMoveVelocity",
        value: function _calculateTouchMoveVelocity() {
            var totalTime = 0;
            if ((totalTime = this._touchMoveTimeDeltas.reduce((function(a, b) {
                return a + b;
            }), totalTime)) <= 0 || totalTime >= .5) return new Vec3;
            var totalMovement = new Vec3;
            return totalMovement = this._touchMoveDisplacements.reduce((function(a, b) {
                return a.add(b), a;
            }), totalMovement), new Vec3(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, 0);
        }
    }, {
        key: "_flattenVectorByDirection",
        value: function _flattenVectorByDirection(vector) {
            var result = vector;
            return result.x = this.horizontal ? result.x : 0, result.y = this.vertical ? result.y : 0, 
            result;
        }
    }, {
        key: "_moveContent",
        value: function _moveContent(deltaMove, canStartBounceBack) {
            var adjustedMove = this._flattenVectorByDirection(deltaMove);
            _tempVec3$1.set(this.getContentPosition()), _tempVec3$1.add(adjustedMove), _tempVec3$1.set(1e-4 * Math.floor(1e4 * _tempVec3$1.x), 1e-4 * Math.floor(1e4 * _tempVec3$1.y), _tempVec3$1.z), 
            this.setContentPosition(_tempVec3$1);
            var outOfBoundary = this._getHowMuchOutOfBoundary();
            this._updateScrollBar(outOfBoundary), this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
        }
    }, {
        key: "_getContentLeftBoundary",
        value: function _getContentLeftBoundary() {
            return this.getContentPosition().x - this._content.anchorX * this._content.width;
        }
    }, {
        key: "_getContentRightBoundary",
        value: function _getContentRightBoundary() {
            return this._getContentLeftBoundary() + this._content.width;
        }
    }, {
        key: "_getContentTopBoundary",
        value: function _getContentTopBoundary() {
            return this._getContentBottomBoundary() + this._content.height;
        }
    }, {
        key: "_getContentBottomBoundary",
        value: function _getContentBottomBoundary() {
            return this.getContentPosition().y - this._content.anchorY * this._content.height;
        }
    }, {
        key: "_getHowMuchOutOfBoundary",
        value: function _getHowMuchOutOfBoundary(addition) {
            if ((addition = addition || new Vec3).equals(ZERO$1, 1e-4) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
            var outOfBoundaryAmount = new Vec3;
            return this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x)), 
            this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y)), 
            addition.equals(ZERO$1, 1e-4) && (this._outOfBoundaryAmount = outOfBoundaryAmount, 
            this._outOfBoundaryAmountDirty = !1), outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
        }
    }, {
        key: "_updateScrollBar",
        value: function _updateScrollBar(outOfBoundary) {
            this._horizontalScrollBar && this._horizontalScrollBar.onScroll(outOfBoundary), 
            this.verticalScrollBar && this.verticalScrollBar.onScroll(outOfBoundary);
        }
    }, {
        key: "_onScrollBarTouchBegan",
        value: function _onScrollBarTouchBegan() {
            this._horizontalScrollBar && this._horizontalScrollBar.onTouchBegan(), this.verticalScrollBar && this.verticalScrollBar.onTouchBegan();
        }
    }, {
        key: "_onScrollBarTouchEnded",
        value: function _onScrollBarTouchEnded() {
            this._horizontalScrollBar && this._horizontalScrollBar.onTouchEnded(), this.verticalScrollBar && this.verticalScrollBar.onTouchEnded();
        }
    }, {
        key: "_dispatchEvent",
        value: function _dispatchEvent(event) {
            if (event === EventType$4.SCROLL_ENDED) this._scrollEventEmitMask = 0; else if (event === EventType$4.SCROLL_TO_TOP || event === EventType$4.SCROLL_TO_BOTTOM || event === EventType$4.SCROLL_TO_LEFT || event === EventType$4.SCROLL_TO_RIGHT) {
                var flag = 1 << eventMap[event];
                if (this._scrollEventEmitMask & flag) return;
                this._scrollEventEmitMask |= flag;
            }
            EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]), this.node.emit(event, this);
        }
    }, {
        key: "_adjustContentOutOfBoundary",
        value: function _adjustContentOutOfBoundary() {
            if (this._content && (this._outOfBoundaryAmountDirty = !0, this._isOutOfBoundary())) {
                var outOfBoundary = this._getHowMuchOutOfBoundary();
                _tempVec3$1.set(this.getContentPosition()), _tempVec3$1.add(outOfBoundary), this._content && (this._content.setPosition(_tempVec3$1), 
                this._updateScrollBar(ZERO$1));
            }
        }
    }, {
        key: "_hideScrollBar",
        value: function _hideScrollBar() {
            this._horizontalScrollBar && this._horizontalScrollBar.hide(), this._verticalScrollBar && this._verticalScrollBar.hide();
        }
    }, {
        key: "_showScrollBar",
        value: function _showScrollBar() {
            this._horizontalScrollBar && this._horizontalScrollBar.show(), this._verticalScrollBar && this._verticalScrollBar.show();
        }
    }, {
        key: "_stopPropagationIfTargetIsMe",
        value: function _stopPropagationIfTargetIsMe(event) {
            event.eventPhase === Event.AT_TARGET && event.target === this.node && (event.propagationStopped = !0);
        }
    }, {
        key: "_processDeltaMove",
        value: function _processDeltaMove(deltaMove) {
            this._scrollChildren(deltaMove), this._gatherTouchMove(deltaMove);
        }
    }, {
        key: "_handleMoveLogic",
        value: function _handleMoveLogic(touch) {
            this._deltaPos.set(this._getLocalAxisAlignDelta(touch)), this._processDeltaMove(this._deltaPos);
        }
    }, {
        key: "_handleReleaseLogic",
        value: function _handleReleaseLogic(touch) {
            this._deltaPos.set(this._getLocalAxisAlignDelta(touch)), this._gatherTouchMove(this._deltaPos), 
            this._processInertiaScroll(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent(EventType$4.SCROLL_ENDED));
        }
    }, {
        key: "_getLocalAxisAlignDelta",
        value: function _getLocalAxisAlignDelta(touch) {
            var uiTransformComp = this.node._uiProps.uiTransformComp, vec = new Vec3;
            return uiTransformComp && (touch.getUILocation(_tempVec2$1), touch.getUIPreviousLocation(_tempVec2_1), 
            _tempVec3$1.set(_tempVec2$1.x, _tempVec2$1.y, 0), _tempVec3_1.set(_tempVec2_1.x, _tempVec2_1.y, 0), 
            uiTransformComp.convertToNodeSpaceAR(_tempVec3$1, _tempVec3$1), uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1), 
            Vec3.subtract(vec, _tempVec3$1, _tempVec3_1)), vec;
        }
    }, {
        key: "_scrollChildren",
        value: function _scrollChildren(deltaMove) {
            var outOfBoundary, scrollEventType, realMove = deltaMove = this._clampDelta(deltaMove);
            this.elastic && (outOfBoundary = this._getHowMuchOutOfBoundary(), realMove.x *= 0 === outOfBoundary.x ? 1 : .5, 
            realMove.y *= 0 === outOfBoundary.y ? 1 : .5), this.elastic || (outOfBoundary = this._getHowMuchOutOfBoundary(realMove), 
            realMove.add(outOfBoundary));
            var pos = this._content.position;
            if (realMove.y > 0) pos.y - this._content.anchorY * this._content.height + realMove.y >= this._bottomBoundary && (scrollEventType = EventType$4.SCROLL_TO_BOTTOM); else if (realMove.y < 0) {
                pos.y - this._content.anchorY * this._content.height + this._content.height + realMove.y <= this._topBoundary && (scrollEventType = EventType$4.SCROLL_TO_TOP);
            } else if (realMove.x < 0) {
                pos.x - this._content.anchorX * this._content.width + this._content.width + realMove.x <= this._rightBoundary && (scrollEventType = EventType$4.SCROLL_TO_RIGHT);
            } else if (realMove.x > 0) {
                pos.x - this._content.anchorX * this._content.width + realMove.x >= this._leftBoundary && (scrollEventType = EventType$4.SCROLL_TO_LEFT);
            }
            this._moveContent(realMove, !1), 0 === realMove.x && 0 === realMove.y || (this._scrolling || (this._scrolling = !0, 
            this._dispatchEvent(EventType$4.SCROLL_BEGAN)), this._dispatchEvent(EventType$4.SCROLLING)), 
            scrollEventType && scrollEventType.length > 0 && this._dispatchEvent(scrollEventType);
        }
    }, {
        key: "_handlePressLogic",
        value: function _handlePressLogic() {
            this._autoScrolling && this._dispatchEvent(EventType$4.SCROLL_ENDED), this._autoScrolling = !1, 
            this._isBouncing = !1, this._touchMovePreviousTimestamp = getTimeInMilliseconds(), 
            this._touchMoveDisplacements.length = 0, this._touchMoveTimeDeltas.length = 0, this._onScrollBarTouchBegan();
        }
    }, {
        key: "_clampDelta",
        value: function _clampDelta(delta) {
            var contentSize = this._content._uiProps.uiTransformComp.contentSize, scrollViewSize = this.node._uiProps.uiTransformComp.contentSize;
            return contentSize.width < scrollViewSize.width && (delta.x = 0), contentSize.height < scrollViewSize.height && (delta.y = 0), 
            delta;
        }
    }, {
        key: "_gatherTouchMove",
        value: function _gatherTouchMove(delta) {
            var clampDt = delta.clone();
            for (this._clampDelta(clampDt); this._touchMoveDisplacements.length >= 5; ) this._touchMoveDisplacements.shift(), 
            this._touchMoveTimeDeltas.shift();
            this._touchMoveDisplacements.push(clampDt);
            var timeStamp = getTimeInMilliseconds();
            this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3), 
            this._touchMovePreviousTimestamp = timeStamp;
        }
    }, {
        key: "_startBounceBackIfNeeded",
        value: function _startBounceBackIfNeeded() {
            if (!this.elastic) return !1;
            var bounceBackAmount = this._getHowMuchOutOfBoundary();
            if ((bounceBackAmount = this._clampDelta(bounceBackAmount)).equals(ZERO$1, 1e-4)) return !1;
            var bounceBackTime = Math.max(this.bounceDuration, 0);
            return this._startAutoScroll(bounceBackAmount, bounceBackTime, !0), this._isBouncing || (bounceBackAmount.y > 0 && this._dispatchEvent(EventType$4.BOUNCE_TOP), 
            bounceBackAmount.y < 0 && this._dispatchEvent(EventType$4.BOUNCE_BOTTOM), bounceBackAmount.x > 0 && this._dispatchEvent(EventType$4.BOUNCE_RIGHT), 
            bounceBackAmount.x < 0 && this._dispatchEvent(EventType$4.BOUNCE_LEFT), this._isBouncing = !0), 
            !0;
        }
    }, {
        key: "_processInertiaScroll",
        value: function _processInertiaScroll() {
            if (!this._startBounceBackIfNeeded() && this.inertia) {
                var touchMoveVelocity = this._calculateTouchMoveVelocity();
                !touchMoveVelocity.equals(_tempVec3$1, 1e-4) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
            }
            this._onScrollBarTouchEnded();
        }
    }, {
        key: "_isOutOfBoundary",
        value: function _isOutOfBoundary() {
            return !this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4);
        }
    }, {
        key: "_isNecessaryAutoScrollBrake",
        value: function _isNecessaryAutoScrollBrake() {
            if (this._autoScrollBraking) return !0;
            if (this._isOutOfBoundary()) {
                if (!this._autoScrollCurrentlyOutOfBoundary) return this._autoScrollCurrentlyOutOfBoundary = !0, 
                this._autoScrollBraking = !0, this._autoScrollBrakingStartPosition = this.getContentPosition(), 
                !0;
            } else this._autoScrollCurrentlyOutOfBoundary = !1;
            return !1;
        }
    }, {
        key: "_processAutoScrolling",
        value: function _processAutoScrolling(dt) {
            var isAutoScrollBrake = this._isNecessaryAutoScrollBrake(), brakingFactor = isAutoScrollBrake ? .05 : 1;
            this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
            var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
            this._autoScrollAttenuate && (percentage = function quintEaseOut(time) {
                return (time -= 1) * time * time * time * time + 1;
            }(percentage));
            var a = new Vec3(this._autoScrollTargetDelta);
            a.multiplyScalar(percentage);
            var newPosition = new Vec3(this._autoScrollStartPosition);
            newPosition.add(a);
            var reachedEnd = Math.abs(percentage - 1) <= 1e-4;
            if (Math.abs(percentage - 1) <= this.getScrollEndedEventTiming() && !this._isScrollEndedWithThresholdEventFired && (this._dispatchEvent(EventType$4.SCROLL_ENG_WITH_THRESHOLD), 
            this._isScrollEndedWithThresholdEventFired = !0), this.elastic) {
                var brakeOffsetPosition = new Vec3(newPosition);
                brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition), isAutoScrollBrake && brakeOffsetPosition.multiplyScalar(brakingFactor), 
                newPosition.set(this._autoScrollBrakingStartPosition), newPosition.add(brakeOffsetPosition);
            } else {
                var moveDelta = new Vec3(newPosition);
                moveDelta.subtract(this.getContentPosition());
                var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
                outOfBoundary.equals(ZERO$1, 1e-4) || (newPosition.add(outOfBoundary), reachedEnd = !0);
            }
            reachedEnd && (this._autoScrolling = !1);
            var deltaMove = new Vec3(newPosition);
            deltaMove.subtract(this.getContentPosition()), this._moveContent(this._clampDelta(deltaMove), reachedEnd), 
            this._dispatchEvent(EventType$4.SCROLLING), this._autoScrolling || (this._isBouncing = !1, 
            this._scrolling = !1, this._dispatchEvent(EventType$4.SCROLL_ENDED));
        }
    }, {
        key: "_checkMouseWheel",
        value: function _checkMouseWheel(dt) {
            if (!this._getHowMuchOutOfBoundary().equals(ZERO$1, 1e-4)) return this._processInertiaScroll(), 
            this.unschedule(this._checkMouseWheel), void (this._stopMouseWheel = !1);
            this._mouseWheelEventElapsedTime += dt, this._mouseWheelEventElapsedTime > .1 && (this._onScrollBarTouchEnded(), 
            this.unschedule(this._checkMouseWheel), this._stopMouseWheel = !1);
        }
    }, {
        key: "_calculateMovePercentDelta",
        value: function _calculateMovePercentDelta(options) {
            var anchor = options.anchor, applyToHorizontal = options.applyToHorizontal, applyToVertical = options.applyToVertical;
            this._calculateBoundary(), anchor.clampf(new Vec2(0, 0), new Vec2(1, 1));
            var scrollSize = this.node._uiProps.uiTransformComp.contentSize, contentSize = this._content._uiProps.uiTransformComp.contentSize, bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
            bottomDelta = -bottomDelta;
            var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
            leftDelta = -leftDelta;
            var moveDelta = new Vec3, totalScrollDelta = 0;
            return applyToHorizontal && (totalScrollDelta = contentSize.width - scrollSize.width, 
            moveDelta.x = leftDelta - totalScrollDelta * anchor.x), applyToVertical && (totalScrollDelta = contentSize.height - scrollSize.height, 
            moveDelta.y = bottomDelta - totalScrollDelta * anchor.y), moveDelta;
        }
    }, {
        key: "_moveContentToTopLeft",
        value: function _moveContentToTopLeft(scrollViewSize) {
            var contentSize = this._content._uiProps.uiTransformComp.contentSize, bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;
            bottomDelta = -bottomDelta;
            var moveDelta = new Vec3, totalScrollDelta = 0, leftDelta = this._getContentLeftBoundary() - this._leftBoundary;
            leftDelta = -leftDelta, contentSize.height < scrollViewSize.height ? (totalScrollDelta = contentSize.height - scrollViewSize.height, 
            moveDelta.y = bottomDelta - totalScrollDelta, this.verticalScrollBar && this.verticalScrollBar.hide()) : this.verticalScrollBar && this.verticalScrollBar.show(), 
            contentSize.width < scrollViewSize.width ? (totalScrollDelta = contentSize.width - scrollViewSize.width, 
            moveDelta.x = leftDelta, this._horizontalScrollBar && this._horizontalScrollBar.hide()) : this._horizontalScrollBar && this._horizontalScrollBar.show(), 
            this._moveContent(moveDelta), this._adjustContentOutOfBoundary();
        }
    }, {
        key: "_scaleChanged",
        value: function _scaleChanged(value) {
            value === TransformBit.SCALE && this._calculateBoundary();
        }
    }, {
        key: "content",
        get: function get() {
            return this._content;
        },
        set: function set(value) {
            this._content !== value && (this._content = value, this._calculateBoundary());
        }
    }, {
        key: "horizontalScrollBar",
        get: function get() {
            return this._horizontalScrollBar;
        },
        set: function set(value) {
            this._horizontalScrollBar !== value && (this._horizontalScrollBar = value, this._horizontalScrollBar && (this._horizontalScrollBar.setScrollView(this), 
            this._updateScrollBar(ZERO$1)));
        }
    }, {
        key: "verticalScrollBar",
        get: function get() {
            return this._verticalScrollBar;
        },
        set: function set(value) {
            this._verticalScrollBar !== value && (this._verticalScrollBar = value, this._verticalScrollBar && (this._verticalScrollBar.setScrollView(this), 
            this._updateScrollBar(ZERO$1)));
        }
    }, {
        key: "view",
        get: function get() {
            return this._content ? this._content.parent : null;
        }
    } ]), ScrollViewComponent;
}(), _class3$u.EventType = EventType$4, _descriptor$$ = _applyDecoratedDescriptor((_class2$18 = _temp$1b).prototype, "bounceDuration", [ _dec5$w ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor2$P = _applyDecoratedDescriptor(_class2$18.prototype, "brake", [ _dec6$u ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .5;
    }
}), _descriptor3$G = _applyDecoratedDescriptor(_class2$18.prototype, "elastic", [ _dec7$p ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$y = _applyDecoratedDescriptor(_class2$18.prototype, "inertia", [ _dec8$n ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _applyDecoratedDescriptor(_class2$18.prototype, "content", [ _dec9$i ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "content"), _class2$18.prototype), 
_descriptor5$s = _applyDecoratedDescriptor(_class2$18.prototype, "horizontal", [ _dec10$d ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _applyDecoratedDescriptor(_class2$18.prototype, "horizontalScrollBar", [ _dec11$c ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "horizontalScrollBar"), _class2$18.prototype), 
_descriptor6$h = _applyDecoratedDescriptor(_class2$18.prototype, "vertical", [ _dec12$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _applyDecoratedDescriptor(_class2$18.prototype, "verticalScrollBar", [ _dec13$9 ], Object.getOwnPropertyDescriptor(_class2$18.prototype, "verticalScrollBar"), _class2$18.prototype), 
_descriptor7$f = _applyDecoratedDescriptor(_class2$18.prototype, "cancelInnerEvents", [ _dec14$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor8$d = _applyDecoratedDescriptor(_class2$18.prototype, "scrollEvents", [ _dec15$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor9$c = _applyDecoratedDescriptor(_class2$18.prototype, "_content", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor10$b = _applyDecoratedDescriptor(_class2$18.prototype, "_horizontalScrollBar", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor11$7 = _applyDecoratedDescriptor(_class2$18.prototype, "_verticalScrollBar", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$1i = _class2$18)) || _class$1i) || _class$1i) || _class$1i) || _class$1i);

cc.ScrollViewComponent = ScrollViewComponent;

var Direction$1, _tempPos$1 = new Vec3;

!function(Direction) {
    Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
}(Direction$1 || (Direction$1 = {})), ccenum(Direction$1);

var _dec$1j, _dec2$W, _dec3$F, _dec4$B, _dec5$y, _dec6$w, _class$1k, _class2$1a, _descriptor$11, _descriptor2$R, SliderComponent = (_dec$1i = ccclass("cc.SliderComponent"), 
_dec2$V = help("i18n:cc.SliderComponent"), _dec3$E = executionOrder(110), _dec4$A = menu("UI/Slider"), 
_dec5$x = property({
    type: SpriteComponent,
    tooltip: "滑块按钮部件"
}), _dec6$v = property({
    type: Direction$1,
    tooltip: "滑动方向"
}), _dec7$q = property({
    slide: !0,
    range: [ 0, 1, .01 ],
    tooltip: "当前进度值，该数值的区间是 0 - 1 之间。"
}), _dec8$o = property({
    type: EventHandler,
    tooltip: "滑动器组件事件回调函数"
}), _dec$1i(_class$1j = _dec2$V(_class$1j = _dec3$E(_class$1j = _dec4$A((_temp$1c = _class3$v = function(_Component) {
    function SliderComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SliderComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SliderComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "slideEvents", _descriptor$10, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_handle", _descriptor2$Q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor3$H, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_progress", _descriptor4$z, _assertThisInitialized(_this)), 
        _this._offset = new Vec3, _this._dragging = !1, _this._touchHandle = !1, _this._handlelocalPos = new Vec3, 
        _this._touchPos = new Vec3, _this;
    }
    return _inherits(SliderComponent, Component), _createClass(SliderComponent, [ {
        key: "__preload",
        value: function __preload() {
            this._updateHandlePosition();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._updateHandlePosition(), this.node.on(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), 
            this.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), this.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), 
            this.node.on(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), 
            this._handle && this._handle.isValid && (this._handle.node.on(exports.SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
            this._handle.node.on(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
            this._handle.node.on(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this));
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.node.off(exports.SystemEventType.TOUCH_START, this._onTouchBegan, this), this.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
            this.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this), this.node.off(exports.SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this), 
            this._handle && this._handle.isValid && (this._handle.node.off(exports.SystemEventType.TOUCH_START, this._onHandleDragStart, this), 
            this._handle.node.off(exports.SystemEventType.TOUCH_MOVE, this._onTouchMoved, this), 
            this._handle.node.off(exports.SystemEventType.TOUCH_END, this._onTouchEnded, this));
        }
    }, {
        key: "_onHandleDragStart",
        value: function _onHandleDragStart(event) {
            if (event && this._handle && this._handle.node._uiProps.uiTransformComp) {
                this._dragging = !0, this._touchHandle = !0;
                var touhPos = event.touch.getUILocation();
                Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0), this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset), 
                event.propagationStopped = !0;
            }
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event) {
            this._handle && event && (this._dragging = !0, this._touchHandle || this._handleSliderLogic(event.touch), 
            event.propagationStopped = !0);
        }
    }, {
        key: "_onTouchMoved",
        value: function _onTouchMoved(event) {
            this._dragging && event && (this._handleSliderLogic(event.touch), event.propagationStopped = !0);
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event) {
            this._dragging = !1, this._touchHandle = !1, this._offset = new Vec3, event && (event.propagationStopped = !0);
        }
    }, {
        key: "_onTouchCancelled",
        value: function _onTouchCancelled(event) {
            this._dragging = !1, event && (event.propagationStopped = !0);
        }
    }, {
        key: "_handleSliderLogic",
        value: function _handleSliderLogic(touch) {
            this._updateProgress(touch), this._emitSlideEvent();
        }
    }, {
        key: "_emitSlideEvent",
        value: function _emitSlideEvent() {
            EventHandler.emitEvents(this.slideEvents, this), this.node.emit("slide", this);
        }
    }, {
        key: "_updateProgress",
        value: function _updateProgress(touch) {
            if (this._handle && touch) {
                var touchPos = touch.getUILocation();
                Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
                var localTouchPos = this.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, _tempPos$1);
                this.direction === Direction$1.Horizontal ? this.progress = clamp01(.5 + (localTouchPos.x - this._offset.x) / this.node.width) : this.progress = clamp01(.5 + (localTouchPos.y - this._offset.y) / this.node.height);
            }
        }
    }, {
        key: "_updateHandlePosition",
        value: function _updateHandlePosition() {
            this._handle && (this._handlelocalPos.set(this._handle.node.getPosition()), this._direction === Direction$1.Horizontal ? this._handlelocalPos.x = -this.node.width * this.node.anchorX + this.progress * this.node.width : this._handlelocalPos.y = -this.node.height * this.node.anchorY + this.progress * this.node.height, 
            this._handle.node.setPosition(this._handlelocalPos));
        }
    }, {
        key: "_changeLayout",
        value: function _changeLayout() {
            var contentSize = this.node.getContentSize();
            if (this.node.setContentSize(contentSize.height, contentSize.width), this._handle) {
                var pos = this._handle.node.position;
                this._direction === Direction$1.Horizontal ? this._handle.node.setPosition(pos.x, 0, pos.z) : this._handle.node.setPosition(0, pos.y, pos.z), 
                this._updateHandlePosition();
            }
        }
    }, {
        key: "handle",
        get: function get() {
            return this._handle;
        },
        set: function set(value) {
            this._handle !== value && (this._handle = value);
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction !== value && (this._direction = value, this._changeLayout());
        }
    }, {
        key: "progress",
        get: function get() {
            return this._progress;
        },
        set: function set(value) {
            this._progress !== value && (this._progress = value, this._updateHandlePosition());
        }
    } ]), SliderComponent;
}(), _class3$v.Direction = Direction$1, _applyDecoratedDescriptor((_class2$19 = _temp$1c).prototype, "handle", [ _dec5$x ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "handle"), _class2$19.prototype), 
_applyDecoratedDescriptor(_class2$19.prototype, "direction", [ _dec6$v ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "direction"), _class2$19.prototype), 
_applyDecoratedDescriptor(_class2$19.prototype, "progress", [ _dec7$q ], Object.getOwnPropertyDescriptor(_class2$19.prototype, "progress"), _class2$19.prototype), 
_descriptor$10 = _applyDecoratedDescriptor(_class2$19.prototype, "slideEvents", [ _dec8$o ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$Q = _applyDecoratedDescriptor(_class2$19.prototype, "_handle", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$H = _applyDecoratedDescriptor(_class2$19.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Direction$1.Horizontal;
    }
}), _descriptor4$z = _applyDecoratedDescriptor(_class2$19.prototype, "_progress", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _class$1j = _class2$19)) || _class$1j) || _class$1j) || _class$1j) || _class$1j);

cc.SliderComponent = SliderComponent;

var _dec$1k, _dec2$X, _dec3$G, _dec4$C, _dec5$z, _dec6$x, _dec7$r, _dec8$p, _dec9$j, _class$1l, _class2$1b, _descriptor$12, _descriptor2$S, _descriptor3$I, _descriptor4$A, _class3$w, _temp$1e, EventType$5, ToggleContainerComponent = (_dec$1j = ccclass("cc.ToggleContainerComponent"), 
_dec2$W = help("i18n:cc.ToggleContainerComponent"), _dec3$F = executionOrder(110), 
_dec4$B = menu("UI/ToggleContainer"), _dec5$y = property({
    type: [ EventHandler ],
    tooltip: "选中事件。列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。"
}), _dec6$w = property({
    tooltip: "如果这个设置为 true， 那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。"
}), _dec$1j(_class$1k = _dec2$W(_class$1k = _dec3$F(_class$1k = _dec4$B(_class$1k = executeInEditMode((_descriptor$11 = _applyDecoratedDescriptor((_class2$1a = function(_Component) {
    function ToggleContainerComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ToggleContainerComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleContainerComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$11, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_allowSwitchOff", _descriptor2$R, _assertThisInitialized(_this)), 
        _this._toggleItems = [], _this;
    }
    return _inherits(ToggleContainerComponent, Component), _createClass(ToggleContainerComponent, [ {
        key: "start",
        value: function start() {
            this._makeAtLeastOneToggleChecked();
        }
    }, {
        key: "updateToggles",
        value: function updateToggles(toggle) {
            this.enabledInHierarchy && toggle.isChecked && (this.toggleItems.forEach((function(item) {
                item !== toggle && item.isChecked && item.enabled && (item.isChecked = !1);
            })), this.checkEvents && EventHandler.emitEvents(this.checkEvents, toggle));
        }
    }, {
        key: "addToggle",
        value: function addToggle(toggle) {
            -1 === this._toggleItems.indexOf(toggle) && this._toggleItems.push(toggle), this._allowOnlyOneToggleChecked();
        }
    }, {
        key: "removeToggle",
        value: function removeToggle(toggle) {
            var index = this._toggleItems.indexOf(toggle);
            index > -1 && this._toggleItems.splice(index, 1), this._makeAtLeastOneToggleChecked();
        }
    }, {
        key: "_allowOnlyOneToggleChecked",
        value: function _allowOnlyOneToggleChecked() {
            var isChecked = !1;
            return this._toggleItems.forEach((function(item) {
                isChecked && item.enabled && (item.isChecked = !1), item.isChecked && item.enabled && (isChecked = !0);
            })), isChecked;
        }
    }, {
        key: "_makeAtLeastOneToggleChecked",
        value: function _makeAtLeastOneToggleChecked() {
            this._allowOnlyOneToggleChecked() || this._allowSwitchOff || this._toggleItems.length > 0 && (this._toggleItems[0].isChecked = !0);
        }
    }, {
        key: "allowSwitchOff",
        get: function get() {
            return this._allowSwitchOff;
        },
        set: function set(value) {
            this._allowSwitchOff = value;
        }
    }, {
        key: "toggleItems",
        get: function get() {
            return this._toggleItems;
        }
    } ]), ToggleContainerComponent;
}()).prototype, "checkEvents", [ _dec5$y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$R = _applyDecoratedDescriptor(_class2$1a.prototype, "_allowSwitchOff", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1a.prototype, "allowSwitchOff", [ _dec6$w ], Object.getOwnPropertyDescriptor(_class2$1a.prototype, "allowSwitchOff"), _class2$1a.prototype), 
_class$1k = _class2$1a)) || _class$1k) || _class$1k) || _class$1k) || _class$1k) || _class$1k);

function extendsEnum() {
    for (var _len = arguments.length, enums = new Array(_len), _key = 0; _key < _len; _key++) enums[_key] = arguments[_key];
    return Object.assign.apply(Object, [ {} ].concat(enums));
}

cc.ToggleContainerComponent = ToggleContainerComponent, (EventType$5 || (EventType$5 = {})).TOGGLE = "toggle";

var _class$1m, ToggleComponent = (_dec$1k = ccclass("cc.ToggleComponent"), _dec2$X = help("i18n:cc.ToggleComponent"), 
_dec3$G = executionOrder(110), _dec4$C = menu("UI/Toggle"), _dec5$z = requireComponent(UITransformComponent), 
_dec6$x = property({
    tooltip: "如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。",
    displayOrder: 2
}), _dec7$r = property({
    type: SpriteComponent,
    tooltip: "Toggle 处于选中状态时显示的精灵图片",
    displayOrder: 3
}), _dec8$p = property({
    type: ToggleContainerComponent,
    tooltip: "Toggle 所属的 ToggleGroup，这个属性是可选的。如果这个属性为 null，则 Toggle 是一个 CheckBox，否则，Toggle 是一个 RadioButton。",
    displayOrder: 4
}), _dec9$j = property({
    type: [ EventHandler ],
    tooltip: "列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成"
}), _dec$1k(_class$1l = _dec2$X(_class$1l = _dec3$G(_class$1l = _dec4$C(_class$1l = _dec5$z((_temp$1e = _class3$w = function(_ButtonComponent) {
    function ToggleComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ToggleComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ToggleComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "checkEvents", _descriptor$12, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isChecked", _descriptor2$S, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_toggleGroup", _descriptor3$I, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_checkMark", _descriptor4$A, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(ToggleComponent, ButtonComponent), _createClass(ToggleComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(ToggleComponent.prototype), "onEnable", this).call(this), this._registerToggleEvent(), 
            this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(ToggleComponent.prototype), "onDisable", this).call(this), 
            this._unregisterToggleEvent(), this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.removeToggle(this);
        }
    }, {
        key: "toggle",
        value: function toggle() {
            var group = this.toggleGroup || this._toggleContainer;
            group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !this.isChecked, 
            group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
        }
    }, {
        key: "check",
        value: function check() {
            var group = this.toggleGroup || this._toggleContainer;
            group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !0, 
            group && group.enabled && group.updateToggles(this), this._emitToggleEvents());
        }
    }, {
        key: "uncheck",
        value: function uncheck() {
            var group = this.toggleGroup || this._toggleContainer;
            group && group.enabled && this.isChecked && !group.allowSwitchOff || (this.isChecked = !1, 
            this._emitToggleEvents());
        }
    }, {
        key: "_updateCheckMark",
        value: function _updateCheckMark() {
            this._checkMark && (this._checkMark.node.active = !!this.isChecked);
        }
    }, {
        key: "_registerToggleEvent",
        value: function _registerToggleEvent() {
            this.node.on(ToggleComponent.EventType.CLICK, this.toggle, this);
        }
    }, {
        key: "_unregisterToggleEvent",
        value: function _unregisterToggleEvent() {
            this.node.off(ToggleComponent.EventType.CLICK, this.toggle, this);
        }
    }, {
        key: "_emitToggleEvents",
        value: function _emitToggleEvents() {
            this.node.emit(ToggleComponent.EventType.TOGGLE, this), this.checkEvents && EventHandler.emitEvents(this.checkEvents, this);
        }
    }, {
        key: "isChecked",
        get: function get() {
            return this._isChecked;
        },
        set: function set(value) {
            this._isChecked !== value && (this._isChecked = value, this._updateCheckMark());
        }
    }, {
        key: "checkMark",
        get: function get() {
            return this._checkMark;
        },
        set: function set(value) {
            this._checkMark !== value && (this._checkMark = value);
        }
    }, {
        key: "toggleGroup",
        get: function get() {
            return this._toggleGroup;
        },
        set: function set(value) {
            this._toggleGroup !== value && (this._toggleGroup && this._toggleGroup.removeToggle(this), 
            this._toggleGroup = value, this._toggleGroup && this._toggleGroup.enabled && this._toggleGroup.addToggle(this));
        }
    }, {
        key: "_resizeToTarget",
        set: function set(value) {
            value && this._resizeNodeToTargetNode();
        }
    }, {
        key: "_toggleContainer",
        get: function get() {
            this.node.parent;
            return null;
        }
    } ]), ToggleComponent;
}(), _class3$w.EventType = extendsEnum(EventType$5, EventType$2), _applyDecoratedDescriptor((_class2$1b = _temp$1e).prototype, "isChecked", [ _dec6$x ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "isChecked"), _class2$1b.prototype), 
_applyDecoratedDescriptor(_class2$1b.prototype, "checkMark", [ _dec7$r ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "checkMark"), _class2$1b.prototype), 
_applyDecoratedDescriptor(_class2$1b.prototype, "toggleGroup", [ _dec8$p ], Object.getOwnPropertyDescriptor(_class2$1b.prototype, "toggleGroup"), _class2$1b.prototype), 
_descriptor$12 = _applyDecoratedDescriptor(_class2$1b.prototype, "checkEvents", [ _dec9$j ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$S = _applyDecoratedDescriptor(_class2$1b.prototype, "_isChecked", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor3$I = _applyDecoratedDescriptor(_class2$1b.prototype, "_toggleGroup", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor4$A = _applyDecoratedDescriptor(_class2$1b.prototype, "_checkMark", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$1l = _class2$1b)) || _class$1l) || _class$1l) || _class$1l) || _class$1l) || _class$1l);

cc.ToggleComponent = ToggleComponent;

var _class$1n, _class2$1c, _temp$1g, UIModelComponent = ccclass("cc.UIModelComponent")(_class$1m = help("i18n:cc.UIModelComponent")(_class$1m = executionOrder(110)(_class$1m = menu("UI/Model")(_class$1m = function(_UIComponent) {
    function UIModelComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UIModelComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIModelComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._models = null, 
        _this._modelComponent = null, _this;
    }
    return _inherits(UIModelComponent, UIComponent), _createClass(UIModelComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this.node._uiProps.uiTransformComp || this.node.addComponent("cc.UITransformComponent"), 
            this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent ? (this._modelComponent._sceneGetter = director.root.ui.getRenderSceneGetter(), 
            this._models = this._modelComponent._collectModels()) : console.warn("node '".concat(this.node && this.node.name, "' doesn't have any renderable component"));
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(UIModelComponent.prototype), "onEnable", this).call(this), 
            this._modelComponent && this._modelComponent._attachToScene();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(UIModelComponent.prototype), "onDisable", this).call(this), 
            this._modelComponent && this._modelComponent._detachFromScene();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(UIModelComponent.prototype), "onDestroy", this).call(this), 
            this._modelComponent = this.getComponent("cc.RenderableComponent"), this._modelComponent && (this._modelComponent._sceneGetter = null, 
            cc.isValid(this._modelComponent, !0) && this._modelComponent._attachToScene(), this._models = null);
        }
    }, {
        key: "updateAssembler",
        value: function updateAssembler(render) {
            if (this._models) {
                for (var _step, _iterator = _createForOfIteratorHelperLoose(this._models); !(_step = _iterator()).done; ) {
                    var m = _step.value;
                    render.commitModel.call(render, this, m, this._modelComponent.material);
                }
                return !0;
            }
            return !1;
        }
    }, {
        key: "update",
        value: function update() {
            this._fitUIRenderQueue();
        }
    }, {
        key: "_fitUIRenderQueue",
        value: function _fitUIRenderQueue() {
            if (this._modelComponent) {
                for (var matNum = this._modelComponent.sharedMaterials.length, i = 0; i < matNum; i++) {
                    var material = this._modelComponent.getMaterialInstance(i);
                    if (null != material) for (var passes = material.passes, ea = material.effectAsset, techIdx = material.technique, passNum = passes.length, j = 0; j < passNum; j++) {
                        if (!passes[j].blendState.targets[0].blend) passes[j].blendState.targets[0].blend = !0, 
                        passes[j].overridePipelineStates(ea.techniques[techIdx].passes[j], {
                            blendState: passes[j].blendState
                        });
                    }
                }
                for (var _i = 0; _i < matNum; _i++) {
                    var _material = this._modelComponent.getMaterialInstance(_i);
                    if (null != _material) for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(_material.passes); !(_step2 = _iterator2()).done; ) {
                        _step2.value._priority = RenderPriority.MAX - 11;
                    }
                }
            }
        }
    }, {
        key: "modelComponent",
        get: function get() {
            return this._modelComponent;
        }
    } ]), UIModelComponent;
}()) || _class$1m) || _class$1m) || _class$1m) || _class$1m;

cc.UIModelComponent = UIModelComponent;

var WebViewEventType, _mat4_temp$2 = new Mat4;

!function(WebViewEventType) {
    WebViewEventType[WebViewEventType.LOADING = 0] = "LOADING", WebViewEventType[WebViewEventType.LOADED = 1] = "LOADED", 
    WebViewEventType[WebViewEventType.ERROR = 2] = "ERROR", WebViewEventType[WebViewEventType.JS_EVALUATED = 3] = "JS_EVALUATED";
}(WebViewEventType || (WebViewEventType = {}));

var polyfill$1 = {
    devicePixelRatio: !1,
    enableDiv: !1
};

sys.os === sys.OS_IOS && (polyfill$1.enableDiv = !0), sys.isMobile ? sys.browserType === sys.BROWSER_TYPE_FIREFOX && (polyfill$1.enableBG = !0) : sys.browserType === sys.BROWSER_TYPE_IE && (polyfill$1.closeHistory = !0);

var _dec$1n, _dec2$Z, _dec3$I, _dec4$E, _dec5$A, _dec6$y, _class$1o, _class2$1d, _descriptor$13, _descriptor2$T, _class3$x, _temp$1h, WebViewImpl = ccclass("cc.WebviewImpl")((_temp$1g = _class2$1c = function() {
    function WebViewImpl() {
        _classCallCheck(this, WebViewImpl), this._EventList = new Map, this._visible = !1, 
        this._div = null, this._iframe = null, this._forceUpdate = !0, this._m00 = 0, this._m01 = 0, 
        this._m04 = 0, this._m05 = 0, this._m12 = 0, this._m13 = 0, this._w = 0, this._h = 0, 
        this._eventListeners = {
            load: function load() {},
            error: function error() {}
        };
    }
    return _createClass(WebViewImpl, [ {
        key: "createDomElementIfNeeded",
        value: function createDomElementIfNeeded(w, h) {
            this._div ? this._updateSize(w, h) : this._createNativeControl(w, h);
        }
    }, {
        key: "removeDom",
        value: function removeDom() {
            var div = this._div;
            div && (contains$1(cc.game.container, div) && cc.game.container.removeChild(div), 
            this._div = null);
            var iframe = this._iframe;
            if (iframe) {
                var cbs = this._eventListeners;
                iframe.removeEventListener("load", cbs.load), iframe.removeEventListener("error", cbs.error), 
                cbs.load = null, cbs.error = null, this._iframe = null;
            }
        }
    }, {
        key: "loadURL",
        value: function loadURL(url) {
            var iframe = this._iframe;
            if (iframe) {
                iframe.src = url;
                var self = this;
                iframe.addEventListener("load", (function cb() {
                    self._updateVisibility(), iframe.removeEventListener("load", cb);
                })), this._dispatchEvent(WebViewImpl.EventType.LOADING);
            }
        }
    }, {
        key: "stopLoading",
        value: function stopLoading() {
            logID(7800);
        }
    }, {
        key: "reload",
        value: function reload() {
            var iframe = this._iframe;
            if (iframe) {
                var win = iframe.contentWindow;
                win && win.location && win.location.reload();
            }
        }
    }, {
        key: "canGoBack",
        value: function canGoBack() {
            return logID(7801), !0;
        }
    }, {
        key: "canGoForward",
        value: function canGoForward() {
            return logID(7802), !0;
        }
    }, {
        key: "goBack",
        value: function goBack() {
            try {
                if (WebViewImpl.Polyfill.closeHistory) return logID(7803);
                var iframe = this._iframe;
                if (iframe) {
                    var win = iframe.contentWindow;
                    win && win.location && win.history.back.call(win);
                }
            } catch (err) {
                log(err);
            }
        }
    }, {
        key: "goForward",
        value: function goForward() {
            try {
                if (WebViewImpl.Polyfill.closeHistory) return logID(7804);
                var iframe = this._iframe;
                if (iframe) {
                    var win = iframe.contentWindow;
                    win && win.location && win.history.forward.call(win);
                }
            } catch (err) {
                log(err);
            }
        }
    }, {
        key: "evaluateJS",
        value: function evaluateJS(str) {
            var iframe = this._iframe;
            if (iframe) iframe.contentWindow;
        }
    }, {
        key: "setScalesPageToFit",
        value: function setScalesPageToFit() {
            logID(7805);
        }
    }, {
        key: "setEventListener",
        value: function setEventListener(event, callback) {
            this._EventList[event] = callback;
        }
    }, {
        key: "removeEventListener",
        value: function removeEventListener(event) {
            this._EventList[event] = null;
        }
    }, {
        key: "_dispatchEvent",
        value: function _dispatchEvent(event) {
            var callback = this._EventList[event];
            callback && this._iframe && callback.call(this, this, this._iframe.src);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.removeDom();
        }
    }, {
        key: "setVisible",
        value: function setVisible(visible) {
            this._visible !== visible && (this._visible = !!visible, this._updateVisibility());
        }
    }, {
        key: "updateMatrix",
        value: function updateMatrix(node) {
            if (this._div && this._visible) {
                node.getWorldMatrix(_mat4_temp$2);
                var contentSize = node.getContentSize();
                if (this._forceUpdate || this._m00 !== _mat4_temp$2.m00 || this._m01 !== _mat4_temp$2.m01 || this._m04 !== _mat4_temp$2.m04 || this._m05 !== _mat4_temp$2.m05 || this._m12 !== _mat4_temp$2.m12 || this._m13 !== _mat4_temp$2.m13 || this._w !== contentSize.width || this._h !== contentSize.height) {
                    this._m00 = _mat4_temp$2.m00, this._m01 = _mat4_temp$2.m01, this._m04 = _mat4_temp$2.m04, 
                    this._m05 = _mat4_temp$2.m05, this._m12 = _mat4_temp$2.m12, this._m13 = _mat4_temp$2.m13, 
                    this._w = contentSize.width, this._h = contentSize.height;
                    var scaleX = view.getScaleX(), scaleY = view.getScaleY(), dpr = view.getDevicePixelRatio();
                    scaleX /= dpr, scaleY /= dpr;
                    var container = cc.game.container, a = _mat4_temp$2.m00 * scaleX, b = _mat4_temp$2.m01, c = _mat4_temp$2.m04, d = _mat4_temp$2.m05 * scaleY, offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0, offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
                    this._updateSize(this._w, this._h);
                    var w = this._div.clientWidth * scaleX, h = this._div.clientHeight * scaleY, ap = node.getAnchorPoint(), appx = w * _mat4_temp$2.m00 * ap.x, appy = h * _mat4_temp$2.m05 * ap.y, matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + (_mat4_temp$2.m12 * scaleX - appx + offsetX) + "," + -(_mat4_temp$2.m13 * scaleY - appy + offsetY) + ")";
                    this._div.style.transform = matrix, this._div.style["-webkit-transform"] = matrix, 
                    this._div.style["transform-origin"] = "0px 100% 0px", this._div.style["-webkit-transform-origin"] = "0px 100% 0px";
                    var renderComp = node.getComponent(UIRenderComponent);
                    renderComp && this._setOpacity(renderComp.color.a);
                }
            }
        }
    }, {
        key: "setOnJSCallback",
        value: function setOnJSCallback(callback) {}
    }, {
        key: "setJavascriptInterfaceScheme",
        value: function setJavascriptInterfaceScheme(scheme) {}
    }, {
        key: "loadData",
        value: function loadData(data, MIMEType, encoding, baseURL) {}
    }, {
        key: "loadHTMLString",
        value: function loadHTMLString(string, baseURL) {}
    }, {
        key: "_updateVisibility",
        value: function _updateVisibility() {
            if (this._div) {
                var div = this._div;
                this._visible ? div.style.visibility = "visible" : div.style.visibility = "hidden", 
                this._forceUpdate = !0;
            }
        }
    }, {
        key: "_updateSize",
        value: function _updateSize(w, h) {
            var div = this._div;
            div && (div.style.width = w + "px", div.style.height = h + "px");
        }
    }, {
        key: "_initEvent",
        value: function _initEvent() {
            var iframe = this._iframe;
            if (iframe) {
                var cbs = this._eventListeners, self = this;
                cbs.load = function() {
                    self._dispatchEvent(WebViewImpl.EventType.LOADED);
                }, cbs.error = function() {
                    self._dispatchEvent(WebViewImpl.EventType.ERROR);
                }, iframe.addEventListener("load", cbs.load), iframe.addEventListener("error", cbs.error);
            }
        }
    }, {
        key: "_initStyle",
        value: function _initStyle() {
            if (this._div) {
                var div = this._div;
                div.style.position = "absolute", div.style.bottom = "0px", div.style.left = "0px";
            }
        }
    }, {
        key: "_setOpacity",
        value: function _setOpacity(opacity) {
            var iframe = this._iframe;
            iframe && iframe.style && (iframe.style.opacity = (opacity / 255).toString());
        }
    }, {
        key: "_createDom",
        value: function _createDom(w, h) {
            WebViewImpl.Polyfill.enableDiv ? (this._div = document.createElement("div"), this._div.style["-webkit-overflow"] = "auto", 
            this._div.style["-webkit-overflow-scrolling"] = "touch", this._iframe = document.createElement("iframe"), 
            this._div.appendChild(this._iframe), this._iframe.style.width = "100%", this._iframe.style.height = "100%") : this._div = this._iframe = document.createElement("iframe"), 
            WebViewImpl.Polyfill.enableBG && (this._div.style.background = "#FFF"), this._div.style.background = "#FFF", 
            this._div.style.height = h + "px", this._div.style.width = w + "px", this._div.style.overflow = "scroll", 
            this._iframe.style.border = "none", cc.game.container.appendChild(this._div), this._updateVisibility();
        }
    }, {
        key: "_createNativeControl",
        value: function _createNativeControl(w, h) {
            this._createDom(w, h), this._initStyle(), this._initEvent();
        }
    } ]), WebViewImpl;
}(), _class2$1c.Polyfill = polyfill$1, _class2$1c.EventType = WebViewEventType, 
_class$1n = _temp$1g)) || _class$1n, EventType$6 = WebViewEventType;

function emptyCallback() {}

var _dec$1o, _dec2$_, _dec3$J, _dec4$F, _dec5$B, _dec6$z, _dec7$s, _dec8$q, _dec9$k, _dec10$e, _dec11$d, _dec12$c, _dec13$a, _dec14$9, _dec15$8, _dec16$7, _class$1p, _class2$1e, _descriptor$14, _descriptor2$U, _descriptor3$J, _descriptor4$B, _descriptor5$t, _descriptor6$i, _descriptor7$g, _descriptor8$e, _descriptor9$d, _descriptor10$c, _descriptor11$8, _descriptor12$7, _descriptor13$7, _descriptor14$7, _descriptor15$3, _descriptor16$3, _descriptor17$2, _descriptor18$2, _class3$y, _temp$1i, WebviewComponent = (_dec$1n = ccclass("cc.WebviewComponent"), 
_dec2$Z = help("i18n:cc.WebviewComponent"), _dec3$I = menu("UI/WebView"), _dec4$E = executionOrder(100), 
_dec5$A = property({
    tooltip: "指定 WebView 加载的网址，它应该是一个 http 或者 https 开头的字符串"
}), _dec6$y = property({
    type: EventHandler,
    tooltip: "WebView 的回调事件，当网页加载过程中，加载完成后或者加载出错时都会回调此函数"
}), _dec$1n(_class$1o = _dec2$Z(_class$1o = _dec3$I(_class$1o = _dec4$E((_temp$1h = _class3$x = function(_UIComponent) {
    function WebviewComponent() {
        var _this;
        return _classCallCheck(this, WebviewComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(WebviewComponent).call(this)), "webviewEvents", _descriptor$13, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_url", _descriptor2$T, _assertThisInitialized(_this)), 
        _this._impl = null, _this._impl = new WebViewImpl, _this;
    }
    return _inherits(WebviewComponent, UIComponent), _createClass(WebviewComponent, [ {
        key: "url",
        get: function get() {
            return this._url;
        },
        set: function set(url) {
            this._url = url;
            var impl = this._impl;
            impl && impl.loadURL(url);
        }
    } ]), _createClass(WebviewComponent, [ {
        key: "onRestore",
        value: function onRestore() {
            this._impl || (this._impl = new WebViewImpl);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            if (this._impl) {
                var impl = this._impl;
                impl.createDomElementIfNeeded(this.node.width, this.node.height), impl.loadURL(this._url), 
                impl.setVisible(!0), impl.setEventListener(EventType$6.LOADED, this._onWebViewLoaded.bind(this)), 
                impl.setEventListener(EventType$6.LOADING, this._onWebViewLoading.bind(this)), impl.setEventListener(EventType$6.ERROR, this._onWebViewLoadError.bind(this));
            }
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            if (this._impl) {
                var impl = this._impl;
                impl.setVisible(!1), impl.setEventListener(EventType$6.LOADED, emptyCallback), impl.setEventListener(EventType$6.LOADING, emptyCallback), 
                impl.setEventListener(EventType$6.ERROR, emptyCallback);
            }
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._impl && (this._impl.destroy(), this._impl = null);
        }
    }, {
        key: "update",
        value: function update(dt) {
            this._impl && this._impl.updateMatrix(this.node);
        }
    }, {
        key: "setJavascriptInterfaceScheme",
        value: function setJavascriptInterfaceScheme(scheme) {
            this._impl && this._impl.setJavascriptInterfaceScheme(scheme);
        }
    }, {
        key: "setOnJSCallback",
        value: function setOnJSCallback(callback) {
            this._impl && this._impl.setOnJSCallback(callback);
        }
    }, {
        key: "evaluateJS",
        value: function evaluateJS(str) {
            this._impl && this._impl.evaluateJS(str);
        }
    }, {
        key: "_onWebViewLoaded",
        value: function _onWebViewLoaded() {
            EventHandler.emitEvents(this.webviewEvents, this, EventType$6.LOADED), this.node.emit("loaded", this);
        }
    }, {
        key: "_onWebViewLoading",
        value: function _onWebViewLoading() {
            return EventHandler.emitEvents(this.webviewEvents, this, EventType$6.LOADING), this.node.emit("loading", this), 
            !0;
        }
    }, {
        key: "_onWebViewLoadError",
        value: function _onWebViewLoadError() {
            EventHandler.emitEvents(this.webviewEvents, this, EventType$6.ERROR), this.node.emit("error", this);
        }
    } ]), WebviewComponent;
}(), _class3$x.EventType = EventType$6, _applyDecoratedDescriptor((_class2$1d = _temp$1h).prototype, "url", [ _dec5$A ], Object.getOwnPropertyDescriptor(_class2$1d.prototype, "url"), _class2$1d.prototype), 
_descriptor$13 = _applyDecoratedDescriptor(_class2$1d.prototype, "webviewEvents", [ _dec6$y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor2$T = _applyDecoratedDescriptor(_class2$1d.prototype, "_url", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return "";
    }
}), _class$1o = _class2$1d)) || _class$1o) || _class$1o) || _class$1o) || _class$1o);

cc.WebviewComponent = WebviewComponent;

var AlignMode, AlignFlags, _zeroVec3 = new Vec3;

function getReadonlyNodeSize(parent) {
    return parent instanceof Scene ? visibleRect : parent.getContentSize();
}

function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
    for (var scale = widgetNode.parent ? widgetNode.parent.getScale() : _zeroVec3, scaleX = scale.x, scaleY = scale.y, translateX = 0, translateY = 0, node = widgetNode.parent; ;) {
        if (!node) return out_inverseTranslate.x = out_inverseTranslate.y = 0, void (out_inverseScale.x = out_inverseScale.y = 1);
        var pos = node.getPosition();
        if (translateX += pos.x, translateY += pos.y, (node = node.parent) === target) break;
        var sx = (scale = node ? node.getScale() : _zeroVec3).x, sy = scale.y;
        translateX *= sx, translateY *= sy, scaleX *= sx, scaleY *= sy;
    }
    out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1, out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1, 
    out_inverseTranslate.x = -translateX, out_inverseTranslate.y = -translateY;
}

!function(AlignMode) {
    AlignMode[AlignMode.ONCE = 0] = "ONCE", AlignMode[AlignMode.ALWAYS = 1] = "ALWAYS", 
    AlignMode[AlignMode.ON_WINDOW_RESIZE = 2] = "ON_WINDOW_RESIZE";
}(AlignMode || (AlignMode = {})), ccenum(AlignMode), function(AlignFlags) {
    AlignFlags[AlignFlags.TOP = 1] = "TOP", AlignFlags[AlignFlags.MID = 2] = "MID", 
    AlignFlags[AlignFlags.BOT = 4] = "BOT", AlignFlags[AlignFlags.LEFT = 8] = "LEFT", 
    AlignFlags[AlignFlags.CENTER = 16] = "CENTER", AlignFlags[AlignFlags.RIGHT = 32] = "RIGHT", 
    AlignFlags[AlignFlags.HORIZONTAL = 56] = "HORIZONTAL", AlignFlags[AlignFlags.VERTICAL = 7] = "VERTICAL";
}(AlignFlags || (AlignFlags = {}));

var _class$1q, TOP_BOT = AlignFlags.TOP | AlignFlags.BOT, LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT;

exports.WidgetComponent = (_dec$1o = ccclass("cc.WidgetComponent"), _dec2$_ = help("i18n:cc.WidgetComponent"), 
_dec3$J = executionOrder(110), _dec4$F = menu("UI/Widget"), _dec5$B = requireComponent(UITransformComponent), 
_dec6$z = property({
    type: Node$1,
    tooltip: "对齐目标"
}), _dec7$s = property({
    tooltip: "是否对齐上边"
}), _dec8$q = property({
    tooltip: "是否对齐下边"
}), _dec9$k = property({
    tooltip: "是否对齐左边"
}), _dec10$e = property({
    tooltip: "是否对齐右边"
}), _dec11$d = property({
    tooltip: "是否垂直方向对齐中点，开启此项会将垂直方向其他对齐选项取消"
}), _dec12$c = property({
    tooltip: "是否水平方向对齐中点，开启此选项会将水平方向其他对齐选项取消"
}), _dec13$a = property({
    visible: !1
}), _dec14$9 = property({
    visible: !1
}), _dec15$8 = property({
    type: AlignMode,
    tooltip: "指定 widget 的对齐方式，用于决定运行时 widget 应何时更新"
}), _dec16$7 = property({
    editorOnly: !0
}), _dec$1o(_class$1p = _dec2$_(_class$1p = _dec3$J(_class$1p = _dec4$F(_class$1p = _dec5$B(_class$1p = executeInEditMode((_temp$1i = _class3$y = function(_Component) {
    function WidgetComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, WidgetComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WidgetComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._lastPos = new Vec3, 
        _this._lastSize = new Size, _this._dirty = !0, _initializerDefineProperty(_this, "_alignFlags", _descriptor$14, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_target", _descriptor2$U, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_left", _descriptor3$J, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_right", _descriptor4$B, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_top", _descriptor5$t, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_bottom", _descriptor6$i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_horizontalCenter", _descriptor7$g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_verticalCenter", _descriptor8$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsLeft", _descriptor9$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsRight", _descriptor10$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsTop", _descriptor11$8, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsBottom", _descriptor12$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsHorizontalCenter", _descriptor13$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isAbsVerticalCenter", _descriptor14$7, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_originalWidth", _descriptor15$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_originalHeight", _descriptor16$3, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_alignMode", _descriptor17$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_lockFlags", _descriptor18$2, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(WidgetComponent, Component), _createClass(WidgetComponent, [ {
        key: "updateAlignment",
        value: function updateAlignment() {
            cc._widgetManager.updateAlignment(this.node);
        }
    }, {
        key: "_validateTargetInDEV",
        value: function _validateTargetInDEV() {}
    }, {
        key: "setDirty",
        value: function setDirty() {
            this._recursiveDirty();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this.node.getPosition(this._lastPos), this.node.getContentSize(this._lastSize), 
            cc._widgetManager.add(this), this._registerEvent(), this._registerTargetEvents();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            cc._widgetManager.remove(this), this._unregisterEvent(), this._unregisterTargetEvents();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._removeParentEvent();
        }
    }, {
        key: "_adjustWidgetToAllowMovingInEditor",
        value: function _adjustWidgetToAllowMovingInEditor(eventType) {
            if (eventType & TransformBit.POSITION && !cc._widgetManager.isAligning) {
                var newPos = this.node.getPosition(), oldPos = this._lastPos, delta = new Vec3(newPos);
                delta.subtract(oldPos);
                var target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
                if (this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3, inverseScale)), 
                target) {
                    var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3;
                    0 !== targetSize.width && 0 !== targetSize.height && Vec3.set(deltaInPercent, delta.x / targetSize.width, delta.y / targetSize.height, deltaInPercent.z), 
                    this.isAlignTop && (this._top -= (this._isAbsTop ? delta.y : deltaInPercent.y) * inverseScale.y), 
                    this.isAlignBottom && (this._bottom += (this._isAbsBottom ? delta.y : deltaInPercent.y) * inverseScale.y), 
                    this.isAlignLeft && (this._left += (this._isAbsLeft ? delta.x : deltaInPercent.x) * inverseScale.x), 
                    this.isAlignRight && (this._right -= (this._isAbsRight ? delta.x : deltaInPercent.x) * inverseScale.x), 
                    this.isAlignHorizontalCenter && (this._horizontalCenter += (this._isAbsHorizontalCenter ? delta.x : deltaInPercent.x) * inverseScale.x), 
                    this.isAlignVerticalCenter && (this._verticalCenter += (this._isAbsVerticalCenter ? delta.y : deltaInPercent.y) * inverseScale.y), 
                    this._recursiveDirty();
                }
            }
        }
    }, {
        key: "_adjustWidgetToAllowResizingInEditor",
        value: function _adjustWidgetToAllowResizingInEditor() {
            if (!cc._widgetManager.isAligning) {
                this.setDirty();
                var newSize = this.node.getContentSize(), oldSize = this._lastSize, delta = new Vec3(newSize.width - oldSize.width, newSize.height - oldSize.height, 0), target = this.node.parent, inverseScale = new Vec3(1, 1, 1);
                if (this.target && (target = this.target, computeInverseTransForTarget(this.node, target, new Vec3, inverseScale)), 
                target) {
                    var targetSize = getReadonlyNodeSize(target), deltaInPercent = new Vec3;
                    0 !== targetSize.width && 0 !== targetSize.height && Vec3.set(deltaInPercent, delta.x / targetSize.width, delta.y / targetSize.height, deltaInPercent.z);
                    var anchor = this.node.getAnchorPoint();
                    this.isAlignTop && (this._top -= (this._isAbsTop ? delta.y : deltaInPercent.y) * (1 - anchor.y) * inverseScale.y), 
                    this.isAlignBottom && (this._bottom -= (this._isAbsBottom ? delta.y : deltaInPercent.y) * anchor.y * inverseScale.y), 
                    this.isAlignLeft && (this._left -= (this._isAbsLeft ? delta.x : deltaInPercent.x) * anchor.x * inverseScale.x), 
                    this.isAlignRight && (this._right -= (this._isAbsRight ? delta.x : deltaInPercent.x) * (1 - anchor.x) * inverseScale.x), 
                    this._recursiveDirty();
                }
            }
        }
    }, {
        key: "_adjustWidgetToAnchorChanged",
        value: function _adjustWidgetToAnchorChanged() {
            this.setDirty();
        }
    }, {
        key: "_adjustTargetToParentChanged",
        value: function _adjustTargetToParentChanged(oldParent) {
            oldParent && this._unregisterOldParentEvents(oldParent), this.node.getParent() && this._registerTargetEvents();
        }
    }, {
        key: "_registerEvent",
        value: function _registerEvent() {
            this.node.on(exports.SystemEventType.TRANSFORM_CHANGED, this._adjustWidgetToAllowMovingInEditor, this), 
            this.node.on(exports.SystemEventType.SIZE_CHANGED, this._adjustWidgetToAllowResizingInEditor, this), 
            this.node.on(exports.SystemEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this), 
            this.node.on(exports.SystemEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        }
    }, {
        key: "_unregisterEvent",
        value: function _unregisterEvent() {
            this.node.off(exports.SystemEventType.TRANSFORM_CHANGED, this._adjustWidgetToAllowMovingInEditor, this), 
            this.node.off(exports.SystemEventType.SIZE_CHANGED, this._adjustWidgetToAllowResizingInEditor, this), 
            this.node.off(exports.SystemEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
        }
    }, {
        key: "_removeParentEvent",
        value: function _removeParentEvent() {
            this.node.off(exports.SystemEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
        }
    }, {
        key: "_autoChangedValue",
        value: function _autoChangedValue(flag, isAbs) {
            if ((this._alignFlags & flag) > 0 && this.node.parent && this.node.parent._uiProps.uiTransformComp) {
                var size = this.node.parent.getContentSize();
                this.isAlignLeft && flag === AlignFlags.LEFT ? this._left = isAbs ? this._left * size.width : this._left / size.width : this.isAlignRight && flag === AlignFlags.RIGHT ? this._right = isAbs ? this._right * size.width : this._right / size.width : this.isAlignHorizontalCenter && flag === AlignFlags.CENTER ? this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width : this.isAlignTop && flag === AlignFlags.TOP ? this._top = isAbs ? this._top * size.height : this._top / size.height : this.isAlignBottom && flag === AlignFlags.BOT ? this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height : this.isAbsoluteVerticalCenter && flag === AlignFlags.MID && (this._verticalCenter = this._verticalCenter / size.height), 
                this._recursiveDirty();
            }
        }
    }, {
        key: "_registerTargetEvents",
        value: function _registerTargetEvents() {
            var target = this._target || this.node.parent;
            target && (target.getComponent(UITransformComponent) ? (target.on(exports.SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
            target.on(exports.SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this)) : cc.warnID(6501, this.node.name));
        }
    }, {
        key: "_unregisterTargetEvents",
        value: function _unregisterTargetEvents() {
            var target = this._target || this.node.parent;
            target && (target.off(exports.SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
            target.off(exports.SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this));
        }
    }, {
        key: "_unregisterOldParentEvents",
        value: function _unregisterOldParentEvents(oldParent) {
            var target = this._target || oldParent;
            target && (target.off(exports.SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this), 
            target.off(exports.SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this));
        }
    }, {
        key: "_targetChangedOperation",
        value: function _targetChangedOperation() {
            this._recursiveDirty();
        }
    }, {
        key: "_setAlign",
        value: function _setAlign(flag, isAlign) {
            if (isAlign !== (this._alignFlags & flag) > 0) {
                var isHorizontal = (flag & LEFT_RIGHT) > 0;
                isAlign ? (this._alignFlags |= flag, isHorizontal ? (this.isAlignHorizontalCenter = !1, 
                this.isStretchWidth && (this._originalWidth = this.node.width)) : (this.isAlignVerticalCenter = !1, 
                this.isStretchHeight && (this._originalHeight = this.node.height))) : (isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight), 
                this._alignFlags &= ~flag);
            }
        }
    }, {
        key: "_recursiveDirty",
        value: function _recursiveDirty() {
            this._dirty || (this._dirty = !0);
        }
    }, {
        key: "target",
        get: function get() {
            return this._target;
        },
        set: function set(value) {
            this._target !== value && (this._unregisterTargetEvents(), this._target = value, 
            this._registerTargetEvents(), this._validateTargetInDEV(), this._recursiveDirty());
        }
    }, {
        key: "isAlignTop",
        get: function get() {
            return (this._alignFlags & AlignFlags.TOP) > 0;
        },
        set: function set(value) {
            this._setAlign(AlignFlags.TOP, value), this._recursiveDirty();
        }
    }, {
        key: "isAlignBottom",
        get: function get() {
            return (this._alignFlags & AlignFlags.BOT) > 0;
        },
        set: function set(value) {
            this._setAlign(AlignFlags.BOT, value), this._recursiveDirty();
        }
    }, {
        key: "isAlignLeft",
        get: function get() {
            return (this._alignFlags & AlignFlags.LEFT) > 0;
        },
        set: function set(value) {
            this._setAlign(AlignFlags.LEFT, value), this._recursiveDirty();
        }
    }, {
        key: "isAlignRight",
        get: function get() {
            return (this._alignFlags & AlignFlags.RIGHT) > 0;
        },
        set: function set(value) {
            this._setAlign(AlignFlags.RIGHT, value), this._recursiveDirty();
        }
    }, {
        key: "isAlignVerticalCenter",
        get: function get() {
            return (this._alignFlags & AlignFlags.MID) > 0;
        },
        set: function set(value) {
            value ? (this.isAlignTop = !1, this.isAlignBottom = !1, this._alignFlags |= AlignFlags.MID) : this._alignFlags &= ~AlignFlags.MID, 
            this._recursiveDirty();
        }
    }, {
        key: "isAlignHorizontalCenter",
        get: function get() {
            return (this._alignFlags & AlignFlags.CENTER) > 0;
        },
        set: function set(value) {
            value ? (this.isAlignLeft = !1, this.isAlignRight = !1, this._alignFlags |= AlignFlags.CENTER) : this._alignFlags &= ~AlignFlags.CENTER, 
            this._recursiveDirty();
        }
    }, {
        key: "isStretchWidth",
        get: function get() {
            return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
        }
    }, {
        key: "isStretchHeight",
        get: function get() {
            return (this._alignFlags & TOP_BOT) === TOP_BOT;
        }
    }, {
        key: "top",
        get: function get() {
            return this._top;
        },
        set: function set(value) {
            this._top = value, this._recursiveDirty();
        }
    }, {
        key: "editorTop",
        get: function get() {
            return this._isAbsTop ? this._top : 100 * this._top;
        },
        set: function set(value) {
            this._top = this._isAbsTop ? value : value / 100, this._recursiveDirty();
        }
    }, {
        key: "bottom",
        get: function get() {
            return this._bottom;
        },
        set: function set(value) {
            this._bottom = value, this._recursiveDirty();
        }
    }, {
        key: "editorBottom",
        get: function get() {
            return this._isAbsBottom ? this._bottom : 100 * this._bottom;
        },
        set: function set(value) {
            this._bottom = this._isAbsBottom ? value : value / 100, this._recursiveDirty();
        }
    }, {
        key: "left",
        get: function get() {
            return this._left;
        },
        set: function set(value) {
            this._left = value, this._recursiveDirty();
        }
    }, {
        key: "editorLeft",
        get: function get() {
            return this._isAbsLeft ? this._left : 100 * this._left;
        },
        set: function set(value) {
            this._left = this._isAbsLeft ? value : value / 100, this._recursiveDirty();
        }
    }, {
        key: "right",
        get: function get() {
            return this._right;
        },
        set: function set(value) {
            this._right = value, this._recursiveDirty();
        }
    }, {
        key: "editorRight",
        get: function get() {
            return this._isAbsRight ? this._right : 100 * this._right;
        },
        set: function set(value) {
            this._right = this._isAbsRight ? value : value / 100, this._recursiveDirty();
        }
    }, {
        key: "horizontalCenter",
        get: function get() {
            return this._horizontalCenter;
        },
        set: function set(value) {
            this._horizontalCenter = value, this._recursiveDirty();
        }
    }, {
        key: "editorHorizontalCenter",
        get: function get() {
            return this._isAbsHorizontalCenter ? this._horizontalCenter : 100 * this._horizontalCenter;
        },
        set: function set(value) {
            this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100, this._recursiveDirty();
        }
    }, {
        key: "verticalCenter",
        get: function get() {
            return this._verticalCenter;
        },
        set: function set(value) {
            this._verticalCenter = value, this._recursiveDirty();
        }
    }, {
        key: "editorVerticalCenter",
        get: function get() {
            return this._isAbsVerticalCenter ? this._verticalCenter : 100 * this._verticalCenter;
        },
        set: function set(value) {
            this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100, this._recursiveDirty();
        }
    }, {
        key: "isAbsoluteTop",
        get: function get() {
            return this._isAbsTop;
        },
        set: function set(value) {
            this._isAbsTop !== value && (this._isAbsTop = value, this._autoChangedValue(AlignFlags.TOP, this._isAbsTop));
        }
    }, {
        key: "isAbsoluteBottom",
        get: function get() {
            return this._isAbsBottom;
        },
        set: function set(value) {
            this._isAbsBottom !== value && (this._isAbsBottom = value, this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom));
        }
    }, {
        key: "isAbsoluteLeft",
        get: function get() {
            return this._isAbsLeft;
        },
        set: function set(value) {
            this._isAbsLeft !== value && (this._isAbsLeft = value, this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft));
        }
    }, {
        key: "isAbsoluteRight",
        get: function get() {
            return this._isAbsRight;
        },
        set: function set(value) {
            this._isAbsRight !== value && (this._isAbsRight = value, this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight));
        }
    }, {
        key: "isAbsoluteHorizontalCenter",
        get: function get() {
            return this._isAbsHorizontalCenter;
        },
        set: function set(value) {
            this._isAbsHorizontalCenter !== value && (this._isAbsHorizontalCenter = value, this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter));
        }
    }, {
        key: "isAbsoluteVerticalCenter",
        get: function get() {
            return this._isAbsVerticalCenter;
        },
        set: function set(value) {
            this._isAbsVerticalCenter !== value && (this._isAbsVerticalCenter = value, this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter));
        }
    }, {
        key: "alignMode",
        get: function get() {
            return this._alignMode;
        },
        set: function set(value) {
            this._alignMode = value, this._recursiveDirty();
        }
    }, {
        key: "alignFlags",
        get: function get() {
            return this._alignFlags;
        },
        set: function set(value) {
            this._alignFlags !== value && (this._alignFlags = value, this._recursiveDirty());
        }
    } ]), WidgetComponent;
}(), _class3$y.AlignMode = AlignMode, _applyDecoratedDescriptor((_class2$1e = _temp$1i).prototype, "target", [ _dec6$z ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "target"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAlignTop", [ _dec7$s ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAlignTop"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAlignBottom", [ _dec8$q ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAlignBottom"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAlignLeft", [ _dec9$k ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAlignLeft"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAlignRight", [ _dec10$e ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAlignRight"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAlignVerticalCenter", [ _dec11$d ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAlignVerticalCenter"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAlignHorizontalCenter", [ _dec12$c ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAlignHorizontalCenter"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isStretchWidth", [ _dec13$a ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isStretchWidth"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isStretchHeight", [ _dec14$9 ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isStretchHeight"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "editorTop", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "editorTop"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "editorBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "editorBottom"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "editorLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "editorLeft"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "editorRight", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "editorRight"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "editorHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "editorHorizontalCenter"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "editorVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "editorVerticalCenter"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAbsoluteTop", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAbsoluteTop"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAbsoluteBottom", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAbsoluteBottom"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAbsoluteLeft", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAbsoluteLeft"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAbsoluteRight", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAbsoluteRight"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAbsoluteHorizontalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAbsoluteHorizontalCenter"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "isAbsoluteVerticalCenter", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "isAbsoluteVerticalCenter"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "alignMode", [ _dec15$8 ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "alignMode"), _class2$1e.prototype), 
_applyDecoratedDescriptor(_class2$1e.prototype, "alignFlags", [ property ], Object.getOwnPropertyDescriptor(_class2$1e.prototype, "alignFlags"), _class2$1e.prototype), 
_descriptor$14 = _applyDecoratedDescriptor(_class2$1e.prototype, "_alignFlags", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$U = _applyDecoratedDescriptor(_class2$1e.prototype, "_target", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$J = _applyDecoratedDescriptor(_class2$1e.prototype, "_left", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor4$B = _applyDecoratedDescriptor(_class2$1e.prototype, "_right", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor5$t = _applyDecoratedDescriptor(_class2$1e.prototype, "_top", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$i = _applyDecoratedDescriptor(_class2$1e.prototype, "_bottom", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$g = _applyDecoratedDescriptor(_class2$1e.prototype, "_horizontalCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$e = _applyDecoratedDescriptor(_class2$1e.prototype, "_verticalCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor9$d = _applyDecoratedDescriptor(_class2$1e.prototype, "_isAbsLeft", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor10$c = _applyDecoratedDescriptor(_class2$1e.prototype, "_isAbsRight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor11$8 = _applyDecoratedDescriptor(_class2$1e.prototype, "_isAbsTop", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor12$7 = _applyDecoratedDescriptor(_class2$1e.prototype, "_isAbsBottom", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor13$7 = _applyDecoratedDescriptor(_class2$1e.prototype, "_isAbsHorizontalCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor14$7 = _applyDecoratedDescriptor(_class2$1e.prototype, "_isAbsVerticalCenter", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor15$3 = _applyDecoratedDescriptor(_class2$1e.prototype, "_originalWidth", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor16$3 = _applyDecoratedDescriptor(_class2$1e.prototype, "_originalHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor17$2 = _applyDecoratedDescriptor(_class2$1e.prototype, "_alignMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return AlignMode.ON_WINDOW_RESIZE;
    }
}), _descriptor18$2 = _applyDecoratedDescriptor(_class2$1e.prototype, "_lockFlags", [ _dec16$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$1p = _class2$1e)) || _class$1p) || _class$1p) || _class$1p) || _class$1p) || _class$1p) || _class$1p), 
exports.WidgetComponent || (exports.WidgetComponent = {}), cc.WidgetComponent = exports.WidgetComponent, 
cc.internal.computeInverseTransForTarget = computeInverseTransForTarget, cc.internal.getReadonlyNodeSize = getReadonlyNodeSize;

var _dec$1q, _dec2$10, _dec3$L, _dec4$H, _dec5$C, _dec6$A, _dec7$t, _dec8$r, _class$1r, _class2$1f, _descriptor$15, _descriptor2$V, _descriptor3$K, _descriptor4$C, _class3$z, _temp$1j, UIReorderComponent = ccclass("cc.UIReorderComponent")(_class$1q = help("i18n:cc.UIReorderComponent")(_class$1q = menu("UI/Reorder")(_class$1q = executionOrder(110)(_class$1q = disallowMultiple(_class$1q = executeInEditMode(_class$1q = function(_UIComponent) {
    function UIReorderComponent() {
        return _classCallCheck(this, UIReorderComponent), _possibleConstructorReturn(this, _getPrototypeOf(UIReorderComponent).apply(this, arguments));
    }
    return _inherits(UIReorderComponent, UIComponent), UIReorderComponent;
}()) || _class$1q) || _class$1q) || _class$1q) || _class$1q) || _class$1q) || _class$1q;

cc.UIReorderComponent = UIReorderComponent;

var Direction$2, _color = new Color;

!function(Direction) {
    Direction[Direction.HORIZONTAL = 0] = "HORIZONTAL", Direction[Direction.VERTICAL = 1] = "VERTICAL";
}(Direction$2 || (Direction$2 = {})), ccenum(Direction$2);

var _dec$1r, _dec2$11, _dec3$M, _dec4$I, _dec5$D, _dec6$B, _dec7$u, _dec8$s, _dec9$l, _dec10$f, _dec11$e, _dec12$d, _dec13$b, _dec14$a, _dec15$9, _dec16$8, _dec17$6, _class$1s, _class2$1g, _descriptor$16, _descriptor2$W, _descriptor3$L, _descriptor4$D, _descriptor5$u, _descriptor6$j, _descriptor7$h, _descriptor8$f, _descriptor9$e, _descriptor10$d, _descriptor11$9, _descriptor12$8, _class3$A, _temp$1k, PageViewIndicatorComponent = (_dec$1q = ccclass("cc.PageViewIndicatorComponent"), 
_dec2$10 = help("i18n:cc.PageViewIndicatorComponent"), _dec3$L = executionOrder(110), 
_dec4$H = menu("UI/PageViewIndicator"), _dec5$C = property({
    type: SpriteFrame,
    tooltip: "每个页面标记显示的图片"
}), _dec6$A = property({
    type: Direction$2,
    tooltip: "页面标记摆放方向"
}), _dec7$t = property({
    type: Size,
    tooltip: "每个页面标记的大小"
}), _dec8$r = property({
    tooltip: "每个页面标记之间的边距"
}), _dec$1q(_class$1r = _dec2$10(_class$1r = _dec3$L(_class$1r = _dec4$H((_temp$1j = _class3$z = function(_Component) {
    function PageViewIndicatorComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, PageViewIndicatorComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PageViewIndicatorComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "spacing", _descriptor$15, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_spriteFrame", _descriptor2$V, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor3$K, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_cellSize", _descriptor4$C, _assertThisInitialized(_this)), 
        _this._layout = null, _this._pageView = null, _this._indicators = [], _this;
    }
    return _inherits(PageViewIndicatorComponent, Component), _createClass(PageViewIndicatorComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._updateLayout();
        }
    }, {
        key: "setPageView",
        value: function setPageView(target) {
            this._pageView = target, this._refresh();
        }
    }, {
        key: "_updateLayout",
        value: function _updateLayout() {
            this._layout = this.getComponent(LayoutComponent), this._layout || (this._layout = this.addComponent(LayoutComponent));
            var layout = this._layout;
            this.direction === Direction$2.HORIZONTAL ? (layout.type = LayoutComponent.Type.HORIZONTAL, 
            layout.spacingX = this.spacing) : this.direction === Direction$2.VERTICAL && (layout.type = LayoutComponent.Type.VERTICAL, 
            layout.spacingY = this.spacing), layout.resizeMode = LayoutComponent.ResizeMode.CONTAINER;
        }
    }, {
        key: "_createIndicator",
        value: function _createIndicator() {
            var node = new Node$1;
            return node.addComponent(SpriteComponent).spriteFrame = this.spriteFrame, node.parent = this.node, 
            node.width = this.cellSize.width, node.height = this.cellSize.height, node;
        }
    }, {
        key: "_changedState",
        value: function _changedState() {
            var indicators = this._indicators;
            if (0 !== indicators.length && this._pageView) {
                var idx = this._pageView.curPageIdx;
                if (!(idx >= indicators.length)) {
                    for (var i = 0; i < indicators.length; ++i) {
                        var node = indicators[i];
                        if (node._uiProps.uiComp) {
                            var uiComp = node._uiProps.uiComp;
                            _color.set(uiComp.color), _color.a = 127.5, uiComp.color = _color;
                        }
                    }
                    if (indicators[idx]._uiProps.uiComp) {
                        var comp = indicators[idx]._uiProps.uiComp;
                        _color.set(comp.color), _color.a = 255, comp.color = _color;
                    }
                }
            }
        }
    }, {
        key: "_refresh",
        value: function _refresh() {
            if (this._pageView) {
                var indicators = this._indicators, pages = this._pageView.getPages();
                if (pages.length !== indicators.length) {
                    var i = 0;
                    if (pages.length > indicators.length) for (i = 0; i < pages.length; ++i) indicators[i] || (indicators[i] = this._createIndicator()); else for (i = indicators.length - pages.length; i > 0; --i) {
                        var node = indicators[i - 1];
                        this.node.removeChild(node), indicators.splice(i - 1, 1);
                    }
                    this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout(), 
                    this._changedState();
                }
            }
        }
    }, {
        key: "spriteFrame",
        get: function get() {
            return this._spriteFrame;
        },
        set: function set(value) {
            this._spriteFrame !== value && (this._spriteFrame = value);
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction !== value && (this._direction = value);
        }
    }, {
        key: "cellSize",
        get: function get() {
            return this._cellSize;
        },
        set: function set(value) {
            this._cellSize !== value && (this._cellSize = value);
        }
    } ]), PageViewIndicatorComponent;
}(), _class3$z.Direction = Direction$2, _applyDecoratedDescriptor((_class2$1f = _temp$1j).prototype, "spriteFrame", [ _dec5$C ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "spriteFrame"), _class2$1f.prototype), 
_applyDecoratedDescriptor(_class2$1f.prototype, "direction", [ _dec6$A ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "direction"), _class2$1f.prototype), 
_applyDecoratedDescriptor(_class2$1f.prototype, "cellSize", [ _dec7$t ], Object.getOwnPropertyDescriptor(_class2$1f.prototype, "cellSize"), _class2$1f.prototype), 
_descriptor$15 = _applyDecoratedDescriptor(_class2$1f.prototype, "spacing", [ _dec8$r ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor2$V = _applyDecoratedDescriptor(_class2$1f.prototype, "_spriteFrame", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor3$K = _applyDecoratedDescriptor(_class2$1f.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Direction$2.HORIZONTAL;
    }
}), _descriptor4$C = _applyDecoratedDescriptor(_class2$1f.prototype, "_cellSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Size(20, 20);
    }
}), _class$1r = _class2$1f)) || _class$1r) || _class$1r) || _class$1r) || _class$1r);

cc.PageViewIndicatorComponent = PageViewIndicatorComponent;

var SizeMode$1, Direction$3, EventType$7, _temp_vec2 = new Vec2;

!function(SizeMode) {
    SizeMode[SizeMode.Unified = 0] = "Unified", SizeMode[SizeMode.Free = 1] = "Free";
}(SizeMode$1 || (SizeMode$1 = {})), ccenum(SizeMode$1), function(Direction) {
    Direction[Direction.Horizontal = 0] = "Horizontal", Direction[Direction.Vertical = 1] = "Vertical";
}(Direction$3 || (Direction$3 = {})), ccenum(Direction$3), (EventType$7 || (EventType$7 = {})).PAGE_TURNING = "page-turning";

var _dec$1s, _dec2$12, _dec3$N, _dec4$J, _dec5$E, _dec6$C, _dec7$v, _dec8$t, _class$1t, _class2$1h, PageViewComponent = (_dec$1r = ccclass("cc.PageViewComponent"), 
_dec2$11 = help("i18n:cc.PageViewComponent"), _dec3$M = executionOrder(110), _dec4$I = menu("UI/PageView"), 
_dec5$D = property({
    type: SizeMode$1,
    tooltip: "页面视图中每个页面大小类型"
}), _dec6$B = property({
    type: Direction$3,
    tooltip: "页面视图滚动类型"
}), _dec7$u = property({
    slide: !0,
    range: [ 0, 1, .01 ],
    tooltip: "滚动临界值，默认单位百分比，当拖拽超出该数值时，松开会自动滚动下一页，小于时则还原"
}), _dec8$s = property({
    slide: !0,
    range: [ 0, 1, .01 ],
    tooltip: "设置 PageView PageTurning 事件的发送时机"
}), _dec9$l = property({
    type: PageViewIndicatorComponent,
    tooltip: "页面视图指示器组件"
}), _dec10$f = property({
    tooltip: "快速滑动翻页临界值\n当用户快速滑动时，会根据滑动开始和结束的距离与时间计算出一个速度值\n该值与此临界值相比较，如果大于临界值，则进行自动翻页"
}), _dec11$e = property({
    type: ScrollBarComponent,
    visible: !1,
    override: !0
}), _dec12$d = property({
    type: ScrollBarComponent,
    visible: !1,
    override: !0
}), _dec13$b = property({
    visible: !1,
    override: !0
}), _dec14$a = property({
    visible: !1,
    override: !0
}), _dec15$9 = property({
    visible: !1,
    override: !0
}), _dec16$8 = property({
    visible: !1,
    override: !0,
    type: [ EventHandler ]
}), _dec17$6 = property({
    type: [ EventHandler ],
    tooltip: "滚动视图的事件回调函数"
}), _dec$1r(_class$1s = _dec2$11(_class$1s = _dec3$M(_class$1s = _dec4$I((_temp$1k = _class3$A = function(_ScrollViewComponent) {
    function PageViewComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, PageViewComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PageViewComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "autoPageTurningThreshold", _descriptor$16, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "horizontal", _descriptor2$W, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "vertical", _descriptor3$L, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor4$D, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "scrollEvents", _descriptor5$u, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "pageTurningSpeed", _descriptor6$j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "pageEvents", _descriptor7$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_sizeMode", _descriptor8$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor9$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_scrollThreshold", _descriptor10$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_pageTurningEventTiming", _descriptor11$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_indicator", _descriptor12$8, _assertThisInitialized(_this)), 
        _this._curPageIdx = 0, _this._lastPageIdx = 0, _this._pages = [], _this._initContentPos = new Vec3, 
        _this._scrollCenterOffsetX = [], _this._scrollCenterOffsetY = [], _this._touchBeganPosition = new Vec3, 
        _this._touchEndPosition = new Vec3, _this;
    }
    return _inherits(PageViewComponent, ScrollViewComponent), _createClass(PageViewComponent, [ {
        key: "__preload",
        value: function __preload() {
            this.node.on(exports.SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            _get(_getPrototypeOf(PageViewComponent.prototype), "onEnable", this).call(this), 
            this.node.on(PageViewComponent.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            _get(_getPrototypeOf(PageViewComponent.prototype), "onDisable", this).call(this), 
            this.node.off(PageViewComponent.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            this._initPages(), this.indicator && this.indicator.setPageView(this);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.node.off(exports.SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);
        }
    }, {
        key: "getCurrentPageIndex",
        value: function getCurrentPageIndex() {
            return this._curPageIdx;
        }
    }, {
        key: "setCurrentPageIndex",
        value: function setCurrentPageIndex(index) {
            this.scrollToPage(index, 1);
        }
    }, {
        key: "getPages",
        value: function getPages() {
            return this._pages;
        }
    }, {
        key: "addPage",
        value: function addPage(page) {
            page && -1 === this._pages.indexOf(page) && this.content && (this.content.addChild(page), 
            this._pages.push(page), this._updatePageView());
        }
    }, {
        key: "insertPage",
        value: function insertPage(page, index) {
            index < 0 || !page || -1 !== this._pages.indexOf(page) || !this.content || (index >= this._pages.length ? this.addPage(page) : (this._pages.splice(index, 0, page), 
            this.content.insertChild(page, index), this._updatePageView()));
        }
    }, {
        key: "removePage",
        value: function removePage(page) {
            if (page && this.content) {
                var index = this._pages.indexOf(page);
                -1 !== index ? this.removePageAtIndex(index) : warnID(4300, page.name);
            }
        }
    }, {
        key: "removePageAtIndex",
        value: function removePageAtIndex(index) {
            var pageList = this._pages;
            if (!(index < 0 || index >= pageList.length)) {
                var page = pageList[index];
                page && this.content && (this.content.removeChild(page), pageList.splice(index, 1), 
                this._updatePageView());
            }
        }
    }, {
        key: "removeAllPages",
        value: function removeAllPages() {
            if (this.content) {
                for (var locPages = this._pages, i = 0, len = locPages.length; i < len; i++) this.content.removeChild(locPages[i]);
                this._pages.length = 0, this._updatePageView();
            }
        }
    }, {
        key: "scrollToPage",
        value: function scrollToPage(idx) {
            var timeInSecond = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3;
            idx < 0 || idx >= this._pages.length || (this._curPageIdx = idx, this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, !0), 
            this.indicator && this.indicator._changedState());
        }
    }, {
        key: "getScrollEndedEventTiming",
        value: function getScrollEndedEventTiming() {
            return this.pageTurningEventTiming;
        }
    }, {
        key: "_updatePageView",
        value: function _updatePageView() {
            var layout = this.content.getComponent(LayoutComponent);
            layout && layout.enabled && layout.updateLayout();
            var pageCount = this._pages.length;
            this._curPageIdx >= pageCount && (this._curPageIdx = 0 === pageCount ? 0 : pageCount - 1, 
            this._lastPageIdx = this._curPageIdx);
            for (var contentPos = this._initContentPos, i = 0; i < pageCount; ++i) {
                var pos = this._pages[i].position;
                this.direction === Direction$3.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x) : this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
            }
            this.indicator && this.indicator._refresh();
        }
    }, {
        key: "_updateAllPagesSize",
        value: function _updateAllPagesSize() {
            if (this.content && this.view && this._sizeMode === SizeMode$1.Unified) for (var locPages = this._pages, selfSize = this.view.getContentSize(), i = 0, len = locPages.length; i < len; i++) locPages[i].setContentSize(selfSize);
        }
    }, {
        key: "_handleReleaseLogic",
        value: function _handleReleaseLogic() {
            this._autoScrollToPage(), this._scrolling && (this._scrolling = !1, this._autoScrolling || this._dispatchEvent(PageViewComponent.EventType.SCROLL_ENDED));
        }
    }, {
        key: "_onTouchBegan",
        value: function _onTouchBegan(event, captureListeners) {
            event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchBeganPosition, _temp_vec2.x, _temp_vec2.y, 0), 
            _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchBegan", this).call(this, event, captureListeners);
        }
    }, {
        key: "_onTouchMoved",
        value: function _onTouchMoved(event, captureListeners) {
            _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchMoved", this).call(this, event, captureListeners);
        }
    }, {
        key: "_onTouchEnded",
        value: function _onTouchEnded(event, captureListeners) {
            event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0), 
            _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchEnded", this).call(this, event, captureListeners);
        }
    }, {
        key: "_onTouchCancelled",
        value: function _onTouchCancelled(event, captureListeners) {
            event.touch.getUILocation(_temp_vec2), Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0), 
            _get(_getPrototypeOf(PageViewComponent.prototype), "_onTouchCancelled", this).call(this, event, captureListeners);
        }
    }, {
        key: "_onMouseWheel",
        value: function _onMouseWheel() {}
    }, {
        key: "_syncScrollDirection",
        value: function _syncScrollDirection() {
            this.horizontal = this.direction === Direction$3.Horizontal, this.vertical = this.direction === Direction$3.Vertical;
        }
    }, {
        key: "_syncSizeMode",
        value: function _syncSizeMode() {
            var view = this.view;
            if (this.content && view) {
                var layout = this.content.getComponent(LayoutComponent);
                if (layout) {
                    if (this._sizeMode === SizeMode$1.Free && this._pages.length > 0) {
                        var lastPage = this._pages[this._pages.length - 1];
                        this.direction === Direction$3.Horizontal ? (layout.paddingLeft = (view.width - this._pages[0].width) / 2, 
                        layout.paddingRight = (view.width - lastPage.width) / 2) : this.direction === Direction$3.Vertical && (layout.paddingTop = (view.height - this._pages[0].height) / 2, 
                        layout.paddingBottom = (view.height - lastPage.height) / 2);
                    }
                    layout.updateLayout();
                }
            }
        }
    }, {
        key: "_initPages",
        value: function _initPages() {
            if (this.content) {
                this._initContentPos = this.content.position;
                for (var children = this.content.children, i = 0; i < children.length; ++i) {
                    var page = children[i];
                    this._pages.indexOf(page) >= 0 || this._pages.push(page);
                }
                this._syncScrollDirection(), this._syncSizeMode(), this._updatePageView();
            }
        }
    }, {
        key: "_dispatchPageTurningEvent",
        value: function _dispatchPageTurningEvent() {
            this._lastPageIdx !== this._curPageIdx && (this._lastPageIdx = this._curPageIdx, 
            EventHandler.emitEvents(this.pageEvents, this), this.node.emit(EventType$7.PAGE_TURNING, this));
        }
    }, {
        key: "_isQuicklyScrollable",
        value: function _isQuicklyScrollable(touchMoveVelocity) {
            if (this.direction === Direction$3.Horizontal) {
                if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) return !0;
            } else if (this.direction === Direction$3.Vertical && Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) return !0;
            return !1;
        }
    }, {
        key: "_moveOffsetValue",
        value: function _moveOffsetValue(idx) {
            var offset = new Vec3;
            if (this._sizeMode === SizeMode$1.Free) this.direction === Direction$3.Horizontal ? offset.x = this._scrollCenterOffsetX[idx] : this.direction === Direction$3.Vertical && (offset.y = this._scrollCenterOffsetY[idx]); else {
                var view = this.view;
                if (!view) return offset;
                this.direction === Direction$3.Horizontal ? offset.x = idx * view.width : this.direction === Direction$3.Vertical && (offset.y = idx * view.height);
            }
            return offset;
        }
    }, {
        key: "_getDragDirection",
        value: function _getDragDirection(moveOffset) {
            return this._direction === Direction$3.Horizontal ? 0 === moveOffset.x ? 0 : moveOffset.x > 0 ? 1 : -1 : 0 === moveOffset.y ? 0 : moveOffset.y < 0 ? 1 : -1;
        }
    }, {
        key: "_isScrollable",
        value: function _isScrollable(offset, index, nextIndex) {
            if (this._sizeMode === SizeMode$1.Free) {
                var curPageCenter = 0, nextPageCenter = 0;
                if (this.direction === Direction$3.Horizontal) return curPageCenter = this._scrollCenterOffsetX[index], 
                nextPageCenter = this._scrollCenterOffsetX[nextIndex], Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                if (this.direction === Direction$3.Vertical) return curPageCenter = this._scrollCenterOffsetY[index], 
                nextPageCenter = this._scrollCenterOffsetY[nextIndex], Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
            } else {
                var view = this.view;
                if (!view) return;
                if (this.direction === Direction$3.Horizontal) return Math.abs(offset.x) >= view.width * this.scrollThreshold;
                if (this.direction === Direction$3.Vertical) return Math.abs(offset.y) >= view.height * this.scrollThreshold;
            }
        }
    }, {
        key: "_autoScrollToPage",
        value: function _autoScrollToPage() {
            var bounceBackStarted = this._startBounceBackIfNeeded(), moveOffset = new Vec3;
            if (Vec3.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition), 
            bounceBackStarted) {
                var dragDirection = this._getDragDirection(moveOffset);
                if (0 === dragDirection) return;
                this._curPageIdx = dragDirection > 0 ? this._pages.length - 1 : 0, this.indicator && this.indicator._changedState();
            } else {
                var index = this._curPageIdx, nextIndex = index + this._getDragDirection(moveOffset), timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
                if (nextIndex < this._pages.length) {
                    if (this._isScrollable(moveOffset, index, nextIndex)) return void this.scrollToPage(nextIndex, timeInSecond);
                    var touchMoveVelocity = this._calculateTouchMoveVelocity();
                    if (this._isQuicklyScrollable(touchMoveVelocity)) return void this.scrollToPage(nextIndex, timeInSecond);
                }
                this.scrollToPage(index, timeInSecond);
            }
        }
    }, {
        key: "sizeMode",
        get: function get() {
            return this._sizeMode;
        },
        set: function set(value) {
            this._sizeMode !== value && (this._sizeMode = value, this._syncSizeMode());
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction !== value && (this._direction = value, this._syncScrollDirection());
        }
    }, {
        key: "scrollThreshold",
        get: function get() {
            return this._scrollThreshold;
        },
        set: function set(value) {
            this._scrollThreshold !== value && (this._scrollThreshold = value);
        }
    }, {
        key: "pageTurningEventTiming",
        get: function get() {
            return this._pageTurningEventTiming;
        },
        set: function set(value) {
            this._pageTurningEventTiming !== value && (this._pageTurningEventTiming = value);
        }
    }, {
        key: "indicator",
        get: function get() {
            return this._indicator;
        },
        set: function set(value) {
            this._indicator !== value && (this._indicator = value, this.indicator && this.indicator.setPageView(this));
        }
    }, {
        key: "curPageIdx",
        get: function get() {
            return this._curPageIdx;
        }
    }, {
        key: "verticalScrollBar",
        get: function get() {
            return _get(_getPrototypeOf(PageViewComponent.prototype), "verticalScrollBar", this);
        },
        set: function set(value) {
            _set(_getPrototypeOf(PageViewComponent.prototype), "verticalScrollBar", value, this, !0);
        }
    }, {
        key: "horizontalScrollBar",
        get: function get() {
            return _get(_getPrototypeOf(PageViewComponent.prototype), "horizontalScrollBar", this);
        },
        set: function set(value) {
            _set(_getPrototypeOf(PageViewComponent.prototype), "horizontalScrollBar", value, this, !0);
        }
    } ]), PageViewComponent;
}(), _class3$A.SizeMode = SizeMode$1, _class3$A.Direction = Direction$3, _class3$A.EventType = extendsEnum(EventType$7, EventType$4), 
_applyDecoratedDescriptor((_class2$1g = _temp$1k).prototype, "sizeMode", [ _dec5$D ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "sizeMode"), _class2$1g.prototype), 
_applyDecoratedDescriptor(_class2$1g.prototype, "direction", [ _dec6$B ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "direction"), _class2$1g.prototype), 
_applyDecoratedDescriptor(_class2$1g.prototype, "scrollThreshold", [ _dec7$u ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "scrollThreshold"), _class2$1g.prototype), 
_applyDecoratedDescriptor(_class2$1g.prototype, "pageTurningEventTiming", [ _dec8$s ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "pageTurningEventTiming"), _class2$1g.prototype), 
_applyDecoratedDescriptor(_class2$1g.prototype, "indicator", [ _dec9$l ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "indicator"), _class2$1g.prototype), 
_descriptor$16 = _applyDecoratedDescriptor(_class2$1g.prototype, "autoPageTurningThreshold", [ _dec10$f ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 100;
    }
}), _applyDecoratedDescriptor(_class2$1g.prototype, "verticalScrollBar", [ _dec11$e ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "verticalScrollBar"), _class2$1g.prototype), 
_applyDecoratedDescriptor(_class2$1g.prototype, "horizontalScrollBar", [ _dec12$d ], Object.getOwnPropertyDescriptor(_class2$1g.prototype, "horizontalScrollBar"), _class2$1g.prototype), 
_descriptor2$W = _applyDecoratedDescriptor(_class2$1g.prototype, "horizontal", [ _dec13$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor3$L = _applyDecoratedDescriptor(_class2$1g.prototype, "vertical", [ _dec14$a ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$D = _applyDecoratedDescriptor(_class2$1g.prototype, "cancelInnerEvents", [ _dec15$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor5$u = _applyDecoratedDescriptor(_class2$1g.prototype, "scrollEvents", [ _dec16$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor6$j = _applyDecoratedDescriptor(_class2$1g.prototype, "pageTurningSpeed", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .3;
    }
}), _descriptor7$h = _applyDecoratedDescriptor(_class2$1g.prototype, "pageEvents", [ _dec17$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor8$f = _applyDecoratedDescriptor(_class2$1g.prototype, "_sizeMode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return SizeMode$1.Unified;
    }
}), _descriptor9$e = _applyDecoratedDescriptor(_class2$1g.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Direction$3.Horizontal;
    }
}), _descriptor10$d = _applyDecoratedDescriptor(_class2$1g.prototype, "_scrollThreshold", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .5;
    }
}), _descriptor11$9 = _applyDecoratedDescriptor(_class2$1g.prototype, "_pageTurningEventTiming", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor12$8 = _applyDecoratedDescriptor(_class2$1g.prototype, "_indicator", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$1s = _class2$1g)) || _class$1s) || _class$1s) || _class$1s) || _class$1s);

cc.PageViewComponent = PageViewComponent;

var _class$1u, _class2$1i, _descriptor$17, UIStaticBatchComponent = (_dec$1s = ccclass("cc.UIStaticBatchComponent"), 
_dec2$12 = help("i18n:cc.UIStaticBatchComponent"), _dec3$N = menu("UI/Render/UIStaticBatch"), 
_dec4$J = executionOrder(110), _dec5$E = property({
    visible: !1,
    override: !0
}), _dec6$C = property({
    visible: !1,
    override: !0
}), _dec7$v = property({
    visible: !1,
    override: !0
}), _dec8$t = property({
    type: Material,
    displayOrder: 3,
    visible: !1,
    override: !0
}), _dec$1s(_class$1t = _dec2$12(_class$1t = _dec3$N(_class$1t = _dec4$J((_applyDecoratedDescriptor((_class2$1h = function(_UIRenderComponent) {
    function UIStaticBatchComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UIStaticBatchComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIStaticBatchComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._init = !1, 
        _this._meshBuffer = null, _this._dirty = !0, _this._lastMeshBuffer = null, _this._uiDrawBatchList = [], 
        _this;
    }
    return _inherits(UIStaticBatchComponent, UIRenderComponent), _createClass(UIStaticBatchComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            var ui = this._getUI();
            if (ui) {
                var attr = vfmt, buffer = new MeshBuffer(ui);
                buffer.initialize(attr, this._arrivalMaxBuffer), this._meshBuffer = buffer;
            }
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(UIStaticBatchComponent.prototype), "onDestroy", this).call(this), 
            this._clearData(), this._meshBuffer && (this._meshBuffer.destroy(), this._meshBuffer = null);
        }
    }, {
        key: "updateAssembler",
        value: function updateAssembler(render) {
            this._dirty && (render.finishMergeBatches(), this._lastMeshBuffer = render.currBufferBatch, 
            render.currBufferBatch = this._meshBuffer, render.currStaticRoot = this), this._init && (render.finishMergeBatches(), 
            render.commitStaticBatch(this));
        }
    }, {
        key: "postUpdateAssembler",
        value: function postUpdateAssembler(render) {
            this._dirty && (render.finishMergeBatches(), render.currBufferBatch = this._lastMeshBuffer, 
            render.currStaticRoot = null, this._dirty = !1, this._init = !0, this.node._static = !0, 
            this._meshBuffer.uploadData());
        }
    }, {
        key: "markAsDirty",
        value: function markAsDirty() {
            this._getUI() && (this.node._static = !1, this._dirty = !0, this._init = !1, this._clearData());
        }
    }, {
        key: "_requireDrawBatch",
        value: function _requireDrawBatch() {
            var batch = new UIDrawBatch;
            return batch.isStatic = !0, this._uiDrawBatchList.push(batch), batch;
        }
    }, {
        key: "_clearData",
        value: function _clearData() {
            if (this._meshBuffer) {
                this._meshBuffer.reset();
                for (var ui = this._getUI(), i = 0; i < this._uiDrawBatchList.length; i++) {
                    this._uiDrawBatchList[i].destroy(ui);
                }
            }
            this._uiDrawBatchList.length = 0, this._init = !1;
        }
    }, {
        key: "_getUI",
        value: function _getUI() {
            return director.root && director.root.ui ? director.root.ui : (warnID(9301), null);
        }
    }, {
        key: "_arrivalMaxBuffer",
        value: function _arrivalMaxBuffer() {
            warnID(9300);
        }
    }, {
        key: "dstBlendFactor",
        get: function get() {
            return this._dstBlendFactor;
        },
        set: function set(value) {
            this._dstBlendFactor !== value && (this._dstBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "srcBlendFactor",
        get: function get() {
            return this._srcBlendFactor;
        },
        set: function set(value) {
            this._srcBlendFactor !== value && (this._srcBlendFactor = value, this._updateBlendFunc());
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(value) {
            this._color !== value && (this._color.set(value), this._updateColor(), this.markForUpdateRenderData());
        }
    }, {
        key: "sharedMaterial",
        get: function get() {
            return this._sharedMaterial;
        },
        set: function set(value) {
            this._sharedMaterial !== value && (this._sharedMaterial = value, this._instanceMaterial && this._instanceMaterial());
        }
    }, {
        key: "drawBatchList",
        get: function get() {
            return this._uiDrawBatchList;
        }
    } ]), UIStaticBatchComponent;
}()).prototype, "dstBlendFactor", [ _dec5$E ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "dstBlendFactor"), _class2$1h.prototype), 
_applyDecoratedDescriptor(_class2$1h.prototype, "srcBlendFactor", [ _dec6$C ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "srcBlendFactor"), _class2$1h.prototype), 
_applyDecoratedDescriptor(_class2$1h.prototype, "color", [ _dec7$v ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "color"), _class2$1h.prototype), 
_applyDecoratedDescriptor(_class2$1h.prototype, "sharedMaterial", [ _dec8$t ], Object.getOwnPropertyDescriptor(_class2$1h.prototype, "sharedMaterial"), _class2$1h.prototype), 
_class$1t = _class2$1h)) || _class$1t) || _class$1t) || _class$1t) || _class$1t), UIOpacityComponent = ccclass("cc.UIOpacityComponent")(_class$1u = help("i18n:cc.UIOpacityComponent")(_class$1u = executionOrder(110)(_class$1u = menu("UI/UIOpacity")(_class$1u = executeInEditMode((_applyDecoratedDescriptor((_class2$1i = function(_Component) {
    function UIOpacityComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, UIOpacityComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIOpacityComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_opacity", _descriptor$17, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(UIOpacityComponent, Component), _createClass(UIOpacityComponent, [ {
        key: "onEnable",
        value: function onEnable() {
            this.node._uiProps.opacity = this._opacity / 255;
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.node._uiProps.opacity = 1;
        }
    }, {
        key: "opacity",
        get: function get() {
            return this._opacity;
        },
        set: function set(value) {
            this._opacity !== value && (this._opacity = value, this.node._uiProps.opacity = value / 255);
        }
    } ]), UIOpacityComponent;
}()).prototype, "opacity", [ property ], Object.getOwnPropertyDescriptor(_class2$1i.prototype, "opacity"), _class2$1i.prototype), 
_descriptor$17 = _applyDecoratedDescriptor(_class2$1i.prototype, "_opacity", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 255;
    }
}), _class$1u = _class2$1i)) || _class$1u) || _class$1u) || _class$1u) || _class$1u) || _class$1u, _tempPos$2 = new Vec3, _defaultAnchor = new Vec2, tInverseTranslate = new Vec3, tInverseScale = new Vec3(1, 1, 1);

function align(node, widget) {
    var target, hasTarget = widget.target, inverseTranslate = tInverseTranslate, inverseScale = tInverseScale;
    if (hasTarget ? computeInverseTransForTarget(node, target = hasTarget, inverseTranslate, inverseScale) : target = node.parent, 
    target.getComponent(UITransformComponent)) {
        var targetSize = getReadonlyNodeSize(target), isScene = target instanceof Scene, targetAnchor = isScene ? _defaultAnchor : target.getAnchorPoint(), isRoot = isScene;
        node.getPosition(_tempPos$2);
        var x = _tempPos$2.x, y = _tempPos$2.y, anchor = node.getAnchorPoint(), scale = node.getScale();
        if (widget.alignFlags & AlignFlags.HORIZONTAL) {
            var localLeft = 0, localRight = 0, targetWidth = targetSize.width;
            isRoot ? (localLeft = visibleRect.left.x, localRight = visibleRect.right.x) : localRight = (localLeft = -targetAnchor.x * targetWidth) + targetWidth, 
            localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth, localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth, 
            hasTarget && (localLeft += inverseTranslate.x, localLeft *= inverseScale.x, localRight += inverseTranslate.x, 
            localRight *= inverseScale.x);
            var width = 0, anchorX = anchor.x, scaleX = scale.x;
            if (scaleX < 0 && (anchorX = 1 - anchorX, scaleX = -scaleX), widget.isStretchWidth) width = localRight - localLeft, 
            0 !== scaleX && (node.width = width / scaleX), x = localLeft + anchorX * width; else if (width = node.width * scaleX, 
            widget.isAlignHorizontalCenter) {
                var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth, targetCenter = (.5 - targetAnchor.x) * targetSize.width;
                hasTarget && (localHorizontalCenter *= inverseScale.x, targetCenter += inverseTranslate.x, 
                targetCenter *= inverseScale.x), x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
            } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
            widget._lastSize.width = width;
        }
        if (widget.alignFlags & AlignFlags.VERTICAL) {
            var localTop = 0, localBottom = 0, targetHeight = targetSize.height;
            isRoot ? (localBottom = visibleRect.bottom.y, localTop = visibleRect.top.y) : localTop = (localBottom = -targetAnchor.y * targetHeight) + targetHeight, 
            localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight, 
            localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight, hasTarget && (localBottom += inverseTranslate.y, 
            localBottom *= inverseScale.y, localTop += inverseTranslate.y, localTop *= inverseScale.y);
            var height = 0, anchorY = anchor.y, scaleY = scale.y;
            if (scaleY < 0 && (anchorY = 1 - anchorY, scaleY = -scaleY), widget.isStretchHeight) height = localTop - localBottom, 
            0 !== scaleY && (node.height = height / scaleY), y = localBottom + anchorY * height; else if (height = node.height * scaleY, 
            widget.isAlignVerticalCenter) {
                var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight, targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
                hasTarget && (localVerticalCenter *= inverseScale.y, targetMiddle += inverseTranslate.y, 
                targetMiddle *= inverseScale.y), y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
            } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
            widget._lastSize.height = height;
        }
        node.setPosition(x, y, _tempPos$2.z), Vec3.set(widget._lastPos, x, y, _tempPos$2.z);
    }
}

function refreshScene() {
    var scene = director.getScene();
    if (scene) {
        if (widgetManager.isAligning = !0, widgetManager._nodesOrderDirty) activeWidgets.length = 0, 
        function visitNode$1(node) {
            var widget = node.getComponent(exports.WidgetComponent);
            if (widget) if (align(node, widget), widget.alignMode !== AlignMode.ALWAYS) widget.enabled = !1; else {
                if (!cc.isValid(node, !0)) return;
                activeWidgets.push(widget);
            }
            for (var _step, _iterator = _createForOfIteratorHelperLoose(node.children); !(_step = _iterator()).done; ) {
                var child = _step.value;
                child.active && visitNode$1(child);
            }
        }(scene), widgetManager._nodesOrderDirty = !1; else {
            var widget = null, iterator = widgetManager._activeWidgetsIterator;
            for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) (widget = activeWidgets[iterator.i])._dirty && (align(widget.node, widget), 
            widget._dirty = !1);
        }
        widgetManager.isAligning = !1;
    }
}

var activeWidgets = [];

var canvasList = [], widgetManager = cc._widgetManager = {
    isAligning: !1,
    _nodesOrderDirty: !1,
    _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
    animationState: null,
    init: function init(director) {
        director.on(Director.EVENT_AFTER_UPDATE, refreshScene), sys.isMobile ? window.addEventListener("resize", this.onResized.bind(this)) : View.instance.on("design-resolution-changed", this.onResized, this);
    },
    add: function add(widget) {
        this._nodesOrderDirty = !0;
        var canvasComp = director.root.ui.getScreen(widget.node._uiProps.uiTransformComp.visibility);
        canvasComp && -1 === canvasList.indexOf(canvasComp) && (canvasList.push(canvasComp), 
        canvasComp.node.on("design-resolution-changed", this.onResized, this));
    },
    remove: function remove(widget) {
        this._activeWidgetsIterator.remove(widget);
    },
    onResized: function onResized() {
        var scene = director.getScene();
        scene && this.refreshWidgetOnResized(scene);
    },
    refreshWidgetOnResized: function refreshWidgetOnResized(node) {
        if (Node$1.isNode(node)) {
            var widget = node.getComponent(exports.WidgetComponent);
            widget && widget.alignMode === AlignMode.ON_WINDOW_RESIZE && (widget.enabled = !0);
        }
        for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(node.children); !(_step2 = _iterator2()).done; ) {
            var child = _step2.value;
            this.refreshWidgetOnResized(child);
        }
    },
    updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
        function i(t, c) {
            return Math.abs(t - c) > 1e-10 ? c : t;
        }
        var widgetNode = widget.node, widgetParent = widgetNode.parent;
        if (widgetParent) {
            var zero = new Vec3, one = new Vec3(1, 1, 1);
            if (widget.target && computeInverseTransForTarget(widgetNode, widgetParent = widget.target, zero, one), 
            !e) return;
            if (!widgetParent.getComponent(UITransformComponent)) return void cc.warnID(6501, widget.node.name);
            var parentAP = widgetParent.getAnchorPoint(), matchSize = getReadonlyNodeSize(widgetParent), myAP = widgetNode.getAnchorPoint(), pos = widgetNode.getPosition(), alignFlags = AlignFlags, widgetNodeScale = widgetNode.getScale(), temp = 0;
            if (e & alignFlags.LEFT) {
                var l = -parentAP.x * matchSize.width;
                l += zero.x, l *= one.x, temp = pos.x - myAP.x * widgetNode.width * widgetNodeScale.x - l, 
                widget.isAbsoluteLeft || (temp /= matchSize.width), temp /= one.x, widget.left = i(widget.left, temp);
            }
            if (e & alignFlags.RIGHT) {
                var r = (1 - parentAP.x) * matchSize.width;
                r += zero.x, temp = (r *= one.x) - (pos.x + (1 - myAP.x) * widgetNode.width * widgetNodeScale.x), 
                widget.isAbsoluteRight || (temp /= matchSize.width), temp /= one.x, widget.right = i(widget.right, temp);
            }
            if (e & alignFlags.TOP) {
                var t = (1 - parentAP.y) * matchSize.height;
                t += zero.y, temp = (t *= one.y) - (pos.y + (1 - myAP.y) * widgetNode.height * widgetNodeScale.y), 
                widget.isAbsoluteTop || (temp /= matchSize.height), temp /= one.y, widget.top = i(widget.top, temp);
            }
            if (e & alignFlags.BOT) {
                var b = -parentAP.y * matchSize.height;
                b += zero.y, b *= one.y, temp = pos.y - myAP.y * widgetNode.height * widgetNodeScale.y - b, 
                widget.isAbsoluteBottom || (temp /= matchSize.height), temp /= one.y, widget.bottom = i(widget.bottom, temp);
            }
        }
    },
    updateAlignment: function updateAlignment(node) {
        var parent = node.parent;
        parent && Node$1.isNode(parent) && updateAlignment(parent);
        var widget = node.getComponent(exports.WidgetComponent);
        widget && parent && align(node, widget);
    },
    AlignMode: AlignMode,
    AlignFlags: AlignFlags
};

director.on(Director.EVENT_INIT, (function() {
    widgetManager.init(director);
}));

var Aim = function Aim(i, x, y) {
    _classCallCheck(this, Aim), this.i = void 0, this.x = void 0, this.y = void 0, this.prev = null, 
    this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1, 
    this.i = i, this.x = x, this.y = y;
};

function linkedList(datas, start, end, dim, clockwise) {
    var i = 0, last = null;
    if (clockwise === function signedArea(datas, start, end, dim) {
        for (var sum = 0, i = start, j = end - dim; i < end; i += dim) sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]), 
        j = i;
        return sum;
    }(datas, start, end, dim) > 0) for (i = start; i < end; i += dim) last = insertNode(i, datas[i], datas[i + 1], last); else for (i = end - dim; i >= start; i -= dim) last = insertNode(i, datas[i], datas[i + 1], last);
    return last && equals$1(last, last.next) && (removeNode(last), last = last.next), 
    last;
}

function filterPoints(start) {
    var end = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    if (!start) return start;
    end || (end = start);
    var p = start, again = !1;
    do {
        if (again = !1, p.steiner || !equals$1(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next; else {
            if (removeNode(p), (p = end = p.prev) === p.next) return null;
            again = !0;
        }
    } while (again || p !== end);
    return end;
}

function earcutLinked(ear, triangles, dim, minX, minY, size) {
    var pass = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0;
    if (ear) {
        !pass && size && indexCurve(ear, minX, minY, size);
        for (var stop = ear, prev = null, next = null; ear.prev !== ear.next; ) if (prev = ear.prev, 
        next = ear.next, size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) triangles.push(prev.i / dim), 
        triangles.push(ear.i / dim), triangles.push(next.i / dim), removeNode(ear), ear = next.next, 
        stop = next.next; else if ((ear = next) === stop) {
            pass ? 1 === pass ? earcutLinked(ear = cureLocalIntersections(ear, triangles, dim), triangles, dim, minX, minY, size, 2) : 2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size) : earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
            break;
        }
    }
}

function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return !1;
    for (var p = ear.next.next; p !== ear.prev; ) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
        p = p.next;
    }
    return !0;
}

function isEarHashed(ear, minX, minY, size) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0) return !1;
    for (var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y, minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size), p = ear.nextZ; p && p.z <= maxZ; ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
        p = p.nextZ;
    }
    for (p = ear.prevZ; p && p.z >= minZ; ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
        p = p.prevZ;
    }
    return !0;
}

function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev, b = p.next.next;
        !equals$1(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a) && (triangles.push(a.i / dim), 
        triangles.push(p.i / dim), triangles.push(b.i / dim), removeNode(p), removeNode(p.next), 
        p = start = b), p = p.next;
    } while (p !== start);
    return p;
}

function splitEarcut(start, triangles, dim, minX, minY, size) {
    var a = start;
    do {
        for (var b = a.next.next; b !== a.prev; ) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                var c = splitPolygon(a, b);
                return a = filterPoints(a, a.next), c = filterPoints(c, c.next), earcutLinked(a, triangles, dim, minX, minY, size), 
                void earcutLinked(c, triangles, dim, minX, minY, size);
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

function compareX(a, b) {
    return a.x - b.x;
}

function eliminateHole(hole, outerNode) {
    if (outerNode = function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -1 / 0, m = null;
        do {
            if (hy <= p.y && hy >= p.next.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    if (qx = x, x === hx) {
                        if (hy === p.y) return p;
                        if (hy === p.next.y) return p.next;
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m) return null;
        if (hx === qx) return m.prev;
        var tan, stop = m, mx = m.x, my = m.y, tanMin = 1 / 0;
        p = m.next;
        for (;p !== stop; ) hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y) && ((tan = Math.abs(hy - p.y) / (hx - p.x)) < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole) && (m = p, 
        tanMin = tan), p = p.next;
        return m;
    }(hole, outerNode)) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

function indexCurve(start, minX, minY, size) {
    var p = start;
    do {
        null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size)), p.prevZ = p.prev, p.nextZ = p.next, 
        p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null, p.prevZ = null, function sortLinked(list) {
        var i = 0, p = null, q = null, e = null, tail = null, numMerges = 0, pSize = 0, qSize = 0, inSize = 1;
        do {
            for (p = list, list = null, tail = null, numMerges = 0; p; ) {
                for (numMerges++, q = p, pSize = 0, i = 0; i < inSize && (pSize++, q = q.nextZ); i++) ;
                for (qSize = inSize; pSize > 0 || qSize > 0 && q; ) 0 === pSize ? (e = q, q = q.nextZ, 
                qSize--) : 0 !== qSize && q ? p.z <= q.z ? (e = p, p = p.nextZ, pSize--) : (e = q, 
                q = q.nextZ, qSize--) : (e = p, p = p.nextZ, pSize--), tail ? tail.nextZ = e : list = e, 
                e.prevZ = tail, tail = e;
                p = q;
            }
            tail.nextZ = null, inSize *= 2;
        } while (numMerges > 1);
        return list;
    }(p);
}

function zOrder(x, y, minX, minY, size) {
    return (x = 1431655765 & ((x = 858993459 & ((x = 252645135 & ((x = 16711935 & ((x = 32767 * (x - minX) / size) | x << 8)) | x << 4)) | x << 2)) | x << 1)) | (y = 1431655765 & ((y = 858993459 & ((y = 252645135 & ((y = 16711935 & ((y = 32767 * (y - minY) / size) | y << 8)) | y << 4)) | y << 2)) | y << 1)) << 1;
}

function getLeftmost(start) {
    var p = start, leftmost = start;
    do {
        p.x < leftmost.x && (leftmost = p), p = p.next;
    } while (p !== start);
    return leftmost;
}

function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !function intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return !0;
            p = p.next;
        } while (p !== a);
        return !1;
    }(a, b) && locallyInside(a, b) && locallyInside(b, a) && function middleInside(a, b) {
        var p = a, inside = !1, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside), 
            p = p.next;
        } while (p !== a);
        return inside;
    }(a, b);
}

function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

function equals$1(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

function intersects(p1, q1, p2, q2) {
    return !!(equals$1(p1, q1) && equals$1(p2, q2) || equals$1(p1, q2) && equals$1(p2, q1)) || area(p1, q1, p2) > 0 != area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 != area(p2, q2, q1) > 0;
}

function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

function splitPolygon(a, b) {
    var a2 = new Aim(a.i, a.x, a.y), b2 = new Aim(b.i, b.x, b.y), an = a.next, bp = b.prev;
    return a.next = b, b.prev = a, a2.next = an, an.prev = a2, b2.next = a2, a2.prev = b2, 
    bp.next = b2, b2.prev = bp, b2;
}

function insertNode(i, x, y, last) {
    var p = new Aim(i, x, y);
    return last ? (p.next = last.next, p.prev = last, last.next.prev = p, last.next = p) : (p.prev = p, 
    p.next = p), p;
}

function removeNode(p) {
    p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), 
    p.nextZ && (p.nextZ.prevZ = p.prevZ);
}

function earcut(datas, holeIndices, dim) {
    dim = dim || 3;
    var hasHoles = holeIndices ? holeIndices.length : 0, outerLen = hasHoles ? holeIndices[0] * dim : datas.length, outerNode = linkedList(datas, 0, outerLen, dim, !0), triangles = [];
    if (!outerNode) return triangles;
    var minX = 0, minY = 0, maxX = 0, maxY = 0, x = 0, y = 0, size = 0;
    if (hasHoles && (outerNode = function eliminateHoles(datas, holeIndices, outerNode, dim) {
        var len, queue = [], i = 0, list = null;
        for (i = 0, len = holeIndices.length; i < len; i++) (list = linkedList(datas, holeIndices[i] * dim, i < len - 1 ? holeIndices[i + 1] * dim : datas.length, dim, !1)) && (list === list.next && (list.steiner = !0), 
        queue.push(getLeftmost(list)));
        if (queue.sort(compareX), !outerNode) return outerNode;
        for (i = 0; i < queue.length; i++) eliminateHole(queue[i], outerNode), outerNode = filterPoints(outerNode, outerNode.next);
        return outerNode;
    }(datas, holeIndices, outerNode, dim)), datas.length > 80 * dim) {
        minX = maxX = datas[0], minY = maxY = datas[1];
        for (var i = dim; i < outerLen; i += dim) (x = datas[i]) < minX && (minX = x), (y = datas[i + 1]) < minY && (minY = y), 
        x > maxX && (maxX = x), y > maxY && (maxY = y);
        size = Math.max(maxX - minX, maxY - minY);
    }
    return earcutLinked(outerNode, triangles, dim, minX, minY, size), triangles;
}

var PI = Math.PI, min$2 = Math.min, max$3 = Math.max, cos$1 = Math.cos, sin = Math.sin, abs$1 = Math.abs, sign$1 = Math.sign, KAPPA90 = .5522847493;

function ellipse(ctx, cx, cy, rx, ry) {
    ctx.moveTo(cx - rx, cy), ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry), 
    ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy), 
    ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry), 
    ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy), 
    ctx.close();
}

for (var Point = function(_Vec) {
    function Point(x, y) {
        var _this;
        return _classCallCheck(this, Point), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Point).call(this, x, y))).dx = 0, 
        _this.dy = 0, _this.dmx = 0, _this.dmy = 0, _this.flags = 0, _this.len = 0, _this.reset(), 
        _this;
    }
    return _inherits(Point, Vec2), _createClass(Point, [ {
        key: "reset",
        value: function reset() {
            this.dx = 0, this.dy = 0, this.dmx = 0, this.dmy = 0, this.flags = 0, this.len = 0;
        }
    } ]), Point;
}(), Path = function() {
    function Path() {
        _classCallCheck(this, Path), this.closed = !1, this.nbevel = 0, this.complex = !0, 
        this.points = [], this.reset();
    }
    return _createClass(Path, [ {
        key: "reset",
        value: function reset() {
            this.closed = !1, this.nbevel = 0, this.complex = !0, this.points ? this.points.length = 0 : this.points = [];
        }
    } ]), Path;
}(), Impl = function() {
    function Impl() {
        _classCallCheck(this, Impl), this.dataOffset = 0, this.updatePathOffset = !1, this.pathLength = 0, 
        this.pathOffset = 0, this.paths = [], this.tessTol = .25, this.distTol = .01, this.fillColor = Color.WHITE.clone(), 
        this.lineCap = LineCap.BUTT, this.strokeColor = Color.BLACK.clone(), this.lineJoin = LineJoin.MITER, 
        this.lineWidth = 0, this.pointsOffset = 0, this._commandx = 0, this._commandy = 0, 
        this._points = [], this._renderDatasPool = new RecyclePool((function() {
            return new MeshRenderData;
        }), 16), this._renderDatas = [], this._curPath = null;
    }
    return _createClass(Impl, [ {
        key: "moveTo",
        value: function moveTo(x, y) {
            this.updatePathOffset && (this.pathOffset = this.pathLength, this.updatePathOffset = !1), 
            this._addPath(), this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, 
            this._commandy = y;
        }
    }, {
        key: "lineTo",
        value: function lineTo(x, y) {
            this.addPoint(x, y, PointFlags.PT_CORNER), this._commandx = x, this._commandy = y;
        }
    }, {
        key: "bezierCurveTo",
        value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
            var path = this._curPath, last = path.points[path.points.length - 1];
            last && (last.x !== c1x || last.y !== c1y || c2x !== x || c2y !== y ? (!function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
                var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234, dx, dy, d2, d3;
                level > 10 || (x34 = .5 * (x3 + x4), y34 = .5 * (y3 + y4), x123 = .5 * ((x12 = .5 * (x1 + x2)) + (x23 = .5 * (x2 + x3))), 
                y123 = .5 * ((y12 = .5 * (y1 + y2)) + (y23 = .5 * (y2 + y3))), ((d2 = abs$1((x2 - x4) * (dy = y4 - y1) - (y2 - y4) * (dx = x4 - x1))) + (d3 = abs$1((x3 - x4) * dy - (y3 - y4) * dx))) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy) ? ctx.addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type) : (tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234 = .5 * (x123 + (x234 = .5 * (x23 + x34))), y1234 = .5 * (y123 + (y234 = .5 * (y23 + y34))), level + 1, 0), 
                tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type)));
            }(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER), this._commandx = x, 
            this._commandy = y) : this.lineTo(x, y));
        }
    }, {
        key: "quadraticCurveTo",
        value: function quadraticCurveTo(cx, cy, x, y) {
            var x0 = this._commandx, y0 = this._commandy;
            this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
        }
    }, {
        key: "arc",
        value: function arc$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
            !function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
                var hda, ndivs, a = 0, da = 0, kappa = 0, dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0, px = 0, py = 0, ptanx = 0, ptany = 0, i = 0;
                if (da = endAngle - startAngle, counterclockwise = counterclockwise || !1) if (abs$1(da) >= 2 * PI) da = 2 * PI; else for (;da < 0; ) da += 2 * PI; else if (abs$1(da) >= 2 * PI) da = 2 * -PI; else for (;da > 0; ) da -= 2 * PI;
                for (ndivs = 0 | max$3(1, min$2(abs$1(da) / (.5 * PI) + .5, 5)), kappa = abs$1(4 / 3 * (1 - cos$1(hda = da / ndivs / 2)) / sin(hda)), 
                counterclockwise || (kappa = -kappa), i = 0; i <= ndivs; i++) x = cx + (dx = cos$1(a = startAngle + da * (i / ndivs))) * r, 
                y = cy + (dy = sin(a)) * r, tanx = -dy * r * kappa, tany = dx * r * kappa, 0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y), 
                px = x, py = y, ptanx = tanx, ptany = tany;
            }(this, cx, cy, r, startAngle, endAngle, counterclockwise);
        }
    }, {
        key: "ellipse",
        value: function ellipse$1(cx, cy, rx, ry) {
            ellipse(this, cx, cy, rx, ry), this._curPath.complex = !1;
        }
    }, {
        key: "circle",
        value: function circle(cx, cy, r) {
            ellipse(this, cx, cy, r, r), this._curPath.complex = !1;
        }
    }, {
        key: "rect",
        value: function rect(x, y, w, h) {
            this.moveTo(x, y), this.lineTo(x + w, y), this.lineTo(x + w, y + h), this.lineTo(x, y + h), 
            this.close(), this._curPath.complex = !1;
        }
    }, {
        key: "roundRect",
        value: function roundRect$1(x, y, w, h, r) {
            !function roundRect(ctx, x, y, w, h, r) {
                if (r < .1) ctx.rect(x, y, w, h); else {
                    var rx = min$2(r, .5 * abs$1(w)) * sign$1(w), ry = min$2(r, .5 * abs$1(h)) * sign$1(h);
                    ctx.moveTo(x, y + ry), ctx.lineTo(x, y + h - ry), ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h), 
                    ctx.lineTo(x + w - rx, y + h), ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry), 
                    ctx.lineTo(x + w, y + ry), ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y), 
                    ctx.lineTo(x + rx, y), ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry), 
                    ctx.close();
                }
            }(this, x, y, w, h, r), this._curPath.complex = !1;
        }
    }, {
        key: "clear",
        value: function clear() {
            var clean = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            this.pathLength = 0, this.pathOffset = 0, this.pointsOffset = 0, this.dataOffset = 0, 
            this._curPath = null, this.paths.length = 0, this._points.length = 0;
            for (var datas = this._renderDatas, i = 0, l = datas.length; i < l; i++) {
                var data = datas[i];
                data && data.reset();
            }
            this._renderDatas.length = 0, clean && this._renderDatasPool.reset();
        }
    }, {
        key: "close",
        value: function close() {
            this._curPath.closed = !0;
        }
    }, {
        key: "requestRenderData",
        value: function requestRenderData() {
            var renderData = this._renderDatasPool.add();
            return this._renderDatas.push(renderData), renderData;
        }
    }, {
        key: "getRenderDatas",
        value: function getRenderDatas() {
            return 0 === this._renderDatas.length && this.requestRenderData(), this._renderDatas;
        }
    }, {
        key: "addPoint",
        value: function addPoint(x, y, flags) {
            var path = this._curPath;
            if (path) {
                var points = this._points, pathPoints = path.points, pt = points[this.pointsOffset++];
                pt ? (pt.x = x, pt.y = y) : (pt = new Point(x, y), points.push(pt)), pt.flags = flags, 
                pathPoints.push(pt);
            }
        }
    }, {
        key: "_addPath",
        value: function _addPath() {
            var offset = this.pathLength, path = this.paths[offset];
            return path ? path.reset() : (path = new Path, this.paths.push(path)), this.pathLength++, 
            this._curPath = path, path;
        }
    } ]), Impl;
}(), PI$1 = Math.PI, min$3 = Math.min, max$4 = Math.max, ceil = Math.ceil, acos$1 = Math.acos, cos$2 = Math.cos, sin$1 = Math.sin, atan2 = Math.atan2, attrs = vfmt, positions = [], uvs = [], colors$2 = [], indices = [], _renderData = null, _impl = null, _curColor = new Color, vec3_temps = [], i$1 = 0; i$1 < 4; i$1++) vec3_temps.push(new Vec3);

function clamp$1(v, minNum, maxNum) {
    return v < minNum ? minNum : v > maxNum ? maxNum : v;
}

var graphicsAssembler = {
    useModel: !0,
    createImpl: function createImpl(graphics) {
        return new Impl;
    },
    updateRenderData: function updateRenderData(graphics) {
        for (var datas = graphics.impl ? graphics.impl.getRenderDatas() : [], _i = 0, l = datas.length; _i < l; _i++) datas[_i].material = graphics.material;
    },
    fillBuffers: function fillBuffers(graphics, renderer) {},
    renderIA: function renderIA(graphics, renderer) {},
    getRenderData: function getRenderData(graphics, cverts) {
        if (!_impl) return null;
        var renderDatas = _impl.getRenderDatas(), renderData = renderDatas[_impl.dataOffset];
        if (!renderData) return null;
        var meshbuffer = renderData, maxVertsCount = meshbuffer ? meshbuffer.vertexCount + cverts : 0;
        return (maxVertsCount > 65535 || 3 * maxVertsCount > 131070) && (++_impl.dataOffset, 
        _impl.dataOffset < renderDatas.length ? renderData = renderDatas[_impl.dataOffset] : (renderData = _impl.requestRenderData(), 
        renderDatas[_impl.dataOffset] = renderData), renderData.material = graphics.material, 
        meshbuffer = renderData), meshbuffer && meshbuffer.vertexCount < maxVertsCount && meshbuffer.request(cverts, 3 * cverts), 
        renderData;
    },
    stroke: function stroke(graphics) {
        Color.copy(_curColor, graphics.strokeColor), graphics.impl && (this._flattenPaths(graphics.impl), 
        this._expandStroke(graphics), graphics.impl.updatePathOffset = !0, this.end(graphics));
    },
    fill: function fill(graphics) {
        Color.copy(_curColor, graphics.fillColor), this._expandFill(graphics), graphics.impl && (graphics.impl.updatePathOffset = !0), 
        this.end(graphics);
    },
    end: function end(graphics) {
        graphics.model && graphics.model.inited && graphics.model.destroy();
        var impl = graphics.impl, primitiveMode = exports.GFXPrimitiveMode.TRIANGLE_LIST, renderDatas = impl && impl.getRenderDatas();
        if (renderDatas) {
            var i = 0;
            positions.length = 0, uvs.length = 0, colors$2.length = 0, indices.length = 0;
            for (var _step, _iterator = _createForOfIteratorHelperLoose(renderDatas); !(_step = _iterator()).done; ) {
                var renderData = _step.value, len = renderData.byteCount >> 2, vData = renderData.vData;
                for (i = 0; i < len; ) positions.push(vData[i++]), positions.push(vData[i++]), positions.push(vData[i++]), 
                uvs.push(vData[i++]), uvs.push(vData[i++]), colors$2.push(vData[i++]), colors$2.push(vData[i++]), 
                colors$2.push(vData[i++]), colors$2.push(vData[i++]);
                len = renderData.indiceCount;
                var iData = renderData.iData;
                for (i = 0; i < len; ) indices.push(iData[i++]);
            }
            var mesh = createMesh({
                primitiveMode: primitiveMode,
                positions: positions,
                uvs: uvs,
                colors: colors$2,
                attributes: attrs,
                indices: indices
            }, void 0, {
                calculateBounds: !1
            });
            graphics.model.initialize(graphics.node), graphics.model.initSubModel(0, mesh.renderingSubMeshes[0], graphics.material), 
            graphics.markForUpdateRenderData();
        }
    },
    _expandStroke: function _expandStroke(graphics) {
        var w = .5 * graphics.lineWidth, lineCap = graphics.lineCap, lineJoin = graphics.lineJoin, miterLimit = graphics.miterLimit;
        if (_impl = graphics.impl) {
            var ncap = function curveDivs(r, arc, tol) {
                var da = 2 * acos$1(r / (r + tol));
                return max$4(2, ceil(arc / da));
            }(w, PI$1, _impl.tessTol);
            this._calculateJoins(_impl, w, lineJoin, miterLimit);
            for (var paths = _impl.paths, cverts = 0, _i2 = _impl.pathOffset, l = _impl.pathLength; _i2 < l; _i2++) {
                var path = paths[_i2], pointsLength = path.points.length;
                lineJoin === LineJoin.ROUND ? cverts += 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : cverts += 2 * (pointsLength + 5 * path.nbevel + 1), 
                path.closed || (lineCap === LineCap.ROUND ? cverts += 2 * (2 * ncap + 2) : cverts += 12);
            }
            var meshbuffer = _renderData = this.getRenderData(graphics, cverts);
            if (meshbuffer) {
                for (var vData = meshbuffer.vData, iData = meshbuffer.iData, _i3 = _impl.pathOffset, _l = _impl.pathLength; _i3 < _l; _i3++) {
                    var _path = paths[_i3], pts = _path.points, _pointsLength = pts.length, offset = meshbuffer.vertexStart, p0 = void 0, p1 = void 0, start = 0, end = 0, loop = _path.closed;
                    if (loop ? (p0 = pts[_pointsLength - 1], p1 = pts[0], start = 0, end = _pointsLength) : (p0 = pts[0], 
                    p1 = pts[1], start = 1, end = _pointsLength - 1), !loop) {
                        var dPos = new Point(p1.x, p1.y);
                        dPos.subtract(p0), dPos.normalize();
                        var dx = dPos.x, dy = dPos.y;
                        lineCap === LineCap.BUTT ? this._buttCap(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
                    }
                    for (var j = start; j < end; ++j) lineJoin === LineJoin.ROUND ? this._roundJoin(p0, p1, w, w, ncap) : 0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) ? this._bevelJoin(p0, p1, w, w) : (this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w), 
                    this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w)), p0 = p1, p1 = pts[j + 1];
                    if (loop) {
                        var vDataoOfset = 9 * offset, data = vData.slice(vDataoOfset, vDataoOfset + 9);
                        vData.set(data, 9 * meshbuffer.vertexStart), vDataoOfset += 9, meshbuffer.vertexStart++, 
                        data = vData.slice(vDataoOfset, vDataoOfset + 9), vData.set(data, 9 * meshbuffer.vertexStart), 
                        meshbuffer.vertexStart++;
                    } else {
                        var _dPos = new Point(p1.x, p1.y);
                        _dPos.subtract(p0), _dPos.normalize();
                        var _dx = _dPos.x, _dy = _dPos.y;
                        lineCap === LineCap.BUTT ? this._buttCap(p1, _dx, _dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p1, _dx, _dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, _dx, _dy, w, ncap);
                    }
                    for (var indicesOffset = meshbuffer.indiceStart, begin = offset + 2, over = meshbuffer.vertexStart; begin < over; begin++) iData[indicesOffset++] = begin - 2, 
                    iData[indicesOffset++] = begin - 1, iData[indicesOffset++] = begin;
                    if (meshbuffer.indiceStart = indicesOffset, indicesOffset !== meshbuffer.indiceCount) {
                        var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                        meshbuffer.iData.set(arr, indicesOffset);
                    }
                }
                _renderData = null, _impl = null;
            }
        }
    },
    _expandFill: function _expandFill(graphics) {
        if (_impl = graphics.impl) {
            for (var paths = _impl.paths, cverts = 0, _i4 = _impl.pathOffset, l = _impl.pathLength; _i4 < l; _i4++) {
                cverts += paths[_i4].points.length;
            }
            var renderData = _renderData = this.getRenderData(graphics, cverts);
            if (renderData) {
                for (var meshbuffer = renderData, vData = meshbuffer.vData, iData = meshbuffer.iData, _i5 = _impl.pathOffset, _l2 = _impl.pathLength; _i5 < _l2; _i5++) {
                    var _path2 = paths[_i5], pts = _path2.points, _pointsLength2 = pts.length;
                    if (0 !== _pointsLength2) {
                        for (var vertexOffset = renderData.vertexStart, j = 0; j < _pointsLength2; ++j) this._vset(pts[j].x, pts[j].y);
                        var indicesOffset = renderData.indiceStart;
                        if (_path2.complex) {
                            for (var earcutData = [], _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                                var vDataOffset = 9 * _j;
                                earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]), earcutData.push(vData[vDataOffset++]);
                            }
                            var newIndices = earcut(earcutData, null, 3);
                            if (!newIndices || 0 === newIndices.length) continue;
                            for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
                        } else for (var first = vertexOffset, start = vertexOffset + 2, _end = meshbuffer.vertexStart; start < _end; start++) iData[indicesOffset++] = first, 
                        iData[indicesOffset++] = start - 1, iData[indicesOffset++] = start;
                        if (meshbuffer.indiceStart = indicesOffset, indicesOffset !== meshbuffer.indiceCount) {
                            var arr = new Array(meshbuffer.indiceCount - indicesOffset);
                            meshbuffer.iData.set(arr, indicesOffset);
                        }
                    }
                }
                _renderData = null, _impl = null;
            }
        }
    },
    _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
        var iw = 0;
        w > 0 && (iw = 1 / w);
        for (var paths = impl.paths, _i6 = impl.pathOffset, l = impl.pathLength; _i6 < l; _i6++) {
            var path = paths[_i6], pts = path.points, ptsLength = pts.length, p0 = pts[ptsLength - 1], p1 = pts[0];
            path.nbevel = 0;
            for (var j = 0; j < ptsLength; j++) {
                var dmr2, limit, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
                if (p1.dmx = .5 * (dlx0 + dlx1), p1.dmy = .5 * (dly0 + dly1), (dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy) > 1e-6) {
                    var scale = 1 / dmr2;
                    scale > 600 && (scale = 600), p1.dmx *= scale, p1.dmy *= scale;
                }
                p1.dx * p0.dy - p0.dx * p1.dy > 0 && (p1.flags |= PointFlags.PT_LEFT), dmr2 * (limit = max$4(11, min$3(p0.len, p1.len) * iw)) * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL), 
                p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL), 
                0 != (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++, 
                p0 = p1, p1 = pts[j + 1];
            }
        }
    },
    _flattenPaths: function _flattenPaths(impl) {
        for (var paths = impl.paths, _i7 = impl.pathOffset, l = impl.pathLength; _i7 < l; _i7++) {
            var path = paths[_i7], pts = path.points, p0 = pts[pts.length - 1], p1 = pts[0];
            p0.equals(p1) && (path.closed = !0, pts.pop(), p0 = pts[pts.length - 1]);
            for (var j = 0, size = pts.length; j < size; j++) {
                var dPos = new Point(p1.x, p1.y);
                dPos.subtract(p0), p0.len = dPos.length(), (dPos.x || dPos.y) && dPos.normalize(), 
                p0.dx = dPos.x, p0.dy = dPos.y, p0 = p1, p1 = pts[j + 1];
            }
        }
    },
    _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
        var x = p1.x, y = p1.y, x0 = 0, y0 = 0, x1 = 0, y1 = 0;
        return 0 !== bevel ? (x0 = x + p0.dy * w, y0 = y - p0.dx * w, x1 = x + p1.dy * w, 
        y1 = y - p1.dx * w) : (x0 = x1 = x + p1.dmx * w, y0 = y1 = y + p1.dmy * w), [ x0, y0, x1, y1 ];
    },
    _buttCap: function _buttCap(p, dx, dy, w, d) {
        var px = p.x - dx * d, py = p.y - dy * d, dlx = dy, dly = -dx;
        this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
    },
    _roundCapStart: function _roundCapStart(p, dx, dy, w, ncap) {
        for (var px = p.x, py = p.y, dlx = dy, dly = -dx, _i8 = 0; _i8 < ncap; _i8++) {
            var a = _i8 / (ncap - 1) * PI$1, ax = cos$2(a) * w, ay = sin$1(a) * w;
            this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay), this._vset(px, py);
        }
        this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
    },
    _roundCapEnd: function _roundCapEnd(p, dx, dy, w, ncap) {
        var px = p.x, py = p.y, dlx = dy, dly = -dx;
        this._vset(px + dlx * w, py + dly * w), this._vset(px - dlx * w, py - dly * w);
        for (var _i9 = 0; _i9 < ncap; _i9++) {
            var a = _i9 / (ncap - 1) * PI$1, ax = cos$2(a) * w, ay = sin$1(a) * w;
            this._vset(px, py), this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay);
        }
    },
    _roundJoin: function _roundJoin(p0, p1, lw, rw, ncap) {
        var dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx, p1x = p1.x, p1y = p1.y;
        if (0 != (p1.flags & PointFlags.PT_LEFT)) {
            var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw), lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], a0 = atan2(-dly0, -dlx0), a1 = atan2(-dly1, -dlx1);
            a1 > a0 && (a1 -= 2 * PI$1), this._vset(lx0, ly0), this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw);
            for (var n = clamp$1(ceil((a0 - a1) / PI$1) * ncap, 2, ncap), _i10 = 0; _i10 < n; _i10++) {
                var a = a0 + _i10 / (n - 1) * (a1 - a0), rx = p1x + cos$2(a) * rw, ry = p1y + sin$1(a) * rw;
                this._vset(p1x, p1y), this._vset(rx, ry);
            }
            this._vset(lx1, ly1), this._vset(p1x - dlx1 * rw, p1y - dly1 * rw);
        } else {
            var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw), rx0 = _out[0], ry0 = _out[1], rx1 = _out[2], ry1 = _out[3], _a = atan2(dly0, dlx0), _a2 = atan2(dly1, dlx1);
            _a2 < _a && (_a2 += 2 * PI$1), this._vset(p1x + dlx0 * rw, p1y + dly0 * rw, 0), 
            this._vset(rx0, ry0, 0);
            for (var _n = clamp$1(ceil((_a2 - _a) / PI$1) * ncap, 2, ncap), _i11 = 0; _i11 < _n; _i11++) {
                var _a3 = _a + _i11 / (_n - 1) * (_a2 - _a), lx = p1x + cos$2(_a3) * lw, ly = p1y + sin$1(_a3) * lw;
                this._vset(lx, ly, 0), this._vset(p1x, p1y, 0);
            }
            this._vset(p1x + dlx1 * rw, p1y + dly1 * rw), this._vset(rx1, ry1);
        }
    },
    _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
        var rx0 = 0, ry0 = 0, rx1 = 0, ry1 = 0, lx0 = 0, ly0 = 0, lx1 = 0, ly1 = 0, dlx0 = p0.dy, dly0 = -p0.dx, dlx1 = p1.dy, dly1 = -p1.dx;
        if (p1.flags & PointFlags.PT_LEFT) {
            var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
            lx0 = out[0], ly0 = out[1], lx1 = out[2], ly1 = out[3], this._vset(lx0, ly0, 0), 
            this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw, 0), this._vset(lx1, ly1, 0), this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw, 0);
        } else {
            var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
            rx0 = _out2[0], ry0 = _out2[1], rx1 = _out2[2], ry1 = _out2[3], this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw, 0), 
            this._vset(rx0, ry0), this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw, 0), this._vset(rx1, ry1);
        }
    },
    _vset: function _vset(x, y) {
        if (_renderData) {
            var meshbuffer = _renderData, dataOffset = 9 * meshbuffer.vertexStart, vData = meshbuffer.vData;
            vData[dataOffset++] = x, vData[dataOffset++] = y, vData[dataOffset++] = 0, vData[dataOffset++] = 1, 
            vData[dataOffset++] = 1, Color.toArray(vData, _curColor, dataOffset), meshbuffer.vertexStart++;
        }
    }
}, graphicsAssemblerManager = {
    getAssembler: function getAssembler(sprite) {
        return graphicsAssembler;
    }
};

GraphicsComponent.Assembler = graphicsAssemblerManager;

var FontLetterDefinition = function FontLetterDefinition() {
    _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.width = 0, 
    this.height = 0, this.offsetX = 0, this.offsetY = 0, this.textureID = 0, this.validDefinition = !1, 
    this.xAdvance = 0;
}, FontAtlas = function() {
    function FontAtlas() {
        _classCallCheck(this, FontAtlas), this._letterDefinitions = {};
    }
    return _createClass(FontAtlas, [ {
        key: "addLetterDefinitions",
        value: function addLetterDefinitions(letter, letterDefinition) {
            this._letterDefinitions[letter] = letterDefinition;
        }
    }, {
        key: "cloneLetterDefinition",
        value: function cloneLetterDefinition() {
            for (var copyLetterDefinitions = {}, _i = 0, _Object$keys = Object.keys(this._letterDefinitions); _i < _Object$keys.length; _i++) {
                var _key = _Object$keys[_i], value = new FontLetterDefinition;
                mixin(value, this._letterDefinitions[_key]), copyLetterDefinitions[_key] = value;
            }
            return copyLetterDefinitions;
        }
    }, {
        key: "assignLetterDefinitions",
        value: function assignLetterDefinitions(letterDefinition) {
            for (var _i2 = 0, _Object$keys2 = Object.keys(this._letterDefinitions); _i2 < _Object$keys2.length; _i2++) {
                var _key2 = _Object$keys2[_i2], newValue = letterDefinition[_key2];
                mixin(this._letterDefinitions[_key2], newValue);
            }
        }
    }, {
        key: "scaleFontLetterDefinition",
        value: function scaleFontLetterDefinition(scaleFactor) {
            for (var _i3 = 0, _Object$keys3 = Object.keys(this._letterDefinitions); _i3 < _Object$keys3.length; _i3++) {
                var fontDefinition = _Object$keys3[_i3], letterDefinitions = this._letterDefinitions[fontDefinition];
                letterDefinitions.width *= scaleFactor, letterDefinitions.height *= scaleFactor, 
                letterDefinitions.offsetX *= scaleFactor, letterDefinitions.offsetY *= scaleFactor, 
                letterDefinitions.xAdvance *= scaleFactor;
            }
        }
    }, {
        key: "getLetterDefinitionForChar",
        value: function getLetterDefinitionForChar(_char) {
            return this._letterDefinitions[_char.charCodeAt(0)];
        }
    }, {
        key: "letterDefinitions",
        get: function get() {
            return this._letterDefinitions;
        }
    } ]), FontAtlas;
}();

cc.FontAtlas = FontAtlas;

var LetterInfo = function LetterInfo() {
    _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.positionX = 0, 
    this.positionY = 0, this.lineIndex = 0;
}, _tmpRect = new Rect, _comp = null, _horizontalKerning = [], _lettersInfo = [], _linesWidth = [], _linesOffsetX = [], _labelDimensions = new Size, _fontAtlas = null, _fntConfig = null, _numberOfLines = 0, _textDesiredHeight = 0, _letterOffsetY = 0, _tailoredTopY = 0, _tailoredBottomY = 0, _bmfontScale = 1, _spriteFrame = null, _string = "", _fontSize = 0, _originFontSize = 0, _contentSize = new Size, _hAlign = 0, _vAlign = 0, _spacingX = 0, _lineHeight = 0, _overflow = 0, _isWrapText = !1, _labelWidth = 0, _labelHeight = 0, _maxLineWidth = 0, bmfont = {
    createData: function createData(comp) {
        return comp.requestRenderData();
    },
    fillBuffers: function fillBuffers(comp, renderer) {
        fillMeshVertices3D(comp.node, renderer, comp.renderData, comp.color);
    },
    appendQuad: function appendQuad(comp, spriteframe, rect, rotated, x, y, scale) {
        var renderData = comp.renderData;
        if (renderData) {
            var dataOffset = renderData.dataLength;
            renderData.dataLength += 4, renderData.vertexCount = renderData.dataLength, renderData.indiceCount = renderData.dataLength / 2 * 3;
            var datas = renderData.datas, texw = spriteframe.width, texh = spriteframe.height, rectWidth = rect.width, rectHeight = rect.height, l = 0, b = 0, t = 0, r = 0;
            rotated ? (l = rect.x / texw, r = (rect.x + rectHeight) / texw, b = (rect.y + rectWidth) / texh, 
            t = rect.y / texh, datas[dataOffset].u = l, datas[dataOffset].v = t, datas[dataOffset + 1].u = l, 
            datas[dataOffset + 1].v = b, datas[dataOffset + 2].u = r, datas[dataOffset + 2].v = t, 
            datas[dataOffset + 3].u = r, datas[dataOffset + 3].v = b) : (l = rect.x / texw, 
            r = (rect.x + rectWidth) / texw, b = (rect.y + rectHeight) / texh, t = rect.y / texh, 
            datas[dataOffset].u = l, datas[dataOffset].v = b, datas[dataOffset + 1].u = r, datas[dataOffset + 1].v = b, 
            datas[dataOffset + 2].u = l, datas[dataOffset + 2].v = t, datas[dataOffset + 3].u = r, 
            datas[dataOffset + 3].v = t), datas[dataOffset].x = x, datas[dataOffset].y = y - rectHeight * scale, 
            datas[dataOffset + 1].x = x + rectWidth * scale, datas[dataOffset + 1].y = y - rectHeight * scale, 
            datas[dataOffset + 2].x = x, datas[dataOffset + 2].y = y, datas[dataOffset + 3].x = x + rectWidth * scale, 
            datas[dataOffset + 3].y = y;
        }
    }
};

addon(bmfont, {
    updateRenderData: function updateRenderData(comp) {
        comp.renderData && comp.renderData.vertDirty && _comp !== comp && (_comp = comp, 
        this._updateProperties(), this._updateContent(), _comp.actualFontSize = _fontSize, 
        _comp.node.setContentSize(_contentSize), _comp.renderData.vertDirty = _comp.renderData.uvDirty = !1, 
        _comp = null, this._resetProperties());
    },
    _updateFontScale: function _updateFontScale() {
        _bmfontScale = _fontSize / _originFontSize;
    },
    _updateProperties: function _updateProperties() {
        if (_comp) {
            var fontAsset = _comp.font;
            if (fontAsset) {
                if (_spriteFrame = fontAsset.spriteFrame, _fntConfig = fontAsset.fntConfig, !(_fontAtlas = _comp.fontAtlas)) {
                    _fontAtlas = new FontAtlas;
                    for (var fontDict = _fntConfig.fontDefDictionary, _i4 = 0, _Object$keys4 = Object.keys(fontDict); _i4 < _Object$keys4.length; _i4++) {
                        var fontDef = _Object$keys4[_i4], letterDefinition = new FontLetterDefinition, rect = fontDict[fontDef].rect;
                        letterDefinition.offsetX = fontDict[fontDef].xOffset, letterDefinition.offsetY = fontDict[fontDef].yOffset, 
                        letterDefinition.width = rect.width, letterDefinition.height = rect.height, letterDefinition.u = rect.x, 
                        letterDefinition.v = rect.y, letterDefinition.textureID = 0, letterDefinition.validDefinition = !0, 
                        letterDefinition.xAdvance = fontDict[fontDef].xAdvance, _fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
                    }
                    _comp.fontAtlas = _fontAtlas;
                }
                _string = _comp.string.toString(), _fontSize = _comp.fontSize, _originFontSize = _fntConfig.fontSize;
                var contentSize = _comp.node.getContentSize();
                _contentSize.width = contentSize.width, _contentSize.height = contentSize.height, 
                _hAlign = _comp.horizontalAlign, _vAlign = _comp.verticalAlign, _spacingX = _comp.spacingX, 
                _overflow = _comp.overflow, _lineHeight = _comp.lineHeight, _isWrapText = _overflow !== exports.Overflow.NONE && (_overflow === exports.Overflow.RESIZE_HEIGHT || _comp.enableWrapText), 
                this._setupBMFontOverflowMetrics();
            }
        }
    },
    _resetProperties: function _resetProperties() {
        _fontAtlas = null, _fntConfig = null, _spriteFrame = null;
    },
    _updateContent: function _updateContent() {
        this._updateFontScale(), this._computeHorizontalKerningForText(), this._alignText();
    },
    _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
        for (var string = _string, stringLen = string.length, kerningDict = _fntConfig.kerningDict, horizontalKerning = _horizontalKerning, prev = -1, i = 0; i < stringLen; ++i) {
            var _key3 = string.charCodeAt(i), kerningAmount = kerningDict[prev << 16 | 65535 & _key3] || 0;
            horizontalKerning[i] = i < stringLen - 1 ? kerningAmount : 0, prev = _key3;
        }
    },
    _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
        var textLen = _string.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2;
        this._updateFontScale();
        for (var letterDefinitions = _fontAtlas.letterDefinitions, index = 0; index < textLen; ) {
            var character = _string.charAt(index);
            if ("\n" !== character) {
                for (var tokenLen = nextTokenFunc(_string, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                    var letterIndex = index + tmp;
                    if ("\r" !== (character = _string.charAt(letterIndex))) if (letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)) {
                        var letterX = nextLetterX + letterDef.offsetX * _bmfontScale;
                        if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                            _linesWidth.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, nextTokenY -= _lineHeight * _bmfontScale + 0, 
                            newLine = !0;
                            break;
                        }
                        letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale, 
                        this._recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex), 
                        letterIndex + 1 < _horizontalKerning.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKerning[letterIndex + 1]), 
                        nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX, tokenRight = letterPosition.x + letterDef.width * _bmfontScale, 
                        tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.height * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef.height * _bmfontScale);
                    } else this._recordPlaceholderInfo(letterIndex, character), console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character); else this._recordPlaceholderInfo(letterIndex, character);
                }
                newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                lowestY > tokenLowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                index += tokenLen);
            } else _linesWidth.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, 
            nextTokenY -= _lineHeight * _bmfontScale + 0, this._recordPlaceholderInfo(index, character), 
            index++;
        }
        return _linesWidth.push(letterRight), _textDesiredHeight = (_numberOfLines = lineIndex + 1) * _lineHeight * _bmfontScale, 
        _numberOfLines > 1 && (_textDesiredHeight += 0 * (_numberOfLines - 1)), _contentSize.width = _labelWidth, 
        _contentSize.height = _labelHeight, _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2))), 
        _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2))), 
        _tailoredTopY = _contentSize.height, _tailoredBottomY = 0, highestY > 0 && (_tailoredTopY = _contentSize.height + highestY), 
        lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY), 
        !0;
    },
    _getFirstCharLen: function _getFirstCharLen() {
        return 1;
    },
    _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
        var len = 1, letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character);
        if (!letterDef) return len;
        for (var nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
        letterDef = _fontAtlas && _fontAtlas.getLetterDefinitionForChar(character)); ++index) {
            if (nextLetterX + letterDef.offsetX * _bmfontScale + letterDef.width * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && _maxLineWidth > 0) return len;
            if (nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
            len++;
        }
        return len;
    },
    _multilineTextWrapByWord: function _multilineTextWrapByWord() {
        return this._multilineTextWrap(this._getFirstWordLen);
    },
    _multilineTextWrapByChar: function _multilineTextWrapByChar() {
        return this._multilineTextWrap(this._getFirstCharLen);
    },
    _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char2) {
        if (letterIndex >= _lettersInfo.length) {
            var tmpInfo = new LetterInfo;
            _lettersInfo.push(tmpInfo);
        }
        _lettersInfo[letterIndex].char = _char2, _lettersInfo[letterIndex].valid = !1;
    },
    _recordLetterInfo: function _recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= _lettersInfo.length) {
            var tmpInfo = new LetterInfo;
            _lettersInfo.push(tmpInfo);
        }
        var cIndex = character.charCodeAt(0);
        _lettersInfo[letterIndex].lineIndex = lineIndex, _lettersInfo[letterIndex].char = character, 
        _lettersInfo[letterIndex].valid = letterDefinitions[cIndex].validDefinition, _lettersInfo[letterIndex].positionX = letterPosition.x, 
        _lettersInfo[letterIndex].positionY = letterPosition.y;
    },
    _alignText: function _alignText() {
        _textDesiredHeight = 0, _linesWidth.length = 0, this._multilineTextWrapByWord(), 
        this._computeAlignmentOffset(), _overflow === exports.Overflow.SHRINK && _fontSize > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp), 
        this._updateQuads() || _overflow === exports.Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
    },
    _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
        var shouldUpdateContent = !0;
        fontSize || (fontSize = .1, shouldUpdateContent = !1), _fontSize = fontSize, shouldUpdateContent && this._updateContent();
    },
    _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
        for (var fontSize = _fontSize, originalLineHeight = _lineHeight, fontAtlas = _fontAtlas, i = 0, tempLetterDefinition = fontAtlas ? fontAtlas.cloneLetterDefinition() : {}, flag = !0; lambda(); ) {
            var newFontSize = fontSize - ++i;
            if (flag = !1, newFontSize <= 0) break;
            var scale = newFontSize / fontSize;
            fontAtlas && (fontAtlas.assignLetterDefinitions(tempLetterDefinition), fontAtlas.scaleFontLetterDefinition(scale)), 
            _lineHeight = originalLineHeight * scale, this._multilineTextWrapByWord(), this._computeAlignmentOffset();
        }
        _lineHeight = originalLineHeight, fontAtlas && fontAtlas.assignLetterDefinitions(tempLetterDefinition), 
        flag || fontSize - i >= 0 && this._scaleFontSizeDown(fontSize - i);
    },
    _isVerticalClamp: function _isVerticalClamp() {
        return _textDesiredHeight > _contentSize.height;
    },
    _isHorizontalClamp: function _isHorizontalClamp() {
        if (_fontAtlas) {
            for (var letterClamp = !1, ctr = 0, l = _string.length; ctr < l; ++ctr) {
                var letterInfo = _lettersInfo[ctr];
                if (letterInfo.valid) {
                    var letterDef = _fontAtlas.getLetterDefinitionForChar(letterInfo.char);
                    if (!letterDef) continue;
                    var px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale, lineIndex = letterInfo.lineIndex;
                    if (_labelWidth > 0) if (_isWrapText) {
                        if (_linesWidth[lineIndex] > _contentSize.width && (px > _contentSize.width || px < 0)) {
                            letterClamp = !0;
                            break;
                        }
                    } else if (px > _contentSize.width) {
                        letterClamp = !0;
                        break;
                    }
                }
            }
            return letterClamp;
        }
    },
    _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
        var wordWidth = _linesWidth[lineIndex], letterOverClamp = px > _contentSize.width || px < 0;
        return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
    },
    _updateQuads: function _updateQuads() {
        if (!_comp) return !1;
        var letterDefinitions = _fontAtlas ? _fontAtlas.letterDefinitions : {}, texture = _spriteFrame, node = _comp.node, renderData = _comp.renderData;
        renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
        for (var anchorPoint = node.getAnchorPoint(), contentSize = _contentSize, appX = anchorPoint.x * contentSize.width, appY = anchorPoint.y * contentSize.height, ret = !0, ctr = 0, l = _string.length; ctr < l; ++ctr) {
            var letterInfo = _lettersInfo[ctr];
            if (letterInfo.valid) {
                var letterDef = letterDefinitions[letterInfo.char.charCodeAt(0)];
                if (letterDef) {
                    _tmpRect.height = letterDef.height, _tmpRect.width = letterDef.width, _tmpRect.x = letterDef.u, 
                    _tmpRect.y = letterDef.v;
                    var py = letterInfo.positionY + _letterOffsetY;
                    if (_labelHeight > 0) {
                        if (py > _tailoredTopY) {
                            var clipTop = py - _tailoredTopY;
                            _tmpRect.y += clipTop, _tmpRect.height -= clipTop, py -= clipTop;
                        }
                        py - letterDef.height * _bmfontScale < _tailoredBottomY && (_tmpRect.height = py < _tailoredBottomY ? 0 : py - _tailoredBottomY);
                    }
                    var lineIndex = letterInfo.lineIndex, px = letterInfo.positionX + letterDef.width / 2 * _bmfontScale + _linesOffsetX[lineIndex];
                    if (_labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow === exports.Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === exports.Overflow.SHRINK) {
                        if (_contentSize.width > letterDef.width) {
                            ret = !1;
                            break;
                        }
                        _tmpRect.width = 0;
                    }
                    if (_spriteFrame && _tmpRect.height > 0 && _tmpRect.width > 0) {
                        var isRotated = _spriteFrame.isRotated(), originalSize = _spriteFrame.getOriginalSize(), rect = _spriteFrame.getRect(), offset = _spriteFrame.getOffset(), trimmedLeft = offset.x + (originalSize.width - rect.width) / 2, trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
                        if (isRotated) {
                            var originalX = _tmpRect.x;
                            _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop, _tmpRect.y = originalX + rect.y - trimmedLeft, 
                            _tmpRect.y < 0 && (_tmpRect.height = _tmpRect.height + trimmedTop);
                        } else _tmpRect.x += rect.x - trimmedLeft, _tmpRect.y += rect.y + trimmedTop;
                        var letterPositionX = letterInfo.positionX + _linesOffsetX[letterInfo.lineIndex];
                        this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appX, py - appY, _bmfontScale);
                    }
                } else console.warn("Can't find letter in this bitmap-font");
            }
        }
        return ret;
    },
    appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {},
    _computeAlignmentOffset: function _computeAlignmentOffset() {
        switch (_linesOffsetX.length = 0, _hAlign) {
          case exports.HorizontalTextAlignment.LEFT:
            for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
            break;

          case exports.HorizontalTextAlignment.CENTER:
            for (var _i5 = 0, l = _linesWidth.length; _i5 < l; _i5++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i5]) / 2);
            break;

          case exports.HorizontalTextAlignment.RIGHT:
            for (var _i6 = 0, _l = _linesWidth.length; _i6 < _l; _i6++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i6]);
        }
        switch (_vAlign) {
          case exports.VerticalTextAlignment.TOP:
            _letterOffsetY = _contentSize.height;
            break;

          case exports.VerticalTextAlignment.CENTER:
            _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2;
            break;

          case exports.VerticalTextAlignment.BOTTOM:
            _letterOffsetY = _textDesiredHeight;
        }
    },
    _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
        var newWidth = _contentSize.width, newHeight = _contentSize.height;
        _overflow === exports.Overflow.RESIZE_HEIGHT && (newHeight = 0), _overflow === exports.Overflow.NONE && (newWidth = 0, 
        newHeight = 0), _labelWidth = newWidth, _labelHeight = newHeight, _labelDimensions.width = newWidth, 
        _labelDimensions.height = newHeight, _maxLineWidth = newWidth;
    }
});

var Overflow = LabelComponent.Overflow, WHITE = Color.WHITE.clone(), TextAlignment = LabelComponent.HorizontalAlign, VerticalTextAlignment = LabelComponent.VerticalAlign, LetterInfo$1 = function LetterInfo() {
    _classCallCheck(this, LetterInfo), this.char = "", this.valid = !0, this.x = 0, 
    this.y = 0, this.line = 0, this.hash = "";
}, FontLetterDefinition$1 = function FontLetterDefinition() {
    _classCallCheck(this, FontLetterDefinition), this.u = 0, this.v = 0, this.w = 0, 
    this.h = 0, this.texture = null, this.offsetX = 0, this.offsetY = 0, this.valid = !1, 
    this.xAdvance = 0;
}, LetterTexture = function() {
    function LetterTexture(_char, labelInfo) {
        _classCallCheck(this, LetterTexture), this.image = null, this.labelInfo = void 0, 
        this.char = void 0, this.data = null, this.canvas = null, this.context = null, this.width = 0, 
        this.height = 0, this.hash = void 0, this.char = _char, this.labelInfo = labelInfo, 
        this.hash = _char.charCodeAt(0) + labelInfo.hash;
    }
    return _createClass(LetterTexture, [ {
        key: "updateRenderData",
        value: function updateRenderData() {
            this._updateProperties(), this._updateTexture();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.image = null;
        }
    }, {
        key: "_updateProperties",
        value: function _updateProperties() {
            if (this.data = LabelComponent._canvasPool.get(), this.canvas = this.data.canvas, 
            this.context = this.data.context, this.context) {
                this.context.font = this.labelInfo.fontDesc;
                var width = safeMeasureText(this.context, this.char);
                this.width = parseFloat(width.toFixed(2)), this.height = this.labelInfo.fontSize;
            }
            this.canvas.width !== this.width && (this.canvas.width = this.width), this.canvas.height !== this.height && (this.canvas.height = this.height), 
            this.image || (this.image = new ImageAsset), this.image.reset(this.canvas);
        }
    }, {
        key: "_updateTexture",
        value: function _updateTexture() {
            if (this.context && this.canvas) {
                var context = this.context, labelInfo = this.labelInfo, width = this.canvas.width, height = this.canvas.height;
                context.textAlign = "center", context.textBaseline = "middle", context.clearRect(0, 0, width, height), 
                context.fillStyle = "rgba(255, 255, 255, 0.005)", context.fillRect(0, 0, width, height), 
                context.font = labelInfo.fontDesc;
                var startX = width / 2, startY = height / 2, color = labelInfo.color;
                if (context.lineJoin = "round", context.fillStyle = "rgba(".concat(color.r, ", ").concat(color.g, ", ").concat(color.b, ", ", 1, ")"), 
                labelInfo.isOutlined) {
                    var strokeColor = labelInfo.out || WHITE;
                    context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                    context.lineWidth = 2 * labelInfo.margin, context.strokeText(this.char, startX, startY);
                }
                context.fillText(this.char, startX, startY);
            }
        }
    } ]), LetterTexture;
}(), LetterRenderTexture = function(_Texture2D) {
    function LetterRenderTexture() {
        return _classCallCheck(this, LetterRenderTexture), _possibleConstructorReturn(this, _getPrototypeOf(LetterRenderTexture).apply(this, arguments));
    }
    return _inherits(LetterRenderTexture, Texture2D), _createClass(LetterRenderTexture, [ {
        key: "initWithSize",
        value: function initWithSize(width, height) {
            var format = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : PixelFormat.RGBA8888;
            this.reset({
                width: width,
                height: height,
                format: format
            }), this.loaded = !0, this.emit("load");
        }
    }, {
        key: "drawTextureAt",
        value: function drawTextureAt(image, x, y) {
            var gfxTexture = this.getGFXTexture();
            if (image && gfxTexture) {
                var gfxDevice = this._getGFXDevice();
                if (gfxDevice) {
                    var region = {
                        buffOffset: 0,
                        buffStride: 0,
                        buffTexHeight: 0,
                        texOffset: {
                            x: x,
                            y: y,
                            z: 0
                        },
                        texExtent: {
                            width: image.width,
                            height: image.height,
                            depth: 1
                        },
                        texSubres: {
                            baseMipLevel: 0,
                            levelCount: 1,
                            baseArrayLayer: 0,
                            layerCount: 1
                        }
                    };
                    gfxDevice.copyTexImagesToTexture([ image.data ], gfxTexture, [ region ]);
                } else console.warn("Unable to get device");
            }
        }
    } ]), LetterRenderTexture;
}(), LetterAtlas = function() {
    function LetterAtlas(width, height) {
        _classCallCheck(this, LetterAtlas), this.texture = void 0, this._x = 2, this._y = 2, 
        this._nextY = 2, this._width = 0, this._height = 0, this._letterDefinitions = new Map, 
        this._dirty = !1, this.texture = new LetterRenderTexture, this.texture.initWithSize(width, height), 
        this._width = width, this._height = height, director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
    }
    return _createClass(LetterAtlas, [ {
        key: "width",
        get: function get() {
            return this._width;
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        }
    } ]), _createClass(LetterAtlas, [ {
        key: "insertLetterTexture",
        value: function insertLetterTexture(letterTexture) {
            var texture = letterTexture.image, device = director.root.device;
            if (!texture || !this.texture || !device) return null;
            var width = texture.width, height = texture.height;
            if (this._x + width + 2 > this._width && (this._x = 2, this._y = this._nextY), this._y + height > this._nextY && (this._nextY = this._y + height + 2), 
            this._nextY > this._height) return null;
            this.texture.drawTextureAt(texture, this._x, this._y), this._dirty = !0;
            var letterDefinition = new FontLetterDefinition$1;
            return letterDefinition.u = this._x, letterDefinition.v = this._y, letterDefinition.texture = this.texture, 
            letterDefinition.valid = !0, letterDefinition.w = letterTexture.width, letterDefinition.h = letterTexture.height, 
            letterDefinition.xAdvance = letterTexture.width, this._x += width + 2, this._letterDefinitions.set(letterTexture.hash, letterDefinition), 
            letterDefinition;
        }
    }, {
        key: "update",
        value: function update() {
            this._dirty && (this._dirty = !1);
        }
    }, {
        key: "reset",
        value: function reset() {
            this._x = 2, this._y = 2, this._nextY = 2, this._letterDefinitions.clear();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.reset(), this.texture && this.texture.destroy();
        }
    }, {
        key: "beforeSceneLoad",
        value: function beforeSceneLoad() {
            this.destroy();
            var texture = new LetterRenderTexture;
            texture.initWithSize(this._width, this._height), this.texture = texture;
        }
    }, {
        key: "getLetter",
        value: function getLetter(key) {
            return this._letterDefinitions.get(key);
        }
    }, {
        key: "addLetterDefinitions",
        value: function addLetterDefinitions(key, letterDefinition) {
            this._letterDefinitions[key] = letterDefinition;
        }
    }, {
        key: "cloneLetterDefinition",
        value: function cloneLetterDefinition() {
            for (var copyLetterDefinitions = {}, _i = 0, _Object$keys = Object.keys(this._letterDefinitions); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i], value = new FontLetterDefinition$1;
                mixin(value, this._letterDefinitions[key]), copyLetterDefinitions[key] = value;
            }
            return copyLetterDefinitions;
        }
    }, {
        key: "assignLetterDefinitions",
        value: function assignLetterDefinitions(letterDefinitions) {
            var _this = this;
            letterDefinitions.forEach((function(value, key) {
                mixin(_this._letterDefinitions[key], value);
            }));
        }
    }, {
        key: "scaleFontLetterDefinition",
        value: function scaleFontLetterDefinition(scaleFactor) {
            for (var _i2 = 0, _Object$keys2 = Object.keys(this._letterDefinitions); _i2 < _Object$keys2.length; _i2++) {
                var fontDefinition = _Object$keys2[_i2], letterDefinitions = this._letterDefinitions[fontDefinition];
                letterDefinitions.w *= scaleFactor, letterDefinitions.h *= scaleFactor, letterDefinitions.offsetX *= scaleFactor, 
                letterDefinitions.offsetY *= scaleFactor, letterDefinitions.xAdvance *= scaleFactor;
            }
        }
    }, {
        key: "getLetterDefinitionForChar",
        value: function getLetterDefinitionForChar(_char2, labelInfo) {
            var hash = _char2.charCodeAt(0) + labelInfo.hash, letterDefinition = this._letterDefinitions.get(hash);
            if (!letterDefinition) {
                var temp = new LetterTexture(_char2, labelInfo);
                temp.updateRenderData(), letterDefinition = this.insertLetterTexture(temp), temp.destroy();
            }
            return letterDefinition;
        }
    } ]), LetterAtlas;
}(), _tmpRect$1 = new Rect, _comp$1 = null, _horizontalKernings = [], _lettersInfo$1 = [], _linesWidth$1 = [], _linesOffsetX$1 = [], _labelDimensions$1 = new Size, _fontAtlas$1 = null, _numberOfLines$1 = 0, _textDesiredHeight$1 = 0, _letterOffsetY$1 = 0, _tailoredTopY$1 = 0, _tailoredBottomY$1 = 0, _bmfontScale$1 = 1, _string$1 = "", _fontSize$1 = 0, _originFontSize$1 = 0, _contentSize$1 = new Size, _hAlign$1 = 0, _vAlign$1 = 0, _spacingX$1 = 0, _lineHeight$1 = 0, _overflow$1 = 0, _isWrapText$1 = !1, _labelWidth$1 = 0, _labelHeight$1 = 0, _maxLineWidth$1 = 0, _fontFamily = "", _isBold = !1, _labelInfo = {
    fontSize: 0,
    lineHeight: 0,
    hash: "",
    fontFamily: "",
    fontDesc: "Arial",
    hAlign: 0,
    vAlign: 0,
    color: WHITE,
    isOutlined: !1,
    out: WHITE,
    margin: 0
}, letterFont = {
    getAssemblerData: function getAssemblerData() {
        return _fontAtlas$1 || (_fontAtlas$1 = new LetterAtlas(1024, 1024)), _fontAtlas$1.texture;
    },
    updateRenderData: function updateRenderData(comp) {
        comp.renderData && comp.renderData.vertDirty && _comp$1 !== comp && (_comp$1 = comp, 
        this._updateFontFamily(comp), _labelInfo.fontFamily = _fontFamily, this._updateProperties(), 
        _labelInfo.fontDesc = this._getFontDesc(), this._updateContent(), _comp$1.actualFontSize = _fontSize$1, 
        _comp$1.node.setContentSize(_contentSize$1), _comp$1.renderData.vertDirty = _comp$1.renderData.uvDirty = !1, 
        _comp$1 = null, this._resetProperties());
    },
    _updateFontScale: function _updateFontScale() {
        _bmfontScale$1 = _fontSize$1 / _originFontSize$1;
    },
    _updateProperties: function _updateProperties() {
        if (_comp$1) {
            _string$1 = _comp$1.string.toString(), _fontSize$1 = _comp$1.fontSize, _originFontSize$1 = _fontSize$1;
            var contentSize = _comp$1.node.getContentSize();
            _contentSize$1.width = contentSize.width, _contentSize$1.height = contentSize.height, 
            _hAlign$1 = _comp$1.horizontalAlign, _vAlign$1 = _comp$1.verticalAlign, _spacingX$1 = _comp$1.spacingX, 
            _overflow$1 = _comp$1.overflow, _lineHeight$1 = _comp$1.lineHeight, _isBold = _comp$1.isBold, 
            _isWrapText$1 = _overflow$1 !== Overflow.NONE && (_overflow$1 === Overflow.RESIZE_HEIGHT || _comp$1.enableWrapText);
            var outline = _comp$1.getComponent(LabelOutlineComponent);
            outline && outline.enabled ? (_labelInfo.isOutlined = !0, _labelInfo.margin = outline.width, 
            _labelInfo.out = outline.color, _labelInfo.out.a = outline.color.a * _comp$1.color.a / 255) : (_labelInfo.isOutlined = !1, 
            _labelInfo.margin = 0), _labelInfo.lineHeight = _lineHeight$1, _labelInfo.fontSize = _fontSize$1, 
            _labelInfo.fontFamily = _fontFamily, _labelInfo.color = _comp$1.color, _labelInfo.hash = this._computeHash(_labelInfo), 
            this._setupBMFontOverflowMetrics();
        }
    },
    _updateFontFamily: function _updateFontFamily(comp) {
        comp.useSystemFont ? _fontFamily = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily = comp.font._nativeAsset : (_fontFamily = loader.getRes(comp.font.nativeUrl) || "") || loader.load(comp.font.nativeUrl, (function(err, fontFamily) {
            _fontFamily = fontFamily || "Arial", comp.font && (comp.font._nativeAsset = fontFamily), 
            comp.updateRenderData(!0);
        })) : _fontFamily = "Arial";
    },
    _computeHash: function _computeHash(labelInfo) {
        var color = labelInfo.color.toHEX("#rrggbb"), out = "";
        return labelInfo.isOutlined && (out = labelInfo.out.toHEX("#rrggbb")), "" + labelInfo.fontSize + labelInfo.fontFamily + color + out;
    },
    _getFontDesc: function _getFontDesc() {
        var fontDesc = _fontSize$1.toString() + "px ";
        return fontDesc += _fontFamily, _isBold && (fontDesc = "bold " + fontDesc), fontDesc;
    },
    _resetProperties: function _resetProperties() {},
    _updateContent: function _updateContent() {
        this._updateFontScale(), this._alignText();
    },
    _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
    _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
        var textLen = _string$1.length, lineIndex = 0, nextTokenX = 0, nextTokenY = 0, longestLine = 0, letterRight = 0, highestY = 0, lowestY = 0, letterDef = null, letterPosition = new Vec2(0, 0);
        this._updateFontScale();
        for (var index = 0; index < textLen; ) {
            var character = _string$1.charAt(index);
            if ("\n" !== character) {
                for (var tokenLen = nextTokenFunc(_string$1, index, textLen), tokenHighestY = highestY, tokenLowestY = lowestY, tokenRight = letterRight, nextLetterX = nextTokenX, newLine = !1, tmp = 0; tmp < tokenLen; ++tmp) {
                    var letterIndex = index + tmp;
                    if ("\r" !== (character = _string$1.charAt(letterIndex))) if (letterDef = _fontAtlas$1 && _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)) {
                        var letterX = nextLetterX + letterDef.offsetX * _bmfontScale$1;
                        if (_isWrapText$1 && _maxLineWidth$1 > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character)) {
                            _linesWidth$1.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, nextTokenY -= _lineHeight$1 * _bmfontScale$1 + 0, 
                            newLine = !0;
                            break;
                        }
                        letterPosition.x = letterX, letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale$1, 
                        this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex), letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]), 
                        nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, tokenRight = letterPosition.x + letterDef.w * _bmfontScale$1, 
                        tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y), tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale$1 && (tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale$1);
                    } else this._recordPlaceholderInfo(letterIndex, character); else this._recordPlaceholderInfo(letterIndex, character);
                }
                newLine || (nextTokenX = nextLetterX, highestY < tokenHighestY && (highestY = tokenHighestY), 
                lowestY > tokenLowestY && (lowestY = tokenLowestY), longestLine < (letterRight = tokenRight) && (longestLine = letterRight), 
                index += tokenLen);
            } else _linesWidth$1.push(letterRight), letterRight = 0, lineIndex++, nextTokenX = 0, 
            nextTokenY -= _lineHeight$1 * _bmfontScale$1 + 0, this._recordPlaceholderInfo(index, character), 
            index++;
        }
        return _linesWidth$1.push(letterRight), _textDesiredHeight$1 = (_numberOfLines$1 = lineIndex + 1) * _lineHeight$1 * _bmfontScale$1, 
        _numberOfLines$1 > 1 && (_textDesiredHeight$1 += 0 * (_numberOfLines$1 - 1)), _contentSize$1.width = _labelWidth$1, 
        _contentSize$1.height = _labelHeight$1, _labelWidth$1 <= 0 && (_contentSize$1.width = parseFloat(longestLine.toFixed(2))), 
        _labelHeight$1 <= 0 && (_contentSize$1.height = parseFloat(_textDesiredHeight$1.toFixed(2))), 
        _tailoredTopY$1 = _contentSize$1.height, _tailoredBottomY$1 = 0, highestY > 0 && (_tailoredTopY$1 = _contentSize$1.height + highestY), 
        lowestY < -_textDesiredHeight$1 && (_tailoredBottomY$1 = _textDesiredHeight$1 + lowestY), 
        !0;
    },
    _getFirstCharLen: function _getFirstCharLen() {
        return 1;
    },
    _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (isUnicodeCJK(character) || "\n" === character || isUnicodeSpace(character)) return 1;
        if (_fontAtlas$1) {
            var len = 1, letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo);
            if (!letterDef) return len;
            for (var nextLetterX = letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, index = startIndex + 1; index < textLen && (character = text.charAt(index), 
            letterDef = _fontAtlas$1.getLetterDefinitionForChar(character, _labelInfo)); ++index) {
                if (nextLetterX + letterDef.offsetX * _bmfontScale$1 + letterDef.w * _bmfontScale$1 > _maxLineWidth$1 && !isUnicodeSpace(character) && _maxLineWidth$1 > 0) return len;
                if (nextLetterX += letterDef.xAdvance * _bmfontScale$1 + _spacingX$1, "\n" === character || isUnicodeSpace(character) || isUnicodeCJK(character)) break;
                len++;
            }
            return len;
        }
    },
    _multilineTextWrapByWord: function _multilineTextWrapByWord() {
        return this._multilineTextWrap(this._getFirstWordLen);
    },
    _multilineTextWrapByChar: function _multilineTextWrapByChar() {
        return this._multilineTextWrap(this._getFirstCharLen);
    },
    _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char3) {
        if (letterIndex >= _lettersInfo$1.length) {
            var tmpInfo = new LetterInfo$1;
            _lettersInfo$1.push(tmpInfo);
        }
        _lettersInfo$1[letterIndex].char = _char3, _lettersInfo$1[letterIndex].hash = _char3.charCodeAt(0) + _labelInfo.hash, 
        _lettersInfo$1[letterIndex].valid = !1;
    },
    _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= _lettersInfo$1.length) {
            var tmpInfo = new LetterInfo$1;
            _lettersInfo$1.push(tmpInfo);
        }
        var key = character.charCodeAt(0) + _labelInfo.hash;
        _lettersInfo$1[letterIndex].line = lineIndex, _lettersInfo$1[letterIndex].char = character, 
        _lettersInfo$1[letterIndex].hash = key;
        var fontLetter = _fontAtlas$1 && _fontAtlas$1.getLetter(key);
        _lettersInfo$1[letterIndex].valid = !!fontLetter && !!fontLetter.valid, _lettersInfo$1[letterIndex].x = letterPosition.x, 
        _lettersInfo$1[letterIndex].y = letterPosition.y;
    },
    _alignText: function _alignText() {
        _textDesiredHeight$1 = 0, _linesWidth$1.length = 0, this._multilineTextWrapByWord(), 
        this._computeAlignmentOffset(), this._updateQuads();
    },
    _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
        var shouldUpdateContent = !0;
        fontSize || (fontSize = .1, shouldUpdateContent = !1), _fontSize$1 = fontSize, shouldUpdateContent && this._updateContent();
    },
    _isVerticalClamp: function _isVerticalClamp() {
        return _textDesiredHeight$1 > _contentSize$1.height;
    },
    _isHorizontalClamp: function _isHorizontalClamp() {
        for (var letterClamp = !1, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
            var letterInfo = _lettersInfo$1[ctr];
            if (letterInfo.valid) {
                var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                if (!letterDef) continue;
                var px = letterInfo.x + letterDef.w * _bmfontScale$1, lineIndex = letterInfo.line;
                if (_labelWidth$1 > 0) if (_isWrapText$1) {
                    if (_linesWidth$1[lineIndex] > _contentSize$1.width && (px > _contentSize$1.width || px < 0)) {
                        letterClamp = !0;
                        break;
                    }
                } else if (px > _contentSize$1.width) {
                    letterClamp = !0;
                    break;
                }
            }
        }
        return letterClamp;
    },
    _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
        var wordWidth = _linesWidth$1[lineIndex], letterOverClamp = px > _contentSize$1.width || px < 0;
        return _isWrapText$1 ? wordWidth > _contentSize$1.width && letterOverClamp : letterOverClamp;
    },
    _updateQuads: function _updateQuads() {
        if (_comp$1 && _fontAtlas$1) {
            var texture = _fontAtlas$1.texture, node = _comp$1.node, renderData = _comp$1.renderData;
            renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
            for (var contentSize = _contentSize$1, ap = node.getAnchorPoint(), appx = ap.x * contentSize.width, appy = ap.y * contentSize.height, ret = !0, ctr = 0, l = _string$1.length; ctr < l; ++ctr) {
                var letterInfo = _lettersInfo$1[ctr];
                if (letterInfo.valid) {
                    var letterDef = _fontAtlas$1.getLetter(letterInfo.hash);
                    if (letterDef) {
                        _tmpRect$1.height = letterDef.h, _tmpRect$1.width = letterDef.w, _tmpRect$1.x = letterDef.u, 
                        _tmpRect$1.y = letterDef.v;
                        var py = letterInfo.y + _letterOffsetY$1;
                        if (_labelHeight$1 > 0) {
                            if (py > _tailoredTopY$1) {
                                var clipTop = py - _tailoredTopY$1;
                                _tmpRect$1.y += clipTop, _tmpRect$1.height -= clipTop, py -= clipTop;
                            }
                            py - letterDef.h * _bmfontScale$1 < _tailoredBottomY$1 && (_tmpRect$1.height = py < _tailoredBottomY$1 ? 0 : py - _tailoredBottomY$1);
                        }
                        var lineIndex = letterInfo.line, px = letterInfo.x + letterDef.w / 2 * _bmfontScale$1 + _linesOffsetX$1[lineIndex];
                        if (_labelWidth$1 > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow$1 === Overflow.CLAMP) _tmpRect$1.width = 0; else if (_overflow$1 === Overflow.SHRINK) {
                            if (_contentSize$1.width > letterDef.w) {
                                ret = !1;
                                break;
                            }
                            _tmpRect$1.width = 0;
                        }
                        if (_tmpRect$1.height > 0 && _tmpRect$1.width > 0) {
                            var letterPositionX = letterInfo.x + _linesOffsetX$1[letterInfo.line];
                            this.appendQuad(_comp$1, texture, _tmpRect$1, !1, letterPositionX - appx, py - appy, _bmfontScale$1);
                        }
                    }
                }
            }
            return ret;
        }
    },
    appendQuad: function appendQuad(renderData, texture, rect, rotated, x, y, scale) {},
    _computeAlignmentOffset: function _computeAlignmentOffset() {
        switch (_linesOffsetX$1.length = 0, _hAlign$1) {
          case TextAlignment.LEFT:
            for (var i = 0; i < _numberOfLines$1; ++i) _linesOffsetX$1.push(0);
            break;

          case TextAlignment.CENTER:
            for (var _i3 = 0, l = _linesWidth$1.length; _i3 < l; _i3++) _linesOffsetX$1.push((_contentSize$1.width - _linesWidth$1[_i3]) / 2);
            break;

          case TextAlignment.RIGHT:
            for (var _i4 = 0, _l = _linesWidth$1.length; _i4 < _l; _i4++) _linesOffsetX$1.push(_contentSize$1.width - _linesWidth$1[_i4]);
        }
        switch (_vAlign$1) {
          case VerticalTextAlignment.TOP:
            _letterOffsetY$1 = _contentSize$1.height;
            break;

          case VerticalTextAlignment.CENTER:
            _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$1) / 2;
            break;

          case VerticalTextAlignment.BOTTOM:
            _letterOffsetY$1 = (_contentSize$1.height + _textDesiredHeight$1) / 2 - (_lineHeight$1 - _fontSize$1);
        }
    },
    _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
        var newWidth = _contentSize$1.width, newHeight = _contentSize$1.height;
        _overflow$1 === Overflow.RESIZE_HEIGHT && (newHeight = 0), _overflow$1 === Overflow.NONE && (newWidth = 0, 
        newHeight = 0), _labelWidth$1 = newWidth, _labelHeight$1 = newHeight, _labelDimensions$1.width = newWidth, 
        _labelDimensions$1.height = newHeight, _maxLineWidth$1 = newWidth;
    }
}, WHITE$1 = new Color(255, 255, 255, 255), letter = {
    createData: function createData(comp) {
        return comp.requestRenderData();
    },
    fillBuffers: function fillBuffers(comp, renderer) {
        if (comp.renderData) {
            var node = comp.node;
            WHITE$1.a = comp.color.a, fillMeshVertices3D(node, renderer, comp.renderData, WHITE$1);
        }
    },
    appendQuad: bmfont.appendQuad
};

addon(letter, letterFont);

var Overflow$1 = LabelComponent.Overflow, WHITE$2 = Color.WHITE.clone(), OUTLINE_SUPPORTED = isChildClassOf(LabelOutlineComponent, Component), _context = null, _canvas = null, _texture = null, _fontDesc = "", _string$2 = "", _fontSize$2 = 0, _drawFontsize = 0, _splitedStrings = [], _canvasSize = new Size, _lineHeight$2 = 0, _hAlign$2 = 0, _vAlign$2 = 0, _color$1 = new Color, _fontFamily$1 = "", _overflow$2 = Overflow$1.NONE, _isWrapText$2 = !1, _isOutlined = !1, _outlineColor = new Color, _outlineWidth = 0, _margin = 0, _isBold$1 = !1, _isItalic = !1, _isUnderline = !1, ttfUtils = {
    getAssemblerData: function getAssemblerData() {
        var sharedLabelData = LabelComponent._canvasPool.get();
        return sharedLabelData.canvas.width = sharedLabelData.canvas.height = 1, sharedLabelData;
    },
    resetAssemblerData: function resetAssemblerData(assemblerData) {
        assemblerData && LabelComponent._canvasPool.put(assemblerData);
    },
    updateRenderData: function updateRenderData(comp) {
        comp.renderData && comp.renderData.vertDirty && (this._updateFontFamly(comp), this._updateProperties(comp), 
        this._calculateLabelFont(), this._calculateSplitedStrings(), this._updateLabelDimensions(), 
        this._calculateTextBaseline(), this._updateTexture(), comp.actualFontSize = _fontSize$2, 
        comp.node.setContentSize(_canvasSize), this.updateVerts(comp), comp.markForUpdateRenderData(!1), 
        _context = null, _canvas = null, _texture = null);
    },
    updateVerts: function updateVerts(comp) {},
    _updateFontFamly: function _updateFontFamly(comp) {
        comp.useSystemFont ? _fontFamily$1 = comp.fontFamily : comp.font ? comp.font._nativeAsset ? _fontFamily$1 = comp.font._nativeAsset : loader.load(comp.font.nativeUrl, (function(err, fontFamily) {
            _fontFamily$1 = fontFamily || "Arial", comp.updateRenderData(!0);
        })) : _fontFamily$1 = "Arial";
    },
    _updateProperties: function _updateProperties(comp) {
        var assemblerData = comp.assemblerData;
        if (assemblerData) {
            _context = assemblerData.context, _canvas = assemblerData.canvas, _texture = comp.spriteFrame, 
            _string$2 = comp.string.toString(), _fontSize$2 = comp.fontSize, _drawFontsize = _fontSize$2, 
            _overflow$2 = comp.overflow, _canvasSize.width = comp.node.width, _canvasSize.height = comp.node.height, 
            _lineHeight$2 = comp.lineHeight, _hAlign$2 = comp.horizontalAlign, _vAlign$2 = comp.verticalAlign, 
            _color$1 = comp.color, _isBold$1 = comp.isBold, _isItalic = comp.isItalic, _isUnderline = comp.isUnderline, 
            _isWrapText$2 = _overflow$2 !== Overflow$1.NONE && (_overflow$2 === Overflow$1.RESIZE_HEIGHT || comp.enableWrapText);
            var outline = OUTLINE_SUPPORTED && comp.getComponent(LabelOutlineComponent);
            outline && outline.enabled ? (_isOutlined = !0, _margin = _outlineWidth = outline.width, 
            _outlineColor.set(outline.color), _outlineColor.a = _outlineColor.a * comp.color.a / 255) : (_isOutlined = !1, 
            _margin = 0);
        }
    },
    _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
        var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
        return labelX = _hAlign$2 === exports.HorizontalTextAlignment.RIGHT ? _canvasSize.width - _margin : _hAlign$2 === exports.HorizontalTextAlignment.CENTER ? _canvasSize.width / 2 : 0 + _margin, 
        _vAlign$2 === exports.VerticalTextAlignment.TOP ? (firstLinelabelY = .13 * _fontSize$2, 
        firstLinelabelY = 0) : firstLinelabelY = _vAlign$2 === exports.VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
        new Vec2(labelX, firstLinelabelY);
    },
    _updateTexture: function _updateTexture() {
        if (_context && _canvas) {
            _context.clearRect(0, 0, _canvas.width, _canvas.height), _context.font = _fontDesc;
            var underlineStartPosition, startPosition = this._calculateFillTextStartPosition(), lineHeight = this._getLineHeight();
            _context.lineJoin = "round", _context.fillStyle = "rgba(".concat(_color$1.r, ", ").concat(_color$1.g, ", ").concat(_color$1.b, ", ").concat(_color$1.a / 255, ")");
            for (var i = 0; i < _splitedStrings.length; ++i) {
                if (_isOutlined) {
                    var strokeColor = _outlineColor || WHITE$2;
                    _context.strokeStyle = "rgba(".concat(strokeColor.r, ", ").concat(strokeColor.g, ", ").concat(strokeColor.b, ", ").concat(strokeColor.a / 255, ")"), 
                    _context.lineWidth = 2 * _outlineWidth, _context.strokeText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
                }
                _context.fillText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight), 
                _isUnderline && (underlineStartPosition = this._calculateUnderlineStartPosition(), 
                _context.save(), _context.beginPath(), _context.lineWidth = _fontSize$2 / 8, _context.strokeStyle = "rgba(".concat(_color$1.r, ", ").concat(_color$1.g, ", ").concat(_color$1.b, ", ").concat(_color$1.a / 255, ")"), 
                _context.moveTo(underlineStartPosition.x, underlineStartPosition.y + i * lineHeight - 1), 
                _context.lineTo(underlineStartPosition.x + _canvas.width, underlineStartPosition.y + i * lineHeight - 1), 
                _context.stroke(), _context.restore());
            }
            if (_texture) {
                var tex;
                tex = _texture instanceof SpriteFrame ? _texture.texture : _texture;
                var uploadAgain = 0 === _canvas.width || 0 === _canvas.height;
                tex.reset({
                    width: _canvas.width,
                    height: _canvas.height,
                    mipmapLevel: uploadAgain ? 0 : 1
                }), uploadAgain || tex.uploadData(_canvas);
            }
        }
    },
    _calculateUnderlineStartPosition: function _calculateUnderlineStartPosition() {
        var labelX, firstLinelabelY, lineHeight = this._getLineHeight(), lineCount = _splitedStrings.length;
        return labelX = 0 + _margin, firstLinelabelY = _vAlign$2 === exports.VerticalTextAlignment.TOP ? _fontSize$2 : _vAlign$2 === exports.VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 + _fontSize$2 / 2 : _canvasSize.height - lineHeight * (lineCount - 1), 
        new Vec2(labelX, firstLinelabelY);
    },
    _updateLabelDimensions: function _updateLabelDimensions() {
        if (_context) {
            var paragraphedStrings = _string$2.split("\n");
            if (_overflow$2 === Overflow$1.RESIZE_HEIGHT) _canvasSize.height = (_splitedStrings.length + .26) * this._getLineHeight(); else if (_overflow$2 === Overflow$1.NONE) {
                _splitedStrings = paragraphedStrings;
                for (var _step, canvasSizeX = 0, canvasSizeY = 0, _iterator = _createForOfIteratorHelperLoose(paragraphedStrings); !(_step = _iterator()).done; ) {
                    var para = _step.value, paraLength = safeMeasureText(_context, para);
                    canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                }
                canvasSizeY = (_splitedStrings.length + .26) * this._getLineHeight(), _canvasSize.width = parseFloat(canvasSizeX.toFixed(2)) + 2 * _margin, 
                _canvasSize.height = parseFloat(canvasSizeY.toFixed(2)), _isItalic && (_canvasSize.width += _drawFontsize * Math.tan(.20943951));
            }
            _canvas && (_canvas.width = _canvasSize.width, _canvas.height = _canvasSize.height);
        }
    },
    _calculateTextBaseline: function _calculateTextBaseline() {
        var hAlign, vAlign;
        hAlign = _hAlign$2 === exports.HorizontalTextAlignment.RIGHT ? "right" : _hAlign$2 === exports.HorizontalTextAlignment.CENTER ? "center" : "left", 
        vAlign = _vAlign$2 === exports.VerticalTextAlignment.TOP ? "top" : _vAlign$2 === exports.VerticalTextAlignment.CENTER ? "middle" : "bottom", 
        _context && (_context.textAlign = hAlign, _context.textBaseline = vAlign);
    },
    _calculateSplitedStrings: function _calculateSplitedStrings() {
        if (_context) {
            var paragraphedStrings = _string$2.split("\n");
            if (_isWrapText$2) {
                _splitedStrings = [];
                for (var _step2, canvasWidthNoMargin = _canvasSize.width - 2 * _margin, _iterator2 = _createForOfIteratorHelperLoose(paragraphedStrings); !(_step2 = _iterator2()).done; ) {
                    var para = _step2.value, textFragment = fragmentText(para, safeMeasureText(_context, para), canvasWidthNoMargin, this._measureText(_context));
                    _splitedStrings = _splitedStrings.concat(textFragment);
                }
            } else _splitedStrings = paragraphedStrings;
        }
    },
    _getFontDesc: function _getFontDesc() {
        var fontDesc = _fontSize$2.toString() + "px ";
        return fontDesc += _fontFamily$1, _isBold$1 && (fontDesc = "bold " + fontDesc), 
        _isItalic && (fontDesc = "italic " + fontDesc), fontDesc;
    },
    _getLineHeight: function _getLineHeight() {
        var nodeSpacingY = _lineHeight$2;
        return 0 | (nodeSpacingY = 0 === nodeSpacingY ? _fontSize$2 : nodeSpacingY * _fontSize$2 / _drawFontsize);
    },
    _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
        for (var _step3, paragraphLength = [], _iterator3 = _createForOfIteratorHelperLoose(paragraphedStrings); !(_step3 = _iterator3()).done; ) {
            var width = safeMeasureText(ctx, _step3.value);
            paragraphLength.push(width);
        }
        return paragraphLength;
    },
    _measureText: function _measureText(ctx) {
        return function(string) {
            return safeMeasureText(ctx, string);
        };
    },
    _calculateLabelFont: function _calculateLabelFont() {
        if (_context && (_fontDesc = this._getFontDesc(), _context.font = _fontDesc, _overflow$2 === Overflow$1.SHRINK)) {
            var paragraphedStrings = _string$2.split("\n"), paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);
            _splitedStrings = paragraphedStrings;
            var i = 0, totalHeight = 0, maxLength = 0;
            if (_isWrapText$2) {
                var canvasWidthNoMargin = _canvasSize.width - 2 * _margin, canvasHeightNoMargin = _canvasSize.height - 2 * _margin;
                if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) return _fontDesc = this._getFontDesc(), 
                void (_context.font = _fontDesc);
                totalHeight = canvasHeightNoMargin + 1, maxLength = canvasWidthNoMargin + 1;
                for (var actualFontSize = _fontSize$2 + 1, textFragment = [], tryDivideByTwo = !0, startShrinkFontSize = 0 | actualFontSize; totalHeight > canvasHeightNoMargin || maxLength > canvasWidthNoMargin; ) {
                    if (tryDivideByTwo ? actualFontSize = startShrinkFontSize / 2 | 0 : startShrinkFontSize = actualFontSize = startShrinkFontSize - 1, 
                    actualFontSize <= 0) {
                        logID(4003);
                        break;
                    }
                    for (_fontSize$2 = actualFontSize, _fontDesc = this._getFontDesc(), _context.font = _fontDesc, 
                    _splitedStrings = [], totalHeight = 0, i = 0; i < paragraphedStrings.length; ++i) {
                        var j = 0, allWidth = safeMeasureText(_context, paragraphedStrings[i]);
                        for (textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context)); j < textFragment.length; ) {
                            maxLength = safeMeasureText(_context, textFragment[j]), totalHeight += this._getLineHeight(), 
                            ++j;
                        }
                        _splitedStrings = _splitedStrings.concat(textFragment);
                    }
                    tryDivideByTwo && (totalHeight > canvasHeightNoMargin ? startShrinkFontSize = 0 | actualFontSize : (tryDivideByTwo = !1, 
                    totalHeight = canvasHeightNoMargin + 1));
                }
            } else {
                for (totalHeight = paragraphedStrings.length * this._getLineHeight(), i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
                var scaleX = (_canvasSize.width - 2 * _margin) / maxLength, scaleY = _canvasSize.height / totalHeight;
                _fontSize$2 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0, _fontDesc = this._getFontDesc(), 
                _context.font = _fontDesc;
            }
        }
    }
}, WHITE$3 = Color.WHITE.clone(), ttf = {
    createData: function createData(comp) {
        var renderData = comp.requestRenderData();
        renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6;
        var vData = renderData.vData = new Float32Array(36);
        vData[3] = vData[21] = vData[22] = vData[31] = 0, vData[4] = vData[12] = vData[13] = vData[30] = 1;
        for (var offset = 5, i = 0; i < 4; i++) Color.toArray(vData, WHITE$3, offset), offset += 9;
        return renderData;
    },
    fillBuffers: function fillBuffers(comp, renderer) {
        var renderData = comp.renderData, datas = renderData.datas, node = comp.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request() || (buffer = renderer.currBufferBatch, indiceOffset = 0, vertexId = 0);
        var vbuf = buffer.vData, ibuf = buffer.iData, vData = renderData.vData, data0 = datas[0], data3 = datas[3];
        node.updateWorldTransform();
        var pos = node._pos, rot = node._rot, scale = node._scale, ax = data0.x * scale.x, bx = data3.x * scale.x, ay = data0.y * scale.y, by = data3.y * scale.y, qx = rot.x, qy = rot.y, qz = rot.z, qw = rot.w, qxy = qx * qy, qzw = qz * qw, qxy2 = qx * qx - qy * qy, qzw2 = qw * qw - qz * qz, cx1 = qzw2 + qxy2, cx2 = 2 * (qxy - qzw), cy1 = qzw2 - qxy2, cy2 = 2 * (qxy + qzw), x = pos.x, y = pos.y;
        vData[0] = cx1 * ax + cx2 * ay + x, vData[1] = cy1 * ay + cy2 * ax + y, vData[9] = cx1 * bx + cx2 * ay + x, 
        vData[10] = cy1 * ay + cy2 * bx + y, vData[18] = cx1 * ax + cx2 * by + x, vData[19] = cy1 * by + cy2 * ax + y, 
        vData[27] = cx1 * bx + cx2 * by + x, vData[28] = cy1 * by + cy2 * bx + y, vbuf.set(vData, vertexOffset), 
        ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
        ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3;
    },
    updateVerts: function updateVerts(comp) {
        var renderData = comp.renderData;
        if (renderData) {
            var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, datas = renderData.datas;
            datas[0].x = -appx, datas[0].y = -appy, datas[3].x = width - appx, datas[3].y = height - appy;
        }
    }
};

addon(ttf, ttfUtils);

var labelAssembler = {
    getAssembler: function getAssembler(comp) {
        var assembler = ttf;
        return comp.font instanceof BitmapFont ? assembler = bmfont : comp.cacheMode === LabelComponent.CacheMode.CHAR && (assembler = letter), 
        assembler;
    }
};

LabelComponent.Assembler = labelAssembler;

var _stencilManager = StencilManager.sharedManager, maskAssembler = {
    createData: function createData(mask) {
        var renderData = mask.requestRenderData();
        return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
        renderData;
    },
    updateRenderData: function updateRenderData(mask) {
        var renderData = mask.renderData;
        renderData && renderData.vertDirty && this.updateVerts && this.updateVerts(mask);
    },
    updateVerts: function updateVerts(mask) {
        var renderData = mask.renderData;
        if (renderData) {
            var l, b, r, t, node = mask.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch;
            l = -appx, b = -appy, r = cw - appx, t = ch - appy, datas[0].x = l, datas[0].y = b, 
            datas[3].x = r, datas[3].y = t, renderData.vertDirty = !1;
        }
    },
    fillBuffers: function fillBuffers(mask, renderer) {
        _stencilManager.pushMask(mask), _stencilManager.clear(), mask.clearGraphics.updateAssembler(renderer), 
        _stencilManager.enterLevel(), mask.graphics.updateAssembler(renderer), _stencilManager.enableMask();
    }
}, maskEndAssembler = {
    fillBuffers: function fillBuffers(mask, ui) {
        _stencilManager.exitMask();
    }
}, StartAssembler = {
    getAssembler: function getAssembler() {
        return maskAssembler;
    }
}, PostAssembler = {
    getAssembler: function getAssembler() {
        return maskEndAssembler;
    }
};

MaskComponent.Assembler = StartAssembler, MaskComponent.PostAssembler = PostAssembler;

var FillType$1 = SpriteComponent.FillType, matrix = new Mat4, barFilled = {
    useModel: !1,
    updateRenderData: function updateRenderData(sprite) {
        var frame = sprite.spriteFrame, renderData = sprite.renderData;
        if (renderData && frame) {
            var uvDirty = renderData.uvDirty, vertDirty = renderData.vertDirty;
            if (!uvDirty && !vertDirty) return;
            var fillStart = sprite.fillStart, fillRange = sprite.fillRange;
            fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange), fillRange = (fillRange = (fillRange = fillStart + fillRange) > 1 ? 1 : fillRange) < 0 ? 0 : fillRange;
            var fillEnd = (fillStart = (fillStart = fillStart > 1 ? 1 : fillStart) < 0 ? 0 : fillStart) + (fillRange = (fillRange -= fillStart) < 0 ? 0 : fillRange);
            fillEnd = fillEnd > 1 ? 1 : fillEnd, uvDirty && this.updateUVs(sprite, fillStart, fillEnd), 
            vertDirty && (this.updateVerts && this.updateVerts(sprite, fillStart, fillEnd), 
            this.updateWorldVerts(sprite));
        }
    },
    updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
        var spriteFrame = sprite.spriteFrame, renderData = sprite.renderData, datas = renderData.datas, atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), ul = 0, vb = 0, quadUV0 = 0, quadUV1 = 0, quadUV2 = 0, quadUV3 = 0, quadUV4 = 0, quadUV5 = 0, quadUV6 = 0, quadUV7 = 0;
        switch (spriteFrame.isRotated() ? (ul = textureRect.x / atlasWidth, vb = (textureRect.y + textureRect.width) / atlasHeight, 
        quadUV0 = quadUV2 = ul, quadUV4 = quadUV6 = (textureRect.x + textureRect.height) / atlasWidth, 
        quadUV3 = quadUV7 = vb, quadUV1 = quadUV5 = textureRect.y / atlasHeight) : (ul = textureRect.x / atlasWidth, 
        vb = (textureRect.y + textureRect.height) / atlasHeight, quadUV0 = quadUV4 = ul, 
        quadUV2 = quadUV6 = (textureRect.x + textureRect.width) / atlasWidth, quadUV1 = quadUV3 = vb, 
        quadUV5 = quadUV7 = textureRect.y / atlasHeight), sprite.fillType) {
          case FillType$1.HORIZONTAL:
            datas[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV3 - quadUV1) * fillStart, 
            datas[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd, datas[1].v = quadUV1 + (quadUV3 - quadUV1) * fillEnd, 
            datas[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart, datas[2].v = quadUV5 + (quadUV7 - quadUV5) * fillStart, 
            datas[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd, datas[3].v = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
            break;

          case FillType$1.VERTICAL:
            datas[0].u = quadUV0 + (quadUV4 - quadUV0) * fillStart, datas[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart, 
            datas[1].u = quadUV2 + (quadUV6 - quadUV2) * fillStart, datas[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart, 
            datas[2].u = quadUV0 + (quadUV4 - quadUV0) * fillEnd, datas[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd, 
            datas[3].u = quadUV2 + (quadUV6 - quadUV2) * fillEnd, datas[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
            break;

          default:
            errorID(2626);
        }
        renderData.uvDirty = !1;
    },
    updateVerts: function updateVerts(sprite, fillStart, fillEnd) {
        var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, progressEnd = 0;
        switch (sprite.fillType) {
          case FillType$1.HORIZONTAL:
            progressEnd = l + (r - l) * fillEnd, l = l + (r - l) * fillStart, r = progressEnd;
            break;

          case FillType$1.VERTICAL:
            progressEnd = b + (t - b) * fillEnd, b = b + (t - b) * fillStart, t = progressEnd;
            break;

          default:
            errorID(2626);
        }
        datas[4].x = l, datas[4].y = b, datas[5].x = r, datas[5].y = b, datas[6].x = l, 
        datas[6].y = t, datas[7].x = r, datas[7].y = t, renderData.vertDirty = !1;
    },
    createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 8, renderData.vertexCount = 4, renderData.indiceCount = 6;
        for (var _step, _iterator = _createForOfIteratorHelperLoose(renderData.datas); !(_step = _iterator()).done; ) {
            _step.value.z = 0;
        }
        return renderData;
    },
    updateWorldVerts: function updateWorldVerts(sprite) {
        var node = sprite.node, datas = sprite.renderData.datas;
        node.getWorldMatrix(matrix);
        for (var i = 0; i < 4; i++) {
            var local = datas[i + 4], world = datas[i];
            Vec3.transformMat4(world, local, matrix);
        }
    },
    fillBuffers: function fillBuffers(sprite, renderer) {
        sprite.node.hasChangedFlags && this.updateWorldVerts(sprite);
        sprite.node;
        !function fillVerticesWithoutCalc3D(node, renderer, renderData, color) {
            var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
            buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
            vertexCount = 0, indiceOffset = 0, vertexId = 0);
            for (var vbuf = buffer.vData, i = 0; i < vertexCount; i++) {
                var vert = datas[i];
                vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
                vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
                vertexOffset += 4;
            }
            var ibuf = buffer.iData;
            ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, 
            ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 3, ibuf[indiceOffset++] = vertexId + 2;
        }(0, renderer, sprite.renderData, sprite.color);
    }
}, PI_2 = 2 * Math.PI, _vertPos = [ new Vec2, new Vec2, new Vec2, new Vec2 ], _vertices = new Array(4), _uvs = new Array(8), _intersectPoint_1 = [ new Vec2, new Vec2, new Vec2, new Vec2 ], _intersectPoint_2 = [ new Vec2, new Vec2, new Vec2, new Vec2 ], _center = new Vec2, _triangles = [ new Vec2, new Vec2, new Vec2, new Vec2 ];

function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
    var sinAngle = Math.sin(angle);
    sinAngle = Math.abs(sinAngle) > 1e-6 ? sinAngle : 0;
    var cosAngle = Math.cos(angle), tanAngle = 0, cotAngle = 0;
    if (0 !== (cosAngle = Math.abs(cosAngle) > 1e-6 ? cosAngle : 0)) {
        if (tanAngle = sinAngle / cosAngle, (left - center.x) * cosAngle > 0) {
            var yleft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left, intersectPoints[0].y = yleft;
        }
        if ((right - center.x) * cosAngle > 0) {
            var yright = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right, intersectPoints[2].y = yright;
        }
    }
    if (0 !== sinAngle) {
        if (cotAngle = cosAngle / sinAngle, (top - center.y) * sinAngle > 0) {
            var xtop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xtop, intersectPoints[3].y = top;
        }
        if ((bottom - center.y) * sinAngle > 0) {
            var xbottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xbottom, intersectPoints[1].y = bottom;
        }
    }
}

function _getVertAngle(start, end) {
    var placementX = end.x - start.x, placementY = end.y - start.y;
    if (0 === placementX && 0 === placementY) return 0;
    if (0 === placementX) return placementY > 0 ? .5 * Math.PI : 1.5 * Math.PI;
    var angle = Math.atan(placementY / placementX);
    return placementX < 0 && (angle += Math.PI), angle;
}

function _generateTriangle(datas, offset, vert0, vert1, vert2) {
    var vertices = _vertices, v0x = vertices[0], v0y = vertices[1], v1x = vertices[2], v1y = vertices[3];
    datas[offset].x = vert0.x, datas[offset].y = vert0.y, datas[offset + 1].x = vert1.x, 
    datas[offset + 1].y = vert1.y, datas[offset + 2].x = vert2.x, datas[offset + 2].y = vert2.y;
    _generateUV((vert0.x - v0x) / (v1x - v0x), (vert0.y - v0y) / (v1y - v0y), datas, offset), 
    _generateUV((vert1.x - v0x) / (v1x - v0x), (vert1.y - v0y) / (v1y - v0y), datas, offset + 1), 
    _generateUV((vert2.x - v0x) / (v1x - v0x), (vert2.y - v0y) / (v1y - v0y), datas, offset + 2);
}

function _generateUV(progressX, progressY, data, offset) {
    var uvs = _uvs, px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX, px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX, py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX, py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX, uv = data[offset];
    uv.u = px1 + (px2 - px1) * progressY, uv.v = py1 + (py2 - py1) * progressY;
}

for (var radialFilled = {
    useModel: !1,
    createData: function createData(sprite) {
        return sprite.requestRenderData();
    },
    updateRenderData: function updateRenderData(sprite) {
        var frame = sprite.spriteFrame, renderData = sprite.renderData;
        if (renderData && frame && (renderData.vertDirty || renderData.uvDirty)) {
            var datas = renderData.datas, fillStart = sprite.fillStart, fillRange = sprite.fillRange;
            for (fillRange < 0 && (fillStart += fillRange, fillRange = -fillRange); fillStart >= 1; ) fillStart -= 1;
            for (;fillStart < 0; ) fillStart += 1;
            var fillEnd = (fillStart *= PI_2) + (fillRange *= PI_2);
            !function _calculateVertices(sprite) {
                var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, l = -appx, b = -appy, r = width - appx, t = height - appy, vertices = _vertices;
                vertices[0] = l, vertices[1] = b, vertices[2] = r, vertices[3] = t;
                var fillCenter = sprite.fillCenter, cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
                _vertPos[0].x = _vertPos[3].x = l, _vertPos[1].x = _vertPos[2].x = r, _vertPos[0].y = _vertPos[1].y = b, 
                _vertPos[2].y = _vertPos[3].y = t;
                for (var _step, _iterator = _createForOfIteratorHelperLoose(_triangles); !(_step = _iterator()).done; ) {
                    var num = _step.value;
                    Vec2.set(num, 0, 0);
                }
                cx !== vertices[0] && Vec2.set(_triangles[0], 3, 0), cx !== vertices[2] && Vec2.set(_triangles[2], 1, 2), 
                cy !== vertices[1] && Vec2.set(_triangles[1], 0, 1), cy !== vertices[3] && Vec2.set(_triangles[3], 2, 3);
            }(sprite), function _calculateUVs(spriteFrame) {
                var atlasWidth = spriteFrame.width, atlasHeight = spriteFrame.height, textureRect = spriteFrame.getRect(), u0 = 0, u1 = 0, v0 = 0, v1 = 0, uvs = _uvs;
                spriteFrame.isRotated() ? (u0 = textureRect.x / atlasWidth, u1 = (textureRect.x + textureRect.height) / atlasWidth, 
                v0 = textureRect.y / atlasHeight, v1 = (textureRect.y + textureRect.width) / atlasHeight, 
                uvs[0] = uvs[2] = u0, uvs[4] = uvs[6] = u1, uvs[3] = uvs[7] = v1, uvs[1] = uvs[5] = v0) : (u0 = textureRect.x / atlasWidth, 
                u1 = (textureRect.x + textureRect.width) / atlasWidth, v0 = textureRect.y / atlasHeight, 
                v1 = (textureRect.y + textureRect.height) / atlasHeight, uvs[0] = uvs[4] = u0, uvs[2] = uvs[6] = u1, 
                uvs[1] = uvs[3] = v1, uvs[5] = uvs[7] = v0);
            }(frame), _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1), 
            _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
            for (var offset = 0, triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                var triangle = _triangles[triangleIndex];
                if (triangle) if (fillRange >= PI_2) renderData.dataLength = offset + 3, _generateTriangle(datas, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]), 
                offset += 3; else {
                    var startAngle = _getVertAngle(_center, _vertPos[triangle.x]), endAngle = _getVertAngle(_center, _vertPos[triangle.y]);
                    endAngle < startAngle && (endAngle += PI_2), startAngle -= PI_2, endAngle -= PI_2;
                    for (var testIndex = 0; testIndex < 3; ++testIndex) startAngle >= fillEnd || (startAngle >= fillStart ? (renderData.dataLength = offset + 3, 
                    _generateTriangle(datas, offset, _center, _vertPos[triangle.x], endAngle >= fillEnd ? _intersectPoint_2[triangleIndex] : _vertPos[triangle.y]), 
                    offset += 3) : endAngle <= fillStart || (endAngle <= fillEnd ? (renderData.dataLength = offset + 3, 
                    _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]), 
                    offset += 3) : (renderData.dataLength = offset + 3, _generateTriangle(datas, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]), 
                    offset += 3))), startAngle += PI_2, endAngle += PI_2;
                }
            }
            renderData.indiceCount = renderData.vertexCount = offset, renderData.vertDirty = renderData.uvDirty = !1;
        }
    },
    fillBuffers: function fillBuffers(comp, renderer) {
        !function fillVertices3D(node, renderer, renderData, color) {
            var datas = renderData.datas, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
            buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
            vertexCount = 0, indiceOffset = 0, vertexId = 0);
            var vbuf = buffer.vData;
            node.getWorldMatrix(_worldMatrix$1);
            for (var i = 0; i < vertexCount; i++) {
                var vert = datas[i];
                Vec3.set(vec3_temp, vert.x, vert.y, 0), Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix$1), 
                vbuf[vertexOffset++] = vec3_temp.x, vbuf[vertexOffset++] = vec3_temp.y, vbuf[vertexOffset++] = vec3_temp.z, 
                vbuf[vertexOffset++] = vert.u, vbuf[vertexOffset++] = vert.v, Color.toArray(vbuf, color, vertexOffset), 
                vertexOffset += 4;
            }
            for (var ibuf = buffer.iData, _i = 0; _i < renderData.dataLength; _i++) ibuf[indiceOffset + _i] = vertexId + _i;
        }(comp.node, renderer, comp.renderData, comp.color);
    }
}, vec3_temps$1 = [], i$2 = 0; i$2 < 4; i$2++) vec3_temps$1.push(new Vec3);

for (var simple = {
    createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        return renderData.dataLength = 4, renderData.vertexCount = 4, renderData.indiceCount = 6, 
        renderData.vData = new Float32Array(36), renderData;
    },
    updateRenderData: function updateRenderData(sprite) {
        var frame = sprite.spriteFrame, renderData = sprite.renderData;
        renderData && frame && (renderData.vertDirty && this.updateVerts(sprite), renderData.uvDirty && this.updateUvs(sprite));
    },
    fillBuffers: function fillBuffers(sprite, renderer) {
        if (null !== sprite) {
            var datas = sprite.renderData.datas, node = sprite.node, buffer = renderer.currBufferBatch, vertexOffset = buffer.byteOffset >> 2, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
            buffer.request() || (buffer = renderer.currBufferBatch, vertexOffset = 0, indiceOffset = 0, 
            vertexId = 0);
            var vbuf = buffer.vData, ibuf = buffer.iData, vData = sprite.renderData.vData, data0 = datas[0], data3 = datas[3], matrix = node.worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13, vl = data0.x, vr = data3.x, vb = data0.y, vt = data3.y, al = a * vl, ar = a * vr, bl = b * vl, br = b * vr, cb = c * vb, ct = c * vt, db = d * vb, dt = d * vt;
            vData[0] = al + cb + tx, vData[1] = bl + db + ty, vData[9] = ar + cb + tx, vData[10] = br + db + ty, 
            vData[18] = al + ct + tx, vData[19] = bl + dt + ty, vData[27] = ar + ct + tx, vData[28] = br + dt + ty, 
            vbuf.set(vData, vertexOffset), ibuf[indiceOffset++] = vertexId, ibuf[indiceOffset++] = vertexId + 1, 
            ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, 
            ibuf[indiceOffset++] = vertexId + 3;
        }
    },
    updateVerts: function updateVerts(sprite) {
        var renderData = sprite.renderData;
        if (renderData) {
            var node = sprite.node, datas = renderData.datas, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = 0, b = 0, r = 0, t = 0;
            if (sprite.trim) l = -appx, b = -appy, r = cw - appx, t = ch - appy; else {
                var frame = sprite.spriteFrame, originSize = frame.getOriginalSize(), rect = frame.getRect(), ow = originSize.width, oh = originSize.height, rw = rect.width, rh = rect.height, offset = frame.getOffset(), scaleX = cw / ow, scaleY = ch / oh, trimLeft = offset.x + (ow - rw) / 2, trimRight = offset.x - (ow - rw) / 2;
                l = trimLeft * scaleX - appx, b = (offset.y + (oh - rh) / 2) * scaleY - appy, r = cw + trimRight * scaleX - appx, 
                t = ch + (offset.y - (oh - rh) / 2) * scaleY - appy;
            }
            datas[0].x = l, datas[0].y = b, datas[0].z = 0, datas[3].x = r, datas[3].y = t, 
            datas[3].z = 0, renderData.vertDirty = !1;
        }
    },
    updateUvs: function updateUvs(sprite) {
        var renderData = sprite.renderData, vData = renderData.vData, uv = sprite.spriteFrame.uv;
        vData[3] = uv[0], vData[4] = uv[1], vData[12] = uv[2], vData[13] = uv[3], vData[21] = uv[4], 
        vData[22] = uv[5], vData[30] = uv[6], vData[31] = uv[7], renderData.uvDirty = !1;
    },
    updateColor: function updateColor(sprite) {
        for (var vData = sprite.renderData.vData, colorOffset = 5, color = sprite.color, colorr = color.r / 255, colorg = color.g / 255, colorb = color.b / 255, colora = color.a / 255, _i = 0; _i < 4; _i++) vData[colorOffset] = colorr, 
        vData[colorOffset + 1] = colorg, vData[colorOffset + 2] = colorb, vData[colorOffset + 3] = colora, 
        colorOffset += 9;
    }
}, vec3_temp$1 = new Vec3, matrix$1 = new Mat4, sliced = {
    useModel: !1,
    createData: function createData(sprite) {
        var renderData = sprite.requestRenderData();
        return renderData.dataLength = 20, renderData.vertexCount = 16, renderData.indiceCount = 54, 
        renderData;
    },
    updateRenderData: function updateRenderData(sprite) {
        var frame = sprite.spriteFrame, renderData = sprite.renderData;
        renderData && frame && (renderData.vertDirty && (this.updateVerts(sprite), this.updateWorldVerts(sprite)));
    },
    updateVerts: function updateVerts(sprite) {
        var renderData = sprite.renderData, datas = renderData.datas, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height, frame = sprite.spriteFrame, leftWidth = frame.insetLeft, rightWidth = frame.insetRight, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, sizableWidth = width - leftWidth - rightWidth, sizableHeight = height - topHeight - bottomHeight, xScale = width / (leftWidth + rightWidth), yScale = height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale, yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale, 
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth, sizableHeight = sizableHeight < 0 ? 0 : sizableHeight, 
        datas[0].x = -appx, datas[0].y = -appy, datas[1].x = leftWidth * xScale - appx, 
        datas[1].y = bottomHeight * yScale - appy, datas[2].x = datas[1].x + sizableWidth, 
        datas[2].y = datas[1].y + sizableHeight, datas[3].x = width - appx, datas[3].y = height - appy, 
        renderData.vertDirty = !1;
    },
    fillBuffers: function fillBuffers(sprite, renderer) {
        sprite.node.hasChangedFlags && this.updateWorldVerts(sprite);
        var buffer = renderer.currBufferBatch, renderData = sprite.renderData, datas = renderData.datas, vertexOffset = buffer.byteOffset >> 2, vertexCount = renderData.vertexCount, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset, uvSliced = sprite.spriteFrame.uvSliced;
        buffer.request(vertexCount, renderData.indiceCount) || (buffer = renderer.currBufferBatch, 
        vertexOffset = 0, indiceOffset = 0, vertexId = 0);
        for (var vbuf = buffer.vData, ibuf = buffer.iData, i = 4; i < 20; ++i) {
            var vert = datas[i], uvs = uvSliced[i - 4];
            vbuf[vertexOffset++] = vert.x, vbuf[vertexOffset++] = vert.y, vbuf[vertexOffset++] = vert.z, 
            vbuf[vertexOffset++] = uvs.u, vbuf[vertexOffset++] = uvs.v, Color.toArray(vbuf, sprite.color, vertexOffset), 
            vertexOffset += 4;
        }
        for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
            var start = vertexId + 4 * r + c;
            ibuf[indiceOffset++] = start, ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 4, 
            ibuf[indiceOffset++] = start + 1, ibuf[indiceOffset++] = start + 5, ibuf[indiceOffset++] = start + 4;
        }
    },
    updateWorldVerts: function updateWorldVerts(sprite) {
        var node = sprite.node, datas = sprite.renderData.datas;
        node.getWorldMatrix(matrix$1);
        for (var row = 0; row < 4; ++row) for (var rowD = datas[row], col = 0; col < 4; ++col) {
            var colD = datas[col], world = datas[4 + 4 * row + col];
            Vec3.set(vec3_temp$1, colD.x, rowD.y, 0), Vec3.transformMat4(world, vec3_temp$1, matrix$1);
        }
    }
}, vec3_temps$2 = [], i$3 = 0; i$3 < 4; i$3++) vec3_temps$2.push(new Vec3);

var _dec$1u, _dec2$14, _dec3$P, _dec4$L, _dec5$F, _dec6$D, _dec7$w, _dec8$u, _class$1v, _class2$1j, _descriptor$18, _descriptor2$X, _descriptor3$M, _descriptor4$E, tilled = {
    useModel: !1,
    createData: function createData(sprite) {
        return sprite.requestRenderData();
    },
    updateRenderData: function updateRenderData(sprite) {
        var renderData = sprite.renderData, frame = sprite.spriteFrame;
        if (frame && renderData && (renderData.uvDirty || renderData.vertDirty)) {
            var node = sprite.node, contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), appx = node.anchorX * contentWidth, appy = node.anchorY * contentHeight, rect = frame.getRect(), rectWidth = rect.width, rectHeight = rect.height, hRepeat = contentWidth / rectWidth, vRepeat = contentHeight / rectHeight, row = Math.ceil(vRepeat), col = Math.ceil(hRepeat), datas = renderData.datas;
            renderData.dataLength = Math.max(8, row + 1, col + 1);
            for (var _i = 0; _i <= col; ++_i) datas[_i].x = Math.min(rectWidth * _i, contentWidth) - appx;
            for (var _i2 = 0; _i2 <= row; ++_i2) datas[_i2].y = Math.min(rectHeight * _i2, contentHeight) - appy;
            renderData.vertexCount = row * col * 4, renderData.indiceCount = row * col * 6, 
            renderData.uvDirty = !1, renderData.vertDirty = !1;
        }
    },
    fillBuffers: function fillBuffers(sprite, renderer) {
        var node = sprite.node, renderData = sprite.renderData, buffer = renderer.currBufferBatch, indiceOffset = buffer.indiceOffset, vertexOffset = buffer.byteOffset >> 2, vertexId = buffer.vertexOffset, vertexCount = renderData.vertexCount, indiceCount = renderData.indiceCount, vbuf = buffer.vData, ibuf = buffer.iData;
        buffer.request(vertexCount, indiceCount) || (buffer = renderer.currBufferBatch, 
        vertexOffset = 0, indiceOffset = 0, vertexId = 0);
        var frame = sprite.spriteFrame, rotated = frame.isRotated(), uv = frame.uv, rect = frame.getRect(), contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), hRepeat = contentWidth / rect.width, vRepeat = contentHeight / rect.height, row = Math.ceil(vRepeat), col = Math.ceil(hRepeat), matrix = node.worldMatrix;
        this.fillVertices(vbuf, vertexOffset, matrix, row, col, renderData.datas);
        for (var coefu = 0, coefv = 0, yindex = 0, ylength = row; yindex < ylength; ++yindex) {
            coefv = Math.min(1, vRepeat - yindex);
            for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
                coefu = Math.min(1, hRepeat - xindex);
                var vertexOffsetU = vertexOffset + 3, vertexOffsetV = vertexOffsetU + 1;
                rotated ? (vbuf[vertexOffsetU] = uv[0], vbuf[vertexOffsetV] = uv[1], vbuf[vertexOffsetU + 9] = uv[0], 
                vbuf[vertexOffsetV + 9] = uv[1] + (uv[7] - uv[1]) * coefu, vbuf[vertexOffsetU + 18] = uv[0] + (uv[6] - uv[0]) * coefv, 
                vbuf[vertexOffsetV + 18] = uv[1], vbuf[vertexOffsetU + 27] = vbuf[vertexOffsetU + 18], 
                vbuf[vertexOffsetV + 27] = vbuf[vertexOffsetV + 9]) : (vbuf[vertexOffsetU] = uv[0], 
                vbuf[vertexOffsetV] = uv[1], vbuf[vertexOffsetU + 9] = uv[0] + (uv[6] - uv[0]) * coefu, 
                vbuf[vertexOffsetV + 9] = uv[1], vbuf[vertexOffsetU + 18] = uv[0], vbuf[vertexOffsetV + 18] = uv[1] + (uv[7] - uv[1]) * coefv, 
                vbuf[vertexOffsetU + 27] = vbuf[vertexOffsetU + 9], vbuf[vertexOffsetV + 27] = vbuf[vertexOffsetV + 18]), 
                Color.toArray(vbuf, sprite.color, vertexOffsetV + 1), Color.toArray(vbuf, sprite.color, vertexOffsetV + 9 + 1), 
                Color.toArray(vbuf, sprite.color, vertexOffsetV + 18 + 1), Color.toArray(vbuf, sprite.color, vertexOffsetV + 27 + 1), 
                vertexOffset += 36;
            }
        }
        for (var _i3 = 0; _i3 < indiceCount; _i3 += 6) ibuf[indiceOffset++] = vertexId, 
        ibuf[indiceOffset++] = vertexId + 1, ibuf[indiceOffset++] = vertexId + 2, ibuf[indiceOffset++] = vertexId + 1, 
        ibuf[indiceOffset++] = vertexId + 3, ibuf[indiceOffset++] = vertexId + 2, vertexId += 4;
    },
    fillVertices: function fillVertices(vbuf, vertexOffset, matrix, row, col, datas) {
        for (var x = 0, x1 = 0, y = 0, y1 = 0, yindex = 0, ylength = row; yindex < ylength; ++yindex) {
            y = datas[yindex].y, y1 = datas[yindex + 1].y;
            for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
                x = datas[xindex].x, x1 = datas[xindex + 1].x, Vec3.set(vec3_temps$2[0], x, y, 0), 
                Vec3.set(vec3_temps$2[1], x1, y, 0), Vec3.set(vec3_temps$2[2], x, y1, 0), Vec3.set(vec3_temps$2[3], x1, y1, 0);
                for (var _i4 = 0; _i4 < 4; _i4++) {
                    var vec3_temp = vec3_temps$2[_i4];
                    Vec3.transformMat4(vec3_temp, vec3_temp, matrix);
                    var offset = 9 * _i4;
                    vbuf[vertexOffset + offset] = vec3_temp.x, vbuf[vertexOffset + offset + 1] = vec3_temp.y, 
                    vbuf[vertexOffset + offset + 2] = vec3_temp.z;
                }
                vertexOffset += 36;
            }
        }
    }
}, SpriteType$1 = SpriteComponent.Type, FillType$2 = SpriteComponent.FillType, spriteAssembler = {
    getAssembler: function getAssembler(spriteComp) {
        var util = simple, comp = spriteComp;
        switch (comp.type) {
          case SpriteType$1.SLICED:
            util = sliced;
            break;

          case SpriteType$1.TILED:
            util = tilled;
            break;

          case SpriteType$1.FILLED:
            util = comp.fillType === FillType$2.RADIAL ? radialFilled : barFilled;
        }
        return util;
    }
};

SpriteComponent.Assembler = spriteAssembler, cc.UI = {
    MeshBuffer: MeshBuffer,
    UIVertexFormat: UIVertexFormat,
    barFilled: barFilled,
    radialFilled: radialFilled,
    simple: simple,
    sliced: sliced,
    ttf: ttf,
    bmfont: bmfont,
    letter: letter,
    mask: maskAssembler,
    maskEnd: maskEndAssembler,
    graphics: graphicsAssembler,
    spriteAssembler: spriteAssembler,
    graphicsAssembler: graphicsAssemblerManager,
    labelAssembler: labelAssembler
};

var _dec$1v, _dec2$15, _dec3$Q, _dec4$M, _dec5$G, _class$1w, _class2$1k, _descriptor$19, _descriptor2$Y, _descriptor3$N, _descriptor4$F, _descriptor5$v, _descriptor6$k, _descriptor7$i, _descriptor8$g, _class3$B, _temp$1o, _class$1x, _class2$1l, _descriptor$1a, _descriptor2$Z, _class4$c, _class5$a, _descriptor3$O, _descriptor4$G, _class7$2, _class8$2, _descriptor5$w, _descriptor6$l, _descriptor7$j, _class9, _temp3$2, BillboardComponent = (_dec$1u = ccclass("cc.BillboardComponent"), 
_dec2$14 = help("i18n:cc.BillboardComponent"), _dec3$P = menu("Components/Billboard"), 
_dec4$L = property({
    type: Texture2D
}), _dec5$F = property({
    type: Texture2D,
    tooltip: "billboard显示的贴图"
}), _dec6$D = property({
    tooltip: "billboard的高度"
}), _dec7$w = property({
    tooltip: "billboard的宽度"
}), _dec8$u = property({
    tooltip: "billboard绕中心点旋转的角度"
}), _dec$1u(_class$1v = _dec2$14(_class$1v = _dec3$P(_class$1v = executeInEditMode((_descriptor$18 = _applyDecoratedDescriptor((_class2$1j = function(_Component) {
    function BillboardComponent() {
        var _this;
        return _classCallCheck(this, BillboardComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BillboardComponent).call(this)), "_texture", _descriptor$18, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_height", _descriptor2$X, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_width", _descriptor3$M, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_rotation", _descriptor4$E, _assertThisInitialized(_this)), 
        _this._model = null, _this._mesh = null, _this._material = null, _this._uniform = new Vec4(1, 1, 0, 0), 
        _this;
    }
    return _inherits(BillboardComponent, Component), _createClass(BillboardComponent, [ {
        key: "texture",
        get: function get() {
            return this._texture;
        },
        set: function set(val) {
            this._texture = val, this._material && this._material.setProperty("mainTexture", val);
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        },
        set: function set(val) {
            this._height = val, this._material && (this._uniform.y = val, this._material.setProperty("cc_size_rotation", this._uniform));
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(val) {
            this._width = val, this._material && (this._uniform.x = val, this._material.setProperty("cc_size_rotation", this._uniform));
        }
    }, {
        key: "rotation",
        get: function get() {
            return Math.round(100 * toDegree(this._rotation)) / 100;
        },
        set: function set(val) {
            this._rotation = toRadian(val), this._material && (this._uniform.z = this._rotation, 
            this._material.setProperty("cc_size_rotation", this._uniform));
        }
    } ]), _createClass(BillboardComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this.createModel();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this.attachToScene(), this._model.enabled = !0, this.width = this._width, this.height = this._height, 
            this.rotation = this.rotation, this.texture = this.texture;
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.detachFromScene();
        }
    }, {
        key: "attachToScene",
        value: function attachToScene() {
            this._model && this.node && this.node.scene && (this._model.scene && this.detachFromScene(), 
            this._getRenderScene().addModel(this._model));
        }
    }, {
        key: "detachFromScene",
        value: function detachFromScene() {
            this._model && this._model.scene && this._model.scene.removeModel(this._model);
        }
    }, {
        key: "createModel",
        value: function createModel() {
            this._mesh = createMesh({
                primitiveMode: exports.GFXPrimitiveMode.TRIANGLE_LIST,
                positions: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ],
                uvs: [ 0, 0, 1, 0, 0, 1, 1, 1 ],
                colors: [ Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a, Color.WHITE.r, Color.WHITE.g, Color.WHITE.b, Color.WHITE.a ],
                attributes: [ {
                    name: exports.GFXAttributeName.ATTR_POSITION,
                    format: exports.GFXFormat.RGB32F
                }, {
                    name: exports.GFXAttributeName.ATTR_TEX_COORD,
                    format: exports.GFXFormat.RG32F
                }, {
                    name: exports.GFXAttributeName.ATTR_COLOR,
                    format: exports.GFXFormat.RGBA8UI,
                    isNormalized: !0
                } ],
                indices: [ 0, 1, 2, 1, 2, 3 ]
            }, void 0, {
                calculateBounds: !1
            }), this._model = cc.director.root.createModel(Model, this.node), this._model.initialize(this.node), 
            null == this._material && (this._material = new Material, this._material.copy(builtinResMgr.get("default-billboard-material"))), 
            this._model.initSubModel(0, this._mesh.renderingSubMeshes[0], this._material);
        }
    } ]), BillboardComponent;
}()).prototype, "_texture", [ _dec4$L ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1j.prototype, "texture", [ _dec5$F ], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "texture"), _class2$1j.prototype), 
_descriptor2$X = _applyDecoratedDescriptor(_class2$1j.prototype, "_height", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$1j.prototype, "height", [ _dec6$D ], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "height"), _class2$1j.prototype), 
_descriptor3$M = _applyDecoratedDescriptor(_class2$1j.prototype, "_width", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$1j.prototype, "width", [ _dec7$w ], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "width"), _class2$1j.prototype), 
_descriptor4$E = _applyDecoratedDescriptor(_class2$1j.prototype, "_rotation", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$1j.prototype, "rotation", [ _dec8$u ], Object.getOwnPropertyDescriptor(_class2$1j.prototype, "rotation"), _class2$1j.prototype), 
_class$1v = _class2$1j)) || _class$1v) || _class$1v) || _class$1v) || _class$1v), _vertex_attrs = [ {
    name: exports.GFXAttributeName.ATTR_POSITION,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD,
    format: exports.GFXFormat.RGBA32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD1,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_COLOR,
    format: exports.GFXFormat.RGBA8,
    isNormalized: !0
} ], _temp_v1 = new Vec3, _temp_v2 = new Vec3, LineModel = function(_Model) {
    function LineModel() {
        var _this;
        return _classCallCheck(this, LineModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(LineModel).call(this)))._capacity = void 0, 
        _this._vertSize = 0, _this._vBuffer = null, _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, 
        _this._vdataUint32 = null, _this._iaInfo = void 0, _this._iaInfoBuffer = void 0, 
        _this._subMeshData = null, _this._vertCount = 0, _this._indexCount = 0, _this.type = ModelType.LINE, 
        _this._capacity = 100, _this._iaInfo = {
            drawInfos: [ {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            } ]
        }, _this._iaInfoBuffer = _this._device.createBuffer({
            usage: exports.GFXBufferUsageBit.INDIRECT,
            memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
            size: 56,
            stride: 1
        }), _this;
    }
    return _inherits(LineModel, Model), _createClass(LineModel, [ {
        key: "setCapacity",
        value: function setCapacity(capacity) {
            this._capacity = capacity, this.createBuffer();
        }
    }, {
        key: "createBuffer",
        value: function createBuffer() {
            this._vertSize = 0;
            for (var _step, _iterator = _createForOfIteratorHelperLoose(_vertex_attrs); !(_step = _iterator()).done; ) {
                var a = _step.value;
                a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
            }
            this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
            this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
        }
    }, {
        key: "_createSubMeshData",
        value: function _createSubMeshData() {
            this._subMeshData && this.destroySubMeshData(), this._vertCount = 2, this._indexCount = 6;
            var vertexBuffer = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: this._vertSize * this._capacity * this._vertCount,
                stride: this._vertSize
            }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
            vertexBuffer.update(vBuffer);
            for (var indices = new Uint16Array((this._capacity - 1) * this._indexCount), dst = 0, i = 0; i < this._capacity - 1; ++i) {
                var baseIdx = 2 * i;
                indices[dst++] = baseIdx, indices[dst++] = baseIdx + 1, indices[dst++] = baseIdx + 2, 
                indices[dst++] = baseIdx + 3, indices[dst++] = baseIdx + 2, indices[dst++] = baseIdx + 1;
            }
            var indexBuffer = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: (this._capacity - 1) * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                stride: Uint16Array.BYTES_PER_ELEMENT
            });
            return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
            this._iaInfo.drawInfos[0].indexCount = (this._capacity - 1) * this._indexCount, 
            this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = new RenderingSubMesh([ vertexBuffer ], _vertex_attrs, exports.GFXPrimitiveMode.TRIANGLE_LIST), 
            this._subMeshData.indexBuffer = indexBuffer, this._subMeshData.indirectBuffer = this._iaInfoBuffer, 
            this.setSubModelMesh(0, this._subMeshData), vBuffer;
        }
    }, {
        key: "addLineVertexData",
        value: function addLineVertexData(positions, width, color) {
            if (positions.length > 1) {
                var offset = 0;
                Vec3.subtract(_temp_v1, positions[1], positions[0]), this._vdataF32[offset++] = positions[0].x, 
                this._vdataF32[offset++] = positions[0].y, this._vdataF32[offset++] = positions[0].z, 
                this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(0, 1), this._vdataF32[offset++] = 0, 
                this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val, 
                this._vdataF32[offset++] = positions[0].x, this._vdataF32[offset++] = positions[0].y, 
                this._vdataF32[offset++] = positions[0].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(0, 1), 
                this._vdataF32[offset++] = 0, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, 
                this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(0, 1)._val;
                for (var i = 1; i < positions.length - 1; i++) {
                    Vec3.subtract(_temp_v1, positions[i - 1], positions[i]), Vec3.subtract(_temp_v2, positions[i + 1], positions[i]), 
                    Vec3.subtract(_temp_v2, _temp_v2, _temp_v1);
                    var seg = i / positions.length;
                    this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                    this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                    this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 0, this._vdataF32[offset++] = _temp_v2.x, 
                    this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val, 
                    this._vdataF32[offset++] = positions[i].x, this._vdataF32[offset++] = positions[i].y, 
                    this._vdataF32[offset++] = positions[i].z, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(seg, 1), 
                    this._vdataF32[offset++] = seg, this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v2.x, 
                    this._vdataF32[offset++] = _temp_v2.y, this._vdataF32[offset++] = _temp_v2.z, this._vdataUint32[offset++] = color.evaluate(seg, 1)._val;
                }
                Vec3.subtract(_temp_v1, positions[positions.length - 1], positions[positions.length - 2]), 
                this._vdataF32[offset++] = positions[positions.length - 1].x, this._vdataF32[offset++] = positions[positions.length - 1].y, 
                this._vdataF32[offset++] = positions[positions.length - 1].z, this._vdataF32[offset++] = 0, 
                this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, this._vdataF32[offset++] = 0, 
                this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, this._vdataF32[offset++] = _temp_v1.z, 
                this._vdataUint32[offset++] = color.evaluate(1, 1)._val, this._vdataF32[offset++] = positions[positions.length - 1].x, 
                this._vdataF32[offset++] = positions[positions.length - 1].y, this._vdataF32[offset++] = positions[positions.length - 1].z, 
                this._vdataF32[offset++] = 1, this._vdataF32[offset++] = width.evaluate(1, 1), this._vdataF32[offset++] = 1, 
                this._vdataF32[offset++] = 1, this._vdataF32[offset++] = _temp_v1.x, this._vdataF32[offset++] = _temp_v1.y, 
                this._vdataF32[offset++] = _temp_v1.z, this._vdataUint32[offset++] = color.evaluate(1, 1)._val;
            }
            this.updateIA(Math.max(0, positions.length - 1));
        }
    }, {
        key: "updateIA",
        value: function updateIA(count) {
            var ia = this.getSubModel(0).inputAssembler;
            ia.vertexBuffers[0].update(this._vdataF32), ia.indexCount = this._indexCount * count, 
            this._iaInfo.drawInfos[0] = ia, this._iaInfoBuffer.update(this._iaInfo);
        }
    }, {
        key: "destroySubMeshData",
        value: function destroySubMeshData() {
            this._subMeshData && (this._subMeshData.destroy(), this._subMeshData = null);
        }
    } ]), LineModel;
}(), Mode$1 = Enum({
    Constant: 0,
    Curve: 1,
    TwoCurves: 2,
    TwoConstants: 3
}), CurveRange = (_dec$1v = ccclass("cc.CurveRange"), _dec2$15 = property({
    type: Mode$1
}), _dec3$Q = property({
    type: AnimationCurve
}), _dec4$M = property({
    type: AnimationCurve
}), _dec5$G = property({
    type: AnimationCurve
}), _dec$1v((_temp$1o = _class3$B = function() {
    function CurveRange() {
        _classCallCheck(this, CurveRange), _initializerDefineProperty(this, "mode", _descriptor$19, this), 
        _initializerDefineProperty(this, "curve", _descriptor2$Y, this), _initializerDefineProperty(this, "curveMin", _descriptor3$N, this), 
        _initializerDefineProperty(this, "curveMax", _descriptor4$F, this), _initializerDefineProperty(this, "constant", _descriptor5$v, this), 
        _initializerDefineProperty(this, "constantMin", _descriptor6$k, this), _initializerDefineProperty(this, "constantMax", _descriptor7$i, this), 
        _initializerDefineProperty(this, "multiplier", _descriptor8$g, this);
    }
    return _createClass(CurveRange, [ {
        key: "evaluate",
        value: function evaluate(time, rndRatio) {
            switch (this.mode) {
              case Mode$1.Constant:
                return this.constant;

              case Mode$1.Curve:
                return this.curve.evaluate(time) * this.multiplier;

              case Mode$1.TwoCurves:
                return lerp(this.curveMin.evaluate(time), this.curveMax.evaluate(time), rndRatio) * this.multiplier;

              case Mode$1.TwoConstants:
                return lerp(this.constantMin, this.constantMax, rndRatio);
            }
        }
    }, {
        key: "getMax",
        value: function getMax() {
            switch (this.mode) {
              case Mode$1.Constant:
                return this.constant;

              case Mode$1.Curve:
                return this.multiplier;

              case Mode$1.TwoConstants:
                return this.constantMax;

              case Mode$1.TwoCurves:
                return this.multiplier;
            }
            return 0;
        }
    }, {
        key: "_onBeforeSerialize",
        value: function _onBeforeSerialize(props) {
            return (!1)[this.mode];
        }
    } ]), CurveRange;
}(), _class3$B.Mode = Mode$1, _descriptor$19 = _applyDecoratedDescriptor((_class2$1k = _temp$1o).prototype, "mode", [ _dec2$15 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode$1.Constant;
    }
}), _descriptor2$Y = _applyDecoratedDescriptor(_class2$1k.prototype, "curve", [ _dec3$Q ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new AnimationCurve;
    }
}), _descriptor3$N = _applyDecoratedDescriptor(_class2$1k.prototype, "curveMin", [ _dec4$M ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new AnimationCurve;
    }
}), _descriptor4$F = _applyDecoratedDescriptor(_class2$1k.prototype, "curveMax", [ _dec5$G ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new AnimationCurve;
    }
}), _descriptor5$v = _applyDecoratedDescriptor(_class2$1k.prototype, "constant", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$k = _applyDecoratedDescriptor(_class2$1k.prototype, "constantMin", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$i = _applyDecoratedDescriptor(_class2$1k.prototype, "constantMax", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$g = _applyDecoratedDescriptor(_class2$1k.prototype, "multiplier", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _class$1w = _class2$1k)) || _class$1w);

function evaluateCurve(cr, time, index) {
    switch (cr.mode) {
      case Mode$1.Constant:
        return cr.constant;

      case Mode$1.Curve:
        return cr.curve.evaluate(time) * cr.multiplier;

      case Mode$1.TwoCurves:
        return 0 === index ? cr.curveMin.evaluate(time) * cr.multiplier : cr.curveMax.evaluate(time) * cr.multiplier;

      case Mode$1.TwoConstants:
        return 0 === index ? cr.constantMin : cr.constantMax;

      default:
        return 0;
    }
}

function evaluateHeight(cr) {
    switch (cr.mode) {
      case Mode$1.TwoConstants:
      case Mode$1.TwoCurves:
        return 2;

      default:
        return 1;
    }
}

function packTexture(data, width, height) {
    var image = new ImageAsset({
        width: width,
        height: height,
        _data: data,
        _compressed: !1,
        format: PixelFormat.RGBA32F
    }), texture = new Texture2D;
    return texture.setFilters(Filter.NEAREST, Filter.NEAREST), texture.setMipFilter(Filter.NONE), 
    texture.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE), 
    texture.image = image, texture;
}

function packCurveRangeXYZ(samples, x, y, z, discrete) {
    for (var height = Math.max(evaluateHeight(x), evaluateHeight(y), evaluateHeight(z)), data = new Float32Array(samples * height * 4), curves = [ x, y, z ], interval = 1 / (samples - 1), h = 0; h < height; h++) for (var i = 0; i < 3; i++) for (var cr = curves[i], sum = 0, average = 0, j = 0; j < samples; j++) {
        var value = evaluateCurve(cr, interval * j, h);
        average = discrete ? value : (sum += value) / (j + 1), data[4 * j + i] = average;
    }
    return packTexture(data, samples, height);
}

var _dec$1x, _dec2$17, _dec3$S, _dec4$N, _dec5$H, _dec6$E, _class$1y, _class2$1m, _descriptor$1b, _descriptor2$_, _descriptor3$P, _descriptor4$H, _descriptor5$x, _descriptor6$m, _descriptor7$k, _class3$C, _temp$1q, _dec$1y, _dec2$18, _dec3$T, _dec4$O, _dec5$I, _dec6$F, _dec7$x, _dec8$v, _dec9$m, _dec10$g, _dec11$f, _dec12$e, _dec13$c, _dec14$b, _class$1z, _class2$1n, _descriptor$1c, _descriptor2$$, _descriptor3$Q, _descriptor4$I, _descriptor5$y, _descriptor6$n, _descriptor7$l, Mode$2 = Enum({
    Blend: 0,
    Fixed: 1
}), Gradient = (ccclass("cc.ColorKey")((_descriptor$1a = _applyDecoratedDescriptor((_class2$1l = function ColorKey() {
    _classCallCheck(this, ColorKey), _initializerDefineProperty(this, "color", _descriptor$1a, this), 
    _initializerDefineProperty(this, "time", _descriptor2$Z, this);
}).prototype, "color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor2$Z = _applyDecoratedDescriptor(_class2$1l.prototype, "time", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$1x = _class2$1l)), ccclass("cc.AlphaKey")((_descriptor3$O = _applyDecoratedDescriptor((_class5$a = function AlphaKey() {
    _classCallCheck(this, AlphaKey), _initializerDefineProperty(this, "alpha", _descriptor3$O, this), 
    _initializerDefineProperty(this, "time", _descriptor4$G, this);
}).prototype, "alpha", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor4$G = _applyDecoratedDescriptor(_class5$a.prototype, "time", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class4$c = _class5$a)), ccclass("cc.Gradient")((_temp3$2 = _class9 = function() {
    function Gradient() {
        _classCallCheck(this, Gradient), _initializerDefineProperty(this, "colorKeys", _descriptor5$w, this), 
        _initializerDefineProperty(this, "alphaKeys", _descriptor6$l, this), _initializerDefineProperty(this, "mode", _descriptor7$j, this), 
        this._color = void 0, this._color = Color.WHITE.clone();
    }
    return _createClass(Gradient, [ {
        key: "setKeys",
        value: function setKeys(colorKeys, alphaKeys) {
            this.colorKeys = colorKeys, this.alphaKeys = alphaKeys;
        }
    }, {
        key: "sortKeys",
        value: function sortKeys() {
            this.colorKeys.length > 1 && this.colorKeys.sort((function(a, b) {
                return a.time - b.time;
            })), this.alphaKeys.length > 1 && this.alphaKeys.sort((function(a, b) {
                return a.time - b.time;
            }));
        }
    }, {
        key: "evaluate",
        value: function evaluate(time) {
            return this.getRGB(time), this._color._set_a_unsafe(this.getAlpha(time)), this._color;
        }
    }, {
        key: "randomColor",
        value: function randomColor() {
            var c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)], a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];
            return this._color.set(c.color), this._color._set_a_unsafe(a.alpha), this._color;
        }
    }, {
        key: "getRGB",
        value: function getRGB(time) {
            if (!(this.colorKeys.length > 1)) return 1 === this.colorKeys.length ? (this._color.set(this.colorKeys[0].color), 
            this._color) : (this._color.set(Color.WHITE), this._color);
            time = repeat(time, 1);
            for (var i = 1; i < this.colorKeys.length; ++i) {
                var preTime = this.colorKeys[i - 1].time, curTime = this.colorKeys[i].time;
                if (time >= preTime && time < curTime) {
                    if (this.mode === Mode$2.Fixed) return this.colorKeys[i].color;
                    var factor = (time - preTime) / (curTime - preTime);
                    return Color.lerp(this._color, this.colorKeys[i - 1].color, this.colorKeys[i].color, factor), 
                    this._color;
                }
            }
            var lastIndex = this.colorKeys.length - 1;
            time < this.colorKeys[0].time ? Color.lerp(this._color, Color.BLACK, this.colorKeys[0].color, time / this.colorKeys[0].time) : time > this.colorKeys[lastIndex].time && Color.lerp(this._color, this.colorKeys[lastIndex].color, Color.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time));
        }
    }, {
        key: "getAlpha",
        value: function getAlpha(time) {
            if (!(this.alphaKeys.length > 1)) return 1 === this.alphaKeys.length ? this.alphaKeys[0].alpha : 255;
            time = repeat(time, 1);
            for (var i = 1; i < this.alphaKeys.length; ++i) {
                var preTime = this.alphaKeys[i - 1].time, curTime = this.alphaKeys[i].time;
                if (time >= preTime && time < curTime) {
                    if (this.mode === Mode$2.Fixed) return this.alphaKeys[i].alpha;
                    var factor = (time - preTime) / (curTime - preTime);
                    return lerp(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
                }
            }
            var lastIndex = this.alphaKeys.length - 1;
            return time < this.alphaKeys[0].time ? lerp(255, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time) : time > this.alphaKeys[lastIndex].time ? lerp(this.alphaKeys[lastIndex].alpha, 255, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time)) : void 0;
        }
    } ]), Gradient;
}(), _class9.Mode = Mode$2, _descriptor5$w = _applyDecoratedDescriptor((_class8$2 = _temp3$2).prototype, "colorKeys", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Array;
    }
}), _descriptor6$l = _applyDecoratedDescriptor(_class8$2.prototype, "alphaKeys", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Array;
    }
}), _descriptor7$j = _applyDecoratedDescriptor(_class8$2.prototype, "mode", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode$2.Blend;
    }
}), _class7$2 = _class8$2)) || _class7$2), Mode$3 = Enum({
    Color: 0,
    Gradient: 1,
    TwoColors: 2,
    TwoGradients: 3,
    RandomColor: 4
}), GradientRange = (_dec$1x = ccclass("cc.GradientRange"), _dec2$17 = property({
    type: Mode$3
}), _dec3$S = property({
    type: Gradient
}), _dec4$N = property({
    type: Gradient
}), _dec5$H = property({
    type: Gradient
}), _dec6$E = property({
    type: Mode$3
}), _dec$1x((_temp$1q = _class3$C = function() {
    function GradientRange() {
        _classCallCheck(this, GradientRange), _initializerDefineProperty(this, "color", _descriptor$1b, this), 
        _initializerDefineProperty(this, "colorMin", _descriptor2$_, this), _initializerDefineProperty(this, "colorMax", _descriptor3$P, this), 
        _initializerDefineProperty(this, "gradient", _descriptor4$H, this), _initializerDefineProperty(this, "gradientMin", _descriptor5$x, this), 
        _initializerDefineProperty(this, "gradientMax", _descriptor6$m, this), _initializerDefineProperty(this, "_mode", _descriptor7$k, this), 
        this._color = Color.WHITE.clone();
    }
    return _createClass(GradientRange, [ {
        key: "evaluate",
        value: function evaluate(time, rndRatio) {
            switch (this._mode) {
              case Mode$3.Color:
                return this.color;

              case Mode$3.TwoColors:
                return Color.lerp(this._color, this.colorMin, this.colorMax, rndRatio), this._color;

              case Mode$3.RandomColor:
                return this.gradient.randomColor();

              case Mode$3.Gradient:
                return this.gradient.evaluate(time);

              case Mode$3.TwoGradients:
                return Color.lerp(this._color, this.gradientMin.evaluate(time), this.gradientMax.evaluate(time), rndRatio), 
                this._color;

              default:
                return this.color;
            }
        }
    }, {
        key: "_onBeforeSerialize",
        value: function _onBeforeSerialize(props) {
            return (!1)[this._mode];
        }
    }, {
        key: "mode",
        get: function get() {
            return this._mode;
        },
        set: function set(m) {
            this._mode = m;
        }
    } ]), GradientRange;
}(), _class3$C.Mode = Mode$3, _applyDecoratedDescriptor((_class2$1m = _temp$1q).prototype, "mode", [ _dec2$17 ], Object.getOwnPropertyDescriptor(_class2$1m.prototype, "mode"), _class2$1m.prototype), 
_descriptor$1b = _applyDecoratedDescriptor(_class2$1m.prototype, "color", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor2$_ = _applyDecoratedDescriptor(_class2$1m.prototype, "colorMin", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor3$P = _applyDecoratedDescriptor(_class2$1m.prototype, "colorMax", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Color.WHITE.clone();
    }
}), _descriptor4$H = _applyDecoratedDescriptor(_class2$1m.prototype, "gradient", [ _dec3$S ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Gradient;
    }
}), _descriptor5$x = _applyDecoratedDescriptor(_class2$1m.prototype, "gradientMin", [ _dec4$N ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Gradient;
    }
}), _descriptor6$m = _applyDecoratedDescriptor(_class2$1m.prototype, "gradientMax", [ _dec5$H ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Gradient;
    }
}), _descriptor7$k = _applyDecoratedDescriptor(_class2$1m.prototype, "_mode", [ _dec6$E ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode$3.Color;
    }
}), _class$1y = _class2$1m)) || _class$1y);

function evaluateGradient(gr, time, index) {
    switch (gr.mode) {
      case Mode$3.Color:
        return gr.color;

      case Mode$3.TwoColors:
        return 0 === index ? gr.colorMin : gr.colorMax;

      case Mode$3.RandomColor:
        return gr.gradient.randomColor();

      case Mode$3.Gradient:
        return gr.gradient.evaluate(time);

      case Mode$3.TwoGradients:
        return 0 === index ? gr.gradientMin.evaluate(time) : gr.gradientMax.evaluate(time);

      default:
        return gr.color;
    }
}

function packGradientRange(samples, gr) {
    for (var height = function evaluateHeight$1(gr) {
        switch (gr.mode) {
          case Mode$3.TwoColors:
          case Mode$3.TwoGradients:
            return 2;

          default:
            return 1;
        }
    }(gr), data = new Uint8Array(samples * height * 4), interval = 1 / (samples - 1), offset = 0, h = 0; h < height; h++) for (var j = 0; j < samples; j++) {
        var color = evaluateGradient(gr, interval * j, h);
        data[offset] = color.r, data[offset + 1] = color.g, data[offset + 2] = color.b, 
        data[offset + 3] = color.a, offset += 4;
    }
    var texture = new Texture2D;
    return texture.create(samples, height, PixelFormat.RGBA8888), texture.setFilters(Filter.LINEAR, Filter.LINEAR), 
    texture.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE), texture.uploadData(data), 
    texture;
}

var _dec$1z, _dec2$19, _dec3$U, _class$1A, _class2$1o, _descriptor$1d, _descriptor2$10, _dec$1A, _dec2$1a, _dec3$V, _dec4$P, _dec5$J, _dec6$G, _class$1B, _class2$1p, _descriptor$1e, _descriptor2$11, _descriptor3$R, _descriptor4$J, _descriptor5$z, define$1 = {
    CC_USE_WORLD_SPACE: !1
}, LineComponent = (_dec$1y = ccclass("cc.LineComponent"), _dec2$18 = help("i18n:cc.LineComponent"), 
_dec3$T = menu("Components/Line"), _dec4$O = property({
    type: Texture2D
}), _dec5$I = property({
    type: Texture2D,
    displayOrder: 0,
    tooltip: "线段中显示的贴图"
}), _dec6$F = property({
    displayOrder: 1,
    tooltip: "线段中各个点的坐标采用哪个坐标系，勾选使用世界坐标系，不选使用本地坐标系"
}), _dec7$x = property({
    type: [ Vec3 ]
}), _dec8$v = property({
    type: [ Vec3 ],
    displayOrder: 2,
    tooltip: "每个线段端点的坐标"
}), _dec9$m = property({
    type: CurveRange
}), _dec10$g = property({
    type: CurveRange,
    displayOrder: 3,
    tooltip: "线段宽度，如果采用曲线，则表示沿着线段方向上的曲线变化"
}), _dec11$f = property({
    type: Vec2,
    displayOrder: 4,
    tooltip: "贴图平铺次数"
}), _dec12$e = property({
    type: Vec2,
    displayOrder: 5,
    tooltip: "贴图坐标的偏移"
}), _dec13$c = property({
    type: GradientRange
}), _dec14$b = property({
    type: GradientRange,
    displayOrder: 6,
    tooltip: "线段颜色，如果采用渐变色，则表示沿着线段方向上的颜色渐变"
}), _dec$1y(_class$1z = _dec2$18(_class$1z = _dec3$T(_class$1z = executeInEditMode((_descriptor$1c = _applyDecoratedDescriptor((_class2$1n = function(_Component) {
    function LineComponent() {
        var _this;
        return _classCallCheck(this, LineComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LineComponent).call(this)), "_texture", _descriptor$1c, _assertThisInitialized(_this)), 
        _this._material = null, _initializerDefineProperty(_this, "_worldSpace", _descriptor2$$, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_positions", _descriptor3$Q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_width", _descriptor4$I, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_tile", _descriptor5$y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_offset", _descriptor6$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_color", _descriptor7$l, _assertThisInitialized(_this)), 
        _this._model = null, _this._tile_offset = new Vec4, _this;
    }
    return _inherits(LineComponent, Component), _createClass(LineComponent, [ {
        key: "texture",
        get: function get() {
            return this._texture;
        },
        set: function set(val) {
            this._texture = val, this._material && this._material.setProperty("mainTexture", val);
        }
    }, {
        key: "worldSpace",
        get: function get() {
            return this._worldSpace;
        },
        set: function set(val) {
            this._worldSpace = val, this._material && (define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
            this._material.recompileShaders(define$1), this._model && this._model.setSubModelMaterial(0, this._material));
        }
    }, {
        key: "positions",
        get: function get() {
            return this._positions;
        },
        set: function set(val) {
            this._positions = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
        }
    }, {
        key: "width",
        get: function get() {
            return this._width;
        },
        set: function set(val) {
            this._width = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
        }
    }, {
        key: "tile",
        get: function get() {
            return this._tile;
        },
        set: function set(val) {
            this._tile.set(val), this._material && (this._tile_offset.x = this._tile.x, this._tile_offset.y = this._tile.y, 
            this._material.setProperty("mainTiling_Offset", this._tile_offset));
        }
    }, {
        key: "offset",
        get: function get() {
            return this._offset;
        },
        set: function set(val) {
            this._offset.set(val), this._material && (this._tile_offset.z = this._offset.x, 
            this._tile_offset.w = this._offset.y, this._material.setProperty("mainTiling_Offset", this._tile_offset));
        }
    }, {
        key: "color",
        get: function get() {
            return this._color;
        },
        set: function set(val) {
            this._color = val, this._model && this._model.addLineVertexData(this._positions, this._width, this._color);
        }
    } ]), _createClass(LineComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._model = cc.director.root.createModel(LineModel), this._model.initialize(this.node), 
            this._model.setCapacity(100), null == this._material && (this._material = new Material, 
            this._material.copy(builtinResMgr.get("default-trail-material")), define$1.CC_USE_WORLD_SPACE = this.worldSpace, 
            this._material.recompileShaders(define$1)), this._model.setSubModelMaterial(0, this._material);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._model && (this.attachToScene(), this.texture = this.texture, this.tile = this._tile, 
            this.offset = this._offset, this._model.addLineVertexData(this._positions, this._width, this._color));
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._model && this.detachFromScene();
        }
    }, {
        key: "attachToScene",
        value: function attachToScene() {
            this._model && this.node && this.node.scene && (this._model.scene && this.detachFromScene(), 
            this._getRenderScene().addModel(this._model));
        }
    }, {
        key: "detachFromScene",
        value: function detachFromScene() {
            this._model && this._model.scene && this._model.scene.removeModel(this._model);
        }
    } ]), LineComponent;
}()).prototype, "_texture", [ _dec4$O ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1n.prototype, "texture", [ _dec5$I ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "texture"), _class2$1n.prototype), 
_descriptor2$$ = _applyDecoratedDescriptor(_class2$1n.prototype, "_worldSpace", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1n.prototype, "worldSpace", [ _dec6$F ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "worldSpace"), _class2$1n.prototype), 
_descriptor3$Q = _applyDecoratedDescriptor(_class2$1n.prototype, "_positions", [ _dec7$x ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _applyDecoratedDescriptor(_class2$1n.prototype, "positions", [ _dec8$v ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "positions"), _class2$1n.prototype), 
_descriptor4$I = _applyDecoratedDescriptor(_class2$1n.prototype, "_width", [ _dec9$m ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _applyDecoratedDescriptor(_class2$1n.prototype, "width", [ _dec10$g ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "width"), _class2$1n.prototype), 
_descriptor5$y = _applyDecoratedDescriptor(_class2$1n.prototype, "_tile", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(1, 1);
    }
}), _applyDecoratedDescriptor(_class2$1n.prototype, "tile", [ _dec11$f ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "tile"), _class2$1n.prototype), 
_descriptor6$n = _applyDecoratedDescriptor(_class2$1n.prototype, "_offset", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec2(0, 0);
    }
}), _applyDecoratedDescriptor(_class2$1n.prototype, "offset", [ _dec12$e ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "offset"), _class2$1n.prototype), 
_descriptor7$l = _applyDecoratedDescriptor(_class2$1n.prototype, "_color", [ _dec13$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange;
    }
}), _applyDecoratedDescriptor(_class2$1n.prototype, "color", [ _dec14$b ], Object.getOwnPropertyDescriptor(_class2$1n.prototype, "color"), _class2$1n.prototype), 
_class$1z = _class2$1n)) || _class$1z) || _class$1z) || _class$1z) || _class$1z), Particle = function Particle(particleSystem) {
    _classCallCheck(this, Particle), this.particleSystem = void 0, this.position = void 0, 
    this.velocity = void 0, this.animatedVelocity = void 0, this.ultimateVelocity = void 0, 
    this.angularVelocity = void 0, this.axisOfRotation = void 0, this.rotation = void 0, 
    this.startSize = void 0, this.size = void 0, this.startColor = void 0, this.color = void 0, 
    this.randomSeed = void 0, this.remainingLifetime = void 0, this.startLifetime = void 0, 
    this.emitAccumulator0 = void 0, this.emitAccumulator1 = void 0, this.frameIndex = void 0, 
    this.startRow = void 0, this.particleSystem = particleSystem, this.position = new Vec3(0, 0, 0), 
    this.velocity = new Vec3(0, 0, 0), this.animatedVelocity = new Vec3(0, 0, 0), this.ultimateVelocity = new Vec3(0, 0, 0), 
    this.angularVelocity = new Vec3(0, 0, 0), this.axisOfRotation = new Vec3(0, 0, 0), 
    this.rotation = new Vec3(0, 0, 0), this.startSize = new Vec3(0, 0, 0), this.size = new Vec3(0, 0, 0), 
    this.startColor = Color.WHITE.clone(), this.color = Color.WHITE.clone(), this.randomSeed = 0, 
    this.remainingLifetime = 0, this.startLifetime = 0, this.emitAccumulator0 = 0, this.emitAccumulator1 = 0, 
    this.frameIndex = 0, this.startRow = 0;
}, PARTICLE_MODULE_NAME_COLOR = "colorModule", PARTICLE_MODULE_NAME_FORCE = "forceModule", PARTICLE_MODULE_NAME_LIMIT = "limitModule", PARTICLE_MODULE_NAME_ROTATION = "rotationModule", PARTICLE_MODULE_NAME_SIZE = "sizeModule", PARTICLE_MODULE_NAME_VELOCITY = "velocityModule", PARTICLE_MODULE_NAME_TEXTURE = "textureModule", PARTICLE_MODULE_ORDER = [ "sizeModule", "colorModule", "forceModule", "velocityModule", "limitModule", "rotationModule", "textureModule" ], PARTICLE_MODULE_PROPERTY = [ "_colorOverLifetimeModule", "_shapeModule", "_sizeOvertimeModule", "_velocityOvertimeModule", "_forceOvertimeModule", "_limitVelocityOvertimeModule", "_rotationOvertimeModule", "_textureAnimationModule", "_trailModule" ], ParticleModuleBase = function() {
    function ParticleModuleBase() {
        _classCallCheck(this, ParticleModuleBase), this.target = null, this.needUpdate = !1, 
        this.needAnimate = !0, this.name = void 0;
    }
    return _createClass(ParticleModuleBase, [ {
        key: "bindTarget",
        value: function bindTarget(target) {
            this.target = target;
        }
    }, {
        key: "update",
        value: function update(space, trans) {}
    } ]), ParticleModuleBase;
}(), Space = Enum({
    World: 0,
    Local: 1,
    Custom: 2
}), RenderMode$1 = Enum({
    Billboard: 0,
    StrecthedBillboard: 1,
    HorizontalBillboard: 2,
    VerticalBillboard: 3,
    Mesh: 4
}), ShapeType = Enum({
    Box: 0,
    Circle: 1,
    Cone: 2,
    Sphere: 3,
    Hemisphere: 4
}), EmitLocation = Enum({
    Base: 0,
    Edge: 1,
    Shell: 2,
    Volume: 3
}), ArcMode = Enum({
    Random: 0,
    Loop: 1,
    PingPong: 2
}), TrailMode = Enum({
    Particles: 0
}), TextureMode = Enum({
    Stretch: 0
}), ModuleRandSeed_LIMIT = 23541, ModuleRandSeed_SIZE = 39825, ModuleRandSeed_TEXTURE = 90794, ModuleRandSeed_FORCE = 212165, ModuleRandSeed_ROTATION = 125292, ModuleRandSeed_VELOCITY_X = 197866, ModuleRandSeed_VELOCITY_Y = 156497, ModuleRandSeed_VELOCITY_Z = 984136, COLOR_OVERTIME_RAND_OFFSET = 91041, ColorOvertimeModule = (_dec$1z = ccclass("cc.ColorOvertimeModule"), 
_dec2$19 = property({
    displayOrder: 0
}), _dec3$U = property({
    type: GradientRange,
    displayOrder: 1
}), _dec$1z((_descriptor$1d = _applyDecoratedDescriptor((_class2$1o = function(_ParticleModuleBase) {
    function ColorOvertimeModule() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ColorOvertimeModule);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ColorOvertimeModule)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_enable", _descriptor$1d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "color", _descriptor2$10, _assertThisInitialized(_this)), 
        _this.name = PARTICLE_MODULE_NAME_COLOR, _this;
    }
    return _inherits(ColorOvertimeModule, ParticleModuleBase), _createClass(ColorOvertimeModule, [ {
        key: "animate",
        value: function animate(particle) {
            particle.color.set(particle.startColor), particle.color.multiply(this.color.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + COLOR_OVERTIME_RAND_OFFSET)));
        }
    }, {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable !== val && (this._enable = val, this.target && this.target.enableModule(this.name, val, this));
        }
    } ]), ColorOvertimeModule;
}()).prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1o.prototype, "enable", [ _dec2$19 ], Object.getOwnPropertyDescriptor(_class2$1o.prototype, "enable"), _class2$1o.prototype), 
_descriptor2$10 = _applyDecoratedDescriptor(_class2$1o.prototype, "color", [ _dec3$U ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange;
    }
}), _class$1A = _class2$1o)) || _class$1A), particleEmitZAxis = new Vec3(0, 0, -1);

function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
    return moduleSpace !== systemSpace ? (systemSpace === Space.World || Mat4.invert(worldTransform, worldTransform), 
    Mat4.getRotation(outQuat, worldTransform), !0) : (Quat.set(outQuat, 0, 0, 0, 1), 
    !1);
}

function fixedAngleUnitVector2(out, theta) {
    Vec2.set(out, Math.cos(theta), Math.sin(theta));
}

function randomUnitVector(out) {
    var z = randomRange(-1, 1), a = randomRange(0, 2 * Math.PI), r = Math.sqrt(1 - z * z), x = r * Math.cos(a), y = r * Math.sin(a);
    Vec3.set(out, x, y, z);
}

function randomPointBetweenSphere(out, minRadius, maxRadius) {
    randomUnitVector(out), Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
}

function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
    fixedAngleUnitVector2(out, theta), out.z = 0, Vec3.multiplyScalar(out, out, minRadius + (maxRadius - minRadius) * random());
}

function randomSortArray(arr) {
    for (var i = 0; i < arr.length; i++) {
        var transpose = i + randomRangeInt(0, arr.length - i), val = arr[transpose];
        arr[transpose] = arr[i], arr[i] = val;
    }
}

function randomSign() {
    var sgn = randomRange(-1, 1);
    return 0 === sgn && sgn++, sign(sgn);
}

var _dec$1B, _dec2$1b, _dec3$W, _dec4$Q, _dec5$K, _dec6$H, _dec7$y, _dec8$w, _dec9$n, _class$1C, _class2$1q, _descriptor$1f, _descriptor2$12, _descriptor3$S, _descriptor4$K, _descriptor5$A, _descriptor6$o, _descriptor7$m, _descriptor8$h, _dec$1C, _dec2$1c, _dec3$X, _dec4$R, _dec5$L, _dec6$I, _class$1D, _class2$1r, _descriptor$1g, _descriptor2$13, _descriptor3$T, _descriptor4$L, _descriptor5$B, FORCE_OVERTIME_RAND_OFFSET = ModuleRandSeed_FORCE, _temp_v3 = new Vec3, ForceOvertimeModule = (_dec$1A = ccclass("cc.ForceOvertimeModule"), 
_dec2$1a = property({
    displayOrder: 0
}), _dec3$V = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 2,
    tooltip: "X 轴方向上的加速度分量"
}), _dec4$P = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 3,
    tooltip: "Y 轴方向上的加速度分量"
}), _dec5$J = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 4,
    tooltip: "Z 轴方向上的加速度分量"
}), _dec6$G = property({
    type: Space,
    displayOrder: 1,
    tooltip: "加速度计算时采用的坐标"
}), _dec$1A((_descriptor$1e = _applyDecoratedDescriptor((_class2$1p = function(_ParticleModuleBase) {
    function ForceOvertimeModule() {
        var _this;
        return _classCallCheck(this, ForceOvertimeModule), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(ForceOvertimeModule).call(this)), "_enable", _descriptor$1e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "x", _descriptor2$11, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "y", _descriptor3$R, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "z", _descriptor4$J, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "space", _descriptor5$z, _assertThisInitialized(_this)), 
        _this.randomized = !1, _this.rotation = void 0, _this.needTransform = void 0, _this.name = PARTICLE_MODULE_NAME_FORCE, 
        _this.rotation = new Quat, _this.needTransform = !1, _this.needUpdate = !0, _this;
    }
    return _inherits(ForceOvertimeModule, ParticleModuleBase), _createClass(ForceOvertimeModule, [ {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable !== val && (this._enable = val, this.target && this.target.enableModule(this.name, val, this));
        }
    } ]), _createClass(ForceOvertimeModule, [ {
        key: "update",
        value: function update(space, worldTransform) {
            this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        }
    }, {
        key: "animate",
        value: function animate(p, dt) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, force = Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)));
            this.needTransform && Vec3.transformQuat(force, force, this.rotation), Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt), 
            Vec3.copy(p.ultimateVelocity, p.velocity);
        }
    } ]), ForceOvertimeModule;
}()).prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1p.prototype, "enable", [ _dec2$1a ], Object.getOwnPropertyDescriptor(_class2$1p.prototype, "enable"), _class2$1p.prototype), 
_descriptor2$11 = _applyDecoratedDescriptor(_class2$1p.prototype, "x", [ _dec3$V ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor3$R = _applyDecoratedDescriptor(_class2$1p.prototype, "y", [ _dec4$P ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor4$J = _applyDecoratedDescriptor(_class2$1p.prototype, "z", [ _dec5$J ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor5$z = _applyDecoratedDescriptor(_class2$1p.prototype, "space", [ _dec6$G ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _class$1B = _class2$1p)) || _class$1B), LIMIT_VELOCITY_RAND_OFFSET = ModuleRandSeed_LIMIT, _temp_v3$1 = new Vec3, _temp_v3_1 = new Vec3, LimitVelocityOvertimeModule = (_dec$1B = ccclass("cc.LimitVelocityOvertimeModule"), 
_dec2$1b = property({
    displayOrder: 0
}), _dec3$W = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 4,
    tooltip: "X 轴方向上的速度下限"
}), _dec4$Q = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 5,
    tooltip: "Y 轴方向上的速度下限"
}), _dec5$K = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 6,
    tooltip: "Z 轴方向上的速度下限"
}), _dec6$H = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 3,
    tooltip: "速度下限"
}), _dec7$y = property({
    displayOrder: 7,
    tooltip: "当前速度与速度下限的插值"
}), _dec8$w = property({
    displayOrder: 2,
    tooltip: "是否三个轴分开限制"
}), _dec9$n = property({
    type: Space,
    displayOrder: 1,
    tooltip: "计算速度下限时采用的坐标系"
}), _dec$1B((_descriptor$1f = _applyDecoratedDescriptor((_class2$1q = function(_ParticleModuleBase) {
    function LimitVelocityOvertimeModule() {
        var _this;
        return _classCallCheck(this, LimitVelocityOvertimeModule), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(LimitVelocityOvertimeModule).call(this)), "_enable", _descriptor$1f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "limitX", _descriptor2$12, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "limitY", _descriptor3$S, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "limitZ", _descriptor4$K, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "limit", _descriptor5$A, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "dampen", _descriptor6$o, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "separateAxes", _descriptor7$m, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "space", _descriptor8$h, _assertThisInitialized(_this)), 
        _this.drag = null, _this.multiplyDragByParticleSize = !1, _this.multiplyDragByParticleVelocity = !1, 
        _this.name = PARTICLE_MODULE_NAME_LIMIT, _this.rotation = void 0, _this.needTransform = void 0, 
        _this.rotation = new Quat, _this.needTransform = !1, _this.needUpdate = !0, _this;
    }
    return _inherits(LimitVelocityOvertimeModule, ParticleModuleBase), _createClass(LimitVelocityOvertimeModule, [ {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable !== val && (this._enable = val, this.target && this.target.enableModule(this.name, val, this));
        }
    } ]), _createClass(LimitVelocityOvertimeModule, [ {
        key: "update",
        value: function update(space, worldTransform) {
            this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        }
    }, {
        key: "animate",
        value: function animate(p, dt) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, dampedVel = _temp_v3$1;
            this.separateAxes ? (Vec3.set(_temp_v3_1, this.limitX.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.limitY.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.limitZ.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET))), 
            this.needTransform && Vec3.transformQuat(_temp_v3_1, _temp_v3_1, this.rotation), 
            Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, _temp_v3_1.x, this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, _temp_v3_1.y, this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, _temp_v3_1.z, this.dampen))) : (Vec3.normalize(dampedVel, p.ultimateVelocity), 
            Vec3.multiplyScalar(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.length(), this.limit.evaluate(normalizedTime, pseudoRandom(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.dampen))), 
            Vec3.copy(p.ultimateVelocity, dampedVel);
        }
    } ]), LimitVelocityOvertimeModule;
}()).prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1q.prototype, "enable", [ _dec2$1b ], Object.getOwnPropertyDescriptor(_class2$1q.prototype, "enable"), _class2$1q.prototype), 
_descriptor2$12 = _applyDecoratedDescriptor(_class2$1q.prototype, "limitX", [ _dec3$W ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor3$S = _applyDecoratedDescriptor(_class2$1q.prototype, "limitY", [ _dec4$Q ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor4$K = _applyDecoratedDescriptor(_class2$1q.prototype, "limitZ", [ _dec5$K ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor5$A = _applyDecoratedDescriptor(_class2$1q.prototype, "limit", [ _dec6$H ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor6$o = _applyDecoratedDescriptor(_class2$1q.prototype, "dampen", [ _dec7$y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 3;
    }
}), _descriptor7$m = _applyDecoratedDescriptor(_class2$1q.prototype, "separateAxes", [ _dec8$w ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor8$h = _applyDecoratedDescriptor(_class2$1q.prototype, "space", [ _dec9$n ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _class$1C = _class2$1q)) || _class$1C);

function dampenBeyondLimit(vel, limit, dampen) {
    var sgn = Math.sign(vel), abs = Math.abs(vel);
    return abs > limit && (abs = lerp(abs, limit, dampen)), abs * sgn;
}

var _dec$1D, _dec2$1d, _dec3$Y, _dec4$S, _dec5$M, _dec6$J, _dec7$z, _class$1E, _class2$1s, _descriptor$1h, _descriptor2$14, _descriptor3$U, _descriptor4$M, _descriptor5$C, _descriptor6$p, _dec$1E, _dec2$1e, _dec3$Z, _dec4$T, _dec5$N, _dec6$K, _dec7$A, _dec8$x, _dec9$o, _dec10$h, _dec11$g, _dec12$f, _dec13$d, _dec14$c, _class$1F, _class2$1t, _descriptor$1i, _descriptor2$15, _descriptor3$V, _descriptor4$N, _descriptor5$D, _descriptor6$q, _descriptor7$n, _descriptor8$i, _descriptor9$f, _descriptor10$e, _descriptor11$a, _descriptor12$9, _descriptor13$8, _dec$1F, _dec2$1f, _dec3$_, _dec4$U, _dec5$O, _dec6$L, _dec7$B, _class$1G, _class2$1u, _descriptor$1j, _descriptor2$16, _descriptor3$W, _descriptor4$O, _descriptor5$E, _descriptor6$r, _dec$1G, _dec2$1g, _class$1H, _class2$1v, _descriptor$1k, _descriptor2$17, _descriptor3$X, _descriptor4$P, _dec$1H, _dec2$1h, _dec3$$, _dec4$V, _dec5$P, _dec6$M, _dec7$C, _dec8$y, _dec9$p, _dec10$i, _dec11$h, _dec12$g, _dec13$e, _dec14$d, _dec15$a, _dec16$9, _dec17$7, _dec18$6, _dec19$6, _dec20$3, _dec21$2, _class$1I, _class2$1w, _descriptor$1l, _descriptor2$18, _descriptor3$Y, _descriptor4$Q, _descriptor5$F, _descriptor6$s, _descriptor7$o, _descriptor8$j, _descriptor9$g, _descriptor10$f, _descriptor11$b, _descriptor12$a, _descriptor13$9, _descriptor14$8, _descriptor15$4, _descriptor16$4, _descriptor17$3, _descriptor18$3, _descriptor19$1, ROTATION_OVERTIME_RAND_OFFSET = ModuleRandSeed_ROTATION, RotationOvertimeModule = (_dec$1C = ccclass("cc.RotationOvertimeModule"), 
_dec2$1c = property({
    displayOrder: 0
}), _dec3$X = property({
    displayOrder: 1,
    tooltip: "是否三个轴分开设定旋转（暂不支持）"
}), _dec4$R = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 2,
    tooltip: "绕 X 轴设定旋转"
}), _dec5$L = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 3,
    tooltip: "绕 Y 轴设定旋转"
}), _dec6$I = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 4,
    tooltip: "绕 Z 轴设定旋转"
}), _dec$1C((_descriptor$1g = _applyDecoratedDescriptor((_class2$1r = function(_ParticleModuleBase) {
    function RotationOvertimeModule() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, RotationOvertimeModule);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RotationOvertimeModule)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_enable", _descriptor$1g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_separateAxes", _descriptor2$13, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "x", _descriptor3$T, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "y", _descriptor4$L, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "z", _descriptor5$B, _assertThisInitialized(_this)), 
        _this.name = PARTICLE_MODULE_NAME_ROTATION, _this;
    }
    return _inherits(RotationOvertimeModule, ParticleModuleBase), _createClass(RotationOvertimeModule, [ {
        key: "animate",
        value: function animate(p, dt) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
            if (this._separateAxes) {
                var rotationRand = pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET);
                p.rotation.x += this.x.evaluate(normalizedTime, rotationRand) * dt, p.rotation.y += this.y.evaluate(normalizedTime, rotationRand) * dt, 
                p.rotation.z += this.z.evaluate(normalizedTime, rotationRand) * dt;
            } else p.rotation.z += this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET)) * dt;
        }
    }, {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable !== val && (this._enable = val, this.target && this.target.enableModule(this.name, val, this));
        }
    }, {
        key: "separateAxes",
        get: function get() {
            return this._separateAxes;
        },
        set: function set(val) {
            this._separateAxes = val;
        }
    } ]), RotationOvertimeModule;
}()).prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1r.prototype, "enable", [ _dec2$1c ], Object.getOwnPropertyDescriptor(_class2$1r.prototype, "enable"), _class2$1r.prototype), 
_descriptor2$13 = _applyDecoratedDescriptor(_class2$1r.prototype, "_separateAxes", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1r.prototype, "separateAxes", [ _dec3$X ], Object.getOwnPropertyDescriptor(_class2$1r.prototype, "separateAxes"), _class2$1r.prototype), 
_descriptor3$T = _applyDecoratedDescriptor(_class2$1r.prototype, "x", [ _dec4$R ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor4$L = _applyDecoratedDescriptor(_class2$1r.prototype, "y", [ _dec5$L ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor5$B = _applyDecoratedDescriptor(_class2$1r.prototype, "z", [ _dec6$I ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _class$1D = _class2$1r)) || _class$1D), SIZE_OVERTIME_RAND_OFFSET = ModuleRandSeed_SIZE, SizeOvertimeModule = (_dec$1D = ccclass("cc.SizeOvertimeModule"), 
_dec2$1d = property({
    displayOrder: 0
}), _dec3$Y = property({
    displayOrder: 1,
    tooltip: "决定是否在每个轴上独立控制粒子大小"
}), _dec4$S = property({
    type: CurveRange,
    displayOrder: 2,
    tooltip: "定义一条曲线来决定粒子在其生命周期中的大小变化"
}), _dec5$M = property({
    type: CurveRange,
    displayOrder: 3,
    tooltip: "定义一条曲线来决定粒子在其生命周期中 X 轴方向上的大小变化"
}), _dec6$J = property({
    type: CurveRange,
    displayOrder: 4,
    tooltip: "定义一条曲线来决定粒子在其生命周期中 Y 轴方向上的大小变化"
}), _dec7$z = property({
    type: CurveRange,
    displayOrder: 5,
    tooltip: "定义一条曲线来决定粒子在其生命周期中 Z 轴方向上的大小变化"
}), _dec$1D((_descriptor$1h = _applyDecoratedDescriptor((_class2$1s = function(_ParticleModuleBase) {
    function SizeOvertimeModule() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, SizeOvertimeModule);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SizeOvertimeModule)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_enable", _descriptor$1h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "separateAxes", _descriptor2$14, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "size", _descriptor3$U, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "x", _descriptor4$M, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "y", _descriptor5$C, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "z", _descriptor6$p, _assertThisInitialized(_this)), 
        _this.name = PARTICLE_MODULE_NAME_SIZE, _this;
    }
    return _inherits(SizeOvertimeModule, ParticleModuleBase), _createClass(SizeOvertimeModule, [ {
        key: "animate",
        value: function animate(particle, dt) {
            if (this.separateAxes) {
                var currLifetime = 1 - particle.remainingLifetime / particle.startLifetime, sizeRand = pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET);
                particle.size.x = particle.startSize.x * this.x.evaluate(currLifetime, sizeRand), 
                particle.size.y = particle.startSize.y * this.y.evaluate(currLifetime, sizeRand), 
                particle.size.z = particle.startSize.z * this.z.evaluate(currLifetime, sizeRand);
            } else Vec3.multiplyScalar(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, pseudoRandom(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET)));
        }
    }, {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable !== val && (this._enable = val, this.target && this.target.enableModule(this.name, val, this));
        }
    } ]), SizeOvertimeModule;
}()).prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1s.prototype, "enable", [ _dec2$1d ], Object.getOwnPropertyDescriptor(_class2$1s.prototype, "enable"), _class2$1s.prototype), 
_descriptor2$14 = _applyDecoratedDescriptor(_class2$1s.prototype, "separateAxes", [ _dec3$Y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$U = _applyDecoratedDescriptor(_class2$1s.prototype, "size", [ _dec4$S ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor4$M = _applyDecoratedDescriptor(_class2$1s.prototype, "x", [ _dec5$M ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor5$C = _applyDecoratedDescriptor(_class2$1s.prototype, "y", [ _dec6$J ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor6$p = _applyDecoratedDescriptor(_class2$1s.prototype, "z", [ _dec7$z ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _class$1E = _class2$1s)) || _class$1E), TEXTURE_ANIMATION_RAND_OFFSET = ModuleRandSeed_TEXTURE, Mode$4 = Enum({
    Grid: 0
}), Animation = Enum({
    WholeSheet: 0,
    SingleRow: 1
}), TextureAnimationModule = (_dec$1E = ccclass("cc.TextureAnimationModule"), _dec2$1e = property({
    formerlySerializedAs: "numTilesX"
}), _dec3$Z = property({
    formerlySerializedAs: "numTilesY"
}), _dec4$T = property({
    displayOrder: 0
}), _dec5$N = property({
    type: Mode$4
}), _dec6$K = property({
    type: Mode$4,
    displayOrder: 1,
    tooltip: "设定粒子贴图动画的类型（暂只支持 Grid 模式）"
}), _dec7$A = property({
    displayOrder: 2,
    tooltip: "X 方向动画帧数"
}), _dec8$x = property({
    displayOrder: 3,
    tooltip: "Y 方向动画帧数"
}), _dec9$o = property({
    type: Animation,
    displayOrder: 4,
    tooltip: "动画播放方式"
}), _dec10$h = property({
    type: CurveRange,
    displayOrder: 7,
    tooltip: "一个周期内动画播放的帧与时间变化曲线"
}), _dec11$g = property({
    type: CurveRange,
    displayOrder: 8,
    tooltip: "从第几帧开始播放，时间为整个粒子系统的生命周期"
}), _dec12$f = property({
    displayOrder: 9,
    tooltip: "一个生命周期内播放循环的次数"
}), _dec13$d = property({
    displayOrder: 5,
    tooltip: "随机从动画贴图中选择一行以生成动画。\n此选项仅在动画播放方式为 SingleRow 时生效"
}), _dec14$c = property({
    displayOrder: 6,
    tooltip: "从动画贴图中选择特定行以生成动画。\n此选项仅在动画播放方式为 SingleRow 时且禁用 randomRow 时可用"
}), _dec$1E((_descriptor$1i = _applyDecoratedDescriptor((_class2$1t = function(_ParticleModuleBase) {
    function TextureAnimationModule() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TextureAnimationModule);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextureAnimationModule)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_enable", _descriptor$1i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_numTilesX", _descriptor2$15, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_numTilesY", _descriptor3$V, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_mode", _descriptor4$N, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "animation", _descriptor5$D, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "frameOverTime", _descriptor6$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startFrame", _descriptor7$n, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "cycleCount", _descriptor8$i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_flipU", _descriptor9$f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_flipV", _descriptor10$e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_uvChannelMask", _descriptor11$a, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "randomRow", _descriptor12$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "rowIndex", _descriptor13$8, _assertThisInitialized(_this)), 
        _this.name = PARTICLE_MODULE_NAME_TEXTURE, _this;
    }
    return _inherits(TextureAnimationModule, ParticleModuleBase), _createClass(TextureAnimationModule, [ {
        key: "init",
        value: function init(p) {
            p.startRow = Math.floor(Math.random() * this.numTilesY);
        }
    }, {
        key: "animate",
        value: function animate(p, dt) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, startFrame = this.startFrame.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) / (this.numTilesX * this.numTilesY);
            if (this.animation === Animation.WholeSheet) p.frameIndex = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1); else if (this.animation === Animation.SingleRow) {
                var rowLength = 1 / this.numTilesY;
                if (this.randomRow) {
                    var f = repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1), from = p.startRow * rowLength, to = from + rowLength;
                    p.frameIndex = lerp(from, to, f);
                } else {
                    var _from = this.rowIndex * rowLength, _to = _from + rowLength;
                    p.frameIndex = lerp(_from, _to, repeat(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, pseudoRandom(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1));
                }
            }
        }
    }, {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable !== val && (this._enable = val, this.target && (this.target.updateMaterialParams(), 
            this.target.enableModule(this.name, val, this)));
        }
    }, {
        key: "mode",
        get: function get() {
            return this._mode;
        },
        set: function set(val) {
            val === Mode$4.Grid || console.error("particle texture animation's sprites is not supported!");
        }
    }, {
        key: "numTilesX",
        get: function get() {
            return this._numTilesX;
        },
        set: function set(val) {
            this._numTilesX !== val && (this._numTilesX = val, this.target.updateMaterialParams());
        }
    }, {
        key: "numTilesY",
        get: function get() {
            return this._numTilesY;
        },
        set: function set(val) {
            this._numTilesY !== val && (this._numTilesY = val, this.target.updateMaterialParams());
        }
    }, {
        key: "flipU",
        get: function get() {
            return this._flipU;
        },
        set: function set(val) {
            console.error("particle texture animation's flipU is not supported!");
        }
    }, {
        key: "flipV",
        get: function get() {
            return this._flipV;
        },
        set: function set(val) {
            console.error("particle texture animation's flipV is not supported!");
        }
    }, {
        key: "uvChannelMask",
        get: function get() {
            return this._uvChannelMask;
        },
        set: function set(val) {
            console.error("particle texture animation's uvChannelMask is not supported!");
        }
    } ]), TextureAnimationModule;
}()).prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$15 = _applyDecoratedDescriptor(_class2$1t.prototype, "_numTilesX", [ _dec2$1e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor3$V = _applyDecoratedDescriptor(_class2$1t.prototype, "_numTilesY", [ _dec3$Z ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$1t.prototype, "enable", [ _dec4$T ], Object.getOwnPropertyDescriptor(_class2$1t.prototype, "enable"), _class2$1t.prototype), 
_descriptor4$N = _applyDecoratedDescriptor(_class2$1t.prototype, "_mode", [ _dec5$N ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Mode$4.Grid;
    }
}), _applyDecoratedDescriptor(_class2$1t.prototype, "mode", [ _dec6$K ], Object.getOwnPropertyDescriptor(_class2$1t.prototype, "mode"), _class2$1t.prototype), 
_applyDecoratedDescriptor(_class2$1t.prototype, "numTilesX", [ _dec7$A ], Object.getOwnPropertyDescriptor(_class2$1t.prototype, "numTilesX"), _class2$1t.prototype), 
_applyDecoratedDescriptor(_class2$1t.prototype, "numTilesY", [ _dec8$x ], Object.getOwnPropertyDescriptor(_class2$1t.prototype, "numTilesY"), _class2$1t.prototype), 
_descriptor5$D = _applyDecoratedDescriptor(_class2$1t.prototype, "animation", [ _dec9$o ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Animation.WholeSheet;
    }
}), _descriptor6$q = _applyDecoratedDescriptor(_class2$1t.prototype, "frameOverTime", [ _dec10$h ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor7$n = _applyDecoratedDescriptor(_class2$1t.prototype, "startFrame", [ _dec11$g ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor8$i = _applyDecoratedDescriptor(_class2$1t.prototype, "cycleCount", [ _dec12$f ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor9$f = _applyDecoratedDescriptor(_class2$1t.prototype, "_flipU", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor10$e = _applyDecoratedDescriptor(_class2$1t.prototype, "_flipV", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11$a = _applyDecoratedDescriptor(_class2$1t.prototype, "_uvChannelMask", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return -1;
    }
}), _descriptor12$9 = _applyDecoratedDescriptor(_class2$1t.prototype, "randomRow", [ _dec13$d ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor13$8 = _applyDecoratedDescriptor(_class2$1t.prototype, "rowIndex", [ _dec14$c ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class$1F = _class2$1t)) || _class$1F), VELOCITY_X_OVERTIME_RAND_OFFSET = ModuleRandSeed_VELOCITY_X, VELOCITY_Y_OVERTIME_RAND_OFFSET = ModuleRandSeed_VELOCITY_Y, VELOCITY_Z_OVERTIME_RAND_OFFSET = ModuleRandSeed_VELOCITY_Z, _temp_v3$2 = new Vec3, VelocityOvertimeModule = (_dec$1F = ccclass("cc.VelocityOvertimeModule"), 
_dec2$1f = property({
    displayOrder: 0
}), _dec3$_ = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 2,
    tooltip: "X 轴方向上的速度分量"
}), _dec4$U = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 3,
    tooltip: "Y 轴方向上的速度分量"
}), _dec5$O = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 4,
    tooltip: "Z 轴方向上的速度分量"
}), _dec6$L = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 5,
    tooltip: "速度修正系数（只支持 CPU 粒子）"
}), _dec7$B = property({
    type: Space,
    displayOrder: 1,
    tooltip: "速度计算时采用的坐标系"
}), _dec$1F((_descriptor$1j = _applyDecoratedDescriptor((_class2$1u = function(_ParticleModuleBase) {
    function VelocityOvertimeModule() {
        var _this;
        return _classCallCheck(this, VelocityOvertimeModule), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(VelocityOvertimeModule).call(this)), "_enable", _descriptor$1j, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "x", _descriptor2$16, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "y", _descriptor3$W, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "z", _descriptor4$O, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "speedModifier", _descriptor5$E, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "space", _descriptor6$r, _assertThisInitialized(_this)), 
        _this.rotation = void 0, _this.needTransform = void 0, _this.name = PARTICLE_MODULE_NAME_VELOCITY, 
        _this.rotation = new Quat, _this.speedModifier.constant = 1, _this.needTransform = !1, 
        _this.needUpdate = !0, _this;
    }
    return _inherits(VelocityOvertimeModule, ParticleModuleBase), _createClass(VelocityOvertimeModule, [ {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable !== val && (this._enable = val, this.target && this.target.enableModule(this.name, val, this));
        }
    } ]), _createClass(VelocityOvertimeModule, [ {
        key: "update",
        value: function update(space, worldTransform) {
            this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
        }
    }, {
        key: "animate",
        value: function animate(p, dt) {
            var normalizedTime = 1 - p.remainingLifetime / p.startLifetime, vel = Vec3.set(_temp_v3$2, this.x.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_X_OVERTIME_RAND_OFFSET)), this.y.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_Y_OVERTIME_RAND_OFFSET)), this.z.evaluate(normalizedTime, pseudoRandom(p.randomSeed ^ VELOCITY_Z_OVERTIME_RAND_OFFSET)));
            this.needTransform && Vec3.transformQuat(vel, vel, this.rotation), Vec3.add(p.animatedVelocity, p.animatedVelocity, vel), 
            Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity), Vec3.multiplyScalar(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed + VELOCITY_X_OVERTIME_RAND_OFFSET)));
        }
    } ]), VelocityOvertimeModule;
}()).prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1u.prototype, "enable", [ _dec2$1f ], Object.getOwnPropertyDescriptor(_class2$1u.prototype, "enable"), _class2$1u.prototype), 
_descriptor2$16 = _applyDecoratedDescriptor(_class2$1u.prototype, "x", [ _dec3$_ ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor3$W = _applyDecoratedDescriptor(_class2$1u.prototype, "y", [ _dec4$U ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor4$O = _applyDecoratedDescriptor(_class2$1u.prototype, "z", [ _dec5$O ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor5$E = _applyDecoratedDescriptor(_class2$1u.prototype, "speedModifier", [ _dec6$L ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor6$r = _applyDecoratedDescriptor(_class2$1u.prototype, "space", [ _dec7$B ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _class$1G = _class2$1u)) || _class$1G), Burst = (_dec$1G = ccclass("cc.Burst"), 
_dec2$1g = property({
    type: CurveRange
}), _dec$1G((_descriptor$1k = _applyDecoratedDescriptor((_class2$1v = function() {
    function Burst() {
        _classCallCheck(this, Burst), _initializerDefineProperty(this, "_time", _descriptor$1k, this), 
        _initializerDefineProperty(this, "_repeatCount", _descriptor2$17, this), _initializerDefineProperty(this, "repeatInterval", _descriptor3$X, this), 
        _initializerDefineProperty(this, "count", _descriptor4$P, this), this._remainingCount = void 0, 
        this._curTime = void 0, this._remainingCount = 0, this._curTime = 0;
    }
    return _createClass(Burst, [ {
        key: "time",
        get: function get() {
            return this._time;
        },
        set: function set(val) {
            this._time = val, this._curTime = val;
        }
    }, {
        key: "repeatCount",
        get: function get() {
            return this._repeatCount;
        },
        set: function set(val) {
            this._repeatCount = val, this._remainingCount = val;
        }
    } ]), _createClass(Burst, [ {
        key: "update",
        value: function update(psys, dt) {
            if (0 === this._remainingCount && (this._remainingCount = this._repeatCount, this._curTime = this._time), 
            this._remainingCount > 0) {
                var preFrameTime = repeat(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
                preFrameTime = preFrameTime > 0 ? preFrameTime : 0;
                var curFrameTime = repeat(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);
                this._curTime >= preFrameTime && this._curTime < curFrameTime && (psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime)), 
                this._curTime += this.repeatInterval, --this._remainingCount);
            }
        }
    }, {
        key: "getMaxCount",
        value: function getMaxCount(psys) {
            return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
        }
    } ]), Burst;
}()).prototype, "_time", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _applyDecoratedDescriptor(_class2$1v.prototype, "time", [ property ], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "time"), _class2$1v.prototype), 
_descriptor2$17 = _applyDecoratedDescriptor(_class2$1v.prototype, "_repeatCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _applyDecoratedDescriptor(_class2$1v.prototype, "repeatCount", [ property ], Object.getOwnPropertyDescriptor(_class2$1v.prototype, "repeatCount"), _class2$1v.prototype), 
_descriptor3$X = _applyDecoratedDescriptor(_class2$1v.prototype, "repeatInterval", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor4$P = _applyDecoratedDescriptor(_class2$1v.prototype, "count", [ _dec2$1g ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _class$1H = _class2$1v)) || _class$1H), _intermediVec = new Vec3(0, 0, 0), _intermediArr = new Array, _unitBoxExtent = new Vec3(.5, .5, .5), ShapeModule = (_dec$1H = ccclass("cc.ShapeModule"), 
_dec2$1h = property({
    displayOrder: 13,
    tooltip: "粒子发射器位置"
}), _dec3$$ = property({
    displayOrder: 14,
    tooltip: "粒子发射器旋转角度"
}), _dec4$V = property({
    displayOrder: 15,
    tooltip: "粒子发射器缩放比例"
}), _dec5$P = property({
    displayOrder: 6,
    tooltip: "粒子发射器在一个扇形范围内发射"
}), _dec6$M = property({
    displayOrder: 5,
    tooltip: "圆锥的轴与母线的夹角\n决定圆锥发射器的开合程度"
}), _dec7$C = property({
    displayOrder: 0
}), _dec8$y = property({
    type: ShapeType,
    displayOrder: 1,
    formerlySerializedAs: "shapeType"
}), _dec9$p = property({
    type: ShapeType,
    tooltip: "粒子发射器类型"
}), _dec10$i = property({
    type: EmitLocation,
    displayOrder: 2,
    tooltip: "粒子从发射器哪个部位发射"
}), _dec11$h = property({
    displayOrder: 16,
    tooltip: "根据粒子的初始方向决定粒子的移动方向"
}), _dec12$g = property({
    displayOrder: 17,
    tooltip: "粒子生成方向随机设定"
}), _dec13$e = property({
    displayOrder: 18,
    tooltip: "表示当前发射方向与当前位置到结点中心连线方向的插值"
}), _dec14$d = property({
    displayOrder: 19,
    tooltip: "粒子生成位置随机设定（设定此值为非 0 会使粒子生成位置超出生成器大小范围）"
}), _dec15$a = property({
    displayOrder: 3,
    tooltip: "粒子发射器半径"
}), _dec16$9 = property({
    displayOrder: 4,
    tooltip: "粒子发射器发射位置（对 Box 类型的发射器无效）:\n - 0 表示从表面发射；\n - 1 表示从中心发射；\n - 0 ~ 1 之间表示在中心到表面之间发射。"
}), _dec17$7 = property({
    type: ArcMode,
    displayOrder: 7,
    tooltip: "粒子在扇形范围内的发射方式"
}), _dec18$6 = property({
    displayOrder: 9,
    tooltip: "控制可能产生粒子的弧周围的离散间隔"
}), _dec19$6 = property({
    type: CurveRange,
    displayOrder: 10,
    tooltip: "粒子沿圆周发射的速度"
}), _dec20$3 = property({
    displayOrder: 11,
    tooltip: "圆锥顶部截面距离底部的轴长\n决定圆锥发射器的高度"
}), _dec21$2 = property({
    displayOrder: 12,
    tooltip: "粒子发射器发射位置（针对 Box 类型的粒子发射器）"
}), _dec$1H((_applyDecoratedDescriptor((_class2$1w = function() {
    function ShapeModule() {
        _classCallCheck(this, ShapeModule), _initializerDefineProperty(this, "_enable", _descriptor$1l, this), 
        _initializerDefineProperty(this, "_shapeType", _descriptor2$18, this), _initializerDefineProperty(this, "emitFrom", _descriptor3$Y, this), 
        _initializerDefineProperty(this, "alignToDirection", _descriptor4$Q, this), _initializerDefineProperty(this, "randomDirectionAmount", _descriptor5$F, this), 
        _initializerDefineProperty(this, "sphericalDirectionAmount", _descriptor6$s, this), 
        _initializerDefineProperty(this, "randomPositionAmount", _descriptor7$o, this), 
        _initializerDefineProperty(this, "radius", _descriptor8$j, this), _initializerDefineProperty(this, "radiusThickness", _descriptor9$g, this), 
        _initializerDefineProperty(this, "arcMode", _descriptor10$f, this), _initializerDefineProperty(this, "arcSpread", _descriptor11$b, this), 
        _initializerDefineProperty(this, "arcSpeed", _descriptor12$a, this), _initializerDefineProperty(this, "length", _descriptor13$9, this), 
        _initializerDefineProperty(this, "boxThickness", _descriptor14$8, this), _initializerDefineProperty(this, "_position", _descriptor15$4, this), 
        _initializerDefineProperty(this, "_rotation", _descriptor16$4, this), _initializerDefineProperty(this, "_scale", _descriptor17$3, this), 
        _initializerDefineProperty(this, "_arc", _descriptor18$3, this), _initializerDefineProperty(this, "_angle", _descriptor19$1, this), 
        this.mat = void 0, this.quat = void 0, this.particleSystem = void 0, this.lastTime = void 0, 
        this.totalAngle = void 0, this.mat = new Mat4, this.quat = new Quat, this.particleSystem = null, 
        this.lastTime = 0, this.totalAngle = 0;
    }
    return _createClass(ShapeModule, [ {
        key: "position",
        get: function get() {
            return this._position;
        },
        set: function set(val) {
            this._position = val, this.constructMat();
        }
    }, {
        key: "rotation",
        get: function get() {
            return this._rotation;
        },
        set: function set(val) {
            this._rotation = val, this.constructMat();
        }
    }, {
        key: "scale",
        get: function get() {
            return this._scale;
        },
        set: function set(val) {
            this._scale = val, this.constructMat();
        }
    }, {
        key: "arc",
        get: function get() {
            return toDegree(this._arc);
        },
        set: function set(val) {
            this._arc = toRadian(val);
        }
    }, {
        key: "angle",
        get: function get() {
            return Math.round(100 * toDegree(this._angle)) / 100;
        },
        set: function set(val) {
            this._angle = toRadian(val);
        }
    }, {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            this._enable = val;
        }
    }, {
        key: "shapeType",
        get: function get() {
            return this._shapeType;
        },
        set: function set(val) {
            switch (this._shapeType = val, this._shapeType) {
              case ShapeType.Box:
                this.emitFrom === EmitLocation.Base && (this.emitFrom = EmitLocation.Volume);
                break;

              case ShapeType.Cone:
                this.emitFrom === EmitLocation.Edge && (this.emitFrom = EmitLocation.Base);
                break;

              case ShapeType.Sphere:
              case ShapeType.Hemisphere:
                this.emitFrom !== EmitLocation.Base && this.emitFrom !== EmitLocation.Edge || (this.emitFrom = EmitLocation.Volume);
            }
        }
    } ]), _createClass(ShapeModule, [ {
        key: "onInit",
        value: function onInit(ps) {
            this.particleSystem = ps, this.constructMat(), this.lastTime = this.particleSystem._time;
        }
    }, {
        key: "emit",
        value: function emit(p) {
            switch (this.shapeType) {
              case ShapeType.Box:
                !function boxEmit(emitFrom, boxThickness, pos, dir) {
                    switch (emitFrom) {
                      case EmitLocation.Volume:
                        !function randomPointInCube(out, extents) {
                            Vec3.set(out, randomRange(-extents.x, extents.x), randomRange(-extents.y, extents.y), randomRange(-extents.z, extents.z));
                        }(pos, _unitBoxExtent);
                        break;

                      case EmitLocation.Shell:
                        _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                        _intermediArr.push(randomRange(-.5, .5)), _intermediArr.push(.5 * randomSign()), 
                        randomSortArray(_intermediArr), applyBoxThickness(_intermediArr, boxThickness), 
                        Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                        break;

                      case EmitLocation.Edge:
                        _intermediArr.splice(0, _intermediArr.length), _intermediArr.push(randomRange(-.5, .5)), 
                        _intermediArr.push(.5 * randomSign()), _intermediArr.push(.5 * randomSign()), randomSortArray(_intermediArr), 
                        applyBoxThickness(_intermediArr, boxThickness), Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
                        break;

                      default:
                        console.warn(emitFrom + " is not supported for box emitter.");
                    }
                    Vec3.copy(dir, particleEmitZAxis);
                }(this.emitFrom, this.boxThickness, p.position, p.velocity);
                break;

              case ShapeType.Circle:
                !function circleEmit(radius, radiusThickness, theta, pos, dir) {
                    randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                    Vec3.normalize(dir, pos);
                }(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
                break;

              case ShapeType.Cone:
                !function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
                    switch (emitFrom) {
                      case EmitLocation.Base:
                        randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                        Vec2.multiplyScalar(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, 
                        Vec3.normalize(dir, dir), pos.z = 0;
                        break;

                      case EmitLocation.Shell:
                        fixedAngleUnitVector2(pos, theta), Vec2.multiplyScalar(dir, pos, Math.sin(angle)), 
                        dir.z = -Math.cos(angle), Vec3.normalize(dir, dir), Vec2.multiplyScalar(pos, pos, radius), 
                        pos.z = 0;
                        break;

                      case EmitLocation.Volume:
                        randomPointBetweenCircleAtFixedAngle(pos, radius * (1 - radiusThickness), radius, theta), 
                        Vec2.multiplyScalar(dir, pos, Math.sin(angle)), dir.z = -Math.cos(angle) * radius, 
                        Vec3.normalize(dir, dir), pos.z = 0, Vec3.add(pos, pos, Vec3.multiplyScalar(_intermediVec, dir, length * random() / -dir.z));
                        break;

                      default:
                        console.warn(emitFrom + " is not supported for cone emitter.");
                    }
                }(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
                break;

              case ShapeType.Sphere:
                !function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                    switch (emitFrom) {
                      case EmitLocation.Volume:
                        randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), Vec3.normalize(dir, pos);
                        break;

                      case EmitLocation.Shell:
                        randomUnitVector(pos), Vec3.multiplyScalar(pos, pos, radius), Vec3.normalize(dir, pos);
                        break;

                      default:
                        console.warn(emitFrom + " is not supported for sphere emitter.");
                    }
                }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                break;

              case ShapeType.Hemisphere:
                !function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
                    switch (emitFrom) {
                      case EmitLocation.Volume:
                        randomPointBetweenSphere(pos, radius * (1 - radiusThickness), radius), pos.z > 0 && (pos.z *= -1), 
                        Vec3.normalize(dir, pos);
                        break;

                      case EmitLocation.Shell:
                        randomUnitVector(pos), Vec3.multiplyScalar(pos, pos, radius), pos.z > 0 && (pos.z *= -1), 
                        Vec3.normalize(dir, pos);
                        break;

                      default:
                        console.warn(emitFrom + " is not supported for hemisphere emitter.");
                    }
                }(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
                break;

              default:
                console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
            }
            if (this.randomPositionAmount > 0 && (p.position.x += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
            p.position.y += randomRange(-this.randomPositionAmount, this.randomPositionAmount), 
            p.position.z += randomRange(-this.randomPositionAmount, this.randomPositionAmount)), 
            Vec3.transformQuat(p.velocity, p.velocity, this.quat), Vec3.transformMat4(p.position, p.position, this.mat), 
            this.sphericalDirectionAmount > 0) {
                var sphericalVel = Vec3.normalize(_intermediVec, p.position);
                Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
            }
            this.lastTime = this.particleSystem._time;
        }
    }, {
        key: "constructMat",
        value: function constructMat() {
            Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z), 
            Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
        }
    }, {
        key: "generateArcAngle",
        value: function generateArcAngle() {
            if (this.arcMode === ArcMode.Random) return randomRange(0, this._arc);
            var angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
            switch (this.totalAngle = angle, 0 !== this.arcSpread && (angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread), 
            this.arcMode) {
              case ArcMode.Loop:
                return repeat(angle, this._arc);

              case ArcMode.PingPong:
                return pingPong(angle, this._arc);
            }
        }
    } ]), ShapeModule;
}()).prototype, "position", [ _dec2$1h ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "position"), _class2$1w.prototype), 
_applyDecoratedDescriptor(_class2$1w.prototype, "rotation", [ _dec3$$ ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "rotation"), _class2$1w.prototype), 
_applyDecoratedDescriptor(_class2$1w.prototype, "scale", [ _dec4$V ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "scale"), _class2$1w.prototype), 
_applyDecoratedDescriptor(_class2$1w.prototype, "arc", [ _dec5$P ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "arc"), _class2$1w.prototype), 
_applyDecoratedDescriptor(_class2$1w.prototype, "angle", [ _dec6$M ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "angle"), _class2$1w.prototype), 
_descriptor$1l = _applyDecoratedDescriptor(_class2$1w.prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1w.prototype, "enable", [ _dec7$C ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "enable"), _class2$1w.prototype), 
_descriptor2$18 = _applyDecoratedDescriptor(_class2$1w.prototype, "_shapeType", [ _dec8$y ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ShapeType.Cone;
    }
}), _applyDecoratedDescriptor(_class2$1w.prototype, "shapeType", [ _dec9$p ], Object.getOwnPropertyDescriptor(_class2$1w.prototype, "shapeType"), _class2$1w.prototype), 
_descriptor3$Y = _applyDecoratedDescriptor(_class2$1w.prototype, "emitFrom", [ _dec10$i ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return EmitLocation.Volume;
    }
}), _descriptor4$Q = _applyDecoratedDescriptor(_class2$1w.prototype, "alignToDirection", [ _dec11$h ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5$F = _applyDecoratedDescriptor(_class2$1w.prototype, "randomDirectionAmount", [ _dec12$g ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor6$s = _applyDecoratedDescriptor(_class2$1w.prototype, "sphericalDirectionAmount", [ _dec13$e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor7$o = _applyDecoratedDescriptor(_class2$1w.prototype, "randomPositionAmount", [ _dec14$d ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor8$j = _applyDecoratedDescriptor(_class2$1w.prototype, "radius", [ _dec15$a ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor9$g = _applyDecoratedDescriptor(_class2$1w.prototype, "radiusThickness", [ _dec16$9 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor10$f = _applyDecoratedDescriptor(_class2$1w.prototype, "arcMode", [ _dec17$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return ArcMode.Random;
    }
}), _descriptor11$b = _applyDecoratedDescriptor(_class2$1w.prototype, "arcSpread", [ _dec18$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor12$a = _applyDecoratedDescriptor(_class2$1w.prototype, "arcSpeed", [ _dec19$6 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor13$9 = _applyDecoratedDescriptor(_class2$1w.prototype, "length", [ _dec20$3 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 5;
    }
}), _descriptor14$8 = _applyDecoratedDescriptor(_class2$1w.prototype, "boxThickness", [ _dec21$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 0, 0);
    }
}), _descriptor15$4 = _applyDecoratedDescriptor(_class2$1w.prototype, "_position", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 0, 0);
    }
}), _descriptor16$4 = _applyDecoratedDescriptor(_class2$1w.prototype, "_rotation", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(0, 0, 0);
    }
}), _descriptor17$3 = _applyDecoratedDescriptor(_class2$1w.prototype, "_scale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _descriptor18$3 = _applyDecoratedDescriptor(_class2$1w.prototype, "_arc", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return toRadian(360);
    }
}), _descriptor19$1 = _applyDecoratedDescriptor(_class2$1w.prototype, "_angle", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return toRadian(25);
    }
}), _class$1I = _class2$1w)) || _class$1I);

function applyBoxThickness(pos, thickness) {
    thickness.x > 0 && (pos[0] += .5 * randomRange(-thickness.x, thickness.x), pos[0] = clamp(pos[0], -.5, .5)), 
    thickness.y > 0 && (pos[1] += .5 * randomRange(-thickness.y, thickness.y), pos[1] = clamp(pos[1], -.5, .5)), 
    thickness.z > 0 && (pos[2] += .5 * randomRange(-thickness.z, thickness.z), pos[2] = clamp(pos[2], -.5, .5));
}

var _dec$1I, _dec2$1i, _dec3$10, _dec4$W, _dec5$Q, _dec6$N, _dec7$D, _dec8$z, _dec9$q, _dec10$j, _dec11$i, _dec12$h, _class$1J, _class2$1x, _descriptor$1m, _descriptor2$19, _descriptor3$Z, _descriptor4$R, _descriptor5$G, _descriptor6$t, _uvs$1 = [ 0, 0, 1, 0, 0, 1, 1, 1 ], ParticleBatchModel = function(_Model) {
    function ParticleBatchModel() {
        var _this;
        return _classCallCheck(this, ParticleBatchModel), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleBatchModel).call(this)))._capacity = void 0, 
        _this._vertAttrs = void 0, _this._vertSize = void 0, _this._vBuffer = void 0, _this._vertAttrsFloatCount = void 0, 
        _this._vdataF32 = void 0, _this._vdataUint32 = void 0, _this._iaInfo = void 0, _this._iaInfoBuffer = void 0, 
        _this._subMeshData = void 0, _this._mesh = void 0, _this._vertCount = 0, _this._indexCount = 0, 
        _this._startTimeOffset = 0, _this._lifeTimeOffset = 0, _this.type = ModelType.PARTICLE_BATCH, 
        _this._capacity = 0, _this._vertAttrs = null, _this._vertSize = 0, _this._vBuffer = null, 
        _this._vertAttrsFloatCount = 0, _this._vdataF32 = null, _this._vdataUint32 = null, 
        _this._iaInfo = {
            drawInfos: [ {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            } ]
        }, _this._iaInfoBuffer = _this._device.createBuffer({
            usage: exports.GFXBufferUsageBit.INDIRECT,
            memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
            size: 56,
            stride: 1
        }), _this._subMeshData = null, _this._mesh = null, _this;
    }
    return _inherits(ParticleBatchModel, Model), _createClass(ParticleBatchModel, [ {
        key: "setCapacity",
        value: function setCapacity(capacity) {
            var capChanged = this._capacity !== capacity;
            this._capacity = capacity, this._inited && capChanged && this._recreateBuffer();
        }
    }, {
        key: "setVertexAttributes",
        value: function setVertexAttributes(mesh, attrs) {
            if (this._mesh !== mesh || this._vertAttrs !== attrs) {
                this._mesh = mesh, this._vertAttrs = attrs, this._vertSize = 0;
                for (var _step, _iterator = _createForOfIteratorHelperLoose(this._vertAttrs); !(_step = _iterator()).done; ) {
                    var a = _step.value;
                    a.offset = this._vertSize, this._vertSize += GFXFormatInfos[a.format].size;
                }
                this._vertAttrsFloatCount = this._vertSize / 4, this._vBuffer = this._createSubMeshData(), 
                this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer), 
                this._inited = !0;
            }
        }
    }, {
        key: "_createSubMeshData",
        value: function _createSubMeshData() {
            this.destroySubMeshData(), this._vertCount = 4, this._indexCount = 6, this._mesh && (this._vertCount = this._mesh.struct.vertexBundles[this._mesh.struct.primitives[0].vertexBundelIndices[0]].view.count, 
            this._indexCount = this._mesh.struct.primitives[0].indexView.count);
            var vertexBuffer = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: this._vertSize * this._capacity * this._vertCount,
                stride: this._vertSize
            }), vBuffer = new ArrayBuffer(this._vertSize * this._capacity * this._vertCount);
            if (this._mesh) {
                var vIdx = this._vertAttrs.findIndex((function(val) {
                    return val.name === exports.GFXAttributeName.ATTR_TEX_COORD3;
                })), vOffset = this._vertAttrs[vIdx++].offset;
                if (this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_POSITION, vBuffer, this._vertSize, vOffset), 
                vOffset = this._vertAttrs[vIdx++].offset, this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_NORMAL, vBuffer, this._vertSize, vOffset), 
                vOffset = this._vertAttrs[this._vertAttrs.findIndex((function(val) {
                    return val.name === exports.GFXAttributeName.ATTR_TEX_COORD;
                }))].offset, this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_TEX_COORD, vBuffer, this._vertSize, vOffset), 
                vOffset = this._vertAttrs[vIdx++].offset, !this._mesh.copyAttribute(0, exports.GFXAttributeName.ATTR_COLOR, vBuffer, this._vertSize, vOffset)) for (var vb = new Uint32Array(vBuffer), iVertex = 0; iVertex < this._vertCount; ++iVertex) vb[iVertex * this._vertAttrsFloatCount + vOffset / 4] = Color.WHITE._val;
                for (var vbFloatArray = new Float32Array(vBuffer), i = 1; i < this._capacity; i++) vbFloatArray.copyWithin(i * this._vertSize * this._vertCount / 4, 0, this._vertSize * this._vertCount / 4);
            }
            vertexBuffer.update(vBuffer);
            var indices = new Uint16Array(this._capacity * this._indexCount);
            if (this._mesh) {
                this._mesh.copyIndices(0, indices);
                for (var _i = 1; _i < this._capacity; _i++) for (var j = 0; j < this._indexCount; j++) indices[_i * this._indexCount + j] = indices[j] + _i * this._vertCount;
            } else for (var dst = 0, _i2 = 0; _i2 < this._capacity; ++_i2) {
                var baseIdx = 4 * _i2;
                indices[dst++] = baseIdx, indices[dst++] = baseIdx + 1, indices[dst++] = baseIdx + 2, 
                indices[dst++] = baseIdx + 3, indices[dst++] = baseIdx + 2, indices[dst++] = baseIdx + 1;
            }
            var indexBuffer = this._device.createBuffer({
                usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: this._capacity * this._indexCount * Uint16Array.BYTES_PER_ELEMENT,
                stride: Uint16Array.BYTES_PER_ELEMENT
            });
            return indexBuffer.update(indices), this._iaInfo.drawInfos[0].vertexCount = this._capacity * this._vertCount, 
            this._iaInfo.drawInfos[0].indexCount = this._capacity * this._indexCount, this._iaInfoBuffer.status === exports.GFXStatus.UNREADY && this._iaInfoBuffer.initialize({
                usage: exports.GFXBufferUsageBit.INDIRECT,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 56,
                stride: 1
            }), this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = new RenderingSubMesh([ vertexBuffer ], this._vertAttrs, exports.GFXPrimitiveMode.TRIANGLE_LIST), 
            this._subMeshData.indexBuffer = indexBuffer, this._subMeshData.indirectBuffer = this._iaInfoBuffer, 
            this.setSubModelMesh(0, this._subMeshData), vBuffer;
        }
    }, {
        key: "setSubModelMaterial",
        value: function setSubModelMaterial(idx, mat) {
            this.initLocalBindings(mat), _get(_getPrototypeOf(ParticleBatchModel.prototype), "setSubModelMaterial", this).call(this, idx, mat);
        }
    }, {
        key: "addParticleVertexData",
        value: function addParticleVertexData(index, pvdata) {
            if (this._mesh) for (var i = 0; i < this._vertCount; i++) {
                var _offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;
                this._vdataF32[_offset++] = pvdata[0].x, this._vdataF32[_offset++] = pvdata[0].y, 
                this._vdataF32[_offset++] = pvdata[0].z, _offset += 2, this._vdataF32[_offset++] = pvdata[1].z, 
                this._vdataF32[_offset++] = pvdata[2].x, this._vdataF32[_offset++] = pvdata[2].y, 
                this._vdataF32[_offset++] = pvdata[2].z, this._vdataF32[_offset++] = pvdata[3].x, 
                this._vdataF32[_offset++] = pvdata[3].y, this._vdataF32[_offset++] = pvdata[3].z, 
                this._vdataUint32[_offset++] = pvdata[4];
            } else {
                var offset = index * this._vertAttrsFloatCount;
                this._vdataF32[offset++] = pvdata[0].x, this._vdataF32[offset++] = pvdata[0].y, 
                this._vdataF32[offset++] = pvdata[0].z, this._vdataF32[offset++] = pvdata[1].x, 
                this._vdataF32[offset++] = pvdata[1].y, this._vdataF32[offset++] = pvdata[1].z, 
                this._vdataF32[offset++] = pvdata[2].x, this._vdataF32[offset++] = pvdata[2].y, 
                this._vdataF32[offset++] = pvdata[2].z, this._vdataF32[offset++] = pvdata[3].x, 
                this._vdataF32[offset++] = pvdata[3].y, this._vdataF32[offset++] = pvdata[3].z, 
                this._vdataUint32[offset++] = pvdata[4], pvdata[5] && (this._vdataF32[offset++] = pvdata[5].x, 
                this._vdataF32[offset++] = pvdata[5].y, this._vdataF32[offset++] = pvdata[5].z);
            }
        }
    }, {
        key: "addGPUParticleVertexData",
        value: function addGPUParticleVertexData(p, num, time) {
            for (var offset = num * this._vertAttrsFloatCount * this._vertCount, i = 0; i < this._vertCount; i++) {
                var idx = offset;
                this._vdataF32[idx++] = p.position.x, this._vdataF32[idx++] = p.position.y, this._vdataF32[idx++] = p.position.z, 
                this._vdataF32[idx++] = time, this._vdataF32[idx++] = p.startSize.x, this._vdataF32[idx++] = p.startSize.y, 
                this._vdataF32[idx++] = p.startSize.z, this._vdataF32[idx++] = _uvs$1[2 * i], this._vdataF32[idx++] = p.rotation.x, 
                this._vdataF32[idx++] = p.rotation.y, this._vdataF32[idx++] = p.rotation.z, this._vdataF32[idx++] = _uvs$1[2 * i + 1], 
                this._vdataF32[idx++] = p.startColor.r / 255, this._vdataF32[idx++] = p.startColor.g / 255, 
                this._vdataF32[idx++] = p.startColor.b / 255, this._vdataF32[idx++] = p.startColor.a / 255, 
                this._vdataF32[idx++] = p.velocity.x, this._vdataF32[idx++] = p.velocity.y, this._vdataF32[idx++] = p.velocity.z, 
                this._vdataF32[idx++] = p.startLifetime, this._vdataF32[idx++] = p.randomSeed, offset += this._vertAttrsFloatCount;
            }
        }
    }, {
        key: "updateGPUParticles",
        value: function updateGPUParticles(num, time, dt) {
            for (var pSize = this._vertAttrsFloatCount * this._vertCount, pBaseIndex = 0, startTime = 0, lastBaseIndex = 0, i = 0; i < num; ++i) pBaseIndex = i * pSize, 
            startTime = this._vdataF32[pBaseIndex + this._startTimeOffset], this._vdataF32[pBaseIndex + this._lifeTimeOffset] - (time - startTime) < dt && (lastBaseIndex = --num * pSize, 
            this._vdataF32.copyWithin(pBaseIndex, lastBaseIndex, lastBaseIndex + pSize), i--);
            return num;
        }
    }, {
        key: "constructAttributeIndex",
        value: function constructAttributeIndex() {
            if (this._vertAttrs) {
                var vIdx = this._vertAttrs.findIndex((function(val) {
                    return "a_position_starttime" === val.name;
                })), vOffset = this._vertAttrs[vIdx].offset;
                this._startTimeOffset = vOffset / 4 + 3, vIdx = this._vertAttrs.findIndex((function(val) {
                    return "a_dir_life" === val.name;
                })), vOffset = this._vertAttrs[vIdx].offset, this._lifeTimeOffset = vOffset / 4 + 3;
            }
        }
    }, {
        key: "updateIA",
        value: function updateIA(count) {
            var ia = this.getSubModel(0).inputAssembler;
            ia.vertexBuffers[0].update(this._vdataF32), ia.indexCount = this._indexCount * count, 
            this._iaInfo.drawInfos[0] = ia, this._iaInfoBuffer.update(this._iaInfo);
        }
    }, {
        key: "clear",
        value: function clear() {
            this.getSubModel(0).inputAssembler.indexCount = 0;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            _get(_getPrototypeOf(ParticleBatchModel.prototype), "destroy", this).call(this), 
            this._vBuffer = null, this._vdataF32 = null, this.destroySubMeshData(), this._iaInfoBuffer.destroy();
        }
    }, {
        key: "_recreateBuffer",
        value: function _recreateBuffer() {
            this._vBuffer = this._createSubMeshData(), this.getSubModel(0).updateCommandBuffer(), 
            this._vdataF32 = new Float32Array(this._vBuffer), this._vdataUint32 = new Uint32Array(this._vBuffer);
        }
    }, {
        key: "destroySubMeshData",
        value: function destroySubMeshData() {
            this._subMeshData && (this._subMeshData.destroy(), this._subMeshData = null);
        }
    } ]), ParticleBatchModel;
}(), ParticleSystemRendererBase = function() {
    function ParticleSystemRendererBase(info) {
        _classCallCheck(this, ParticleSystemRendererBase), this._particleSystem = null, 
        this._model = null, this._renderInfo = null, this._vertAttrs = [], this._renderInfo = info;
    }
    return _createClass(ParticleSystemRendererBase, [ {
        key: "onInit",
        value: function onInit(ps) {
            this._particleSystem = ps;
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._particleSystem && (this.attachToScene(), this._model.initialize(this._particleSystem.node), 
            this._model.enabled = this._particleSystem.enabledInHierarchy);
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.detachFromScene();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._model && (cc.director.root.destroyModel(this._model), this._model = null);
        }
    }, {
        key: "attachToScene",
        value: function attachToScene() {
            this._model && (this._model.scene && this.detachFromScene(), this._particleSystem._getRenderScene().addModel(this._model));
        }
    }, {
        key: "detachFromScene",
        value: function detachFromScene() {
            this._model && this._model.scene && this._model.scene.removeModel(this._model);
        }
    }, {
        key: "setVertexAttributes",
        value: function setVertexAttributes() {
            this._model && this._model.setVertexAttributes(this._renderInfo.renderMode === RenderMode$1.Mesh ? this._renderInfo.mesh : null, this._vertAttrs);
        }
    }, {
        key: "_updateModel",
        value: function _updateModel() {
            this._model || (this._model = cc.director.root.createModel(ParticleBatchModel), 
            this._model.setCapacity(this._particleSystem.capacity), this._model.visFlags = this._particleSystem.visibility), 
            this._model.setVertexAttributes(this._renderInfo.renderMode === RenderMode$1.Mesh ? this._renderInfo.mesh : null, this._vertAttrs);
        }
    }, {
        key: "updateTrailMaterial",
        value: function updateTrailMaterial() {}
    }, {
        key: "getDefaultTrailMaterial",
        value: function getDefaultTrailMaterial() {
            return null;
        }
    } ]), ParticleSystemRendererBase;
}(), _tempAttribUV = new Vec3, _tempWorldTrans = new Mat4, _anim_module = [ "_colorOverLifetimeModule", "_sizeOvertimeModule", "_velocityOvertimeModule", "_forceOvertimeModule", "_limitVelocityOvertimeModule", "_rotationOvertimeModule", "_textureAnimationModule" ], _uvs$2 = [ 0, 0, 1, 0, 0, 1, 1, 1 ], _vertex_attrs$1 = [ {
    name: exports.GFXAttributeName.ATTR_POSITION,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD1,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD2,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_COLOR,
    format: exports.GFXFormat.RGBA8,
    isNormalized: !0
} ], _vertex_attrs_stretch = [ {
    name: exports.GFXAttributeName.ATTR_POSITION,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD1,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD2,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_COLOR,
    format: exports.GFXFormat.RGBA8,
    isNormalized: !0
}, {
    name: exports.GFXAttributeName.ATTR_COLOR1,
    format: exports.GFXFormat.RGB32F
} ], _vertex_attrs_mesh = [ {
    name: exports.GFXAttributeName.ATTR_POSITION,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD1,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD2,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_COLOR,
    format: exports.GFXFormat.RGBA8,
    isNormalized: !0
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD3,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_NORMAL,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_COLOR1,
    format: exports.GFXFormat.RGBA8,
    isNormalized: !0
} ], _matInsInfo$3 = {
    parent: null,
    owner: null,
    subModelIdx: 0
}, ParticleSystemRendererCPU = function(_ParticleSystemRender) {
    function ParticleSystemRendererCPU(info) {
        var _this;
        return _classCallCheck(this, ParticleSystemRendererCPU), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleSystemRendererCPU).call(this, info)))._defines = void 0, 
        _this._trailDefines = void 0, _this._frameTile_velLenScale = void 0, _this._defaultMat = null, 
        _this._node_scale = void 0, _this._attrs = void 0, _this._particles = null, _this._defaultTrailMat = null, 
        _this._updateList = new Map, _this._animateList = new Map, _this._runAnimateList = new Array, 
        _this._fillDataFunc = null, _this._uScaleHandle = 0, _this._uLenHandle = 0, _this._model = null, 
        _this._frameTile_velLenScale = new Vec4(1, 1, 0, 0), _this._node_scale = new Vec4, 
        _this._attrs = new Array(5), _this._defines = {
            CC_USE_WORLD_SPACE: !0,
            CC_USE_BILLBOARD: !0,
            CC_USE_STRETCHED_BILLBOARD: !1,
            CC_USE_HORIZONTAL_BILLBOARD: !1,
            CC_USE_VERTICAL_BILLBOARD: !1
        }, _this._trailDefines = {
            CC_USE_WORLD_SPACE: !0
        }, _this;
    }
    return _inherits(ParticleSystemRendererCPU, ParticleSystemRendererBase), _createClass(ParticleSystemRendererCPU, [ {
        key: "onInit",
        value: function onInit(ps) {
            var _this2 = this;
            _get(_getPrototypeOf(ParticleSystemRendererCPU.prototype), "onInit", this).call(this, ps), 
            this._particles = new RecyclePool((function() {
                return new Particle(_this2);
            }), 16), this._setVertexAttrib(), this._updateModel(), this._setFillFunc(), this._initModuleList(), 
            this.updateMaterialParams(), this.updateTrailMaterial();
        }
    }, {
        key: "clear",
        value: function clear() {
            this._particles.reset(), this._particleSystem._trailModule && this._particleSystem._trailModule.clear(), 
            this.updateRenderData();
        }
    }, {
        key: "updateRenderMode",
        value: function updateRenderMode() {
            this._setVertexAttrib(), this._updateModel(), this._setFillFunc(), this.updateMaterialParams();
        }
    }, {
        key: "getFreeParticle",
        value: function getFreeParticle() {
            return this._particles.length >= this._particleSystem.capacity ? null : this._particles.add();
        }
    }, {
        key: "getDefaultTrailMaterial",
        value: function getDefaultTrailMaterial() {
            return this._defaultTrailMat;
        }
    }, {
        key: "setNewParticle",
        value: function setNewParticle(p) {}
    }, {
        key: "_initModuleList",
        value: function _initModuleList() {
            var _this3 = this;
            _anim_module.forEach((function(val) {
                var pm = _this3._particleSystem[val];
                pm && pm.enable && (pm.needUpdate && (_this3._updateList[pm.name] = pm), pm.needAnimate && (_this3._animateList[pm.name] = pm));
            })), this._runAnimateList.length = 0;
            for (var i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
                var p = this._animateList[PARTICLE_MODULE_ORDER[i]];
                p && this._runAnimateList.push(p);
            }
        }
    }, {
        key: "enableModule",
        value: function enableModule(name, val, pm) {
            val ? (pm.needUpdate && (this._updateList[pm.name] = pm), pm.needAnimate && (this._animateList[pm.name] = pm)) : (delete this._animateList[name], 
            delete this._updateList[name]), this._runAnimateList.length = 0;
            for (var i = 0, len = PARTICLE_MODULE_ORDER.length; i < len; i++) {
                var p = this._animateList[PARTICLE_MODULE_ORDER[i]];
                p && this._runAnimateList.push(p);
            }
        }
    }, {
        key: "updateParticles",
        value: function updateParticles(dt) {
            var _this4 = this, ps = this._particleSystem;
            if (!ps) return this._particles.length;
            switch (ps.node.getWorldMatrix(_tempWorldTrans), ps.scaleSpace) {
              case Space.Local:
                ps.node.getScale(this._node_scale);
                break;

              case Space.World:
                ps.node.getWorldScale(this._node_scale);
            }
            (ps.getMaterialInstance(0) || this._defaultMat).passes[0].setUniform(this._uScaleHandle, this._node_scale), 
            this._updateList.forEach((function(value, key) {
                value.update(ps._simulationSpace, _tempWorldTrans);
            }));
            var trailModule = ps._trailModule, trailEnable = trailModule && trailModule.enable;
            trailEnable && trailModule.update();
            for (var _loop = function _loop(_i) {
                var p = _this4._particles.data[_i];
                if (p.remainingLifetime -= dt, Vec3.set(p.animatedVelocity, 0, 0, 0), p.remainingLifetime < 0) return trailEnable && trailModule.removeParticle(p), 
                _this4._particles.removeAt(_i), --_i, i = _i, "continue";
                p.velocity.y -= 9.8 * ps.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, pseudoRandom(p.randomSeed)) * dt, 
                Vec3.copy(p.ultimateVelocity, p.velocity), _this4._runAnimateList.forEach((function(value) {
                    value.animate(p, dt);
                })), Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt), trailEnable && trailModule.animate(p, dt), 
                i = _i;
            }, i = 0; i < this._particles.length; ++i) _loop(i);
            return this._particles.length;
        }
    }, {
        key: "updateRenderData",
        value: function updateRenderData() {
            for (var idx = 0, _i2 = 0; _i2 < this._particles.length; ++_i2) {
                var p = this._particles.data[_i2], fi = 0, textureModule = this._particleSystem._textureAnimationModule;
                textureModule && textureModule.enable && (fi = p.frameIndex), idx = 4 * _i2, this._fillDataFunc(p, idx, fi);
            }
            this._model.updateIA(this._particles.length);
        }
    }, {
        key: "getParticleCount",
        value: function getParticleCount() {
            return this._particles.length;
        }
    }, {
        key: "onMaterialModified",
        value: function onMaterialModified(index, material) {
            0 === index ? (this._updateModel(), this.updateMaterialParams()) : this.updateTrailMaterial();
        }
    }, {
        key: "onRebuildPSO",
        value: function onRebuildPSO(index, material) {
            this._model && 0 === index && this._model.setSubModelMaterial(0, material);
            var trailModule = this._particleSystem._trailModule;
            trailModule && trailModule._trailModel && 1 === index && trailModule._trailModel.setSubModelMaterial(0, material);
        }
    }, {
        key: "_setFillFunc",
        value: function _setFillFunc() {
            this._renderInfo.renderMode === RenderMode$1.Mesh ? this._fillDataFunc = this._fillMeshData : this._renderInfo.renderMode === RenderMode$1.StrecthedBillboard ? this._fillDataFunc = this._fillStrecthedData : this._fillDataFunc = this._fillNormalData;
        }
    }, {
        key: "_fillMeshData",
        value: function _fillMeshData(p, idx, fi) {
            var i = idx / 4, attrNum = 0;
            this._attrs[attrNum++] = p.position, _tempAttribUV.z = fi, this._attrs[attrNum++] = _tempAttribUV, 
            this._attrs[attrNum++] = p.size, this._attrs[attrNum++] = p.rotation, this._attrs[attrNum++] = p.color._val, 
            this._model.addParticleVertexData(i, this._attrs);
        }
    }, {
        key: "_fillStrecthedData",
        value: function _fillStrecthedData(p, idx, fi) {
            for (var attrNum = 0, j = 0; j < 4; ++j) attrNum = 0, this._attrs[attrNum++] = p.position, 
            _tempAttribUV.x = _uvs$2[2 * j], _tempAttribUV.y = _uvs$2[2 * j + 1], _tempAttribUV.z = fi, 
            this._attrs[attrNum++] = _tempAttribUV, this._attrs[attrNum++] = p.size, this._attrs[attrNum++] = p.rotation, 
            this._attrs[attrNum++] = p.color._val, this._attrs[attrNum++] = p.ultimateVelocity, 
            this._attrs[attrNum++] = p.ultimateVelocity, this._model.addParticleVertexData(idx++, this._attrs);
        }
    }, {
        key: "_fillNormalData",
        value: function _fillNormalData(p, idx, fi) {
            for (var attrNum = 0, j = 0; j < 4; ++j) attrNum = 0, this._attrs[attrNum++] = p.position, 
            _tempAttribUV.x = _uvs$2[2 * j], _tempAttribUV.y = _uvs$2[2 * j + 1], _tempAttribUV.z = fi, 
            this._attrs[attrNum++] = _tempAttribUV, this._attrs[attrNum++] = p.size, this._attrs[attrNum++] = p.rotation, 
            this._attrs[attrNum++] = p.color._val, this._attrs[attrNum++] = null, this._model.addParticleVertexData(idx++, this._attrs);
        }
    }, {
        key: "_setVertexAttrib",
        value: function _setVertexAttrib() {
            switch (this._renderInfo.renderMode) {
              case RenderMode$1.StrecthedBillboard:
                this._vertAttrs = _vertex_attrs_stretch.slice();
                break;

              case RenderMode$1.Mesh:
                this._vertAttrs = _vertex_attrs_mesh.slice();
                break;

              default:
                this._vertAttrs = _vertex_attrs$1.slice();
            }
        }
    }, {
        key: "updateMaterialParams",
        value: function updateMaterialParams() {
            if (this._particleSystem) {
                var ps = this._particleSystem, shareMaterial = ps.sharedMaterial;
                if (null != shareMaterial) {
                    var effectName = shareMaterial._effectAsset._name;
                    this._renderInfo.mainTexture = shareMaterial.getProperty("mainTexture", 0), -1 !== effectName.indexOf("particle") && -1 === effectName.indexOf("particle-gpu") || ps.setMaterial(null, 0);
                }
                null == ps.sharedMaterial && null == this._defaultMat && (_matInsInfo$3.parent = builtinResMgr.get("default-particle-material"), 
                _matInsInfo$3.owner = this._particleSystem, _matInsInfo$3.subModelIdx = 0, this._defaultMat = new MaterialInstance(_matInsInfo$3), 
                null !== this._renderInfo.mainTexture && this._defaultMat.setProperty("mainTexture", this._renderInfo.mainTexture));
                var mat = ps.getMaterialInstance(0) || this._defaultMat;
                ps._simulationSpace === Space.World ? this._defines.CC_USE_WORLD_SPACE = !0 : this._defines.CC_USE_WORLD_SPACE = !1;
                var pass = mat.passes[0];
                this._uScaleHandle = pass.getHandle("scale"), this._uLenHandle = pass.getHandle("frameTile_velLenScale");
                var renderMode = this._renderInfo.renderMode, vlenScale = this._frameTile_velLenScale;
                renderMode === RenderMode$1.Billboard ? this._defines.CC_RENDER_MODE = 0 : renderMode === RenderMode$1.StrecthedBillboard ? (this._defines.CC_RENDER_MODE = 1, 
                vlenScale.z = this._renderInfo.velocityScale, vlenScale.w = this._renderInfo.lengthScale) : renderMode === RenderMode$1.HorizontalBillboard ? this._defines.CC_RENDER_MODE = 2 : renderMode === RenderMode$1.VerticalBillboard ? this._defines.CC_RENDER_MODE = 3 : renderMode === RenderMode$1.Mesh ? this._defines.CC_RENDER_MODE = 4 : console.warn("particle system renderMode ".concat(renderMode, " not support."));
                var textureModule = ps._textureAnimationModule;
                textureModule && textureModule.enable ? (Vec2.set(vlenScale, textureModule.numTilesX, textureModule.numTilesY), 
                pass.setUniform(this._uLenHandle, vlenScale)) : pass.setUniform(this._uLenHandle, vlenScale), 
                mat.recompileShaders(this._defines), this._model && this._model.setSubModelMaterial(0, mat);
            }
        }
    }, {
        key: "updateTrailMaterial",
        value: function updateTrailMaterial() {
            if (this._particleSystem) {
                var ps = this._particleSystem, trailModule = ps._trailModule;
                if (trailModule && trailModule.enable) {
                    ps.simulationSpace === Space.World || trailModule.space === Space.World ? this._trailDefines.CC_USE_WORLD_SPACE = !0 : this._trailDefines.CC_USE_WORLD_SPACE = !1;
                    var mat = ps.getMaterialInstance(1);
                    null === mat && null === this._defaultTrailMat && (_matInsInfo$3.parent = builtinResMgr.get("default-trail-material"), 
                    _matInsInfo$3.owner = this._particleSystem, _matInsInfo$3.subModelIdx = 1, this._defaultTrailMat = new MaterialInstance(_matInsInfo$3)), 
                    (mat = mat || this._defaultTrailMat).recompileShaders(this._trailDefines), trailModule._updateMaterial();
                }
            }
        }
    } ]), ParticleSystemRendererCPU;
}(), _tempWorldTrans$1 = new Mat4, _tempVec4 = new Vec4, _world_rot = new Quat, _vert_attr_name_POSITION_STARTTIME = "a_position_starttime", _vert_attr_name_VERT_SIZE_UV = "a_size_uv", _vert_attr_name_VERT_ROTATION_UV = "a_rotation_uv", _vert_attr_name_COLOR = "a_color", _vert_attr_name_DIR_LIFE = "a_dir_life", _vert_attr_name_RANDOM_SEED = "a_rndSeed", _gpu_vert_attr = [ {
    name: _vert_attr_name_POSITION_STARTTIME,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_VERT_SIZE_UV,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_VERT_ROTATION_UV,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_COLOR,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_DIR_LIFE,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_RANDOM_SEED,
    format: exports.GFXFormat.R32F
} ], _gpu_vert_attr_mesh = [ {
    name: _vert_attr_name_POSITION_STARTTIME,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_VERT_SIZE_UV,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_VERT_ROTATION_UV,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_COLOR,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_DIR_LIFE,
    format: exports.GFXFormat.RGBA32F
}, {
    name: _vert_attr_name_RANDOM_SEED,
    format: exports.GFXFormat.R32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_TEX_COORD3,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_NORMAL,
    format: exports.GFXFormat.RGB32F
}, {
    name: exports.GFXAttributeName.ATTR_COLOR1,
    format: exports.GFXFormat.RGBA8,
    isNormalized: !0
} ], _matInsInfo$4 = {
    parent: null,
    owner: null,
    subModelIdx: 0
}, ParticleSystemRendererGPU = function(_ParticleSystemRender) {
    function ParticleSystemRendererGPU(info) {
        var _this;
        return _classCallCheck(this, ParticleSystemRendererGPU), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleSystemRendererGPU).call(this, info)))._defines = void 0, 
        _this._frameTile_velLenScale = void 0, _this._node_scale = void 0, _this._vertAttrs = [], 
        _this._defaultMat = null, _this._particleNum = 0, _this._tempParticle = null, _this._colorTexture = null, 
        _this._forceTexture = null, _this._velocityTexture = null, _this._rotationTexture = null, 
        _this._sizeTexture = null, _this._animTexture = null, _this._uTimeHandle = 0, _this._uRotHandle = 0, 
        _this._frameTile_velLenScale = new Vec4(1, 1, 0, 0), _this._node_scale = new Vec4, 
        _this._defines = {
            CC_USE_WORLD_SPACE: !0,
            CC_USE_BILLBOARD: !0,
            CC_USE_STRETCHED_BILLBOARD: !1,
            CC_USE_HORIZONTAL_BILLBOARD: !1,
            CC_USE_VERTICAL_BILLBOARD: !1,
            COLOR_OVER_TIME_MODULE_ENABLE: !1
        }, _this._tempParticle = new Particle(null), _this._particleNum = 0, _this;
    }
    return _inherits(ParticleSystemRendererGPU, ParticleSystemRendererBase), _createClass(ParticleSystemRendererGPU, [ {
        key: "onInit",
        value: function onInit(ps) {
            _get(_getPrototypeOf(ParticleSystemRendererGPU.prototype), "onInit", this).call(this, ps), 
            this._setVertexAttrib(), this._updateModel(), this._model.constructAttributeIndex(), 
            this.updateMaterialParams();
        }
    }, {
        key: "updateRenderMode",
        value: function updateRenderMode() {
            this._setVertexAttrib(), this._updateModel(), this.updateMaterialParams();
        }
    }, {
        key: "clear",
        value: function clear() {
            this._particleNum = 0, this.updateRenderData();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            _get(_getPrototypeOf(ParticleSystemRendererGPU.prototype), "onDestroy", this).call(this), 
            this._forceTexture && this._forceTexture.destroy(), this._velocityTexture && this._velocityTexture.destroy(), 
            this._colorTexture && this._colorTexture.destroy(), this._sizeTexture && this._sizeTexture.destroy(), 
            this._rotationTexture && this._rotationTexture.destroy(), this._animTexture && this._animTexture.destroy();
        }
    }, {
        key: "enableModule",
        value: function enableModule(name, val, pm) {
            var mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;
            mat && (this.initShaderUniform(mat), mat.recompileShaders(this._defines), this._model && this._model.setSubModelMaterial(0, mat));
        }
    }, {
        key: "getFreeParticle",
        value: function getFreeParticle() {
            return this._particleNum >= this._particleSystem._capacity ? null : this._tempParticle;
        }
    }, {
        key: "setNewParticle",
        value: function setNewParticle(p) {
            this._model.addGPUParticleVertexData(p, this._particleNum, this._particleSystem._time), 
            this._particleNum++;
        }
    }, {
        key: "updateParticles",
        value: function updateParticles(dt) {
            return this._particleNum = this._model.updateGPUParticles(this._particleNum, this._particleSystem._time, dt), 
            this.updateShaderUniform(dt), this._particleNum;
        }
    }, {
        key: "updateRenderData",
        value: function updateRenderData() {
            this._model.updateIA(this._particleNum);
        }
    }, {
        key: "updateShaderUniform",
        value: function updateShaderUniform(dt) {
            var mat = this._particleSystem.getMaterialInstance(0) || this._defaultMat;
            if (mat) {
                var pass = mat.passes[0];
                _tempVec4.x = this._particleSystem._time, _tempVec4.y = dt, pass.setUniform(this._uTimeHandle, _tempVec4), 
                this._particleSystem.node.getWorldRotation(_world_rot), pass.setUniform(this._uRotHandle, _world_rot);
            }
        }
    }, {
        key: "initShaderUniform",
        value: function initShaderUniform(mat) {
            var pass = mat.passes[0];
            this._uTimeHandle = pass.getHandle("u_timeDelta"), this._uRotHandle = pass.getHandle("u_worldRot"), 
            pass.setUniform(pass.getHandle("scale"), this._node_scale), pass.setUniform(pass.getHandle("frameTile_velLenScale"), this._frameTile_velLenScale), 
            _tempVec4.x = 32, _tempVec4.y = 1 / 32, pass.setUniform(pass.getHandle("u_sampleInfo"), _tempVec4);
            var enable = !1, forceModule = this._particleSystem._forceOvertimeModule;
            if (enable = forceModule && forceModule.enable, this._defines.FORCE_OVER_TIME_MODULE_ENABLE = enable, 
            enable) {
                this._forceTexture && this._forceTexture.destroy(), this._forceTexture = packCurveRangeXYZ(32, forceModule.x, forceModule.y, forceModule.z);
                var handle = pass.getHandle("force_over_time_tex0"), binding = Pass.getBindingFromHandle(handle);
                pass.bindSampler(binding, this._forceTexture.getGFXSampler()), pass.bindTextureView(binding, this._forceTexture.getGFXTextureView());
                var spaceHandle = pass.getHandle("u_force_space");
                pass.setUniform(spaceHandle, forceModule.space);
                var modeHandle = pass.getHandle("u_force_mode");
                pass.setUniform(modeHandle, this._forceTexture.height);
            }
            var velocityModule = this._particleSystem._velocityOvertimeModule;
            if (enable = velocityModule && velocityModule.enable, this._defines.VELOCITY_OVER_TIME_MODULE_ENABLE = enable, 
            enable) {
                this._velocityTexture && this._velocityTexture.destroy(), this._velocityTexture = function packCurveRangeXYZW(samples, x, y, z, w, discrete) {
                    for (var height = Math.max(evaluateHeight(x), evaluateHeight(y), evaluateHeight(z), evaluateHeight(w)), data = new Float32Array(samples * height * 4), curves = [ x, y, z, w ], interval = 1 / (samples - 1), h = 0; h < height; h++) for (var i = 0; i < 4; i++) for (var cr = curves[i], sum = 0, average = 0, j = 0; j < samples; j++) {
                        var value = evaluateCurve(cr, interval * j, h);
                        average = discrete ? value : (sum += value) / (j + 1), data[4 * j + i] = average;
                    }
                    return packTexture(data, samples, height);
                }(32, velocityModule.x, velocityModule.y, velocityModule.z, velocityModule.speedModifier);
                var _handle = pass.getHandle("velocity_over_time_tex0"), _binding = Pass.getBindingFromHandle(_handle);
                pass.bindSampler(_binding, this._velocityTexture.getGFXSampler()), pass.bindTextureView(_binding, this._velocityTexture.getGFXTextureView());
                var _spaceHandle = pass.getHandle("u_velocity_space");
                pass.setUniform(_spaceHandle, velocityModule.space);
                var _modeHandle = pass.getHandle("u_velocity_mode");
                pass.setUniform(_modeHandle, this._velocityTexture.height);
            }
            var colorModule = this._particleSystem._colorOverLifetimeModule;
            if (enable = colorModule && colorModule.enable, this._defines.COLOR_OVER_TIME_MODULE_ENABLE = enable, 
            enable) {
                this._colorTexture && this._colorTexture.destroy(), this._colorTexture = packGradientRange(32, colorModule.color);
                var _handle2 = pass.getHandle("color_over_time_tex0"), _binding2 = Pass.getBindingFromHandle(_handle2);
                pass.bindSampler(_binding2, this._colorTexture.getGFXSampler()), pass.bindTextureView(_binding2, this._colorTexture.getGFXTextureView());
                var _modeHandle2 = pass.getHandle("u_color_mode");
                pass.setUniform(_modeHandle2, this._colorTexture.height);
            }
            var roationModule = this._particleSystem._rotationOvertimeModule;
            if (enable = roationModule && roationModule.enable, this._defines.ROTATION_OVER_TIME_MODULE_ENABLE = enable, 
            enable) {
                this._rotationTexture && this._rotationTexture.destroy(), roationModule.separateAxes ? this._rotationTexture = packCurveRangeXYZ(32, roationModule.x, roationModule.y, roationModule.z) : this._rotationTexture = function packCurveRangeZ(samples, cr, discrete) {
                    for (var height = evaluateHeight(cr), data = new Float32Array(samples * height * 4), interval = 1 / (samples - 1), offset = 0, h = 0; h < height; h++) for (var j = 0; j < samples; j++) {
                        var value = evaluateCurve(cr, interval * j, h);
                        data[offset + 2] = value, offset += 4;
                    }
                    return packTexture(data, samples, height);
                }(32, roationModule.z);
                var _handle3 = pass.getHandle("rotation_over_time_tex0"), _binding3 = Pass.getBindingFromHandle(_handle3);
                pass.bindSampler(_binding3, this._rotationTexture.getGFXSampler()), pass.bindTextureView(_binding3, this._rotationTexture.getGFXTextureView());
                var _modeHandle3 = pass.getHandle("u_rotation_mode");
                pass.setUniform(_modeHandle3, this._rotationTexture.height);
            }
            var sizeModule = this._particleSystem._sizeOvertimeModule;
            if (enable = sizeModule && sizeModule.enable, this._defines.SIZE_OVER_TIME_MODULE_ENABLE = enable, 
            enable) {
                this._sizeTexture && this._sizeTexture.destroy(), sizeModule.separateAxes ? this._sizeTexture = packCurveRangeXYZ(32, sizeModule.x, sizeModule.y, sizeModule.z, !0) : this._sizeTexture = function packCurveRangeN(samples, cr, discrete) {
                    for (var height = evaluateHeight(cr), data = new Float32Array(samples * height * 4), interval = 1 / (samples - 1), sum = 0, average = 0, offset = 0, h = 0; h < height; h++) {
                        sum = 0;
                        for (var j = 0; j < samples; j++) {
                            var value = evaluateCurve(cr, interval * j, h);
                            average = discrete ? value : (sum += value) / (j + 1), data[offset] = average, data[offset + 1] = average, 
                            data[offset + 2] = average, offset += 4;
                        }
                    }
                    return packTexture(data, samples, height);
                }(32, sizeModule.size, !0);
                var _handle4 = pass.getHandle("size_over_time_tex0"), _binding4 = Pass.getBindingFromHandle(_handle4);
                pass.bindSampler(_binding4, this._sizeTexture.getGFXSampler()), pass.bindTextureView(_binding4, this._sizeTexture.getGFXTextureView());
                var _modeHandle4 = pass.getHandle("u_size_mode");
                pass.setUniform(_modeHandle4, this._sizeTexture.height);
            }
            var textureModule = this._particleSystem._textureAnimationModule;
            if (enable = textureModule && textureModule.enable, this._defines.TEXTURE_ANIMATION_MODULE_ENABLE = enable, 
            enable) {
                this._animTexture && this._animTexture.destroy(), this._animTexture = function packCurveRangeXY(samples, x, y, discrete) {
                    for (var height = Math.max(evaluateHeight(x), evaluateHeight(y)), data = new Float32Array(samples * height * 4), curves = [ x, y ], interval = 1 / (samples - 1), h = 0; h < height; h++) for (var i = 0; i < 2; i++) for (var cr = curves[i], sum = 0, average = 0, j = 0; j < samples; j++) {
                        var value = evaluateCurve(cr, interval * j, h);
                        average = discrete ? value : (sum += value) / (j + 1), data[4 * j + i] = average;
                    }
                    return packTexture(data, samples, height);
                }(32, textureModule.startFrame, textureModule.frameOverTime);
                var _handle5 = pass.getHandle("texture_animation_tex0"), _binding5 = Pass.getBindingFromHandle(_handle5);
                pass.bindSampler(_binding5, this._animTexture.getGFXSampler()), pass.bindTextureView(_binding5, this._animTexture.getGFXTextureView());
                var infoHandle = pass.getHandle("u_anim_info");
                _tempVec4.x = this._animTexture.height, _tempVec4.y = textureModule.numTilesX * textureModule.numTilesY, 
                _tempVec4.z = textureModule.cycleCount, pass.setUniform(infoHandle, _tempVec4);
            }
        }
    }, {
        key: "getParticleCount",
        value: function getParticleCount() {
            return this._particleNum;
        }
    }, {
        key: "onMaterialModified",
        value: function onMaterialModified(index, material) {
            this._updateModel(), this.updateMaterialParams();
        }
    }, {
        key: "onRebuildPSO",
        value: function onRebuildPSO(index, material) {
            this._model && 0 === index && this._model.setSubModelMaterial(0, material);
        }
    }, {
        key: "_setVertexAttrib",
        value: function _setVertexAttrib() {
            switch (this._renderInfo.renderMode) {
              case RenderMode$1.StrecthedBillboard:
                this._vertAttrs = _gpu_vert_attr.slice();
                break;

              case RenderMode$1.Mesh:
                this._vertAttrs = _gpu_vert_attr_mesh.slice();
                break;

              default:
                this._vertAttrs = _gpu_vert_attr.slice();
            }
        }
    }, {
        key: "updateMaterialParams",
        value: function updateMaterialParams() {
            if (this._particleSystem) {
                var ps = this._particleSystem, shareMaterial = ps.sharedMaterial;
                if (null !== shareMaterial) {
                    var effectName = shareMaterial._effectAsset._name;
                    this._renderInfo.mainTexture = shareMaterial.getProperty("mainTexture", 0), -1 === effectName.indexOf("particle-gpu") && (this._renderInfo.mainTexture = shareMaterial.getProperty("mainTexture", 0), 
                    this._particleSystem.setMaterial(null, 0));
                }
                null == shareMaterial && null == this._defaultMat && (_matInsInfo$4.parent = builtinResMgr.get("default-particle-gpu-material"), 
                _matInsInfo$4.owner = ps, _matInsInfo$4.subModelIdx = 0, this._defaultMat = new MaterialInstance(_matInsInfo$4), 
                null !== this._renderInfo.mainTexture && this._defaultMat.setProperty("mainTexture", this._renderInfo.mainTexture));
                var mat = ps.getMaterialInstance(0) || this._defaultMat;
                switch (ps.node.getWorldMatrix(_tempWorldTrans$1), ps.scaleSpace) {
                  case Space.Local:
                    ps.node.getScale(this._node_scale);
                    break;

                  case Space.World:
                    ps.node.getWorldScale(this._node_scale);
                }
                ps._simulationSpace === Space.World ? this._defines.CC_USE_WORLD_SPACE = !0 : this._defines.CC_USE_WORLD_SPACE = !1;
                var renderMode = this._renderInfo.renderMode;
                renderMode === RenderMode$1.Billboard ? this._defines.CC_RENDER_MODE = 0 : renderMode === RenderMode$1.StrecthedBillboard ? (this._defines.CC_RENDER_MODE = 1, 
                this._frameTile_velLenScale.z = this._renderInfo.velocityScale, this._frameTile_velLenScale.w = this._renderInfo.lengthScale) : renderMode === RenderMode$1.HorizontalBillboard ? this._defines.CC_RENDER_MODE = 2 : renderMode === RenderMode$1.VerticalBillboard ? this._defines.CC_RENDER_MODE = 3 : renderMode === RenderMode$1.Mesh ? this._defines.CC_RENDER_MODE = 4 : console.warn("particle system renderMode ".concat(renderMode, " not support."));
                var textureModule = ps._textureAnimationModule;
                textureModule && textureModule.enable && Vec2.set(this._frameTile_velLenScale, textureModule.numTilesX, textureModule.numTilesY), 
                this.initShaderUniform(mat), mat.recompileShaders(this._defines), this._model && this._model.setSubModelMaterial(0, mat);
            }
        }
    } ]), ParticleSystemRendererGPU;
}();

function isSupportGPUParticle() {
    var device = director.root.device;
    return !!(device.maxVertexTextureUnits >= 8 && device.hasFeature(exports.GFXFeature.TEXTURE_FLOAT)) || (cc.warn("Maybe the device has restrictions on vertex textures or does not support float textures."), 
    !1);
}

var _dec$1J, _dec2$1j, _dec3$11, _dec4$X, _dec5$R, _dec6$O, _dec7$E, _dec8$A, _dec9$r, _dec10$k, _dec11$j, _dec12$i, _dec13$f, _dec14$e, _class$1K, _class2$1y, _descriptor$1n, _descriptor2$1a, _descriptor3$_, _descriptor4$S, _descriptor5$H, _descriptor6$u, _descriptor7$p, _descriptor8$k, _descriptor9$h, _descriptor10$g, _descriptor11$c, _descriptor12$b, _descriptor13$a, _dec$1K, _dec2$1k, _dec3$12, _dec4$Y, _dec5$S, _dec6$P, _dec7$F, _dec8$B, _dec9$s, _dec10$l, _dec11$k, _dec12$j, _dec13$g, _dec14$f, _dec15$b, _dec16$a, _dec17$8, _dec18$7, _dec19$7, _dec20$4, _dec21$3, _dec22$2, _dec23$2, _dec24$2, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _class$1L, _class2$1z, _descriptor$1o, _descriptor2$1b, _descriptor3$$, _descriptor4$T, _descriptor5$I, _descriptor6$v, _descriptor7$q, _descriptor8$l, _descriptor9$i, _descriptor10$h, _descriptor11$d, _descriptor12$c, _descriptor13$b, _descriptor14$9, _descriptor15$5, _descriptor16$5, _descriptor17$4, _descriptor18$4, _descriptor19$2, _descriptor20$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _descriptor24$1, _descriptor25$1, _descriptor26$1, _descriptor27$1, _descriptor28$1, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _descriptor33, _descriptor34, _descriptor35, PhysicsWorld, BoxShape, SphereShape, CapsuleShape, ParticleSystemRenderer = (_dec$1I = ccclass("cc.ParticleSystemRenderer"), 
_dec2$1i = property({
    type: RenderMode$1,
    displayOrder: 0,
    tooltip: "设定粒子生成模式"
}), _dec3$10 = property({
    displayOrder: 1,
    tooltip: "在粒子生成方式为 StrecthedBillboard 时,对粒子在运动方向上按速度大小进行拉伸"
}), _dec4$W = property({
    displayOrder: 2,
    tooltip: "在粒子生成方式为 StrecthedBillboard 时,对粒子在运动方向上按粒子大小进行拉伸"
}), _dec5$Q = property({
    type: RenderMode$1,
    displayOrder: 3
}), _dec6$N = property({
    displayOrder: 4
}), _dec7$D = property({
    displayOrder: 5
}), _dec8$z = property({
    displayOrder: 6
}), _dec9$q = property({
    type: Mesh,
    displayOrder: 7,
    tooltip: "粒子发射的模型"
}), _dec10$j = property({
    type: Material,
    displayOrder: 8,
    tooltip: "粒子使用的材质"
}), _dec11$i = property({
    type: Material,
    displayOrder: 9,
    tooltip: "拖尾使用的材质"
}), _dec12$h = property({
    displayOrder: 10,
    tooltip: "是否启用GPU粒子"
}), _dec$1I((_applyDecoratedDescriptor((_class2$1x = function() {
    function ParticleSystemRenderer() {
        _classCallCheck(this, ParticleSystemRenderer), _initializerDefineProperty(this, "_renderMode", _descriptor$1m, this), 
        _initializerDefineProperty(this, "_velocityScale", _descriptor2$19, this), _initializerDefineProperty(this, "_lengthScale", _descriptor3$Z, this), 
        _initializerDefineProperty(this, "_mesh", _descriptor4$R, this), _initializerDefineProperty(this, "_mainTexture", _descriptor5$G, this), 
        _initializerDefineProperty(this, "_useGPU", _descriptor6$t, this), this._particleSystem = null;
    }
    return _createClass(ParticleSystemRenderer, [ {
        key: "onInit",
        value: function onInit(ps) {
            this._particleSystem = ps;
            var useGPU = this._useGPU && isSupportGPUParticle();
            this._particleSystem.processor = useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this), 
            this._particleSystem.processor.onInit(ps);
        }
    }, {
        key: "_switchProcessor",
        value: function _switchProcessor() {
            this._particleSystem.processor && (this._particleSystem.processor.detachFromScene(), 
            this._particleSystem.processor.clear(), this._particleSystem.processor = null), 
            this._particleSystem.processor = this._useGPU ? new ParticleSystemRendererGPU(this) : new ParticleSystemRendererCPU(this), 
            this._particleSystem.processor.onInit(this._particleSystem), this._particleSystem.processor.onEnable(), 
            this._particleSystem.bindModule();
        }
    }, {
        key: "renderMode",
        get: function get() {
            return this._renderMode;
        },
        set: function set(val) {
            this._renderMode !== val && (this._renderMode = val, this._particleSystem.processor.updateRenderMode());
        }
    }, {
        key: "velocityScale",
        get: function get() {
            return this._velocityScale;
        },
        set: function set(val) {
            this._velocityScale = val, this._particleSystem.processor.updateMaterialParams();
        }
    }, {
        key: "lengthScale",
        get: function get() {
            return this._lengthScale;
        },
        set: function set(val) {
            this._lengthScale = val, this._particleSystem.processor.updateMaterialParams();
        }
    }, {
        key: "mesh",
        get: function get() {
            return this._mesh;
        },
        set: function set(val) {
            this._mesh = val, this._particleSystem.processor.setVertexAttributes();
        }
    }, {
        key: "particleMaterial",
        get: function get() {
            return this._particleSystem ? this._particleSystem.getMaterial(0) : null;
        },
        set: function set(val) {
            this._particleSystem.setMaterial(val, 0);
        }
    }, {
        key: "trailMaterial",
        get: function get() {
            return this._particleSystem ? this._particleSystem.getMaterial(1) : null;
        },
        set: function set(val) {
            this._particleSystem.setMaterial(val, 1);
        }
    }, {
        key: "mainTexture",
        get: function get() {
            return this._mainTexture;
        },
        set: function set(val) {
            this._mainTexture = val;
        }
    }, {
        key: "useGPU",
        get: function get() {
            return this._useGPU;
        },
        set: function set(val) {
            this._useGPU !== val && (isSupportGPUParticle() ? this._useGPU = val : this._useGPU = !1, 
            this._switchProcessor());
        }
    } ]), ParticleSystemRenderer;
}()).prototype, "renderMode", [ _dec2$1i ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "renderMode"), _class2$1x.prototype), 
_applyDecoratedDescriptor(_class2$1x.prototype, "velocityScale", [ _dec3$10 ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "velocityScale"), _class2$1x.prototype), 
_applyDecoratedDescriptor(_class2$1x.prototype, "lengthScale", [ _dec4$W ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "lengthScale"), _class2$1x.prototype), 
_descriptor$1m = _applyDecoratedDescriptor(_class2$1x.prototype, "_renderMode", [ _dec5$Q ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return RenderMode$1.Billboard;
    }
}), _descriptor2$19 = _applyDecoratedDescriptor(_class2$1x.prototype, "_velocityScale", [ _dec6$N ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor3$Z = _applyDecoratedDescriptor(_class2$1x.prototype, "_lengthScale", [ _dec7$D ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor4$R = _applyDecoratedDescriptor(_class2$1x.prototype, "_mesh", [ _dec8$z ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1x.prototype, "mesh", [ _dec9$q ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "mesh"), _class2$1x.prototype), 
_applyDecoratedDescriptor(_class2$1x.prototype, "particleMaterial", [ _dec10$j ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "particleMaterial"), _class2$1x.prototype), 
_applyDecoratedDescriptor(_class2$1x.prototype, "trailMaterial", [ _dec11$i ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "trailMaterial"), _class2$1x.prototype), 
_descriptor5$G = _applyDecoratedDescriptor(_class2$1x.prototype, "_mainTexture", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor6$t = _applyDecoratedDescriptor(_class2$1x.prototype, "_useGPU", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _applyDecoratedDescriptor(_class2$1x.prototype, "useGPU", [ _dec12$h ], Object.getOwnPropertyDescriptor(_class2$1x.prototype, "useGPU"), _class2$1x.prototype), 
_class$1J = _class2$1x)) || _class$1J), DIRECTION_THRESHOLD = Math.cos(toRadian(100)), _temp_trailEle = {
    position: new Vec3,
    velocity: new Vec3
}, _temp_quat = new Quat, _temp_xform = new Mat4, _temp_vec3 = new Vec3, _temp_vec3_1$1 = new Vec3, _temp_color = new Color, TrailSegment = function() {
    function TrailSegment(maxTrailElementNum) {
        for (_classCallCheck(this, TrailSegment), this.start = void 0, this.end = void 0, 
        this.trailElements = void 0, this.start = -1, this.end = -1, this.trailElements = []; maxTrailElementNum--; ) this.trailElements.push({
            position: new Vec3,
            lifetime: 0,
            width: 0,
            velocity: new Vec3,
            direction: 0,
            color: new Color
        });
    }
    return _createClass(TrailSegment, [ {
        key: "getElement",
        value: function getElement(idx) {
            return -1 === this.start ? null : (idx < 0 && (idx = (idx + this.trailElements.length) % this.trailElements.length), 
            idx >= this.trailElements.length && (idx %= this.trailElements.length), this.trailElements[idx]);
        }
    }, {
        key: "addElement",
        value: function addElement() {
            if (0 === this.trailElements.length) return null;
            if (-1 === this.start) return this.start = 0, this.end = 1, this.trailElements[0];
            this.start === this.end && (this.trailElements.splice(this.end, 0, {
                position: new Vec3,
                lifetime: 0,
                width: 0,
                velocity: new Vec3,
                direction: 0,
                color: new Color
            }), this.start++, this.start %= this.trailElements.length);
            var newEleLoc = this.end++;
            return this.end %= this.trailElements.length, this.trailElements[newEleLoc];
        }
    }, {
        key: "iterateElement",
        value: function iterateElement(target, f, p, dt) {
            for (var end = this.start >= this.end ? this.end + this.trailElements.length : this.end, i = this.start; i < end; i++) f(target, this.trailElements[i % this.trailElements.length], p, dt) && (this.start++, 
            this.start %= this.trailElements.length);
            this.start === end && (this.start = -1, this.end = -1);
        }
    }, {
        key: "count",
        value: function count() {
            return this.start < this.end ? this.end - this.start : this.trailElements.length + this.end - this.start;
        }
    }, {
        key: "clear",
        value: function clear() {
            this.start = -1, this.end = -1;
        }
    } ]), TrailSegment;
}(), TrailModule = (_dec$1J = ccclass("cc.TrailModule"), _dec2$1j = property({
    displayOrder: 0
}), _dec3$11 = property({
    type: TrailMode,
    displayOrder: 1,
    tooltip: "Particle在每个粒子的运动轨迹上形成拖尾效果"
}), _dec4$X = property({
    type: CurveRange,
    displayOrder: 3,
    tooltip: "拖尾的生命周期"
}), _dec5$R = property({
    displayOrder: 5,
    tooltip: "粒子每生成一个拖尾节点所运行的最短距离"
}), _dec6$O = property({
    type: Space,
    displayOrder: 6,
    tooltip: "拖尾所在的坐标系，World在世界坐标系中运行，Local在本地坐标系中运行"
}), _dec7$E = property({
    displayOrder: 7,
    tooltip: "拖尾是否跟随粒子一起消失",
    visible: !1
}), _dec8$A = property({
    type: TextureMode,
    displayOrder: 8,
    tooltip: "贴图在拖尾上的展开形式，Stretch贴图覆盖在整条拖尾上，Repeat贴图覆盖在一段拖尾上"
}), _dec9$r = property({
    displayOrder: 9,
    tooltip: "拖尾宽度继承自粒子大小"
}), _dec10$k = property({
    type: CurveRange,
    displayOrder: 10,
    tooltip: "拖尾宽度，如果继承自粒子则是粒子大小的比例"
}), _dec11$j = property({
    displayOrder: 11,
    tooltip: "拖尾颜色是否继承自粒子"
}), _dec12$i = property({
    type: GradientRange,
    displayOrder: 12,
    tooltip: "拖尾颜色随拖尾自身长度的颜色渐变"
}), _dec13$f = property({
    type: GradientRange,
    displayOrder: 13,
    tooltip: "拖尾颜色随时间的颜色渐变"
}), _dec14$e = property({
    type: Space
}), _dec$1J((_applyDecoratedDescriptor((_class2$1y = function() {
    function TrailModule() {
        _classCallCheck(this, TrailModule), _initializerDefineProperty(this, "_enable", _descriptor$1n, this), 
        _initializerDefineProperty(this, "mode", _descriptor2$1a, this), _initializerDefineProperty(this, "lifeTime", _descriptor3$_, this), 
        _initializerDefineProperty(this, "_minParticleDistance", _descriptor4$S, this), 
        _initializerDefineProperty(this, "existWithParticles", _descriptor5$H, this), _initializerDefineProperty(this, "textureMode", _descriptor6$u, this), 
        _initializerDefineProperty(this, "widthFromParticle", _descriptor7$p, this), _initializerDefineProperty(this, "widthRatio", _descriptor8$k, this), 
        _initializerDefineProperty(this, "colorFromParticle", _descriptor9$h, this), _initializerDefineProperty(this, "colorOverTrail", _descriptor10$g, this), 
        _initializerDefineProperty(this, "colorOvertime", _descriptor11$c, this), _initializerDefineProperty(this, "_space", _descriptor12$b, this), 
        _initializerDefineProperty(this, "_particleSystem", _descriptor13$a, this), this._minSquaredDistance = 0, 
        this._vertSize = void 0, this._trailNum = 0, this._trailLifetime = 0, this.vbOffset = 0, 
        this.ibOffset = 0, this._trailSegments = null, this._particleTrail = void 0, this._trailModel = null, 
        this._iaInfo = void 0, this._iaInfoBuffer = null, this._subMeshData = null, this._vertAttrs = void 0, 
        this._vbF32 = null, this._vbUint32 = null, this._iBuffer = null, this._needTransform = !1, 
        this._defaultMat = null, this._iaInfo = {
            drawInfos: [ {
                vertexCount: 0,
                firstVertex: 0,
                indexCount: 0,
                firstIndex: 0,
                vertexOffset: 0,
                instanceCount: 0,
                firstInstance: 0
            } ]
        }, this._vertAttrs = [ {
            name: exports.GFXAttributeName.ATTR_POSITION,
            format: exports.GFXFormat.RGB32F
        }, {
            name: exports.GFXAttributeName.ATTR_TEX_COORD,
            format: exports.GFXFormat.RGBA32F
        }, {
            name: exports.GFXAttributeName.ATTR_TEX_COORD1,
            format: exports.GFXFormat.RGB32F
        }, {
            name: exports.GFXAttributeName.ATTR_COLOR,
            format: exports.GFXFormat.RGBA8,
            isNormalized: !0
        } ], this._vertSize = 0;
        for (var _step, _iterator = _createForOfIteratorHelperLoose(this._vertAttrs); !(_step = _iterator()).done; ) {
            var a = _step.value;
            this._vertSize += GFXFormatInfos[a.format].size;
        }
        this._particleTrail = new Map;
    }
    return _createClass(TrailModule, [ {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(val) {
            val === this._enable && this._trailModel || (val && !this._trailModel && this._createModel(), 
            val && !this._enable && (this._enable = val, this._particleSystem.processor.updateTrailMaterial()), 
            this._enable = val, this._trailModel && (this._trailModel.enabled = val), val ? this.onEnable() : this.onDisable());
        }
    }, {
        key: "minParticleDistance",
        get: function get() {
            return this._minParticleDistance;
        },
        set: function set(val) {
            this._minParticleDistance = val, this._minSquaredDistance = val * val;
        }
    }, {
        key: "space",
        get: function get() {
            return this._space;
        },
        set: function set(val) {
            this._space = val, this._particleSystem && this._particleSystem.processor.updateTrailMaterial();
        }
    } ]), _createClass(TrailModule, [ {
        key: "onInit",
        value: function onInit(ps) {
            this._particleSystem = ps, this.minParticleDistance = this._minParticleDistance;
            for (var burstCount = 0, psTime = ps.startLifetime.getMax(), psRate = ps.rateOverTime.getMax(), duration = ps.duration, i = 0, len = ps.bursts.length; i < len; i++) {
                burstCount += ps.bursts[i].getMaxCount(ps) * Math.ceil(psTime / duration);
            }
            this._trailNum = Math.ceil(psTime * this.lifeTime.getMax() * 60 * (psRate * duration + burstCount)), 
            this._trailSegments = new Pool$1((function() {
                return new TrailSegment(10);
            }), Math.ceil(psRate * duration)), this._enable && (this.enable = this._enable, 
            this._updateMaterial());
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._attachToScene();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._particleTrail.clear(), this._detachFromScene();
        }
    }, {
        key: "_attachToScene",
        value: function _attachToScene() {
            this._trailModel && (this._trailModel.scene && this._detachFromScene(), this._particleSystem._getRenderScene().addModel(this._trailModel));
        }
    }, {
        key: "_detachFromScene",
        value: function _detachFromScene() {
            this._trailModel && this._trailModel.scene && this._trailModel.scene.removeModel(this._trailModel);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.destroySubMeshData(), this._trailModel && (director.root.destroyModel(this._trailModel), 
            this._trailModel = null), this._trailSegments && (this._trailSegments.clear((function(obj) {
                obj.trailElements.length = 0;
            })), this._trailSegments = null);
        }
    }, {
        key: "clear",
        value: function clear() {
            if (this.enable) {
                for (var trailIter = this._particleTrail.values(), trail = trailIter.next(); !trail.done; ) trail.value.clear(), 
                trail = trailIter.next();
                this._particleTrail.clear(), this.updateRenderData();
            }
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial() {
            if (this._particleSystem && this._trailModel) {
                var mat = this._particleSystem.getMaterialInstance(1);
                mat ? this._trailModel.setSubModelMaterial(0, mat) : this._trailModel.setSubModelMaterial(0, this._particleSystem.processor._defaultTrailMat);
            }
        }
    }, {
        key: "update",
        value: function update() {
            this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1), this.space === Space.World && this._particleSystem._simulationSpace === Space.Local ? (this._needTransform = !0, 
            this._particleSystem.node.getWorldMatrix(_temp_xform), this._particleSystem.node.getWorldRotation(_temp_quat)) : this._needTransform = !1;
        }
    }, {
        key: "animate",
        value: function animate(p, scaledDt) {
            if (this._trailSegments) {
                var trail = this._particleTrail.get(p);
                if (!trail) return trail = this._trailSegments.alloc(), void this._particleTrail.set(p, trail);
                var lastSeg = trail.getElement(trail.end - 1);
                if (this._needTransform ? Vec3.transformMat4(_temp_vec3, p.position, _temp_xform) : Vec3.copy(_temp_vec3, p.position), 
                !(lastSeg && (trail.iterateElement(this, this._updateTrailElement, p, scaledDt), 
                Vec3.squaredDistance(lastSeg.position, _temp_vec3) < this._minSquaredDistance)) && (lastSeg = trail.addElement())) {
                    Vec3.copy(lastSeg.position, _temp_vec3), lastSeg.lifetime = 0, this.widthFromParticle ? lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1) : lastSeg.width = this.widthRatio.evaluate(0, 1);
                    var trailNum = trail.count();
                    if (2 === trailNum) {
                        var lastSecondTrail = trail.getElement(trail.end - 2);
                        Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
                    } else if (trailNum > 2) {
                        var _lastSecondTrail = trail.getElement(trail.end - 2), lastThirdTrail = trail.getElement(trail.end - 3);
                        Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail.position), Vec3.subtract(_temp_vec3_1$1, lastSeg.position, _lastSecondTrail.position), 
                        Vec3.subtract(_lastSecondTrail.velocity, _temp_vec3_1$1, _temp_vec3), Vec3.equals(Vec3.ZERO, _lastSecondTrail.velocity) && Vec3.copy(_lastSecondTrail.velocity, _temp_vec3), 
                        Vec3.normalize(_lastSecondTrail.velocity, _lastSecondTrail.velocity), this._checkDirectionReverse(_lastSecondTrail, lastThirdTrail);
                    }
                    this.colorFromParticle ? lastSeg.color.set(p.color) : lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
                }
            }
        }
    }, {
        key: "removeParticle",
        value: function removeParticle(p) {
            var trail = this._particleTrail.get(p);
            trail && this._trailSegments && (trail.clear(), this._trailSegments.free(trail), 
            this._particleTrail.delete(p));
        }
    }, {
        key: "updateRenderData",
        value: function updateRenderData() {
            this.vbOffset = 0, this.ibOffset = 0;
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._particleTrail.keys()); !(_step2 = _iterator2()).done; ) {
                var p = _step2.value, trailSeg = this._particleTrail.get(p);
                if (-1 !== trailSeg.start) {
                    var indexOffset = 4 * this.vbOffset / this._vertSize, end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end, trailNum = end - trailSeg.start, textCoordSeg = 1 / trailNum, startSegEle = trailSeg.trailElements[trailSeg.start];
                    this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, 4);
                    for (var i = trailSeg.start + 1; i < end; i++) {
                        var segEle = trailSeg.trailElements[i % trailSeg.trailElements.length], j = i - trailSeg.start;
                        this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, 5);
                    }
                    if (this._needTransform ? Vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform) : Vec3.copy(_temp_trailEle.position, p.position), 
                    1 === trailNum || 2 === trailNum) {
                        var lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
                        Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position), 
                        this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x, 
                        this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y, 
                        this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z, 
                        this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x, this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y, 
                        this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z, Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position), 
                        this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
                    } else if (trailNum > 2) {
                        var _lastSecondTrail2 = trailSeg.getElement(trailSeg.end - 1), lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
                        Vec3.subtract(_temp_vec3, lastThirdTrail.position, _lastSecondTrail2.position), 
                        Vec3.subtract(_temp_vec3_1$1, _temp_trailEle.position, _lastSecondTrail2.position), 
                        Vec3.normalize(_temp_vec3, _temp_vec3), Vec3.normalize(_temp_vec3_1$1, _temp_vec3_1$1), 
                        Vec3.subtract(_lastSecondTrail2.velocity, _temp_vec3_1$1, _temp_vec3), Vec3.normalize(_lastSecondTrail2.velocity, _lastSecondTrail2.velocity), 
                        this._checkDirectionReverse(_lastSecondTrail2, lastThirdTrail), this.vbOffset -= this._vertSize / 4 * 2, 
                        this.ibOffset -= 6, this._fillVertexBuffer(_lastSecondTrail2, this.colorOverTrail.evaluate(textCoordSeg, 1), indexOffset, textCoordSeg, trailNum - 1, 5), 
                        Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, _lastSecondTrail2.position), 
                        Vec3.normalize(_temp_trailEle.velocity, _temp_trailEle.velocity), this._checkDirectionReverse(_temp_trailEle, _lastSecondTrail2);
                    }
                    this.widthFromParticle ? _temp_trailEle.width = p.size.x * this.widthRatio.evaluate(0, 1) : _temp_trailEle.width = this.widthRatio.evaluate(0, 1), 
                    _temp_trailEle.color = p.color, Vec3.equals(_temp_trailEle.velocity, Vec3.ZERO) ? this.ibOffset -= 3 : this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, 1);
                }
            }
            this.updateIA(this.ibOffset);
        }
    }, {
        key: "updateIA",
        value: function updateIA(count) {
            if (this._trailModel && this._trailModel.subModelNum > 0) {
                var subModel = this._trailModel.getSubModel(0);
                subModel.inputAssembler.vertexBuffers[0].update(this._vbF32), subModel.inputAssembler.indexBuffer.update(this._iBuffer), 
                subModel.inputAssembler.indexCount = count, this._iaInfo.drawInfos[0] = subModel.inputAssembler, 
                this._iaInfoBuffer.update(this._iaInfo);
            }
        }
    }, {
        key: "_createModel",
        value: function _createModel() {
            if (!this._trailModel) {
                var device = director.root.device, vertexBuffer = device.createBuffer({
                    usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: this._vertSize * (this._trailNum + 1) * 2,
                    stride: this._vertSize
                }), vBuffer = new ArrayBuffer(this._vertSize * (this._trailNum + 1) * 2);
                this._vbF32 = new Float32Array(vBuffer), this._vbUint32 = new Uint32Array(vBuffer), 
                vertexBuffer.update(vBuffer);
                var indexBuffer = device.createBuffer({
                    usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 6 * this._trailNum * Uint16Array.BYTES_PER_ELEMENT,
                    stride: Uint16Array.BYTES_PER_ELEMENT
                });
                this._iBuffer = new Uint16Array(6 * this._trailNum), indexBuffer.update(this._iBuffer), 
                this._iaInfoBuffer = device.createBuffer({
                    usage: exports.GFXBufferUsageBit.INDIRECT,
                    memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                    size: 56,
                    stride: 1
                }), this._iaInfo.drawInfos[0].vertexCount = 2 * (this._trailNum + 1), this._iaInfo.drawInfos[0].indexCount = 6 * this._trailNum, 
                this._iaInfoBuffer.update(this._iaInfo), this._subMeshData = new RenderingSubMesh([ vertexBuffer ], this._vertAttrs, exports.GFXPrimitiveMode.TRIANGLE_LIST), 
                this._subMeshData.indexBuffer = indexBuffer, this._subMeshData.indirectBuffer = this._iaInfoBuffer, 
                this._trailModel = director.root.createModel(Model), this._trailModel.initialize(this._particleSystem.node), 
                this._trailModel.visFlags = this._particleSystem.visibility, this._trailModel.setSubModelMesh(0, this._subMeshData), 
                this._trailModel.enabled = !0;
            }
        }
    }, {
        key: "_updateTrailElement",
        value: function _updateTrailElement(module, trailEle, p, dt) {
            return trailEle.lifetime += dt, module.colorFromParticle ? (trailEle.color.set(p.color), 
            trailEle.color.multiply(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1))) : trailEle.color.set(module.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1)), 
            module.widthFromParticle ? trailEle.width = p.size.x * module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1) : trailEle.width = module.widthRatio.evaluate(trailEle.lifetime / module._trailLifetime, 1), 
            trailEle.lifetime > module._trailLifetime;
        }
    }, {
        key: "_fillVertexBuffer",
        value: function _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
            this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
            this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = trailSeg.direction, 
            this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
            this._vbF32[this.vbOffset++] = 0, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
            this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
            _temp_color.set(trailSeg.color), _temp_color.multiply(colorModifer), this._vbUint32[this.vbOffset++] = _temp_color._val, 
            this._vbF32[this.vbOffset++] = trailSeg.position.x, this._vbF32[this.vbOffset++] = trailSeg.position.y, 
            this._vbF32[this.vbOffset++] = trailSeg.position.z, this._vbF32[this.vbOffset++] = 1 - trailSeg.direction, 
            this._vbF32[this.vbOffset++] = trailSeg.width, this._vbF32[this.vbOffset++] = xTexCoord, 
            this._vbF32[this.vbOffset++] = 1, this._vbF32[this.vbOffset++] = trailSeg.velocity.x, 
            this._vbF32[this.vbOffset++] = trailSeg.velocity.y, this._vbF32[this.vbOffset++] = trailSeg.velocity.z, 
            this._vbUint32[this.vbOffset++] = _temp_color._val, 1 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1), 
            4 & indexSet && (this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx, 
            this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1, this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2);
        }
    }, {
        key: "_checkDirectionReverse",
        value: function _checkDirectionReverse(currElement, prevElement) {
            Vec3.dot(currElement.velocity, prevElement.velocity) < DIRECTION_THRESHOLD ? currElement.direction = 1 - prevElement.direction : currElement.direction = prevElement.direction;
        }
    }, {
        key: "destroySubMeshData",
        value: function destroySubMeshData() {
            this._subMeshData && (this._subMeshData.destroy(), this._subMeshData = null);
        }
    } ]), TrailModule;
}()).prototype, "enable", [ _dec2$1j ], Object.getOwnPropertyDescriptor(_class2$1y.prototype, "enable"), _class2$1y.prototype), 
_descriptor$1n = _applyDecoratedDescriptor(_class2$1y.prototype, "_enable", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor2$1a = _applyDecoratedDescriptor(_class2$1y.prototype, "mode", [ _dec3$11 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return TrailMode.Particles;
    }
}), _descriptor3$_ = _applyDecoratedDescriptor(_class2$1y.prototype, "lifeTime", [ _dec4$X ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor4$S = _applyDecoratedDescriptor(_class2$1y.prototype, "_minParticleDistance", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _applyDecoratedDescriptor(_class2$1y.prototype, "minParticleDistance", [ _dec5$R ], Object.getOwnPropertyDescriptor(_class2$1y.prototype, "minParticleDistance"), _class2$1y.prototype), 
_applyDecoratedDescriptor(_class2$1y.prototype, "space", [ _dec6$O ], Object.getOwnPropertyDescriptor(_class2$1y.prototype, "space"), _class2$1y.prototype), 
_descriptor5$H = _applyDecoratedDescriptor(_class2$1y.prototype, "existWithParticles", [ _dec7$E ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor6$u = _applyDecoratedDescriptor(_class2$1y.prototype, "textureMode", [ _dec8$A ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return TextureMode.Stretch;
    }
}), _descriptor7$p = _applyDecoratedDescriptor(_class2$1y.prototype, "widthFromParticle", [ _dec9$r ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor8$k = _applyDecoratedDescriptor(_class2$1y.prototype, "widthRatio", [ _dec10$k ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor9$h = _applyDecoratedDescriptor(_class2$1y.prototype, "colorFromParticle", [ _dec11$j ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor10$g = _applyDecoratedDescriptor(_class2$1y.prototype, "colorOverTrail", [ _dec12$i ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange;
    }
}), _descriptor11$c = _applyDecoratedDescriptor(_class2$1y.prototype, "colorOvertime", [ _dec13$f ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange;
    }
}), _descriptor12$b = _applyDecoratedDescriptor(_class2$1y.prototype, "_space", [ _dec14$e ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.World;
    }
}), _descriptor13$a = _applyDecoratedDescriptor(_class2$1y.prototype, "_particleSystem", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$1K = _class2$1y)) || _class$1K), _world_mat = new Mat4, _world_rol = new Quat, ParticleSystemComponent = (_dec$1K = ccclass("cc.ParticleSystemComponent"), 
_dec2$1k = help("i18n:cc.ParticleSystemComponent"), _dec3$12 = menu("Components/ParticleSystem"), 
_dec4$Y = executionOrder(99), _dec5$S = property({
    displayOrder: 1,
    tooltip: "粒子系统能生成的最大粒子数量"
}), _dec6$P = property({
    type: GradientRange,
    displayOrder: 8,
    tooltip: "粒子初始颜色"
}), _dec7$F = property({
    type: Space,
    displayOrder: 9,
    tooltip: "选择缩放坐标系"
}), _dec8$B = property({
    displayOrder: 10,
    tooltip: "粒子初始大小"
}), _dec9$s = property({
    type: CurveRange,
    displayOrder: 10,
    formerlySerializedAs: "startSize",
    tooltip: "粒子初始大小"
}), _dec10$l = property({
    type: CurveRange,
    displayOrder: 10,
    tooltip: "粒子初始大小"
}), _dec11$k = property({
    type: CurveRange,
    displayOrder: 10,
    tooltip: "粒子初始大小"
}), _dec12$j = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 11,
    tooltip: "粒子初始速度"
}), _dec13$g = property({
    displayOrder: 12,
    tooltip: "粒子初始旋转角度"
}), _dec14$f = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 12,
    tooltip: "粒子初始旋转角度"
}), _dec15$b = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 12,
    tooltip: "粒子初始旋转角度"
}), _dec16$a = property({
    type: CurveRange,
    range: [ -1, 1 ],
    radian: !0,
    displayOrder: 12,
    formerlySerializedAs: "startRotation",
    tooltip: "粒子初始旋转角度"
}), _dec17$8 = property({
    type: CurveRange,
    displayOrder: 6,
    tooltip: "粒子系统开始运行后，延迟粒子发射的时间"
}), _dec18$7 = property({
    type: CurveRange,
    displayOrder: 7,
    tooltip: "粒子生命周期"
}), _dec19$7 = property({
    displayOrder: 0,
    tooltip: "粒子系统运行时间"
}), _dec20$4 = property({
    displayOrder: 2,
    tooltip: "粒子系统是否循环播放"
}), _dec21$3 = property({
    displayOrder: 3,
    tooltip: "选中之后，粒子系统会以已播放完一轮之后的状态开始播放（仅当循环播放启用时有效）"
}), _dec22$2 = property({
    type: Space,
    displayOrder: 4,
    tooltip: "控制粒子坐标计算所在的坐标系"
}), _dec23$2 = property({
    displayOrder: 5,
    tooltip: "控制整个粒子系统的更新速度"
}), _dec24$2 = property({
    displayOrder: 2,
    tooltip: "粒子系统加载后是否自动开始播放"
}), _dec25 = property({
    type: CurveRange,
    range: [ -1, 1 ],
    displayOrder: 13,
    tooltip: "粒子受重力影响的重力系数"
}), _dec26 = property({
    type: CurveRange,
    displayOrder: 14,
    tooltip: "每秒发射的粒子数"
}), _dec27 = property({
    type: CurveRange,
    displayOrder: 15,
    tooltip: "每移动单位距离发射的粒子数"
}), _dec28 = property({
    type: [ Burst ],
    displayOrder: 16,
    tooltip: "在某个时间点发射给定数量的粒子"
}), _dec29 = property({
    type: Material,
    displayName: "Materials",
    visible: !1,
    override: !0
}), _dec30 = property({
    type: ColorOvertimeModule
}), _dec31 = property({
    type: ColorOvertimeModule,
    displayOrder: 23,
    tooltip: "颜色模块"
}), _dec32 = property({
    type: ShapeModule
}), _dec33 = property({
    type: ShapeModule,
    displayOrder: 17,
    tooltip: "发射器模块"
}), _dec34 = property({
    type: SizeOvertimeModule
}), _dec35 = property({
    type: SizeOvertimeModule,
    displayOrder: 21,
    tooltip: "大小模块"
}), _dec36 = property({
    type: VelocityOvertimeModule
}), _dec37 = property({
    type: VelocityOvertimeModule,
    displayOrder: 18,
    tooltip: "速度模块"
}), _dec38 = property({
    type: ForceOvertimeModule
}), _dec39 = property({
    type: ForceOvertimeModule,
    displayOrder: 19,
    tooltip: "加速度模块"
}), _dec40 = property({
    type: LimitVelocityOvertimeModule
}), _dec41 = property({
    type: LimitVelocityOvertimeModule,
    displayOrder: 20,
    tooltip: "限速模块"
}), _dec42 = property({
    type: RotationOvertimeModule
}), _dec43 = property({
    type: RotationOvertimeModule,
    displayOrder: 22,
    tooltip: "旋转模块"
}), _dec44 = property({
    type: TextureAnimationModule
}), _dec45 = property({
    type: TextureAnimationModule,
    displayOrder: 24,
    tooltip: "贴图动画模块"
}), _dec46 = property({
    type: TrailModule
}), _dec47 = property({
    type: TrailModule,
    displayOrder: 25,
    tooltip: "拖尾模块"
}), _dec48 = property({
    type: ParticleSystemRenderer,
    displayOrder: 26,
    tooltip: "渲染模块"
}), _dec49 = property({
    displayOrder: 27,
    tooltip: "是否剔除非 enable 的模块数据"
}), _dec$1K(_class$1L = _dec2$1k(_class$1L = _dec3$12(_class$1L = _dec4$Y(_class$1L = executeInEditMode((_applyDecoratedDescriptor((_class2$1z = function(_RenderableComponent) {
    function ParticleSystemComponent() {
        var _this;
        return _classCallCheck(this, ParticleSystemComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(ParticleSystemComponent).call(this)), "startColor", _descriptor$1o, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "scaleSpace", _descriptor2$1b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startSize3D", _descriptor3$$, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startSizeX", _descriptor4$T, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startSizeY", _descriptor5$I, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startSizeZ", _descriptor6$v, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startSpeed", _descriptor7$q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startRotation3D", _descriptor8$l, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startRotationX", _descriptor9$i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startRotationY", _descriptor10$h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startRotationZ", _descriptor11$d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startDelay", _descriptor12$c, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "startLifetime", _descriptor13$b, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "duration", _descriptor14$9, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "loop", _descriptor15$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "simulationSpeed", _descriptor16$5, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "playOnAwake", _descriptor17$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "gravityModifier", _descriptor18$4, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "rateOverTime", _descriptor19$2, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "rateOverDistance", _descriptor20$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "bursts", _descriptor21$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_colorOverLifetimeModule", _descriptor22$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_shapeModule", _descriptor23$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_sizeOvertimeModule", _descriptor24$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_velocityOvertimeModule", _descriptor25$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_forceOvertimeModule", _descriptor26$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_limitVelocityOvertimeModule", _descriptor27$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_rotationOvertimeModule", _descriptor28$1, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_textureAnimationModule", _descriptor29, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_trailModule", _descriptor30, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "renderer", _descriptor31, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "enableCulling", _descriptor32, _assertThisInitialized(_this)), 
        _this._isPlaying = void 0, _this._isPaused = void 0, _this._isStopped = void 0, 
        _this._isEmitting = void 0, _this._time = void 0, _this._emitRateTimeCounter = void 0, 
        _this._emitRateDistanceCounter = void 0, _this._oldWPos = void 0, _this._curWPos = void 0, 
        _this._customData1 = void 0, _this._customData2 = void 0, _this._subEmitters = void 0, 
        _initializerDefineProperty(_this, "_prewarm", _descriptor33, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_capacity", _descriptor34, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_simulationSpace", _descriptor35, _assertThisInitialized(_this)), 
        _this.processor = null, _this.rateOverTime.constant = 10, _this.startLifetime.constant = 5, 
        _this.startSizeX.constant = 1, _this.startSpeed.constant = 5, _this._isPlaying = !1, 
        _this._isPaused = !1, _this._isStopped = !0, _this._isEmitting = !1, _this._time = 0, 
        _this._emitRateTimeCounter = 0, _this._emitRateDistanceCounter = 0, _this._oldWPos = new Vec3, 
        _this._curWPos = new Vec3, _this._customData1 = new Vec2, _this._customData2 = new Vec2, 
        _this._subEmitters = [], _this;
    }
    return _inherits(ParticleSystemComponent, RenderableComponent), _createClass(ParticleSystemComponent, [ {
        key: "capacity",
        get: function get() {
            return this._capacity;
        },
        set: function set(val) {
            this._capacity = Math.floor(val), this.processor && this.processor._model && this.processor._model.setCapacity(this._capacity);
        }
    }, {
        key: "prewarm",
        get: function get() {
            return this._prewarm;
        },
        set: function set(val) {
            !0 === val && this.loop, this._prewarm = val;
        }
    }, {
        key: "simulationSpace",
        get: function get() {
            return this._simulationSpace;
        },
        set: function set(val) {
            val !== this._simulationSpace && (this._simulationSpace = val, this.processor && (this.processor.updateMaterialParams(), 
            this.processor.updateTrailMaterial()));
        }
    }, {
        key: "sharedMaterials",
        get: function get() {
            return _get(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", this);
        },
        set: function set(val) {
            _set(_getPrototypeOf(ParticleSystemComponent.prototype), "sharedMaterials", val, this, !0);
        }
    }, {
        key: "colorOverLifetimeModule",
        get: function get() {
            return this._colorOverLifetimeModule;
        },
        set: function set(val) {
            val && (this._colorOverLifetimeModule = val);
        }
    }, {
        key: "shapeModule",
        get: function get() {
            return this._shapeModule;
        },
        set: function set(val) {
            val && (this._shapeModule = val);
        }
    }, {
        key: "sizeOvertimeModule",
        get: function get() {
            return this._sizeOvertimeModule;
        },
        set: function set(val) {
            val && (this._sizeOvertimeModule = val);
        }
    }, {
        key: "velocityOvertimeModule",
        get: function get() {
            return this._velocityOvertimeModule;
        },
        set: function set(val) {
            val && (this._velocityOvertimeModule = val);
        }
    }, {
        key: "forceOvertimeModule",
        get: function get() {
            return this._forceOvertimeModule;
        },
        set: function set(val) {
            val && (this._forceOvertimeModule = val);
        }
    }, {
        key: "limitVelocityOvertimeModule",
        get: function get() {
            return this._limitVelocityOvertimeModule;
        },
        set: function set(val) {
            val && (this._limitVelocityOvertimeModule = val);
        }
    }, {
        key: "rotationOvertimeModule",
        get: function get() {
            return this._rotationOvertimeModule;
        },
        set: function set(val) {
            val && (this._rotationOvertimeModule = val);
        }
    }, {
        key: "textureAnimationModule",
        get: function get() {
            return this._textureAnimationModule;
        },
        set: function set(val) {
            val && (this._textureAnimationModule = val);
        }
    }, {
        key: "trailModule",
        get: function get() {
            return this._trailModule;
        },
        set: function set(val) {
            val && (this._trailModule = val);
        }
    } ]), _createClass(ParticleSystemComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this.renderer.onInit(this), this._shapeModule && this._shapeModule.onInit(this), 
            this._trailModule && this._trailModule.onInit(this), this.bindModule(), this._resetPosition();
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(index, material) {
            this.processor.onMaterialModified(index, material);
        }
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(index, material) {
            this.processor.onRebuildPSO(index, material);
        }
    }, {
        key: "_collectModels",
        value: function _collectModels() {
            return this._models.length = 0, this._models.push(this.processor._model), this._trailModule && this._trailModule.enable && this._trailModule._trailModel && this._models.push(this._trailModule._trailModel), 
            this._models;
        }
    }, {
        key: "_attachToScene",
        value: function _attachToScene() {
            this.processor.attachToScene(), this._trailModule && this._trailModule.enable && this._trailModule._attachToScene();
        }
    }, {
        key: "_detachFromScene",
        value: function _detachFromScene() {
            this.processor.detachFromScene(), this._trailModule && this._trailModule.enable && this._trailModule._detachFromScene();
        }
    }, {
        key: "bindModule",
        value: function bindModule() {
            this._colorOverLifetimeModule && this._colorOverLifetimeModule.bindTarget(this.processor), 
            this._sizeOvertimeModule && this._sizeOvertimeModule.bindTarget(this.processor), 
            this._rotationOvertimeModule && this._rotationOvertimeModule.bindTarget(this.processor), 
            this._forceOvertimeModule && this._forceOvertimeModule.bindTarget(this.processor), 
            this._limitVelocityOvertimeModule && this._limitVelocityOvertimeModule.bindTarget(this.processor), 
            this._velocityOvertimeModule && this._velocityOvertimeModule.bindTarget(this.processor), 
            this._textureAnimationModule && this._textureAnimationModule.bindTarget(this.processor);
        }
    }, {
        key: "play",
        value: function play() {
            this._isPaused && (this._isPaused = !1), this._isStopped && (this._isStopped = !1), 
            this._isPlaying = !0, this._isEmitting = !0, this._resetPosition(), this._prewarm && this._prewarmSystem();
        }
    }, {
        key: "pause",
        value: function pause() {
            this._isStopped ? console.warn("pause(): particle system is already stopped.") : (this._isPlaying && (this._isPlaying = !1), 
            this._isPaused = !0);
        }
    }, {
        key: "stop",
        value: function stop() {
            (this._isPlaying || this._isPaused) && this.clear(), this._isPlaying && (this._isPlaying = !1), 
            this._isPaused && (this._isPaused = !1), this._time = 0, this._emitRateTimeCounter = 0, 
            this._emitRateDistanceCounter = 0, this._isStopped = !0;
        }
    }, {
        key: "clear",
        value: function clear() {
            this.enabledInHierarchy && (this.processor.clear(), this._trailModule && this._trailModule.clear());
        }
    }, {
        key: "getParticleCount",
        value: function getParticleCount() {
            return this.processor.getParticleCount();
        }
    }, {
        key: "setCustomData1",
        value: function setCustomData1(x, y) {
            Vec2.set(this._customData1, x, y);
        }
    }, {
        key: "setCustomData2",
        value: function setCustomData2(x, y) {
            Vec2.set(this._customData2, x, y);
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.processor.onDestroy(), this._trailModule && this._trailModule.destroy();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this.playOnAwake && this.play(), this.processor.onEnable(), this._trailModule && this._trailModule.onEnable();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.processor.onDisable(), this._trailModule && this._trailModule.onDisable();
        }
    }, {
        key: "update",
        value: function update(dt) {
            var scaledDeltaTime = dt * this.simulationSpeed;
            this._isPlaying && (this._time += scaledDeltaTime, this._emit(scaledDeltaTime), 
            0 !== this.processor.updateParticles(scaledDeltaTime) || this._isEmitting || this.stop(), 
            this.processor.updateRenderData(), this._trailModule && this._trailModule.enable && this._trailModule.updateRenderData());
        }
    }, {
        key: "_onVisibilityChange",
        value: function _onVisibilityChange(val) {
            this.processor._model && (this.processor._model.visFlags = val);
        }
    }, {
        key: "emit",
        value: function emit(count, dt) {
            var delta = this._time / this.duration;
            this._simulationSpace === Space.World && (this.node.getWorldMatrix(_world_mat), 
            this.node.getWorldRotation(_world_rol));
            for (var i = 0; i < count; ++i) {
                var particle = this.processor.getFreeParticle();
                if (null === particle) return;
                var rand = pseudoRandom(randomRangeInt(0, 2147483647));
                this._shapeModule && this._shapeModule.enable ? this._shapeModule.emit(particle) : (Vec3.set(particle.position, 0, 0, 0), 
                Vec3.copy(particle.velocity, particleEmitZAxis)), this._textureAnimationModule && this._textureAnimationModule.enable && this._textureAnimationModule.init(particle), 
                Vec3.multiplyScalar(particle.velocity, particle.velocity, this.startSpeed.evaluate(delta, rand)), 
                this._simulationSpace === Space.World && (Vec3.transformMat4(particle.position, particle.position, _world_mat), 
                Vec3.transformQuat(particle.velocity, particle.velocity, _world_rol)), Vec3.copy(particle.ultimateVelocity, particle.velocity), 
                this.startRotation3D ? Vec3.set(particle.rotation, this.startRotationX.evaluate(delta, rand), this.startRotationY.evaluate(delta, rand), this.startRotationZ.evaluate(delta, rand)) : Vec3.set(particle.rotation, 0, 0, this.startRotationZ.evaluate(delta, rand)), 
                this.startSize3D ? Vec3.set(particle.startSize, this.startSizeX.evaluate(delta, rand), this.startSizeY.evaluate(delta, rand), this.startSizeZ.evaluate(delta, rand)) : (Vec3.set(particle.startSize, this.startSizeX.evaluate(delta, rand), 1, 1), 
                particle.startSize.y = particle.startSize.x), Vec3.copy(particle.size, particle.startSize), 
                particle.startColor.set(this.startColor.evaluate(delta, rand)), particle.color.set(particle.startColor), 
                particle.startLifetime = this.startLifetime.evaluate(delta, rand) + dt, particle.remainingLifetime = particle.startLifetime, 
                particle.randomSeed = randomRangeInt(0, 233280), this.processor.setNewParticle(particle);
            }
        }
    }, {
        key: "_prewarmSystem",
        value: function _prewarmSystem() {
            this.startDelay.mode = Mode$1.Constant, this.startDelay.constant = 0;
            for (var cnt = this.duration / 1, i = 0; i < cnt; ++i) this._time += 1, this._emit(1), 
            this.processor.updateParticles(1);
        }
    }, {
        key: "_emit",
        value: function _emit(dt) {
            var startDelay = this.startDelay.evaluate(0, 1);
            if (this._time > startDelay) {
                if (this._time > this.duration + startDelay && !this.loop) return void (this._isEmitting = !1);
                if (this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt, 
                this._emitRateTimeCounter > 1 && this._isEmitting) {
                    var emitNum = Math.floor(this._emitRateTimeCounter);
                    this._emitRateTimeCounter -= emitNum, this.emit(emitNum, dt);
                }
                this.node.getWorldPosition(this._curWPos);
                var distance = Vec3.distance(this._curWPos, this._oldWPos);
                if (Vec3.copy(this._oldWPos, this._curWPos), this._emitRateDistanceCounter += distance * this.rateOverDistance.evaluate(this._time / this.duration, 1), 
                this._emitRateDistanceCounter > 1 && this._isEmitting) {
                    var _emitNum = Math.floor(this._emitRateDistanceCounter);
                    this._emitRateDistanceCounter -= _emitNum, this.emit(_emitNum, dt);
                }
                for (var _step, _iterator = _createForOfIteratorHelperLoose(this.bursts); !(_step = _iterator()).done; ) {
                    _step.value.update(this, dt);
                }
            }
        }
    }, {
        key: "_resetPosition",
        value: function _resetPosition() {
            this.node.getWorldPosition(this._oldWPos), Vec3.copy(this._curWPos, this._oldWPos);
        }
    }, {
        key: "addSubEmitter",
        value: function addSubEmitter(subEmitter) {
            this._subEmitters.push(subEmitter);
        }
    }, {
        key: "removeSubEmitter",
        value: function removeSubEmitter(idx) {
            this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
        }
    }, {
        key: "addBurst",
        value: function addBurst(burst) {
            this.bursts.push(burst);
        }
    }, {
        key: "removeBurst",
        value: function removeBurst(idx) {
            this.bursts.splice(this.bursts.indexOf(idx), 1);
        }
    }, {
        key: "_onBeforeSerialize",
        value: function _onBeforeSerialize(props) {
            var _this2 = this;
            return this.enableCulling ? props.filter((function(p) {
                return !PARTICLE_MODULE_PROPERTY.includes(p) || _this2[p] && _this2[p].enable;
            })) : props;
        }
    }, {
        key: "isPlaying",
        get: function get() {
            return this._isPlaying;
        }
    }, {
        key: "isPaused",
        get: function get() {
            return this._isPaused;
        }
    }, {
        key: "isStopped",
        get: function get() {
            return this._isStopped;
        }
    }, {
        key: "isEmitting",
        get: function get() {
            return this._isEmitting;
        }
    }, {
        key: "time",
        get: function get() {
            return this._time;
        }
    } ]), ParticleSystemComponent;
}()).prototype, "capacity", [ _dec5$S ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "capacity"), _class2$1z.prototype), 
_descriptor$1o = _applyDecoratedDescriptor(_class2$1z.prototype, "startColor", [ _dec6$P ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new GradientRange;
    }
}), _descriptor2$1b = _applyDecoratedDescriptor(_class2$1z.prototype, "scaleSpace", [ _dec7$F ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _descriptor3$$ = _applyDecoratedDescriptor(_class2$1z.prototype, "startSize3D", [ _dec8$B ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor4$T = _applyDecoratedDescriptor(_class2$1z.prototype, "startSizeX", [ _dec9$s ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor5$I = _applyDecoratedDescriptor(_class2$1z.prototype, "startSizeY", [ _dec10$l ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor6$v = _applyDecoratedDescriptor(_class2$1z.prototype, "startSizeZ", [ _dec11$k ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor7$q = _applyDecoratedDescriptor(_class2$1z.prototype, "startSpeed", [ _dec12$j ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor8$l = _applyDecoratedDescriptor(_class2$1z.prototype, "startRotation3D", [ _dec13$g ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor9$i = _applyDecoratedDescriptor(_class2$1z.prototype, "startRotationX", [ _dec14$f ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor10$h = _applyDecoratedDescriptor(_class2$1z.prototype, "startRotationY", [ _dec15$b ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor11$d = _applyDecoratedDescriptor(_class2$1z.prototype, "startRotationZ", [ _dec16$a ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor12$c = _applyDecoratedDescriptor(_class2$1z.prototype, "startDelay", [ _dec17$8 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor13$b = _applyDecoratedDescriptor(_class2$1z.prototype, "startLifetime", [ _dec18$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor14$9 = _applyDecoratedDescriptor(_class2$1z.prototype, "duration", [ _dec19$7 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 5;
    }
}), _descriptor15$5 = _applyDecoratedDescriptor(_class2$1z.prototype, "loop", [ _dec20$4 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "prewarm", [ _dec21$3 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "prewarm"), _class2$1z.prototype), 
_applyDecoratedDescriptor(_class2$1z.prototype, "simulationSpace", [ _dec22$2 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "simulationSpace"), _class2$1z.prototype), 
_descriptor16$5 = _applyDecoratedDescriptor(_class2$1z.prototype, "simulationSpeed", [ _dec23$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor17$4 = _applyDecoratedDescriptor(_class2$1z.prototype, "playOnAwake", [ _dec24$2 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor18$4 = _applyDecoratedDescriptor(_class2$1z.prototype, "gravityModifier", [ _dec25 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor19$2 = _applyDecoratedDescriptor(_class2$1z.prototype, "rateOverTime", [ _dec26 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor20$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "rateOverDistance", [ _dec27 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new CurveRange;
    }
}), _descriptor21$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "bursts", [ _dec28 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Array;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "sharedMaterials", [ _dec29 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "sharedMaterials"), _class2$1z.prototype), 
_descriptor22$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "_colorOverLifetimeModule", [ _dec30 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "colorOverLifetimeModule", [ _dec31 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "colorOverLifetimeModule"), _class2$1z.prototype), 
_descriptor23$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "_shapeModule", [ _dec32 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "shapeModule", [ _dec33 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "shapeModule"), _class2$1z.prototype), 
_descriptor24$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "_sizeOvertimeModule", [ _dec34 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "sizeOvertimeModule", [ _dec35 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "sizeOvertimeModule"), _class2$1z.prototype), 
_descriptor25$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "_velocityOvertimeModule", [ _dec36 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "velocityOvertimeModule", [ _dec37 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "velocityOvertimeModule"), _class2$1z.prototype), 
_descriptor26$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "_forceOvertimeModule", [ _dec38 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "forceOvertimeModule", [ _dec39 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "forceOvertimeModule"), _class2$1z.prototype), 
_descriptor27$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "_limitVelocityOvertimeModule", [ _dec40 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "limitVelocityOvertimeModule", [ _dec41 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "limitVelocityOvertimeModule"), _class2$1z.prototype), 
_descriptor28$1 = _applyDecoratedDescriptor(_class2$1z.prototype, "_rotationOvertimeModule", [ _dec42 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "rotationOvertimeModule", [ _dec43 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "rotationOvertimeModule"), _class2$1z.prototype), 
_descriptor29 = _applyDecoratedDescriptor(_class2$1z.prototype, "_textureAnimationModule", [ _dec44 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "textureAnimationModule", [ _dec45 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "textureAnimationModule"), _class2$1z.prototype), 
_descriptor30 = _applyDecoratedDescriptor(_class2$1z.prototype, "_trailModule", [ _dec46 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _applyDecoratedDescriptor(_class2$1z.prototype, "trailModule", [ _dec47 ], Object.getOwnPropertyDescriptor(_class2$1z.prototype, "trailModule"), _class2$1z.prototype), 
_descriptor31 = _applyDecoratedDescriptor(_class2$1z.prototype, "renderer", [ _dec48 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new ParticleSystemRenderer;
    }
}), _descriptor32 = _applyDecoratedDescriptor(_class2$1z.prototype, "enableCulling", [ _dec49 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor33 = _applyDecoratedDescriptor(_class2$1z.prototype, "_prewarm", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor34 = _applyDecoratedDescriptor(_class2$1z.prototype, "_capacity", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 100;
    }
}), _descriptor35 = _applyDecoratedDescriptor(_class2$1z.prototype, "_simulationSpace", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return Space.Local;
    }
}), _class$1L = _class2$1z)) || _class$1L) || _class$1L) || _class$1L) || _class$1L) || _class$1L), ParticleUtils = function() {
    function ParticleUtils() {
        _classCallCheck(this, ParticleUtils);
    }
    return _createClass(ParticleUtils, null, [ {
        key: "instantiate",
        value: function instantiate$1(prefab) {
            return this.registeredSceneEvent || (director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.onSceneUnload, this), 
            this.registeredSceneEvent = !0), this.particleSystemPool.has(prefab._uuid) || this.particleSystemPool.set(prefab._uuid, new Pool$1((function() {
                return instantiate(prefab) || new Node$1;
            }), 1)), this.particleSystemPool.get(prefab._uuid).alloc();
        }
    }, {
        key: "destroy",
        value: function destroy(prefab) {
            this.particleSystemPool.has(prefab._prefab.asset._uuid) && (this.stop(prefab), this.particleSystemPool.get(prefab._prefab.asset._uuid).free(prefab));
        }
    }, {
        key: "play",
        value: function play(rootNode) {
            for (var _step, _iterator = _createForOfIteratorHelperLoose(rootNode.getComponentsInChildren(ParticleSystemComponent)); !(_step = _iterator()).done; ) {
                _step.value.play();
            }
        }
    }, {
        key: "stop",
        value: function stop(rootNode) {
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(rootNode.getComponentsInChildren(ParticleSystemComponent)); !(_step2 = _iterator2()).done; ) {
                _step2.value.stop();
            }
        }
    }, {
        key: "onSceneUnload",
        value: function onSceneUnload() {
            this.particleSystemPool.forEach((function(value) {
                value.clear((function(prefab) {
                    prefab.destroy();
                }));
            })), this.particleSystemPool.clear();
        }
    } ]), ParticleUtils;
}();

ParticleUtils.particleSystemPool = new Map, ParticleUtils.registeredSceneEvent = !1, 
exports.removeProperty(Burst.prototype, "Burst.prototype", [ {
    name: "minCount"
}, {
    name: "maxCount"
} ]), cc.ParticleSystemComponent = ParticleSystemComponent, cc.BillboardComponent = BillboardComponent, 
cc.LineComponent = LineComponent, cc.ParticleUtils = ParticleUtils;

var BuiltinObject = function() {
    function BuiltinObject() {
        _classCallCheck(this, BuiltinObject), this.collisionFilterGroup = 1, this.collisionFilterMask = 1;
    }
    return _createClass(BuiltinObject, [ {
        key: "getGroup",
        value: function getGroup() {
            return this.collisionFilterGroup;
        }
    }, {
        key: "setGroup",
        value: function setGroup(v) {
            this.collisionFilterGroup = v;
        }
    }, {
        key: "addGroup",
        value: function addGroup(v) {
            this.collisionFilterGroup |= v;
        }
    }, {
        key: "removeGroup",
        value: function removeGroup(v) {
            this.collisionFilterGroup &= ~v;
        }
    }, {
        key: "getMask",
        value: function getMask() {
            return this.collisionFilterMask;
        }
    }, {
        key: "setMask",
        value: function setMask(v) {
            this.collisionFilterMask = v;
        }
    }, {
        key: "addMask",
        value: function addMask(v) {
            this.collisionFilterMask |= v;
        }
    }, {
        key: "removeMask",
        value: function removeMask(v) {
            this.collisionFilterMask &= ~v;
        }
    } ]), BuiltinObject;
}(), m4_0 = new Mat4, v3_0 = new Vec3, v3_1$a = new Vec3, quat_0 = new Quat, BuiltinSharedBody = function(_BuiltinObject) {
    function BuiltinSharedBody(node, world) {
        var _this;
        return _classCallCheck(this, BuiltinSharedBody), (_this = _possibleConstructorReturn(this, _getPrototypeOf(BuiltinSharedBody).call(this)))._id = void 0, 
        _this.index = -1, _this.ref = 0, _this.node = void 0, _this.world = void 0, _this.shapes = [], 
        _this._id = BuiltinSharedBody.idCounter++, _this.node = node, _this.world = world, 
        _this;
    }
    return _inherits(BuiltinSharedBody, BuiltinObject), _createClass(BuiltinSharedBody, [ {
        key: "id",
        get: function get() {
            return this._id;
        }
    }, {
        key: "enabled",
        set: function set(v) {
            v ? this.index < 0 && (this.index = this.world.bodies.length, this.world.addSharedBody(this), 
            this.syncInitial()) : this.index >= 0 && 0 == this.shapes.length && (this.index = -1, 
            this.world.removeSharedBody(this));
        }
    }, {
        key: "reference",
        set: function set(v) {
            v ? this.ref++ : this.ref--, 0 == this.ref && this.destroy();
        }
    } ], [ {
        key: "getSharedBody",
        value: function getSharedBody(node, wrappedWorld) {
            var key = node.uuid;
            if (BuiltinSharedBody.sharedBodesMap.has(key)) return BuiltinSharedBody.sharedBodesMap.get(key);
            var newSB = new BuiltinSharedBody(node, wrappedWorld);
            return BuiltinSharedBody.sharedBodesMap.set(node.uuid, newSB), newSB;
        }
    } ]), _createClass(BuiltinSharedBody, [ {
        key: "intersects",
        value: function intersects(body) {
            for (var i = 0; i < this.shapes.length; i++) for (var shapeA = this.shapes[i], j = 0; j < body.shapes.length; j++) {
                var shapeB = body.shapes[j];
                intersect.resolve(shapeA.worldShape, shapeB.worldShape) && (this.world.shapeArr.push(shapeA), 
                this.world.shapeArr.push(shapeB));
            }
        }
    }, {
        key: "addShape",
        value: function addShape(shape) {
            this.shapes.indexOf(shape) < 0 && this.shapes.push(shape);
        }
    }, {
        key: "removeShape",
        value: function removeShape(shape) {
            var i = this.shapes.indexOf(shape);
            i >= 0 && this.shapes.splice(i, 1);
        }
    }, {
        key: "syncSceneToPhysics",
        value: function syncSceneToPhysics() {
            if (this.node.hasChangedFlags) {
                this.node.getWorldMatrix(m4_0), v3_0.set(this.node.worldPosition), quat_0.set(this.node.worldRotation), 
                v3_1$a.set(this.node.worldScale);
                for (var i = 0; i < this.shapes.length; i++) this.shapes[i].transform(m4_0, v3_0, quat_0, v3_1$a);
            }
        }
    }, {
        key: "syncInitial",
        value: function syncInitial() {
            this.node.getWorldMatrix(m4_0), v3_0.set(this.node.worldPosition), quat_0.set(this.node.worldRotation), 
            v3_1$a.set(this.node.worldScale);
            for (var i = 0; i < this.shapes.length; i++) this.shapes[i].transform(m4_0, v3_0, quat_0, v3_1$a);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            BuiltinSharedBody.sharedBodesMap.delete(this.node.uuid), this.node = null, this.world = null, 
            this.shapes = null;
        }
    } ]), BuiltinSharedBody;
}();

BuiltinSharedBody.sharedBodesMap = new Map, BuiltinSharedBody.idCounter = 0;

var _class$1M, _class2$1A, _descriptor$1p, _descriptor2$1c, _class3$D, _temp$1E, ArrayCollisionMatrix = function() {
    function ArrayCollisionMatrix() {
        _classCallCheck(this, ArrayCollisionMatrix), this.matrix = [];
    }
    return _createClass(ArrayCollisionMatrix, [ {
        key: "get",
        value: function get(i, j) {
            if (j > i) {
                var temp = j;
                j = i, i = temp;
            }
            return this.matrix[(i * (i + 1) >> 1) + j - 1];
        }
    }, {
        key: "set",
        value: function set(i, j, value) {
            if (j > i) {
                var temp = j;
                j = i, i = temp;
            }
            this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
        }
    }, {
        key: "reset",
        value: function reset() {
            this.matrix.length = 0;
        }
    }, {
        key: "setNumObjects",
        value: function setNumObjects(n) {
            this.matrix.length = n * (n - 1) >> 1;
        }
    } ]), ArrayCollisionMatrix;
}(), hitPoint = new Vec3, TriggerEventObject = {
    type: "onTriggerEnter",
    selfCollider: null,
    otherCollider: null
}, BuiltInWorld = function() {
    function BuiltInWorld() {
        _classCallCheck(this, BuiltInWorld), this.shapeArr = [], this.bodies = [], this._shapeArrPrev = [], 
        this._collisionMatrix = new ArrayCollisionMatrix, this._collisionMatrixPrev = new ArrayCollisionMatrix;
    }
    return _createClass(BuiltInWorld, [ {
        key: "setGravity",
        value: function setGravity(v) {}
    }, {
        key: "setAllowSleep",
        value: function setAllowSleep(v) {}
    }, {
        key: "setDefaultMaterial",
        value: function setDefaultMaterial(v) {}
    }, {
        key: "step",
        value: function step(deltaTime) {
            var tmp = this._shapeArrPrev;
            this._shapeArrPrev = this.shapeArr, this.shapeArr = tmp, this.shapeArr.length = 0;
            for (var i = 0; i < this.bodies.length; i++) for (var bodyA = this.bodies[i], j = i + 1; j < this.bodies.length; j++) {
                var bodyB = this.bodies[j];
                0 != (bodyA.collisionFilterGroup & bodyB.collisionFilterMask) && 0 != (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) && bodyA.intersects(bodyB);
            }
        }
    }, {
        key: "syncSceneToPhysics",
        value: function syncSceneToPhysics() {
            for (var i = 0; i < this.bodies.length; i++) this.bodies[i].syncSceneToPhysics();
        }
    }, {
        key: "emitEvents",
        value: function emitEvents() {
            this.emitTriggerEvent();
        }
    }, {
        key: "raycastClosest",
        value: function raycastClosest(worldRay, options, out) {
            for (var tmp_d = 1 / 0, max_d = options.maxDistance, mask = options.mask, i = 0; i < this.bodies.length; i++) {
                var body = this.bodies[i];
                if (body.collisionFilterGroup & mask) for (var _i = 0; _i < body.shapes.length; _i++) {
                    var shape = body.shapes[_i], distance = intersect.resolve(worldRay, shape.worldShape);
                    0 == distance || distance > max_d || tmp_d > distance && (tmp_d = distance, Vec3.normalize(hitPoint, worldRay.d), 
                    Vec3.scaleAndAdd(hitPoint, worldRay.o, hitPoint, distance), out._assign(hitPoint, distance, shape.collider, Vec3.ZERO));
                }
            }
            return !(tmp_d == 1 / 0);
        }
    }, {
        key: "raycast",
        value: function raycast(worldRay, options, pool, results) {
            for (var max_d = options.maxDistance, mask = options.mask, i = 0; i < this.bodies.length; i++) {
                var body = this.bodies[i];
                if (body.collisionFilterGroup & mask) for (var _i2 = 0; _i2 < body.shapes.length; _i2++) {
                    var shape = body.shapes[_i2], distance = intersect.resolve(worldRay, shape.worldShape);
                    if (!(0 == distance || distance > max_d)) {
                        var r = pool.add();
                        worldRay.computeHit(hitPoint, distance), r._assign(hitPoint, distance, shape.collider, Vec3.ZERO), 
                        results.push(r);
                    }
                }
            }
            return results.length > 0;
        }
    }, {
        key: "getSharedBody",
        value: function getSharedBody(node) {
            return BuiltinSharedBody.getSharedBody(node, this);
        }
    }, {
        key: "addSharedBody",
        value: function addSharedBody(body) {
            this.bodies.indexOf(body) < 0 && this.bodies.push(body);
        }
    }, {
        key: "removeSharedBody",
        value: function removeSharedBody(body) {
            var index = this.bodies.indexOf(body);
            index >= 0 && this.bodies.splice(index, 1);
        }
    }, {
        key: "emitTriggerEvent",
        value: function emitTriggerEvent() {
            for (var shapeA, shapeB, i = 0; i < this.shapeArr.length; i += 2) shapeA = this.shapeArr[i], 
            shapeB = this.shapeArr[i + 1], TriggerEventObject.selfCollider = shapeA.collider, 
            TriggerEventObject.otherCollider = shapeB.collider, this._collisionMatrix.set(shapeA.id, shapeB.id, !0), 
            this._collisionMatrixPrev.get(shapeA.id, shapeB.id) ? TriggerEventObject.type = "onTriggerStay" : TriggerEventObject.type = "onTriggerEnter", 
            shapeA.collider && shapeA.collider.emit(TriggerEventObject.type, TriggerEventObject), 
            TriggerEventObject.selfCollider = shapeB.collider, TriggerEventObject.otherCollider = shapeA.collider, 
            shapeB.collider && shapeB.collider.emit(TriggerEventObject.type, TriggerEventObject);
            for (var _i3 = 0; _i3 < this._shapeArrPrev.length; _i3 += 2) shapeA = this._shapeArrPrev[_i3], 
            shapeB = this._shapeArrPrev[_i3 + 1], this._collisionMatrixPrev.get(shapeA.id, shapeB.id) && (this._collisionMatrix.get(shapeA.id, shapeB.id) || (TriggerEventObject.type = "onTriggerExit", 
            TriggerEventObject.selfCollider = shapeA.collider, TriggerEventObject.otherCollider = shapeB.collider, 
            shapeA.collider && shapeA.collider.emit(TriggerEventObject.type, TriggerEventObject), 
            TriggerEventObject.selfCollider = shapeB.collider, TriggerEventObject.otherCollider = shapeA.collider, 
            shapeB.collider && shapeB.collider.emit(TriggerEventObject.type, TriggerEventObject), 
            this._collisionMatrix.set(shapeA.id, shapeB.id, !1)));
            var temp = this._collisionMatrixPrev.matrix;
            this._collisionMatrixPrev.matrix = this._collisionMatrix.matrix, this._collisionMatrix.matrix = temp, 
            this._collisionMatrix.reset();
        }
    }, {
        key: "impl",
        get: function get() {
            return this;
        }
    } ]), BuiltInWorld;
}();

function checkPhysicsModule(obj) {
    return null == obj && (errorID(9600), !0);
}

var _dec$1M, _dec2$1l, _dec3$13, _dec4$Z, _dec5$T, _class$1N, _class2$1B, _descriptor$1q, _descriptor2$1d, _descriptor3$10, PhysicMaterial = ccclass("cc.PhysicMaterial")((_temp$1E = _class3$D = function(_Asset) {
    function PhysicMaterial() {
        var _this;
        return _classCallCheck(this, PhysicMaterial), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicMaterial).call(this)), "_friction", _descriptor$1p, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_restitution", _descriptor2$1c, _assertThisInitialized(_this)), 
        PhysicMaterial.allMaterials.push(_assertThisInitialized(_this)), "" == _this._uuid && (_this._uuid = "pm_" + PhysicMaterial._idCounter++), 
        _this;
    }
    return _inherits(PhysicMaterial, Asset), _createClass(PhysicMaterial, [ {
        key: "friction",
        get: function get() {
            return this._friction;
        },
        set: function set(value) {
            equals(this._friction, value) || (this._friction = value, this.emit("physics_material_update"));
        }
    }, {
        key: "restitution",
        get: function get() {
            return this._restitution;
        },
        set: function set(value) {
            equals(this._restitution, value) || (this._restitution = value, this.emit("physics_material_update"));
        }
    } ]), _createClass(PhysicMaterial, [ {
        key: "clone",
        value: function clone() {
            var c = new PhysicMaterial;
            return c._friction = this._friction, c._restitution = this._restitution, c;
        }
    }, {
        key: "destroy",
        value: function destroy() {
            if (_get(_getPrototypeOf(PhysicMaterial.prototype), "destroy", this).call(this)) {
                var idx = PhysicMaterial.allMaterials.indexOf(this);
                return idx >= 0 && PhysicMaterial.allMaterials.splice(idx, 1), !0;
            }
            return !1;
        }
    } ]), PhysicMaterial;
}(), _class3$D.allMaterials = [], _class3$D._idCounter = 0, _applyDecoratedDescriptor((_class2$1A = _temp$1E).prototype, "friction", [ property ], Object.getOwnPropertyDescriptor(_class2$1A.prototype, "friction"), _class2$1A.prototype), 
_applyDecoratedDescriptor(_class2$1A.prototype, "restitution", [ property ], Object.getOwnPropertyDescriptor(_class2$1A.prototype, "restitution"), _class2$1A.prototype), 
_descriptor$1p = _applyDecoratedDescriptor(_class2$1A.prototype, "_friction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor2$1c = _applyDecoratedDescriptor(_class2$1A.prototype, "_restitution", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _class$1M = _class2$1A)) || _class$1M, PhysicsRayResult = function() {
    function PhysicsRayResult() {
        _classCallCheck(this, PhysicsRayResult), this._hitPoint = new Vec3, this._hitNormal = new Vec3, 
        this._distance = 0, this._collider = null;
    }
    return _createClass(PhysicsRayResult, [ {
        key: "_assign",
        value: function _assign(hitPoint, distance, collider, hitNormal) {
            Vec3.copy(this._hitPoint, hitPoint), Vec3.copy(this._hitNormal, hitNormal), this._distance = distance, 
            this._collider = collider;
        }
    }, {
        key: "clone",
        value: function clone() {
            var c = new PhysicsRayResult;
            return Vec3.copy(c._hitPoint, this._hitPoint), Vec3.copy(c._hitNormal, this._hitNormal), 
            c._distance = this._distance, c._collider = this._collider, c;
        }
    }, {
        key: "hitPoint",
        get: function get() {
            return this._hitPoint;
        }
    }, {
        key: "distance",
        get: function get() {
            return this._distance;
        }
    }, {
        key: "collider",
        get: function get() {
            return this._collider;
        }
    }, {
        key: "hitNormal",
        get: function get() {
            return this._hitNormal;
        }
    } ]), PhysicsRayResult;
}(), PhysicsSystem = function(_System) {
    function PhysicsSystem() {
        var _this;
        return _classCallCheck(this, PhysicsSystem), (_this = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsSystem).call(this))).physicsWorld = void 0, 
        _this.raycastClosestResult = new PhysicsRayResult, _this.raycastResults = [], _this._enable = !0, 
        _this._allowSleep = !0, _this._gravity = new Vec3(0, -10, 0), _this._maxSubStep = 1, 
        _this._deltaTime = 1 / 60, _this._useFixedTime = !0, _this._timeSinceLastUpdate = 0, 
        _this._timeReset = !0, _this.raycastOptions = {
            group: -1,
            mask: -1,
            queryTrigger: !0,
            maxDistance: 1e7
        }, _this.raycastResultPool = new RecyclePool((function() {
            return new PhysicsRayResult;
        }), 1), _this.physicsWorld = function createPhysicsWorld() {
            return checkPhysicsModule(PhysicsWorld) ? null : new PhysicsWorld;
        }(), _this.gravity = _this._gravity, _this.allowSleep = _this._allowSleep, _this._material = new PhysicMaterial, 
        _this._material.friction = .5, _this._material.restitution = .1, _this._material.on("physics_material_update", _this._updateMaterial, _assertThisInitialized(_this)), 
        _this.physicsWorld.setDefaultMaterial(_this._material), _this;
    }
    return _inherits(PhysicsSystem, System), _createClass(PhysicsSystem, [ {
        key: "enable",
        get: function get() {
            return this._enable;
        },
        set: function set(value) {
            value || (this._timeReset = !0), this._enable = value;
        }
    }, {
        key: "allowSleep",
        get: function get() {
            return this._allowSleep;
        },
        set: function set(v) {
            this._allowSleep = v;
        }
    }, {
        key: "maxSubStep",
        get: function get() {
            return this._maxSubStep;
        },
        set: function set(value) {
            this._maxSubStep = value;
        }
    }, {
        key: "deltaTime",
        get: function get() {
            return this._deltaTime;
        },
        set: function set(value) {
            this._deltaTime = value;
        }
    }, {
        key: "useFixedTime",
        get: function get() {
            return this._useFixedTime;
        },
        set: function set(value) {
            this._useFixedTime = value;
        }
    }, {
        key: "gravity",
        get: function get() {
            return this._gravity;
        },
        set: function set(gravity) {
            this._gravity.set(gravity);
        }
    }, {
        key: "defaultMaterial",
        get: function get() {
            return this._material;
        }
    } ], [ {
        key: "instance",
        get: function get() {
            return checkPhysicsModule(PhysicsSystem._instance) ? null : PhysicsSystem._instance;
        }
    } ]), _createClass(PhysicsSystem, [ {
        key: "postUpdate",
        value: function postUpdate(deltaTime) {
            this._enable ? (this._timeReset ? (this._timeSinceLastUpdate = 0, this._timeReset = !1) : this._timeSinceLastUpdate = deltaTime, 
            this.physicsWorld.emitEvents(), director.emit(Director.EVENT_BEFORE_PHYSICS), this.physicsWorld.syncSceneToPhysics(), 
            this._useFixedTime ? this.physicsWorld.step(this._deltaTime) : this.physicsWorld.step(this._deltaTime, this._timeSinceLastUpdate, this._maxSubStep), 
            this.physicsWorld.syncSceneToPhysics(), director.emit(Director.EVENT_AFTER_PHYSICS)) : this.physicsWorld.syncSceneToPhysics();
        }
    }, {
        key: "raycast",
        value: function raycast(worldRay) {
            var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4294967295, maxDistance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e7, queryTrigger = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
            return this.raycastResultPool.reset(), this.raycastResults.length = 0, this.raycastOptions.mask = mask, 
            this.raycastOptions.maxDistance = maxDistance, this.raycastOptions.queryTrigger = queryTrigger, 
            this.physicsWorld.raycast(worldRay, this.raycastOptions, this.raycastResultPool, this.raycastResults);
        }
    }, {
        key: "raycastClosest",
        value: function raycastClosest(worldRay) {
            var mask = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4294967295, maxDistance = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e7, queryTrigger = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
            return this.raycastOptions.mask = mask, this.raycastOptions.maxDistance = maxDistance, 
            this.raycastOptions.queryTrigger = queryTrigger, this.physicsWorld.raycastClosest(worldRay, this.raycastOptions, this.raycastClosestResult);
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial() {}
    } ]), PhysicsSystem;
}();

PhysicsSystem.ID = "PHYSICS", PhysicsSystem._instance = void 0, director.on(Director.EVENT_INIT, (function() {
    var sys = new cc.PhysicsSystem;
    cc.PhysicsSystem._instance = sys, director.registerSystem(PhysicsSystem.ID, sys, 0);
}));

var _dec$1N, _dec2$1m, _dec3$14, _dec4$_, _dec5$U, _class$1O, _class2$1C, _descriptor$1r, _dec$1O, _dec2$1n, _dec3$15, _dec4$$, _dec5$V, _class$1P, _class2$1D, _descriptor$1s, ERigidBodyType, EAxisDirection, _dec$1P, _dec2$1o, _dec3$16, _dec4$10, _dec5$W, _dec6$Q, _dec7$G, _class$1Q, _class2$1E, _descriptor$1t, _descriptor2$1e, _descriptor3$11, ColliderComponent = (_dec$1M = ccclass("cc.ColliderComponent"), 
_dec2$1l = property({
    type: PhysicMaterial,
    displayName: "Material",
    displayOrder: -1,
    tooltip: "源材质"
}), _dec3$13 = property({
    displayOrder: 0,
    tooltip: "是否与其它碰撞器产生碰撞，并产生物理行为"
}), _dec4$Z = property({
    type: Vec3,
    displayOrder: 1,
    tooltip: "形状的中心点（与所在 Node 中心点的相对位置）"
}), _dec5$T = property({
    type: PhysicMaterial
}), _dec$1M((_applyDecoratedDescriptor((_class2$1B = function(_Eventify) {
    function ColliderComponent() {
        var _this;
        return _classCallCheck(this, ColliderComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ColliderComponent).call(this)))._isSharedMaterial = !0, 
        _initializerDefineProperty(_this, "_material", _descriptor$1q, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isTrigger", _descriptor2$1d, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_center", _descriptor3$10, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(ColliderComponent, Eventify(Component)), _createClass(ColliderComponent, [ {
        key: "sharedMaterial",
        get: function get() {
            return this._material;
        },
        set: function set(value) {
            this.material = value;
        }
    }, {
        key: "material",
        get: function get() {
            return this._material;
        },
        set: function set(value) {
            this._material = value;
        }
    }, {
        key: "isTrigger",
        get: function get() {
            return this._isTrigger;
        },
        set: function set(value) {
            this._isTrigger = value, this._shape.setAsTrigger(this._isTrigger);
        }
    }, {
        key: "center",
        get: function get() {
            return this._center;
        },
        set: function set(value) {
            Vec3.copy(this._center, value), this._shape.setCenter(this._center);
        }
    }, {
        key: "attachedRigidBody",
        get: function get() {
            return this.shape.attachedRigidBody;
        }
    }, {
        key: "shape",
        get: function get() {
            return this._shape;
        }
    }, {
        key: "_assertOnload",
        get: function get() {
            var r = 0 == this._isOnLoadCalled;
            return r && error("Physics Error: Please make sure that the node has been added to the scene"), 
            !r;
        }
    } ]), _createClass(ColliderComponent, [ {
        key: "on",
        value: function on(type, callback, target, once) {
            _get(_getPrototypeOf(ColliderComponent.prototype), "on", this).call(this, type, callback, target, once);
        }
    }, {
        key: "off",
        value: function off(type, callback, target) {
            _get(_getPrototypeOf(ColliderComponent.prototype), "off", this).call(this, type, callback, target);
        }
    }, {
        key: "once",
        value: function once(type, callback, target) {
            _get(_getPrototypeOf(ColliderComponent.prototype), "once", this).call(this, type, callback, target);
        }
    }, {
        key: "setGroup",
        value: function setGroup(v) {
            this._shape.setGroup(v);
        }
    }, {
        key: "getGroup",
        value: function getGroup() {
            return this._shape.getGroup();
        }
    }, {
        key: "addGroup",
        value: function addGroup(v) {
            this._shape.addGroup(v);
        }
    }, {
        key: "removeGroup",
        value: function removeGroup(v) {
            this._shape.removeGroup(v);
        }
    }, {
        key: "getMask",
        value: function getMask() {
            return this._shape.getMask();
        }
    }, {
        key: "setMask",
        value: function setMask(v) {
            this._shape.setMask(v);
        }
    }, {
        key: "addMask",
        value: function addMask(v) {
            this._shape.addMask(v);
        }
    }, {
        key: "removeMask",
        value: function removeMask(v) {
            this._shape.removeMask(v);
        }
    }, {
        key: "__preload",
        value: function __preload() {
            this._shape.initialize(this);
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            this._shape.onLoad();
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._shape.onEnable();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._shape.onDisable();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._material && this._material.off("physics_material_update", this._updateMaterial, this), 
            this._shape.onDestroy();
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial() {
            this._shape.setMaterial(this._material);
        }
    } ]), ColliderComponent;
}()).prototype, "sharedMaterial", [ _dec2$1l ], Object.getOwnPropertyDescriptor(_class2$1B.prototype, "sharedMaterial"), _class2$1B.prototype), 
_applyDecoratedDescriptor(_class2$1B.prototype, "isTrigger", [ _dec3$13 ], Object.getOwnPropertyDescriptor(_class2$1B.prototype, "isTrigger"), _class2$1B.prototype), 
_applyDecoratedDescriptor(_class2$1B.prototype, "center", [ _dec4$Z ], Object.getOwnPropertyDescriptor(_class2$1B.prototype, "center"), _class2$1B.prototype), 
_descriptor$1q = _applyDecoratedDescriptor(_class2$1B.prototype, "_material", [ _dec5$T ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$1d = _applyDecoratedDescriptor(_class2$1B.prototype, "_isTrigger", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$10 = _applyDecoratedDescriptor(_class2$1B.prototype, "_center", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3;
    }
}), _class$1N = _class2$1B)) || _class$1N), BoxColliderComponent = (_dec$1N = ccclass("cc.BoxColliderComponent"), 
_dec2$1m = help("i18n:cc.BoxColliderComponent"), _dec3$14 = executionOrder(98), 
_dec4$_ = menu("Physics/BoxCollider"), _dec5$U = property({
    type: Vec3,
    tooltip: "盒的大小，即长、宽、高"
}), _dec$1N(_class$1O = _dec2$1m(_class$1O = _dec3$14(_class$1O = _dec4$_(_class$1O = executeInEditMode((_applyDecoratedDescriptor((_class2$1C = function(_ColliderComponent) {
    function BoxColliderComponent() {
        var _this;
        return _classCallCheck(this, BoxColliderComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(BoxColliderComponent).call(this)), "_size", _descriptor$1r, _assertThisInitialized(_this)), 
        _this._shape = function createBoxShape(size) {
            return checkPhysicsModule(BoxShape) ? null : new BoxShape(size);
        }(_this._size), _this;
    }
    return _inherits(BoxColliderComponent, ColliderComponent), _createClass(BoxColliderComponent, [ {
        key: "size",
        get: function get() {
            return this._size;
        },
        set: function set(value) {
            Vec3.copy(this._size, value), this.shape.setSize(this._size);
        }
    }, {
        key: "shape",
        get: function get() {
            return this._shape;
        }
    } ]), BoxColliderComponent;
}()).prototype, "size", [ _dec5$U ], Object.getOwnPropertyDescriptor(_class2$1C.prototype, "size"), _class2$1C.prototype), 
_descriptor$1r = _applyDecoratedDescriptor(_class2$1C.prototype, "_size", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _class$1O = _class2$1C)) || _class$1O) || _class$1O) || _class$1O) || _class$1O) || _class$1O), SphereColliderComponent = (_dec$1O = ccclass("cc.SphereColliderComponent"), 
_dec2$1n = help("i18n:cc.SphereColliderComponent"), _dec3$15 = executionOrder(98), 
_dec4$$ = menu("Physics/SphereCollider"), _dec5$V = property({
    tooltip: "球的半径"
}), _dec$1O(_class$1P = _dec2$1n(_class$1P = _dec3$15(_class$1P = _dec4$$(_class$1P = executeInEditMode((_applyDecoratedDescriptor((_class2$1D = function(_ColliderComponent) {
    function SphereColliderComponent() {
        var _this;
        return _classCallCheck(this, SphereColliderComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(SphereColliderComponent).call(this)), "_radius", _descriptor$1s, _assertThisInitialized(_this)), 
        _this._shape = function createSphereShape(radius) {
            return checkPhysicsModule(SphereShape) ? null : new SphereShape(radius);
        }(_this._radius), _this;
    }
    return _inherits(SphereColliderComponent, ColliderComponent), _createClass(SphereColliderComponent, [ {
        key: "radius",
        get: function get() {
            return this._radius;
        },
        set: function set(value) {
            this._radius = value, this.shape.setRadius(this._radius);
        }
    }, {
        key: "shape",
        get: function get() {
            return this._shape;
        }
    } ]), SphereColliderComponent;
}()).prototype, "radius", [ _dec5$V ], Object.getOwnPropertyDescriptor(_class2$1D.prototype, "radius"), _class2$1D.prototype), 
_descriptor$1s = _applyDecoratedDescriptor(_class2$1D.prototype, "_radius", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _class$1P = _class2$1D)) || _class$1P) || _class$1P) || _class$1P) || _class$1P) || _class$1P);

(ERigidBodyType = exports.ERigidBodyType || (exports.ERigidBodyType = {}))[ERigidBodyType.DYNAMIC = 1] = "DYNAMIC", 
ERigidBodyType[ERigidBodyType.STATIC = 2] = "STATIC", ERigidBodyType[ERigidBodyType.KINEMATIC = 4] = "KINEMATIC", 
(EAxisDirection = exports.EAxisDirection || (exports.EAxisDirection = {}))[EAxisDirection.X_AXIS = 0] = "X_AXIS", 
EAxisDirection[EAxisDirection.Y_AXIS = 1] = "Y_AXIS", EAxisDirection[EAxisDirection.Z_AXIS = 2] = "Z_AXIS", 
Enum(exports.EAxisDirection);

var _dec$1Q, _dec2$1p, _dec3$17, _dec4$11, _dec5$X, _dec6$R, _dec7$H, _class$1R, _class2$1F, _descriptor$1u, _descriptor2$1f, _descriptor3$12, _dec$1R, _dec2$1q, _dec3$18, _dec4$12, _dec5$Y, _class$1S, _class2$1G, _descriptor$1v, _dec$1S, _dec2$1r, _dec3$19, _dec4$13, _dec5$Z, _dec6$S, _dec7$I, _dec8$C, _dec9$t, _dec10$m, _dec11$l, _dec12$k, _class$1T, _class2$1H, _descriptor$1w, _descriptor2$1g, _descriptor3$13, _descriptor4$U, _descriptor5$J, _descriptor6$w, _descriptor7$r, _descriptor8$m, _dec$1T, _dec2$1s, _dec3$1a, _dec4$14, _dec5$_, _dec6$T, _dec7$J, _dec8$D, _dec9$u, _class$1U, _class2$1I, _descriptor$1x, _descriptor2$1h, _descriptor3$14, _descriptor4$V, CapsuleColliderComponent = (_dec$1P = ccclass("cc.CapsuleColliderComponent"), 
_dec2$1o = help("i18n:cc.CapsuleColliderComponent"), _dec3$16 = executionOrder(98), 
_dec4$10 = menu("Physics/CapsuleCollider"), _dec5$W = property({
    tooltip: "本地坐标系下胶囊体上的球的半径"
}), _dec6$Q = property({
    tooltip: "本地坐标系下胶囊体上的圆柱体的高度"
}), _dec7$G = property({
    type: exports.EAxisDirection,
    tooltip: "本地坐标系下胶囊体的朝向"
}), _dec$1P(_class$1Q = _dec2$1o(_class$1Q = _dec3$16(_class$1Q = _dec4$10(_class$1Q = executeInEditMode((_applyDecoratedDescriptor((_class2$1E = function(_ColliderComponent) {
    function CapsuleColliderComponent() {
        var _this;
        return _classCallCheck(this, CapsuleColliderComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CapsuleColliderComponent).call(this)), "_radius", _descriptor$1t, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_cylinderHeight", _descriptor2$1e, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor3$11, _assertThisInitialized(_this)), 
        _this._shape = function createCapsuleShape() {
            var radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, height = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, dir = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            return checkPhysicsModule(CapsuleShape) ? null : new CapsuleShape(radius, height, dir);
        }(), _this;
    }
    return _inherits(CapsuleColliderComponent, ColliderComponent), _createClass(CapsuleColliderComponent, [ {
        key: "radius",
        get: function get() {
            return this._radius;
        },
        set: function set(value) {
            value < 0 && (value = 0), this._radius = value, this.shape.setRadius(value);
        }
    }, {
        key: "cylinderHeight",
        get: function get() {
            return this._cylinderHeight;
        },
        set: function set(value) {
            value < 0 && (value = 0), this._cylinderHeight = value, this.shape.setCylinderHeight(value);
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            (value = Math.floor(value)) < exports.EAxisDirection.X_AXIS || value > exports.EAxisDirection.Z_AXIS || (this._direction = value, 
            this.shape.setDirection(value));
        }
    }, {
        key: "height",
        get: function get() {
            return 2 * this._radius + this._cylinderHeight;
        },
        set: function set(value) {
            var ch = value - 2 * this._radius;
            ch < 0 && (ch = 0), this.cylinderHeight = ch;
        }
    }, {
        key: "worldHeight",
        get: function get() {
            return 2 * this._radius * this._getRadiusScale() + this._cylinderHeight * this._getHeightScale();
        }
    }, {
        key: "shape",
        get: function get() {
            return this._shape;
        }
    } ]), _createClass(CapsuleColliderComponent, [ {
        key: "_getRadiusScale",
        value: function _getRadiusScale() {
            if (null == this.node) return 1;
            var ws = this.node.worldScale;
            return this._direction == exports.EAxisDirection.Y_AXIS ? Math.abs(absMax(ws.x, ws.z)) : this._direction == exports.EAxisDirection.X_AXIS ? Math.abs(absMax(ws.y, ws.z)) : Math.abs(absMax(ws.x, ws.y));
        }
    }, {
        key: "_getHeightScale",
        value: function _getHeightScale() {
            if (null == this.node) return 1;
            var ws = this.node.worldScale;
            return this._direction == exports.EAxisDirection.Y_AXIS ? Math.abs(ws.y) : this._direction == exports.EAxisDirection.X_AXIS ? Math.abs(ws.x) : Math.abs(ws.z);
        }
    } ]), CapsuleColliderComponent;
}()).prototype, "radius", [ _dec5$W ], Object.getOwnPropertyDescriptor(_class2$1E.prototype, "radius"), _class2$1E.prototype), 
_applyDecoratedDescriptor(_class2$1E.prototype, "cylinderHeight", [ _dec6$Q ], Object.getOwnPropertyDescriptor(_class2$1E.prototype, "cylinderHeight"), _class2$1E.prototype), 
_applyDecoratedDescriptor(_class2$1E.prototype, "direction", [ _dec7$G ], Object.getOwnPropertyDescriptor(_class2$1E.prototype, "direction"), _class2$1E.prototype), 
_descriptor$1t = _applyDecoratedDescriptor(_class2$1E.prototype, "_radius", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .5;
    }
}), _descriptor2$1e = _applyDecoratedDescriptor(_class2$1E.prototype, "_cylinderHeight", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor3$11 = _applyDecoratedDescriptor(_class2$1E.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.EAxisDirection.Y_AXIS;
    }
}), _class$1Q = _class2$1E)) || _class$1Q) || _class$1Q) || _class$1Q) || _class$1Q) || _class$1Q), CylinderColliderComponent = (_dec$1Q = ccclass("cc.CylinderColliderComponent"), 
_dec2$1p = help("i18n:cc.CylinderColliderComponent"), _dec3$17 = executionOrder(98), 
_dec4$11 = menu("Physics/CylinderCollider(beta)"), _dec5$X = property({
    tooltip: "圆柱体上圆面的半径"
}), _dec6$R = property({
    tooltip: "圆柱体在相应轴向的高度"
}), _dec7$H = property({
    type: exports.EAxisDirection
}), _dec$1Q(_class$1R = _dec2$1p(_class$1R = _dec3$17(_class$1R = _dec4$11(_class$1R = executeInEditMode((_applyDecoratedDescriptor((_class2$1F = function(_ColliderComponent) {
    function CylinderColliderComponent() {
        var _this;
        return _classCallCheck(this, CylinderColliderComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(CylinderColliderComponent).call(this)), "_radius", _descriptor$1u, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_height", _descriptor2$1f, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_direction", _descriptor3$12, _assertThisInitialized(_this)), 
        _this._shape = function createCylinderShape() {
            warnID(9612);
            var func = function func() {};
            return {
                setRadius: func,
                setHeight: func,
                setDirection: func,
                setMaterial: func,
                setIsTrigger: func,
                setCenter: func,
                initialize: func,
                onLoad: func,
                onEnable: func,
                onDisable: func,
                onDestroy: func
            };
        }(), _this;
    }
    return _inherits(CylinderColliderComponent, ColliderComponent), _createClass(CylinderColliderComponent, [ {
        key: "radius",
        get: function get() {
            return this._radius;
        },
        set: function set(value) {
            this._radius != value && (value < 0 && (value = 0), this._radius = value, this.shape.setRadius(value));
        }
    }, {
        key: "height",
        get: function get() {
            return this._height;
        },
        set: function set(value) {
            this._height != value && (value < 0 && (value = 0), this._height = value, this.shape.setHeight(value));
        }
    }, {
        key: "direction",
        get: function get() {
            return this._direction;
        },
        set: function set(value) {
            this._direction != value && (value < exports.EAxisDirection.X_AXIS || value > exports.EAxisDirection.Z_AXIS || (this._direction = value, 
            this.shape.setDirection(value)));
        }
    }, {
        key: "shape",
        get: function get() {
            return this._shape;
        }
    } ]), CylinderColliderComponent;
}()).prototype, "radius", [ _dec5$X ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "radius"), _class2$1F.prototype), 
_applyDecoratedDescriptor(_class2$1F.prototype, "height", [ _dec6$R ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "height"), _class2$1F.prototype), 
_applyDecoratedDescriptor(_class2$1F.prototype, "direction", [ _dec7$H ], Object.getOwnPropertyDescriptor(_class2$1F.prototype, "direction"), _class2$1F.prototype), 
_descriptor$1u = _applyDecoratedDescriptor(_class2$1F.prototype, "_radius", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .5;
    }
}), _descriptor2$1f = _applyDecoratedDescriptor(_class2$1F.prototype, "_height", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 2;
    }
}), _descriptor3$12 = _applyDecoratedDescriptor(_class2$1F.prototype, "_direction", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return exports.EAxisDirection.Y_AXIS;
    }
}), _class$1R = _class2$1F)) || _class$1R) || _class$1R) || _class$1R) || _class$1R) || _class$1R), MeshColliderComponent = (_dec$1R = ccclass("cc.MeshColliderComponent"), 
_dec2$1q = help("i18n:cc.MeshColliderComponent"), _dec3$18 = executionOrder(98), 
_dec4$12 = menu("Physics/MeshCollider"), _dec5$Y = property({
    type: Mesh
}), _dec$1R(_class$1S = _dec2$1q(_class$1S = _dec3$18(_class$1S = _dec4$12(_class$1S = executeInEditMode((_applyDecoratedDescriptor((_class2$1G = function(_ColliderComponent) {
    function MeshColliderComponent() {
        var _this;
        return _classCallCheck(this, MeshColliderComponent), _initializerDefineProperty(_this = _possibleConstructorReturn(this, _getPrototypeOf(MeshColliderComponent).call(this)), "_mesh", _descriptor$1v, _assertThisInitialized(_this)), 
        _this._shape = function createTrimeshShape() {
            warnID(9611);
            var func = function func() {};
            return {
                setMesh: func,
                setMaterial: func,
                setIsTrigger: func,
                setCenter: func,
                initialize: func,
                onLoad: func,
                onEnable: func,
                onDisable: func,
                onDestroy: func
            };
        }(), _this;
    }
    return _inherits(MeshColliderComponent, ColliderComponent), _createClass(MeshColliderComponent, [ {
        key: "mesh",
        get: function get() {
            return this._mesh;
        },
        set: function set(value) {
            this._mesh = value, this.shape.setMesh(this._mesh);
        }
    }, {
        key: "shape",
        get: function get() {
            return this._shape;
        }
    } ]), MeshColliderComponent;
}()).prototype, "mesh", [ _dec5$Y ], Object.getOwnPropertyDescriptor(_class2$1G.prototype, "mesh"), _class2$1G.prototype), 
_descriptor$1v = _applyDecoratedDescriptor(_class2$1G.prototype, "_mesh", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _class$1S = _class2$1G)) || _class$1S) || _class$1S) || _class$1S) || _class$1S) || _class$1S), RigidBodyComponent = (_dec$1S = ccclass("cc.RigidBodyComponent"), 
_dec2$1r = help("i18n:cc.RigidBodyComponent"), _dec3$19 = executionOrder(99), _dec4$13 = menu("Physics/RigidBody"), 
_dec5$Z = property({
    displayOrder: 0,
    tooltip: "刚体的质量"
}), _dec6$S = property({
    displayOrder: 1,
    tooltip: "线性阻尼"
}), _dec7$I = property({
    displayOrder: 2,
    tooltip: "旋转阻尼"
}), _dec8$C = property({
    displayOrder: 3,
    tooltip: "刚体是否由物理系统控制运动"
}), _dec9$t = property({
    displayOrder: 4,
    tooltip: "刚体是否使用重力"
}), _dec10$m = property({
    displayOrder: 5,
    tooltip: "刚体是否固定旋转"
}), _dec11$l = property({
    displayOrder: 6,
    tooltip: "线性速度的因子，可以用来控制每个轴方向上的速度的缩放"
}), _dec12$k = property({
    displayOrder: 7,
    tooltip: "旋转速度的因子，可以用来控制每个轴方向上的旋转速度的缩放"
}), _dec$1S(_class$1T = _dec2$1r(_class$1T = _dec3$19(_class$1T = _dec4$13(_class$1T = executeInEditMode(_class$1T = disallowMultiple((_applyDecoratedDescriptor((_class2$1H = function(_Component) {
    function RigidBodyComponent() {
        var _this;
        return _classCallCheck(this, RigidBodyComponent), (_this = _possibleConstructorReturn(this, _getPrototypeOf(RigidBodyComponent).call(this)))._allowSleep = !0, 
        _initializerDefineProperty(_this, "_mass", _descriptor$1w, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_linearDamping", _descriptor2$1g, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_angularDamping", _descriptor3$13, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_fixedRotation", _descriptor4$U, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_isKinematic", _descriptor5$J, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_useGravity", _descriptor6$w, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_linearFactor", _descriptor7$r, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_angularFactor", _descriptor8$m, _assertThisInitialized(_this)), 
        _this;
    }
    return _inherits(RigidBodyComponent, Component), _createClass(RigidBodyComponent, [ {
        key: "allowSleep",
        get: function get() {
            return this._allowSleep;
        },
        set: function set(v) {
            this._allowSleep = v;
        }
    }, {
        key: "mass",
        get: function get() {
            return this._mass;
        },
        set: function set(value) {
            this._mass = value;
        }
    }, {
        key: "linearDamping",
        get: function get() {
            return this._linearDamping;
        },
        set: function set(value) {
            this._linearDamping = value;
        }
    }, {
        key: "angularDamping",
        get: function get() {
            return this._angularDamping;
        },
        set: function set(value) {
            this._angularDamping = value;
        }
    }, {
        key: "isKinematic",
        get: function get() {
            return this._isKinematic;
        },
        set: function set(value) {
            this._isKinematic = value;
        }
    }, {
        key: "useGravity",
        get: function get() {
            return this._useGravity;
        },
        set: function set(value) {
            this._useGravity = value;
        }
    }, {
        key: "fixedRotation",
        get: function get() {
            return this._fixedRotation;
        },
        set: function set(value) {
            this._fixedRotation = value;
        }
    }, {
        key: "linearFactor",
        get: function get() {
            return this._linearFactor;
        },
        set: function set(value) {
            Vec3.copy(this._linearFactor, value);
        }
    }, {
        key: "angularFactor",
        get: function get() {
            return this._angularFactor;
        },
        set: function set(value) {
            Vec3.copy(this._angularFactor, value);
        }
    }, {
        key: "isAwake",
        get: function get() {
            return !1;
        }
    }, {
        key: "isSleepy",
        get: function get() {
            return !1;
        }
    }, {
        key: "isSleeping",
        get: function get() {
            return !1;
        }
    }, {
        key: "body",
        get: function get() {
            return this._body;
        }
    }, {
        key: "_assertOnload",
        get: function get() {
            var r = 0 == this._isOnLoadCalled;
            return r && error("[Physics]: Please make sure that the node has been added to the scene"), 
            !r;
        }
    } ]), _createClass(RigidBodyComponent, [ {
        key: "__preload",
        value: function __preload() {}
    }, {
        key: "onEnable",
        value: function onEnable() {}
    }, {
        key: "onDisable",
        value: function onDisable() {}
    }, {
        key: "onDestroy",
        value: function onDestroy() {}
    }, {
        key: "applyForce",
        value: function applyForce(force, relativePoint) {}
    }, {
        key: "applyLocalForce",
        value: function applyLocalForce(force, localPoint) {}
    }, {
        key: "applyImpulse",
        value: function applyImpulse(impulse, relativePoint) {}
    }, {
        key: "applyLocalImpulse",
        value: function applyLocalImpulse(impulse, localPoint) {}
    }, {
        key: "applyTorque",
        value: function applyTorque(torque) {}
    }, {
        key: "applyLocalTorque",
        value: function applyLocalTorque(torque) {}
    }, {
        key: "wakeUp",
        value: function wakeUp() {}
    }, {
        key: "sleep",
        value: function sleep() {}
    }, {
        key: "getLinearVelocity",
        value: function getLinearVelocity(out) {}
    }, {
        key: "setLinearVelocity",
        value: function setLinearVelocity(value) {}
    }, {
        key: "getAngularVelocity",
        value: function getAngularVelocity(out) {}
    }, {
        key: "setAngularVelocity",
        value: function setAngularVelocity(value) {}
    }, {
        key: "setGroup",
        value: function setGroup(v) {}
    }, {
        key: "getGroup",
        value: function getGroup() {
            return 0;
        }
    }, {
        key: "addGroup",
        value: function addGroup(v) {}
    }, {
        key: "removeGroup",
        value: function removeGroup(v) {}
    }, {
        key: "getMask",
        value: function getMask() {
            return 0;
        }
    }, {
        key: "setMask",
        value: function setMask(v) {}
    }, {
        key: "addMask",
        value: function addMask(v) {}
    }, {
        key: "removeMask",
        value: function removeMask(v) {}
    } ]), RigidBodyComponent;
}()).prototype, "mass", [ _dec5$Z ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "mass"), _class2$1H.prototype), 
_applyDecoratedDescriptor(_class2$1H.prototype, "linearDamping", [ _dec6$S ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "linearDamping"), _class2$1H.prototype), 
_applyDecoratedDescriptor(_class2$1H.prototype, "angularDamping", [ _dec7$I ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "angularDamping"), _class2$1H.prototype), 
_applyDecoratedDescriptor(_class2$1H.prototype, "isKinematic", [ _dec8$C ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "isKinematic"), _class2$1H.prototype), 
_applyDecoratedDescriptor(_class2$1H.prototype, "useGravity", [ _dec9$t ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "useGravity"), _class2$1H.prototype), 
_applyDecoratedDescriptor(_class2$1H.prototype, "fixedRotation", [ _dec10$m ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "fixedRotation"), _class2$1H.prototype), 
_applyDecoratedDescriptor(_class2$1H.prototype, "linearFactor", [ _dec11$l ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "linearFactor"), _class2$1H.prototype), 
_applyDecoratedDescriptor(_class2$1H.prototype, "angularFactor", [ _dec12$k ], Object.getOwnPropertyDescriptor(_class2$1H.prototype, "angularFactor"), _class2$1H.prototype), 
_descriptor$1w = _applyDecoratedDescriptor(_class2$1H.prototype, "_mass", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor2$1g = _applyDecoratedDescriptor(_class2$1H.prototype, "_linearDamping", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor3$13 = _applyDecoratedDescriptor(_class2$1H.prototype, "_angularDamping", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return .1;
    }
}), _descriptor4$U = _applyDecoratedDescriptor(_class2$1H.prototype, "_fixedRotation", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor5$J = _applyDecoratedDescriptor(_class2$1H.prototype, "_isKinematic", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor6$w = _applyDecoratedDescriptor(_class2$1H.prototype, "_useGravity", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor7$r = _applyDecoratedDescriptor(_class2$1H.prototype, "_linearFactor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _descriptor8$m = _applyDecoratedDescriptor(_class2$1H.prototype, "_angularFactor", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3(1, 1, 1);
    }
}), _class$1T = _class2$1H)) || _class$1T) || _class$1T) || _class$1T) || _class$1T) || _class$1T) || _class$1T), ConstantForce = (_dec$1T = ccclass("cc.ConstantForce"), 
_dec2$1s = help("i18n:cc.ConstantForce"), _dec3$1a = executionOrder(98), _dec4$14 = requireComponent(RigidBodyComponent), 
_dec5$_ = menu("Physics/ConstantForce"), _dec6$T = property({
    displayOrder: 0,
    tooltip: "世界坐标系下的力"
}), _dec7$J = property({
    displayOrder: 1,
    tooltip: "本地坐标系下的力"
}), _dec8$D = property({
    displayOrder: 2,
    tooltip: "世界坐标系下的扭转力"
}), _dec9$u = property({
    displayOrder: 3,
    tooltip: "本地坐标系下的扭转力"
}), _dec$1T(_class$1U = _dec2$1s(_class$1U = _dec3$1a(_class$1U = _dec4$14(_class$1U = _dec5$_(_class$1U = disallowMultiple(_class$1U = executeInEditMode((_descriptor$1x = _applyDecoratedDescriptor((_class2$1I = function(_Component) {
    function ConstantForce() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, ConstantForce);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ConstantForce)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._rigidBody = null, 
        _initializerDefineProperty(_this, "_force", _descriptor$1x, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_localForce", _descriptor2$1h, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_torque", _descriptor3$14, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_localTorque", _descriptor4$V, _assertThisInitialized(_this)), 
        _this._mask = 0, _this;
    }
    return _inherits(ConstantForce, Component), _createClass(ConstantForce, [ {
        key: "onLoad",
        value: function onLoad() {}
    }, {
        key: "lateUpdate",
        value: function lateUpdate(dt) {}
    }, {
        key: "_maskUpdate",
        value: function _maskUpdate(t, m) {
            t.strictEquals(Vec3.ZERO) ? this._mask &= ~m : this._mask |= m;
        }
    }, {
        key: "force",
        get: function get() {
            return this._force;
        },
        set: function set(value) {
            Vec3.copy(this._force, value), this._maskUpdate(this._force, 1);
        }
    }, {
        key: "localForce",
        get: function get() {
            return this._localForce;
        },
        set: function set(value) {
            Vec3.copy(this._localForce, value), this._maskUpdate(this.localForce, 2);
        }
    }, {
        key: "torque",
        get: function get() {
            return this._torque;
        },
        set: function set(value) {
            Vec3.copy(this._torque, value), this._maskUpdate(this._torque, 4);
        }
    }, {
        key: "localTorque",
        get: function get() {
            return this._localTorque;
        },
        set: function set(value) {
            Vec3.copy(this._localTorque, value), this._maskUpdate(this._localTorque, 8);
        }
    } ]), ConstantForce;
}()).prototype, "_force", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3;
    }
}), _descriptor2$1h = _applyDecoratedDescriptor(_class2$1I.prototype, "_localForce", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3;
    }
}), _descriptor3$14 = _applyDecoratedDescriptor(_class2$1I.prototype, "_torque", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3;
    }
}), _descriptor4$V = _applyDecoratedDescriptor(_class2$1I.prototype, "_localTorque", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return new Vec3;
    }
}), _applyDecoratedDescriptor(_class2$1I.prototype, "force", [ _dec6$T ], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "force"), _class2$1I.prototype), 
_applyDecoratedDescriptor(_class2$1I.prototype, "localForce", [ _dec7$J ], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "localForce"), _class2$1I.prototype), 
_applyDecoratedDescriptor(_class2$1I.prototype, "torque", [ _dec8$D ], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "torque"), _class2$1I.prototype), 
_applyDecoratedDescriptor(_class2$1I.prototype, "localTorque", [ _dec9$u ], Object.getOwnPropertyDescriptor(_class2$1I.prototype, "localTorque"), _class2$1I.prototype), 
_class$1U = _class2$1I)) || _class$1U) || _class$1U) || _class$1U) || _class$1U) || _class$1U) || _class$1U) || _class$1U);

exports.replaceProperty(PhysicsSystem, "PhysicsSystem", [ {
    name: "ins",
    newName: "instance"
} ]), exports.replaceProperty(ColliderComponent.prototype, "ColliderComponent.prototype", [ {
    name: "attachedRigidbody",
    newName: "attachedRigidBody"
} ]), exports.replaceProperty(BoxColliderComponent.prototype, "BoxColliderComponent.prototype", [ {
    name: "boxShape",
    newName: "shape"
} ]), exports.replaceProperty(SphereColliderComponent.prototype, "SphereColliderComponent.prototype", [ {
    name: "sphereShape",
    newName: "shape"
} ]), exports.replaceProperty(CapsuleColliderComponent.prototype, "CapsuleColliderComponent.prototype", [ {
    name: "capsuleShape",
    newName: "shape"
} ]), exports.replaceProperty(RigidBodyComponent.prototype, "RigidBodyComponent.prototype", [ {
    name: "rigidBody",
    newName: "body"
} ]), cc.PhysicsSystem = PhysicsSystem, cc.ColliderComponent = ColliderComponent, 
cc.BoxColliderComponent = BoxColliderComponent, cc.SphereColliderComponent = SphereColliderComponent, 
cc.RigidBodyComponent = RigidBodyComponent, cc.PhysicMaterial = PhysicMaterial, 
cc.PhysicsRayResult = PhysicsRayResult, cc.ConstantForce = ConstantForce;

var BuiltinShape = function() {
    function BuiltinShape() {
        _classCallCheck(this, BuiltinShape), this.id = BuiltinShape.idCounter++;
    }
    return _createClass(BuiltinShape, [ {
        key: "setMaterial",
        value: function setMaterial(v) {}
    }, {
        key: "setAsTrigger",
        value: function setAsTrigger(v) {}
    }, {
        key: "setCenter",
        value: function setCenter(v) {
            Vec3.copy(this._localShape.center, v);
        }
    }, {
        key: "initialize",
        value: function initialize(comp) {
            this._collider = comp, this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._collider.node), 
            this._sharedBody.reference = !0;
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            this.setCenter(this._collider.center);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            this._sharedBody.addShape(this), this._sharedBody.enabled = !0;
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this._sharedBody.removeShape(this), this._sharedBody.enabled = !1;
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this._sharedBody.reference = !1, this._collider = null, this._localShape = null, 
            this._worldShape = null;
        }
    }, {
        key: "transform",
        value: function transform(m, pos, rot, scale) {
            this._localShape.transform(m, pos, rot, scale, this._worldShape);
        }
    }, {
        key: "getGroup",
        value: function getGroup() {
            return this._sharedBody.getGroup();
        }
    }, {
        key: "setGroup",
        value: function setGroup(v) {
            this._sharedBody.setGroup(v);
        }
    }, {
        key: "addGroup",
        value: function addGroup(v) {
            this._sharedBody.addGroup(v);
        }
    }, {
        key: "removeGroup",
        value: function removeGroup(v) {
            this._sharedBody.removeGroup(v);
        }
    }, {
        key: "getMask",
        value: function getMask() {
            return this._sharedBody.getMask();
        }
    }, {
        key: "setMask",
        value: function setMask(v) {
            this._sharedBody.setMask(v);
        }
    }, {
        key: "addMask",
        value: function addMask(v) {
            this._sharedBody.addMask(v);
        }
    }, {
        key: "removeMask",
        value: function removeMask(v) {
            this._sharedBody.removeMask(v);
        }
    }, {
        key: "attachedRigidBody",
        get: function get() {
            return null;
        }
    }, {
        key: "localShape",
        get: function get() {
            return this._localShape;
        }
    }, {
        key: "worldShape",
        get: function get() {
            return this._worldShape;
        }
    }, {
        key: "impl",
        get: function get() {
            return this._worldShape;
        }
    }, {
        key: "sharedBody",
        get: function get() {
            return this._sharedBody;
        }
    }, {
        key: "collider",
        get: function get() {
            return this._collider;
        }
    } ]), BuiltinShape;
}();

BuiltinShape.idCounter = 0;

var BuiltinBoxShape = function(_BuiltinShape) {
    function BuiltinBoxShape(size) {
        var _this;
        return _classCallCheck(this, BuiltinBoxShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(BuiltinBoxShape).call(this)))._localShape = new obb, 
        _this._worldShape = new obb, Vec3.multiplyScalar(_this.localObb.halfExtents, size, .5), 
        Vec3.copy(_this.worldObb.halfExtents, _this.localObb.halfExtents), _this;
    }
    return _inherits(BuiltinBoxShape, BuiltinShape), _createClass(BuiltinBoxShape, [ {
        key: "localObb",
        get: function get() {
            return this._localShape;
        }
    }, {
        key: "worldObb",
        get: function get() {
            return this._worldShape;
        }
    }, {
        key: "collider",
        get: function get() {
            return this._collider;
        }
    } ]), _createClass(BuiltinBoxShape, [ {
        key: "setSize",
        value: function setSize(size) {
            Vec3.multiplyScalar(this.localObb.halfExtents, size, .5), Vec3.multiply(this.worldObb.halfExtents, this.localObb.halfExtents, this.collider.node.worldScale);
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(BuiltinBoxShape.prototype), "onLoad", this).call(this), this.setSize(this.collider.size);
        }
    } ]), BuiltinBoxShape;
}();

var _dec$1U, _dec2$1t, _dec3$1b, _dec4$15, _dec5$$, _dec6$U, _dec7$K, _dec8$E, _class$1V, _class2$1J, _descriptor$1y, _descriptor2$1i, _descriptor3$15, _descriptor4$W, BuiltinSphereShape = function(_BuiltinShape) {
    function BuiltinSphereShape(radius) {
        var _this;
        return _classCallCheck(this, BuiltinSphereShape), (_this = _possibleConstructorReturn(this, _getPrototypeOf(BuiltinSphereShape).call(this)))._localShape = new sphere(0, 0, 0, radius), 
        _this._worldShape = new sphere(0, 0, 0, radius), _this;
    }
    return _inherits(BuiltinSphereShape, BuiltinShape), _createClass(BuiltinSphereShape, [ {
        key: "setRadius",
        value: function setRadius(radius) {
            this.localSphere.radius = radius;
            var s = function maxComponent$1(v) {
                return Math.max(v.x, Math.max(v.y, v.z));
            }(this.collider.node.worldScale);
            this.worldSphere.radius = this.localSphere.radius * s;
        }
    }, {
        key: "localSphere",
        get: function get() {
            return this._localShape;
        }
    }, {
        key: "worldSphere",
        get: function get() {
            return this._worldShape;
        }
    }, {
        key: "collider",
        get: function get() {
            return this._collider;
        }
    } ]), _createClass(BuiltinSphereShape, [ {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(BuiltinSphereShape.prototype), "onLoad", this).call(this), 
            this.setRadius(this.collider.radius);
        }
    } ]), BuiltinSphereShape;
}(), BuiltinCapsuleShape = function(_BuiltinShape) {
    function BuiltinCapsuleShape() {
        var _this, radius = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, height = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, direction = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : exports.EAxisDirection.Y_AXIS;
        _classCallCheck(this, BuiltinCapsuleShape);
        var halfHeight = (height - 2 * radius) / 2, h = halfHeight < 0 ? 0 : halfHeight;
        return (_this = _possibleConstructorReturn(this, _getPrototypeOf(BuiltinCapsuleShape).call(this)))._localShape = new capsule(radius, h, direction), 
        _this._worldShape = new capsule(radius, h, direction), _this;
    }
    return _inherits(BuiltinCapsuleShape, BuiltinShape), _createClass(BuiltinCapsuleShape, [ {
        key: "localCapsule",
        get: function get() {
            return this._localShape;
        }
    }, {
        key: "worldCapsule",
        get: function get() {
            return this._worldShape;
        }
    }, {
        key: "collider",
        get: function get() {
            return this._collider;
        }
    } ]), _createClass(BuiltinCapsuleShape, [ {
        key: "setRadius",
        value: function setRadius(v) {
            this.localCapsule.radius = v, this.transform(this._sharedBody.node.worldMatrix, this._sharedBody.node.worldPosition, this._sharedBody.node.worldRotation, this._sharedBody.node.worldScale);
        }
    }, {
        key: "setCylinderHeight",
        value: function setCylinderHeight(v) {
            this.localCapsule.halfHeight = v / 2, this.localCapsule.updateCache(), this.transform(this._sharedBody.node.worldMatrix, this._sharedBody.node.worldPosition, this._sharedBody.node.worldRotation, this._sharedBody.node.worldScale);
        }
    }, {
        key: "setDirection",
        value: function setDirection(v) {
            this.localCapsule.axis = v, this.localCapsule.updateCache(), this.worldCapsule.axis = v, 
            this.worldCapsule.updateCache(), this.transform(this._sharedBody.node.worldMatrix, this._sharedBody.node.worldPosition, this._sharedBody.node.worldRotation, this._sharedBody.node.worldScale);
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            _get(_getPrototypeOf(BuiltinCapsuleShape.prototype), "onLoad", this).call(this), 
            this.setRadius(this.collider.radius), this.setDirection(this.collider.direction);
        }
    } ]), BuiltinCapsuleShape;
}();

exports.removeProperty(BuiltinCapsuleShape.prototype, "shape.prototype", [ {
    name: "setHeight",
    suggest: "You should use the interface provided by the component."
} ]), function instantiate$1(obj) {
    BoxShape = obj.box, SphereShape = obj.sphere, obj.body, PhysicsWorld = obj.world, 
    obj.capsule && (CapsuleShape = obj.capsule), obj.trimesh && obj.trimesh, obj.cylinder && obj.cylinder;
}({
    box: BuiltinBoxShape,
    sphere: BuiltinSphereShape,
    world: BuiltInWorld,
    capsule: BuiltinCapsuleShape
});

var AudioSourceComponent = (_dec$1U = ccclass("cc.AudioSourceComponent"), _dec2$1t = help("i18n:cc.AudioSourceComponent"), 
_dec3$1b = menu("Components/AudioSource"), _dec4$15 = property(exports.AudioClip), 
_dec5$$ = property({
    type: exports.AudioClip,
    tooltip: "i18n:audio.clip"
}), _dec6$U = property({
    tooltip: "i18n:audio.loop"
}), _dec7$K = property({
    tooltip: "i18n:audio.playOnAwake"
}), _dec8$E = property({
    range: [ 0, 1 ],
    tooltip: "i18n:audio.volume"
}), _dec$1U(_class$1V = _dec2$1t(_class$1V = _dec3$1b((_descriptor$1y = _applyDecoratedDescriptor((_class2$1J = function(_Component) {
    function AudioSourceComponent() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, AudioSourceComponent);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return _initializerDefineProperty(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AudioSourceComponent)).call.apply(_getPrototypeOf2, [ this ].concat(args))), "_clip", _descriptor$1y, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_loop", _descriptor2$1i, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_playOnAwake", _descriptor3$15, _assertThisInitialized(_this)), 
        _initializerDefineProperty(_this, "_volume", _descriptor4$W, _assertThisInitialized(_this)), 
        _this._cachedCurrentTime = 0, _this;
    }
    return _inherits(AudioSourceComponent, Component), _createClass(AudioSourceComponent, [ {
        key: "onLoad",
        value: function onLoad() {
            this._syncStates(), this._playOnAwake && this.play();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            this.pause();
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            this.stop();
        }
    }, {
        key: "play",
        value: function play() {
            this._clip && (this.playing ? this.currentTime = 0 : this._clip.play());
        }
    }, {
        key: "pause",
        value: function pause() {
            this._clip && this._clip.pause();
        }
    }, {
        key: "stop",
        value: function stop() {
            this._clip && this._clip.stop();
        }
    }, {
        key: "playOneShot",
        value: function playOneShot(clip) {
            var volumeScale = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            clip.playOneShot(this._volume * volumeScale);
        }
    }, {
        key: "_syncStates",
        value: function _syncStates() {
            this._clip && (this._clip.setCurrentTime(this._cachedCurrentTime), this._clip.setLoop(this._loop), 
            this._clip.setVolume(this._volume, !0), this._volume = this._clip.getVolume());
        }
    }, {
        key: "clip",
        set: function set(val) {
            this._clip = val, this._syncStates();
        },
        get: function get() {
            return this._clip;
        }
    }, {
        key: "loop",
        set: function set(val) {
            this._loop = val, this._clip && this._clip.setLoop(val);
        },
        get: function get() {
            return this._loop;
        }
    }, {
        key: "playOnAwake",
        set: function set(val) {
            this._playOnAwake = val;
        },
        get: function get() {
            return this._playOnAwake;
        }
    }, {
        key: "volume",
        set: function set(val) {
            isNaN(val) ? console.warn("illegal audio volume!") : (val = clamp(val, 0, 1), this._clip ? (this._clip.setVolume(val), 
            this._volume = this._clip.getVolume()) : this._volume = val);
        },
        get: function get() {
            return this._volume;
        }
    }, {
        key: "currentTime",
        set: function set(num) {
            isNaN(num) ? console.warn("illegal audio time!") : (num = clamp(num, 0, this.duration), 
            this._cachedCurrentTime = num, this._clip && this._clip.setCurrentTime(this._cachedCurrentTime));
        },
        get: function get() {
            return this._clip ? this._clip.getCurrentTime() : this._cachedCurrentTime;
        }
    }, {
        key: "duration",
        get: function get() {
            return this._clip ? this._clip.getDuration() : 0;
        }
    }, {
        key: "state",
        get: function get() {
            return this._clip ? this._clip.state : exports.AudioClip.PlayingState.INITIALIZING;
        }
    }, {
        key: "playing",
        get: function get() {
            return this.state === exports.AudioClip.PlayingState.PLAYING;
        }
    } ]), AudioSourceComponent;
}()).prototype, "_clip", [ _dec4$15 ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor2$1i = _applyDecoratedDescriptor(_class2$1J.prototype, "_loop", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !1;
    }
}), _descriptor3$15 = _applyDecoratedDescriptor(_class2$1J.prototype, "_playOnAwake", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return !0;
    }
}), _descriptor4$W = _applyDecoratedDescriptor(_class2$1J.prototype, "_volume", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _applyDecoratedDescriptor(_class2$1J.prototype, "clip", [ _dec5$$ ], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "clip"), _class2$1J.prototype), 
_applyDecoratedDescriptor(_class2$1J.prototype, "loop", [ _dec6$U ], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "loop"), _class2$1J.prototype), 
_applyDecoratedDescriptor(_class2$1J.prototype, "playOnAwake", [ _dec7$K ], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "playOnAwake"), _class2$1J.prototype), 
_applyDecoratedDescriptor(_class2$1J.prototype, "volume", [ _dec8$E ], Object.getOwnPropertyDescriptor(_class2$1J.prototype, "volume"), _class2$1J.prototype), 
_class$1V = _class2$1J)) || _class$1V) || _class$1V) || _class$1V);

cc.AudioSourceComponent = AudioSourceComponent;

var ID_COUNTER = 0, HashElement = function HashElement() {
    _classCallCheck(this, HashElement), this.actions = [], this.target = null, this.actionIndex = 0, 
    this.currentAction = null, this.paused = !1, this.lock = !1;
}, ActionManager = function() {
    function ActionManager() {
        _classCallCheck(this, ActionManager), this._hashTargets = createMap(!0), this._arrayTargets = [], 
        this._elementPool = [];
    }
    return _createClass(ActionManager, [ {
        key: "_searchElementByTarget",
        value: function _searchElementByTarget(arr, target) {
            for (var k = 0; k < arr.length; k++) if (target === arr[k].target) return arr[k];
            return null;
        }
    }, {
        key: "_getElement",
        value: function _getElement(target, paused) {
            var element = this._elementPool.pop();
            return element || (element = new HashElement), element.target = target, element.paused = !!paused, 
            element;
        }
    }, {
        key: "_putElement",
        value: function _putElement(element) {
            element.actions.length = 0, element.actionIndex = 0, element.currentAction = null, 
            element.paused = !1, element.target = null, element.lock = !1, this._elementPool.push(element);
        }
    }, {
        key: "addAction",
        value: function addAction(action, target, paused) {
            if (action && target) {
                null == target.uuid && (target.uuid = "_TWEEN_UUID_" + ID_COUNTER++);
                var element = this._hashTargets[target.uuid];
                element ? element.actions || (element.actions = []) : (element = this._getElement(target, paused), 
                this._hashTargets[target.uuid] = element, this._arrayTargets.push(element)), element.actions.push(action), 
                action.startWithTarget(target);
            } else errorID(1e3);
        }
    }, {
        key: "removeAllActions",
        value: function removeAllActions() {
            for (var locTargets = this._arrayTargets, i = 0; i < locTargets.length; i++) {
                var element = locTargets[i];
                element && this._putElement(element);
            }
            this._arrayTargets.length = 0, this._hashTargets = createMap(!0);
        }
    }, {
        key: "removeAllActionsFromTarget",
        value: function removeAllActionsFromTarget(target, forceDelete) {
            if (null != target) {
                var element = this._hashTargets[target.uuid];
                element && (element.actions.length = 0, this._deleteHashElement(element));
            }
        }
    }, {
        key: "removeAction",
        value: function removeAction(action) {
            if (null != action) {
                var target = action.getOriginalTarget(), element = this._hashTargets[target.uuid];
                if (element) for (var i = 0; i < element.actions.length; i++) if (element.actions[i] === action) {
                    element.actions.splice(i, 1), element.actionIndex >= i && element.actionIndex--;
                    break;
                }
            }
        }
    }, {
        key: "removeActionByTag",
        value: function removeActionByTag(tag, target) {
            tag === cc.Action.TAG_INVALID && cc.logID(1002), cc.assertID(target, 1003);
            var element = this._hashTargets[target.uuid];
            if (element) for (var limit = element.actions.length, i = 0; i < limit; ++i) {
                var action = element.actions[i];
                if (action && action.getTag() === tag && action.getOriginalTarget() === target) {
                    this._removeActionAtIndex(i, element);
                    break;
                }
            }
        }
    }, {
        key: "getActionByTag",
        value: function getActionByTag(tag, target) {
            tag === cc.Action.TAG_INVALID && cc.logID(1004);
            var element = this._hashTargets[target.uuid];
            if (element) {
                if (null != element.actions) for (var i = 0; i < element.actions.length; ++i) {
                    var action = element.actions[i];
                    if (action && action.getTag() === tag) return action;
                }
                cc.logID(1005, tag);
            }
            return null;
        }
    }, {
        key: "getNumberOfRunningActionsInTarget",
        value: function getNumberOfRunningActionsInTarget(target) {
            var element = this._hashTargets[target.uuid];
            return element && element.actions ? element.actions.length : 0;
        }
    }, {
        key: "pauseTarget",
        value: function pauseTarget(target) {
            var element = this._hashTargets[target.uuid];
            element && (element.paused = !0);
        }
    }, {
        key: "resumeTarget",
        value: function resumeTarget(target) {
            var element = this._hashTargets[target.uuid];
            element && (element.paused = !1);
        }
    }, {
        key: "pauseAllRunningActions",
        value: function pauseAllRunningActions() {
            for (var idsWithActions = [], locTargets = this._arrayTargets, i = 0; i < locTargets.length; i++) {
                var element = locTargets[i];
                element && !element.paused && (element.paused = !0, idsWithActions.push(element.target));
            }
            return idsWithActions;
        }
    }, {
        key: "resumeTargets",
        value: function resumeTargets(targetsToResume) {
            if (targetsToResume) for (var i = 0; i < targetsToResume.length; i++) targetsToResume[i] && this.resumeTarget(targetsToResume[i]);
        }
    }, {
        key: "pauseTargets",
        value: function pauseTargets(targetsToPause) {
            if (targetsToPause) for (var i = 0; i < targetsToPause.length; i++) targetsToPause[i] && this.pauseTarget(targetsToPause[i]);
        }
    }, {
        key: "purgeSharedManager",
        value: function purgeSharedManager() {
            cc.director.getScheduler().unscheduleUpdate(this);
        }
    }, {
        key: "_removeActionAtIndex",
        value: function _removeActionAtIndex(index, element) {
            element.actions[index];
            element.actions.splice(index, 1), element.actionIndex >= index && element.actionIndex--, 
            0 === element.actions.length && this._deleteHashElement(element);
        }
    }, {
        key: "_deleteHashElement",
        value: function _deleteHashElement(element) {
            var ret = !1;
            if (element && !element.lock && this._hashTargets[element.target.uuid]) {
                delete this._hashTargets[element.target.uuid];
                for (var targets = this._arrayTargets, i = 0, l = targets.length; i < l; i++) if (targets[i] === element) {
                    targets.splice(i, 1);
                    break;
                }
                this._putElement(element), ret = !0;
            }
            return ret;
        }
    }, {
        key: "update",
        value: function update(dt) {
            for (var locCurrTarget, locTargets = this._arrayTargets, elt = 0; elt < locTargets.length; elt++) {
                if (this._currentTarget = locTargets[elt], !(locCurrTarget = this._currentTarget).paused && locCurrTarget.actions) {
                    for (locCurrTarget.lock = !0, locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) if (locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex], 
                    locCurrTarget.currentAction) {
                        if (locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1)), 
                        locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                            locCurrTarget.currentAction.stop();
                            var action = locCurrTarget.currentAction;
                            locCurrTarget.currentAction = null, this.removeAction(action);
                        }
                        locCurrTarget.currentAction = null;
                    }
                    locCurrTarget.lock = !1;
                }
                0 === locCurrTarget.actions.length && this._deleteHashElement(locCurrTarget) && elt--;
            }
        }
    } ]), ActionManager;
}(), TweenSystem = function(_System) {
    function TweenSystem() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TweenSystem);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TweenSystem)).call.apply(_getPrototypeOf2, [ this ].concat(args)))).actionMgr = new ActionManager, 
        _this;
    }
    return _inherits(TweenSystem, System), _createClass(TweenSystem, [ {
        key: "postUpdate",
        value: function postUpdate(dt) {
            this.actionMgr.update(dt);
        }
    }, {
        key: "ActionManager",
        get: function get() {
            return this.actionMgr;
        }
    } ]), TweenSystem;
}();

TweenSystem.ID = "TWEEN", TweenSystem.instance = void 0, director.on(Director.EVENT_INIT, (function() {
    var sys = new TweenSystem;
    TweenSystem.instance = sys, director.registerSystem(TweenSystem.ID, sys, 100);
}));

var Action = function() {
    function Action() {
        _classCallCheck(this, Action), this.originalTarget = null, this.target = null, this.tag = Action.TAG_INVALID;
    }
    return _createClass(Action, [ {
        key: "clone",
        value: function clone() {
            var action = new Action;
            return action.originalTarget = null, action.target = null, action.tag = this.tag, 
            action;
        }
    }, {
        key: "isDone",
        value: function isDone() {
            return !0;
        }
    }, {
        key: "startWithTarget",
        value: function startWithTarget(target) {
            this.originalTarget = target, this.target = target;
        }
    }, {
        key: "stop",
        value: function stop() {
            this.target = null;
        }
    }, {
        key: "step",
        value: function step(dt) {
            logID(1006);
        }
    }, {
        key: "update",
        value: function update(dt) {
            logID(1007);
        }
    }, {
        key: "getTarget",
        value: function getTarget() {
            return this.target;
        }
    }, {
        key: "setTarget",
        value: function setTarget(target) {
            this.target = target;
        }
    }, {
        key: "getOriginalTarget",
        value: function getOriginalTarget() {
            return this.originalTarget;
        }
    }, {
        key: "setOriginalTarget",
        value: function setOriginalTarget(originalTarget) {
            this.originalTarget = originalTarget;
        }
    }, {
        key: "getTag",
        value: function getTag() {
            return this.tag;
        }
    }, {
        key: "setTag",
        value: function setTag(tag) {
            this.tag = tag;
        }
    }, {
        key: "reverse",
        value: function reverse() {
            return logID(1008), null;
        }
    }, {
        key: "retain",
        value: function retain() {}
    }, {
        key: "release",
        value: function release() {}
    } ]), Action;
}();

Action.TAG_INVALID = -1;

var FiniteTimeAction = function(_Action) {
    function FiniteTimeAction() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, FiniteTimeAction);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FiniteTimeAction)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._duration = 0, 
        _this._timesForRepeat = 1, _this;
    }
    return _inherits(FiniteTimeAction, Action), _createClass(FiniteTimeAction, [ {
        key: "getDuration",
        value: function getDuration() {
            return this._duration * (this._timesForRepeat || 1);
        }
    }, {
        key: "setDuration",
        value: function setDuration(duration) {
            this._duration = duration;
        }
    }, {
        key: "clone",
        value: function clone() {
            return new FiniteTimeAction;
        }
    } ]), FiniteTimeAction;
}(), ActionInstant = function(_FiniteTimeAction) {
    function ActionInstant() {
        return _classCallCheck(this, ActionInstant), _possibleConstructorReturn(this, _getPrototypeOf(ActionInstant).apply(this, arguments));
    }
    return _inherits(ActionInstant, FiniteTimeAction), _createClass(ActionInstant, [ {
        key: "isDone",
        value: function isDone() {
            return !0;
        }
    }, {
        key: "step",
        value: function step(dt) {
            this.update(1);
        }
    }, {
        key: "update",
        value: function update(dt) {}
    }, {
        key: "reverse",
        value: function reverse() {
            return this.clone();
        }
    }, {
        key: "clone",
        value: function clone() {
            return new ActionInstant;
        }
    } ]), ActionInstant;
}(), Show = function(_ActionInstant) {
    function Show() {
        return _classCallCheck(this, Show), _possibleConstructorReturn(this, _getPrototypeOf(Show).apply(this, arguments));
    }
    return _inherits(Show, ActionInstant), _createClass(Show, [ {
        key: "update",
        value: function update(dt) {
            for (var _renderComps = this.target.getComponentsInChildren(RenderableComponent), i = 0; i < _renderComps.length; ++i) {
                _renderComps[i].enabled = !0;
            }
        }
    }, {
        key: "reverse",
        value: function reverse() {
            return new Hide;
        }
    }, {
        key: "clone",
        value: function clone() {
            return new Show;
        }
    } ]), Show;
}();

var Hide = function(_ActionInstant2) {
    function Hide() {
        return _classCallCheck(this, Hide), _possibleConstructorReturn(this, _getPrototypeOf(Hide).apply(this, arguments));
    }
    return _inherits(Hide, ActionInstant), _createClass(Hide, [ {
        key: "update",
        value: function update(dt) {
            for (var _renderComps = this.target.getComponentsInChildren(RenderableComponent), i = 0; i < _renderComps.length; ++i) {
                _renderComps[i].enabled = !1;
            }
        }
    }, {
        key: "reverse",
        value: function reverse() {
            return new Show;
        }
    }, {
        key: "clone",
        value: function clone() {
            return new Hide;
        }
    } ]), Hide;
}();

var RemoveSelf = function(_ActionInstant4) {
    function RemoveSelf(isNeedCleanUp) {
        var _this;
        return _classCallCheck(this, RemoveSelf), (_this = _possibleConstructorReturn(this, _getPrototypeOf(RemoveSelf).call(this)))._isNeedCleanUp = !0, 
        void 0 !== isNeedCleanUp && _this.init(isNeedCleanUp), _this;
    }
    return _inherits(RemoveSelf, ActionInstant), _createClass(RemoveSelf, [ {
        key: "update",
        value: function update(dt) {
            this.target.removeFromParent(), this._isNeedCleanUp && this.target.destroy();
        }
    }, {
        key: "init",
        value: function init(isNeedCleanUp) {
            return this._isNeedCleanUp = isNeedCleanUp, !0;
        }
    }, {
        key: "reverse",
        value: function reverse() {
            return new RemoveSelf(this._isNeedCleanUp);
        }
    }, {
        key: "clone",
        value: function clone() {
            return new RemoveSelf(this._isNeedCleanUp);
        }
    } ]), RemoveSelf;
}();

var CallFunc = function(_ActionInstant5) {
    function CallFunc(selector, selectorTarget, data) {
        var _this2;
        return _classCallCheck(this, CallFunc), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(CallFunc).call(this)))._selectorTarget = null, 
        _this2._function = null, _this2._data = null, _this2.initWithFunction(selector, selectorTarget, data), 
        _this2;
    }
    return _inherits(CallFunc, ActionInstant), _createClass(CallFunc, [ {
        key: "initWithFunction",
        value: function initWithFunction(selector, selectorTarget, data) {
            return selector && (this._function = selector), selectorTarget && (this._selectorTarget = selectorTarget), 
            void 0 !== data && (this._data = data), !0;
        }
    }, {
        key: "execute",
        value: function execute() {
            this._function && this._function.call(this._selectorTarget, this.target, this._data);
        }
    }, {
        key: "update",
        value: function update(dt) {
            this.execute();
        }
    }, {
        key: "getTargetCallback",
        value: function getTargetCallback() {
            return this._selectorTarget;
        }
    }, {
        key: "setTargetCallback",
        value: function setTargetCallback(sel) {
            sel !== this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), 
            this._selectorTarget = sel);
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new CallFunc;
            return action.initWithFunction(this._function, this._selectorTarget, this._data), 
            action;
        }
    } ]), CallFunc;
}();

var ActionInterval = function(_FiniteTimeAction) {
    function ActionInterval(d) {
        var _this;
        return _classCallCheck(this, ActionInterval), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ActionInterval).call(this))).MAX_VALUE = 2, 
        _this._elapsed = 0, _this._firstTick = !1, _this._easeList = [], _this._speed = 1, 
        _this._repeatForever = !1, _this._repeatMethod = !1, _this._speedMethod = !1, void 0 === d || isNaN(d) || _this.initWithDuration(d), 
        _this;
    }
    return _inherits(ActionInterval, FiniteTimeAction), _createClass(ActionInterval, [ {
        key: "getElapsed",
        value: function getElapsed() {
            return this._elapsed;
        }
    }, {
        key: "initWithDuration",
        value: function initWithDuration(d) {
            return this._duration = 0 === d ? macro.FLT_EPSILON : d, this._elapsed = 0, this._firstTick = !0, 
            !0;
        }
    }, {
        key: "isDone",
        value: function isDone() {
            return this._elapsed >= this._duration;
        }
    }, {
        key: "_cloneDecoration",
        value: function _cloneDecoration(action) {
            action._repeatForever = this._repeatForever, action._speed = this._speed, action._timesForRepeat = this._timesForRepeat, 
            action._easeList = this._easeList, action._speedMethod = this._speedMethod, action._repeatMethod = this._repeatMethod;
        }
    }, {
        key: "_reverseEaseList",
        value: function _reverseEaseList(action) {
            if (this._easeList) {
                action._easeList = [];
                for (var i = 0; i < this._easeList.length; i++) action._easeList.push(this._easeList[i]);
            }
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new ActionInterval(this._duration);
            return this._cloneDecoration(action), action;
        }
    }, {
        key: "easing",
        value: function easing(easeObj) {
            this._easeList ? this._easeList.length = 0 : this._easeList = [];
            for (var i = 0; i < arguments.length; i++) this._easeList.push(arguments[i]);
            return this;
        }
    }, {
        key: "_computeEaseTime",
        value: function _computeEaseTime(dt) {
            return dt;
        }
    }, {
        key: "step",
        value: function step(dt) {
            this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += dt;
            var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
            t = 1 > t ? t : 1, this.update(t > 0 ? t : 0), this._repeatMethod && this._timesForRepeat > 1 && this.isDone() && (this._repeatForever || this._timesForRepeat--, 
            this.startWithTarget(this.target), this.step(this._elapsed - this._duration));
        }
    }, {
        key: "startWithTarget",
        value: function startWithTarget(target) {
            Action.prototype.startWithTarget.call(this, target), this._elapsed = 0, this._firstTick = !0;
        }
    }, {
        key: "reverse",
        value: function reverse() {
            return logID(1010), this;
        }
    }, {
        key: "setAmplitudeRate",
        value: function setAmplitudeRate(amp) {
            logID(1011);
        }
    }, {
        key: "getAmplitudeRate",
        value: function getAmplitudeRate() {
            return logID(1012), 0;
        }
    }, {
        key: "speed",
        value: function speed(_speed) {
            return _speed <= 0 ? (logID(1013), this) : (this._speedMethod = !0, this._speed *= _speed, 
            this);
        }
    }, {
        key: "getSpeed",
        value: function getSpeed() {
            return this._speed;
        }
    }, {
        key: "setSpeed",
        value: function setSpeed(speed) {
            return this._speed = speed, this;
        }
    }, {
        key: "repeat",
        value: function repeat(times) {
            return times = Math.round(times), isNaN(times) || times < 1 ? (logID(1014), this) : (this._repeatMethod = !0, 
            this._timesForRepeat *= times, this);
        }
    }, {
        key: "repeatForever",
        value: function repeatForever() {
            return this._repeatMethod = !0, this._timesForRepeat = this.MAX_VALUE, this._repeatForever = !0, 
            this;
        }
    } ]), ActionInterval;
}(), Sequence = function(_ActionInterval) {
    function Sequence(tempArray) {
        var _this2;
        _classCallCheck(this, Sequence), (_this2 = _possibleConstructorReturn(this, _getPrototypeOf(Sequence).call(this)))._actions = [], 
        _this2._split = 0, _this2._last = 0, _this2._reversed = !1;
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) return errorID(1019), _possibleConstructorReturn(_this2);
        var last = paramArray.length - 1;
        if (last >= 0 && null == paramArray[last] && logID(1015), last >= 0) {
            for (var action1, prev = paramArray[0], i = 1; i < last; i++) paramArray[i] && (action1 = prev, 
            prev = Sequence._actionOneTwo(action1, paramArray[i]));
            _this2.initWithTwoActions(prev, paramArray[last]);
        }
        return _this2;
    }
    return _inherits(Sequence, ActionInterval), _createClass(Sequence, [ {
        key: "initWithTwoActions",
        value: function initWithTwoActions(actionOne, actionTwo) {
            if (!actionOne || !actionTwo) return errorID(1025), !1;
            var durationOne = actionOne._duration, durationTwo = actionTwo._duration, d = (durationOne *= actionOne._repeatMethod ? actionOne._timesForRepeat : 1) + (durationTwo *= actionTwo._repeatMethod ? actionTwo._timesForRepeat : 1);
            return this.initWithDuration(d), this._actions[0] = actionOne, this._actions[1] = actionTwo, 
            !0;
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new Sequence;
            return this._cloneDecoration(action), action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone()), 
            action;
        }
    }, {
        key: "startWithTarget",
        value: function startWithTarget(target) {
            ActionInterval.prototype.startWithTarget.call(this, target), this._split = this._actions[0]._duration / this._duration, 
            this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1, 
            this._last = -1;
        }
    }, {
        key: "stop",
        value: function stop() {
            -1 !== this._last && this._actions[this._last].stop(), Action.prototype.stop.call(this);
        }
    }, {
        key: "update",
        value: function update(dt) {
            var new_t, actionFound, found = 0, locSplit = this._split, locActions = this._actions, locLast = this._last;
            (dt = this._computeEaseTime(dt)) < locSplit ? (new_t = 0 !== locSplit ? dt / locSplit : 1, 
            0 === found && 1 === locLast && this._reversed && (locActions[1].update(0), locActions[1].stop())) : (found = 1, 
            new_t = 1 === locSplit ? 1 : (dt - locSplit) / (1 - locSplit), -1 === locLast && (locActions[0].startWithTarget(this.target), 
            locActions[0].update(1), locActions[0].stop()), 0 === locLast && (locActions[0].update(1), 
            locActions[0].stop())), actionFound = locActions[found], locLast === found && actionFound.isDone() || (locLast !== found && actionFound.startWithTarget(this.target), 
            new_t *= actionFound._timesForRepeat, actionFound.update(new_t > 1 ? new_t % 1 : new_t), 
            this._last = found);
        }
    }, {
        key: "reverse",
        value: function reverse() {
            var action = Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
            return this._cloneDecoration(action), this._reverseEaseList(action), action._reversed = !0, 
            action;
        }
    } ]), Sequence;
}();

function sequence(tempArray) {
    var paramArray = tempArray instanceof Array ? tempArray : arguments;
    if (1 === paramArray.length) return errorID(1019), null;
    var last = paramArray.length - 1;
    last >= 0 && null == paramArray[last] && logID(1015);
    var result = null;
    if (last >= 0) {
        result = paramArray[0];
        for (var i = 1; i <= last; i++) paramArray[i] && (result = Sequence._actionOneTwo(result, paramArray[i]));
    }
    return result;
}

Sequence._actionOneTwo = function(actionOne, actionTwo) {
    var sequence = new Sequence;
    return sequence.initWithTwoActions(actionOne, actionTwo), sequence;
};

var Repeat = function(_ActionInterval2) {
    function Repeat(action, times) {
        var _this3;
        return _classCallCheck(this, Repeat), (_this3 = _possibleConstructorReturn(this, _getPrototypeOf(Repeat).call(this)))._times = 0, 
        _this3._total = 0, _this3._nextDt = 0, _this3._actionInstant = !1, _this3._innerAction = null, 
        void 0 !== times && _this3.initWithAction(action, times), _this3;
    }
    return _inherits(Repeat, ActionInterval), _createClass(Repeat, [ {
        key: "initWithAction",
        value: function initWithAction(action, times) {
            var duration = action._duration * times;
            return !!this.initWithDuration(duration) && (this._times = times, this._innerAction = action, 
            action instanceof ActionInstant && (this._actionInstant = !0, this._times -= 1), 
            this._total = 0, !0);
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new Repeat;
            return this._cloneDecoration(action), action.initWithAction(this._innerAction.clone(), this._times), 
            action;
        }
    }, {
        key: "startWithTarget",
        value: function startWithTarget(target) {
            this._total = 0, this._nextDt = this._innerAction._duration / this._duration, ActionInterval.prototype.startWithTarget.call(this, target), 
            this._innerAction.startWithTarget(target);
        }
    }, {
        key: "stop",
        value: function stop() {
            this._innerAction.stop(), Action.prototype.stop.call(this);
        }
    }, {
        key: "update",
        value: function update(dt) {
            dt = this._computeEaseTime(dt);
            var locInnerAction = this._innerAction, locDuration = this._duration, locTimes = this._times, locNextDt = this._nextDt;
            if (dt >= locNextDt) {
                for (;dt > locNextDt && this._total < locTimes; ) locInnerAction.update(1), this._total++, 
                locInnerAction.stop(), locInnerAction.startWithTarget(this.target), locNextDt += locInnerAction._duration / locDuration, 
                this._nextDt = locNextDt > 1 ? 1 : locNextDt;
                dt >= 1 && this._total < locTimes && (locInnerAction.update(1), this._total++), 
                this._actionInstant || (this._total === locTimes ? locInnerAction.stop() : locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration)));
            } else locInnerAction.update(dt * locTimes % 1);
        }
    }, {
        key: "isDone",
        value: function isDone() {
            return this._total === this._times;
        }
    }, {
        key: "reverse",
        value: function reverse() {
            var action = new Repeat(this._innerAction.reverse(), this._times);
            return this._cloneDecoration(action), this._reverseEaseList(action), action;
        }
    }, {
        key: "setInnerAction",
        value: function setInnerAction(action) {
            this._innerAction !== action && (this._innerAction = action);
        }
    }, {
        key: "getInnerAction",
        value: function getInnerAction() {
            return this._innerAction;
        }
    } ]), Repeat;
}();

var RepeatForever = function(_ActionInterval3) {
    function RepeatForever(action) {
        var _this4;
        return _classCallCheck(this, RepeatForever), (_this4 = _possibleConstructorReturn(this, _getPrototypeOf(RepeatForever).call(this)))._innerAction = null, 
        action && _this4.initWithAction(action), _this4;
    }
    return _inherits(RepeatForever, ActionInterval), _createClass(RepeatForever, [ {
        key: "initWithAction",
        value: function initWithAction(action) {
            return action ? (this._innerAction = action, !0) : (errorID(1026), !1);
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new RepeatForever;
            return this._cloneDecoration(action), action.initWithAction(this._innerAction.clone()), 
            action;
        }
    }, {
        key: "startWithTarget",
        value: function startWithTarget(target) {
            ActionInterval.prototype.startWithTarget.call(this, target), this._innerAction.startWithTarget(target);
        }
    }, {
        key: "step",
        value: function step(dt) {
            var locInnerAction = this._innerAction;
            locInnerAction.step(dt), locInnerAction.isDone() && (locInnerAction.startWithTarget(this.target), 
            locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration));
        }
    }, {
        key: "isDone",
        value: function isDone() {
            return !1;
        }
    }, {
        key: "reverse",
        value: function reverse() {
            var action = new RepeatForever(this._innerAction.reverse());
            return this._cloneDecoration(action), this._reverseEaseList(action), action;
        }
    }, {
        key: "setInnerAction",
        value: function setInnerAction(action) {
            this._innerAction !== action && (this._innerAction = action);
        }
    }, {
        key: "getInnerAction",
        value: function getInnerAction() {
            return this._innerAction;
        }
    } ]), RepeatForever;
}();

var Spawn = function(_ActionInterval4) {
    function Spawn(tempArray) {
        var _this5;
        _classCallCheck(this, Spawn), (_this5 = _possibleConstructorReturn(this, _getPrototypeOf(Spawn).call(this)))._one = null, 
        _this5._two = null;
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) return errorID(1020), _possibleConstructorReturn(_this5);
        var last = paramArray.length - 1;
        if (last >= 0 && null == paramArray[last] && logID(1015), last >= 0) {
            for (var action1, prev = paramArray[0], i = 1; i < last; i++) paramArray[i] && (action1 = prev, 
            prev = Spawn._actionOneTwo(action1, paramArray[i]));
            _this5.initWithTwoActions(prev, paramArray[last]);
        }
        return _this5;
    }
    return _inherits(Spawn, ActionInterval), _createClass(Spawn, [ {
        key: "initWithTwoActions",
        value: function initWithTwoActions(action1, action2) {
            if (!action1 || !action2) return errorID(1027), !1;
            var ret = !1, d1 = action1._duration, d2 = action2._duration;
            return this.initWithDuration(Math.max(d1, d2)) && (this._one = action1, this._two = action2, 
            d1 > d2 ? this._two = Sequence._actionOneTwo(action2, delayTime(d1 - d2)) : d1 < d2 && (this._one = Sequence._actionOneTwo(action1, delayTime(d2 - d1))), 
            ret = !0), ret;
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new Spawn;
            return this._cloneDecoration(action), action.initWithTwoActions(this._one.clone(), this._two.clone()), 
            action;
        }
    }, {
        key: "startWithTarget",
        value: function startWithTarget(target) {
            ActionInterval.prototype.startWithTarget.call(this, target), this._one.startWithTarget(target), 
            this._two.startWithTarget(target);
        }
    }, {
        key: "stop",
        value: function stop() {
            this._one.stop(), this._two.stop(), Action.prototype.stop.call(this);
        }
    }, {
        key: "update",
        value: function update(dt) {
            dt = this._computeEaseTime(dt), this._one && this._one.update(dt), this._two && this._two.update(dt);
        }
    }, {
        key: "reverse",
        value: function reverse() {
            var action = Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
            return this._cloneDecoration(action), this._reverseEaseList(action), action;
        }
    } ]), Spawn;
}();

function spawn(tempArray) {
    var paramArray = tempArray instanceof Array ? tempArray : arguments;
    if (1 === paramArray.length) return errorID(1020), null;
    paramArray.length > 0 && null == paramArray[paramArray.length - 1] && logID(1015);
    for (var prev = paramArray[0], i = 1; i < paramArray.length; i++) null != paramArray[i] && (prev = Spawn._actionOneTwo(prev, paramArray[i]));
    return prev;
}

Spawn._actionOneTwo = function(action1, action2) {
    var pSpawn = new Spawn;
    return pSpawn.initWithTwoActions(action1, action2), pSpawn;
};

var DelayTime = function(_ActionInterval5) {
    function DelayTime() {
        return _classCallCheck(this, DelayTime), _possibleConstructorReturn(this, _getPrototypeOf(DelayTime).apply(this, arguments));
    }
    return _inherits(DelayTime, ActionInterval), _createClass(DelayTime, [ {
        key: "update",
        value: function update(dt) {}
    }, {
        key: "reverse",
        value: function reverse() {
            var action = new DelayTime(this._duration);
            return this._cloneDecoration(action), this._reverseEaseList(action), action;
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new DelayTime;
            return this._cloneDecoration(action), action.initWithDuration(this._duration), action;
        }
    } ]), DelayTime;
}();

function delayTime(d) {
    return new DelayTime(d);
}

var ReverseTime = function(_ActionInterval6) {
    function ReverseTime(action) {
        var _this6;
        return _classCallCheck(this, ReverseTime), (_this6 = _possibleConstructorReturn(this, _getPrototypeOf(ReverseTime).call(this)))._other = null, 
        action && _this6.initWithAction(action), _this6;
    }
    return _inherits(ReverseTime, ActionInterval), _createClass(ReverseTime, [ {
        key: "initWithAction",
        value: function initWithAction(action) {
            return action ? action === this._other ? (errorID(1029), !1) : !!ActionInterval.prototype.initWithDuration.call(this, action._duration) && (this._other = action, 
            !0) : (errorID(1028), !1);
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new ReverseTime;
            return this._cloneDecoration(action), action.initWithAction(this._other.clone()), 
            action;
        }
    }, {
        key: "startWithTarget",
        value: function startWithTarget(target) {
            ActionInterval.prototype.startWithTarget.call(this, target), this._other.startWithTarget(target);
        }
    }, {
        key: "update",
        value: function update(dt) {
            dt = this._computeEaseTime(dt), this._other && this._other.update(1 - dt);
        }
    }, {
        key: "reverse",
        value: function reverse() {
            return this._other.clone();
        }
    }, {
        key: "stop",
        value: function stop() {
            this._other.stop(), Action.prototype.stop.call(this);
        }
    } ]), ReverseTime;
}();

var TweenAction = function(_ActionInterval) {
    function TweenAction(duration, props, opts) {
        var _this;
        if (_classCallCheck(this, TweenAction), (_this = _possibleConstructorReturn(this, _getPrototypeOf(TweenAction).call(this)))._opts = void 0, 
        _this._props = void 0, _this._originProps = void 0, null == opts) opts = Object.create(null); else if (function TweenOptionChecker(opts) {
            var header = " [Tween:] ", message = " option is not support in v" + cc.ENGINE_VERSION;
            opts.delay && warn(header + "delay" + message), opts.repeat && warn(header + "repeat" + message), 
            opts.repeatDelay && warn(header + "repeatDelay" + message), opts.interpolation && warn(header + "interpolation" + message), 
            opts.onStop && warn(header + "onStop" + message);
        }(opts), opts.easing && "string" == typeof opts.easing && (opts.easing = function TweenEasinAdapter(easingName) {
            var initialChar = easingName.charAt(0);
            if (/[A-Z]/.test(initialChar)) {
                var arr = (easingName = easingName.replace(initialChar, initialChar.toLowerCase())).split("-");
                if (2 == arr.length) {
                    var str0 = arr[0];
                    if ("linear" == str0) easingName = "linear"; else {
                        var str1 = arr[1];
                        switch (str0) {
                          case "quadratic":
                            easingName = "quad" + str1;
                            break;

                          case "quartic":
                            easingName = "quart" + str1;
                            break;

                          case "quintic":
                            easingName = "quint" + str1;
                            break;

                          case "sinusoidal":
                            easingName = "sine" + str1;
                            break;

                          case "exponential":
                            easingName = "expo" + str1;
                            break;

                          case "circular":
                            easingName = "circ" + str1;
                            break;

                          default:
                            easingName = str0 + str1;
                        }
                    }
                }
            }
            return easingName;
        }(opts.easing)), opts.progress || (opts.progress = _this.progress), opts.easing && "string" == typeof opts.easing) {
            var easingName = opts.easing;
            opts.easing = easing[easingName], opts.easing || warnID(1031, easingName);
        }
        for (var name in _this._opts = opts, _this._props = Object.create(null), props) {
            var value = props[name], _easing = void 0, progress = void 0;
            void 0 !== value.value && (value.easing || value.progress) && ("string" == typeof value.easing ? !(_easing = _easing[value.easing]) && warnID(1031, value.easing) : _easing = value.easing, 
            progress = value.progress, value = value.value);
            var prop = Object.create(null);
            prop.value = value, prop.easing = _easing, prop.progress = progress, _this._props[name] = prop;
        }
        return _this._originProps = props, _this.initWithDuration(duration), _this;
    }
    return _inherits(TweenAction, ActionInterval), _createClass(TweenAction, [ {
        key: "clone",
        value: function clone() {
            var action = new TweenAction(this._duration, this._originProps, this._opts);
            return this._cloneDecoration(action), action;
        }
    }, {
        key: "startWithTarget",
        value: function startWithTarget(target) {
            ActionInterval.prototype.startWithTarget.call(this, target);
            var relative = !!this._opts.relative, props = this._props;
            for (var property in props) {
                var _t = target[property];
                if (void 0 !== _t) {
                    var prop = props[property], value = prop.value;
                    if ("number" == typeof _t) prop.start = _t, prop.current = _t, prop.end = relative ? _t + value : value; else if ("object" === _typeof(_t)) for (var k in null == prop.start && (prop.start = {}, 
                    prop.current = {}, prop.end = {}), value) prop.start[k] = _t[k], prop.current[k] = _t[k], 
                    prop.end[k] = relative ? _t[k] + value[k] : value[k];
                }
            }
            this._opts.onStart && this._opts.onStart(this.target);
        }
    }, {
        key: "update",
        value: function update(t) {
            var target = this.target;
            if (target) {
                var props = this._props, opts = this._opts, easingTime = t;
                opts.easing && (easingTime = opts.easing(t));
                var progress = opts.progress;
                for (var name in props) {
                    var prop = props[name], time = prop.easing ? prop.easing(t) : easingTime, interpolation = prop.progress ? prop.progress : progress, start = prop.start, end = prop.end;
                    if ("number" == typeof start) prop.current = interpolation(start, end, prop.current, time); else if ("object" === _typeof(start)) for (var k in start) prop.current[k] = interpolation(start[k], end[k], prop.current[k], time);
                    target[name] = prop.current;
                }
                opts.onUpdate && opts.onUpdate(this.target, t), 1 == t && opts.onComplete && opts.onComplete(this.target);
            }
        }
    }, {
        key: "progress",
        value: function progress(start, end, current, t) {
            return start + (end - start) * t;
        }
    } ]), TweenAction;
}(), SetAction = function(_ActionInstant) {
    function SetAction(props) {
        var _this;
        return _classCallCheck(this, SetAction), (_this = _possibleConstructorReturn(this, _getPrototypeOf(SetAction).call(this)))._props = void 0, 
        _this._props = {}, void 0 !== props && _this.init(props), _this;
    }
    return _inherits(SetAction, ActionInstant), _createClass(SetAction, [ {
        key: "init",
        value: function init(props) {
            for (var name in props) this._props[name] = props[name];
            return !0;
        }
    }, {
        key: "update",
        value: function update() {
            var props = this._props, target = this.target;
            for (var name in props) target[name] = props[name];
        }
    }, {
        key: "clone",
        value: function clone() {
            var action = new SetAction;
            return action.init(this._props), action;
        }
    } ]), SetAction;
}(), Tween = function() {
    function Tween(target) {
        _classCallCheck(this, Tween), this._actions = [], this._finalAction = null, this._target = null, 
        this._target = void 0 === target ? null : target, this._target && this._target instanceof Node$1 && this._target.on(exports.SystemEventType.NODE_DESTROYED, this._destroy, this);
    }
    return _createClass(Tween, [ {
        key: "then",
        value: function then(other) {
            return other instanceof Action ? this._actions.push(other.clone()) : this._actions.push(other._union()), 
            this;
        }
    }, {
        key: "target",
        value: function target(_target) {
            return this._target && this._target instanceof Node$1 && this._target.off(exports.SystemEventType.NODE_DESTROYED, this._destroy, this), 
            this._target = _target, this._target && this._target instanceof Node$1 && this._target.on(exports.SystemEventType.NODE_DESTROYED, this._destroy, this), 
            this;
        }
    }, {
        key: "start",
        value: function start() {
            return this._target ? (this._finalAction && TweenSystem.instance.ActionManager.removeAction(this._finalAction), 
            this._finalAction = this._union(), TweenSystem.instance.ActionManager.addAction(this._finalAction, this._target, !1), 
            this) : (warn("Please set target to tween first"), this);
        }
    }, {
        key: "stop",
        value: function stop() {
            return this._finalAction && TweenSystem.instance.ActionManager.removeAction(this._finalAction), 
            this;
        }
    }, {
        key: "clone",
        value: function clone(target) {
            var action = this._union();
            return tween(target).then(action.clone());
        }
    }, {
        key: "union",
        value: function union() {
            var action = this._union();
            return this._actions.length = 0, this._actions.push(action), this;
        }
    }, {
        key: "to",
        value: function to(duration, props, opts) {
            (opts = opts || Object.create(null)).relative = !1;
            var action = new TweenAction(duration, props, opts);
            return this._actions.push(action), this;
        }
    }, {
        key: "by",
        value: function by(duration, props, opts) {
            (opts = opts || Object.create(null)).relative = !0;
            var action = new TweenAction(duration, props, opts);
            return this._actions.push(action), this;
        }
    }, {
        key: "set",
        value: function set(props) {
            var action = new SetAction(props);
            return this._actions.push(action), this;
        }
    }, {
        key: "delay",
        value: function delay(duration) {
            var action = delayTime(duration);
            return this._actions.push(action), this;
        }
    }, {
        key: "call",
        value: function call(callback) {
            var action = function callFunc(selector, selectorTarget, data) {
                return new CallFunc(selector, selectorTarget, data);
            }(callback);
            return this._actions.push(action), this;
        }
    }, {
        key: "sequence",
        value: function sequence() {
            var action = Tween._wrappedSequence.apply(Tween, arguments);
            return this._actions.push(action), this;
        }
    }, {
        key: "parallel",
        value: function parallel() {
            var action = Tween._wrappedParallel.apply(Tween, arguments);
            return this._actions.push(action), this;
        }
    }, {
        key: "repeat",
        value: function repeat(repeatTimes, embedTween) {
            if (repeatTimes == 1 / 0) return this.repeatForever(embedTween);
            var action, actions = this._actions;
            return action = embedTween instanceof Tween ? embedTween._union() : actions.pop(), 
            actions.push(function repeat$2(action, times) {
                return new Repeat(action, times);
            }(action, repeatTimes)), this;
        }
    }, {
        key: "repeatForever",
        value: function repeatForever$1(embedTween) {
            var action, actions = this._actions;
            return action = embedTween instanceof Tween ? embedTween._union() : actions.pop(), 
            actions.push(function repeatForever(action) {
                return new RepeatForever(action);
            }(action)), this;
        }
    }, {
        key: "reverseTime",
        value: function reverseTime$1(embedTween) {
            var action, actions = this._actions;
            return action = embedTween instanceof Tween ? embedTween._union() : actions.pop(), 
            actions.push(function reverseTime(action) {
                return new ReverseTime(action);
            }(action)), this;
        }
    }, {
        key: "hide",
        value: function hide$1() {
            var action = function hide() {
                return new Hide;
            }();
            return this._actions.push(action), this;
        }
    }, {
        key: "show",
        value: function show$1() {
            var action = function show() {
                return new Show;
            }();
            return this._actions.push(action), this;
        }
    }, {
        key: "removeSelf",
        value: function removeSelf$1() {
            var action = function removeSelf(isNeedCleanUp) {
                return new RemoveSelf(isNeedCleanUp);
            }(!1);
            return this._actions.push(action), this;
        }
    }, {
        key: "_union",
        value: function _union() {
            var actions = this._actions;
            return 1 === actions.length ? actions[0] : sequence(actions);
        }
    }, {
        key: "_destroy",
        value: function _destroy() {
            this.stop();
        }
    } ], [ {
        key: "_wrappedSequence",
        value: function _wrappedSequence() {
            var tmp_args = Tween._tmp_args;
            tmp_args.length = 0;
            for (var l = arguments.length, i = 0; i < l; i++) {
                var arg = tmp_args[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                arg instanceof Tween && (tmp_args[i] = arg._union());
            }
            return sequence.apply(sequence, tmp_args);
        }
    }, {
        key: "_wrappedParallel",
        value: function _wrappedParallel() {
            var tmp_args = Tween._tmp_args;
            tmp_args.length = 0;
            for (var l = arguments.length, i = 0; i < l; i++) {
                var arg = tmp_args[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
                arg instanceof Tween && (tmp_args[i] = arg._union());
            }
            return spawn.apply(spawn, tmp_args);
        }
    } ]), Tween;
}();

function tween(target) {
    return new Tween(target);
}

function tweenUtil(target) {
    return warn("tweenUtil' is deprecated, please use 'tween' instead "), new Tween(target);
}

Tween._tmp_args = [], cc.Tween = Tween, cc.tween = tween, cc.tweenUtil = tweenUtil;

var _class$1W, _class$1X, _class2$1K, _descriptor$1z, _descriptor2$1j, _descriptor3$16, _descriptor4$X, _class4$d, _class5$b, _descriptor5$K, _descriptor6$x, _class7$3, _class8$3, _descriptor7$s, _class10$2, _class11$2, _descriptor8$n, _descriptor9$j, _descriptor10$i, _descriptor11$e, _descriptor12$d, _dec5$10, _dec6$V, _dec7$L, _dec8$F, _dec9$v, _dec10$n, _dec11$m, _dec12$l, _class13$1, _class14$1, _descriptor13$c, _descriptor14$a, _descriptor15$6, _descriptor16$6, HeightField = function() {
    function HeightField(w, h) {
        _classCallCheck(this, HeightField), this.data = new Uint16Array, this.w = 0, this.h = 0, 
        this.w = w, this.h = h, this.data = new Uint16Array(w * h);
        for (var i = 0; i < w * h; ++i) this.data[i] = 0;
    }
    return _createClass(HeightField, [ {
        key: "set",
        value: function set(i, j, value) {
            this.data[j * this.w + i] = value;
        }
    }, {
        key: "get",
        value: function get(i, j) {
            return this.data[j * this.w + i];
        }
    }, {
        key: "getClamp",
        value: function getClamp(i, j) {
            return i = clamp(i, 0, this.w - 1), j = clamp(j, 0, this.h - 1), this.get(i, j);
        }
    }, {
        key: "getAt",
        value: function getAt(x, y) {
            var fx = x, fy = y, ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
            ix0 = clamp(ix0, 0, this.w - 1), iz0 = clamp(iz0, 0, this.h - 1), ix1 = clamp(ix1, 0, this.w - 1), 
            iz1 = clamp(iz1, 0, this.h - 1);
            var a = this.get(ix0, iz0), b = this.get(ix1, iz0), c = this.get(ix0, iz1), d = this.get(ix1, iz1), m = .5 * (b + c);
            return dx + dz <= 1 ? d = m + (m - a) : a = m + (m - d), (a * (1 - dx) + b * dx) * (1 - dz) + (c * (1 - dx) + d * dx) * dz;
        }
    } ]), HeightField;
}(), TerrainBuffer = function() {
    function TerrainBuffer() {
        _classCallCheck(this, TerrainBuffer), this.length = 0, this.buffer = new Uint8Array(2048), 
        this._buffView = new DataView(this.buffer.buffer), this._seekPos = 0;
    }
    return _createClass(TerrainBuffer, [ {
        key: "reserve",
        value: function reserve(size) {
            if (!(this.buffer.byteLength > size)) {
                for (var capacity = this.buffer.byteLength; capacity < size; ) capacity += capacity;
                for (var temp = new Uint8Array(capacity), i = 0; i < this.length; ++i) temp[i] = this.buffer[i];
                this.buffer = temp, this._buffView = new DataView(this.buffer.buffer);
            }
        }
    }, {
        key: "assign",
        value: function assign(buff) {
            this.buffer = buff, this.length = buff.length, this._seekPos = buff.byteOffset, 
            this._buffView = new DataView(buff.buffer);
        }
    }, {
        key: "writeInt8",
        value: function writeInt8(value) {
            this.reserve(this.length + 1), this._buffView.setInt8(this.length, value), this.length += 1;
        }
    }, {
        key: "writeInt16",
        value: function writeInt16(value) {
            this.reserve(this.length + 2), this._buffView.setInt16(this.length, value, !0), 
            this.length += 2;
        }
    }, {
        key: "writeInt32",
        value: function writeInt32(value) {
            this.reserve(this.length + 4), this._buffView.setInt32(this.length, value, !0), 
            this.length += 4;
        }
    }, {
        key: "writeIntArray",
        value: function writeIntArray(value) {
            this.reserve(this.length + 4 * value.length);
            for (var i = 0; i < value.length; ++i) this._buffView.setInt32(this.length + 4 * i, value[i], !0);
            this.length += 4 * value.length;
        }
    }, {
        key: "writeFloat",
        value: function writeFloat(value) {
            this.reserve(this.length + 4), this._buffView.setFloat32(this.length, value, !0), 
            this.length += 4;
        }
    }, {
        key: "writeFloatArray",
        value: function writeFloatArray(value) {
            this.reserve(this.length + 4 * value.length);
            for (var i = 0; i < value.length; ++i) this._buffView.setFloat32(this.length + 4 * i, value[i], !0);
            this.length += 4 * value.length;
        }
    }, {
        key: "writeString",
        value: function writeString(value) {
            this.reserve(this.length + value.length + 4), this._buffView.setInt32(this.length, value.length, !0);
            for (var i = 0; i < value.length; ++i) this._buffView.setInt8(this.length + 4 + i, value.charCodeAt(i));
            this.length += value.length + 4;
        }
    }, {
        key: "readInt8",
        value: function readInt8() {
            var value = this._buffView.getInt8(this._seekPos);
            return this._seekPos += 1, value;
        }
    }, {
        key: "readInt16",
        value: function readInt16() {
            var value = this._buffView.getInt16(this._seekPos, !0);
            return this._seekPos += 2, value;
        }
    }, {
        key: "readInt",
        value: function readInt() {
            var value = this._buffView.getInt32(this._seekPos, !0);
            return this._seekPos += 4, value;
        }
    }, {
        key: "readIntArray",
        value: function readIntArray(value) {
            for (var i = 0; i < value.length; ++i) value[i] = this._buffView.getInt32(this._seekPos + 4 * i, !0);
            return this._seekPos += 4 * value.length, value;
        }
    }, {
        key: "readFloat",
        value: function readFloat() {
            var value = this._buffView.getFloat32(this._seekPos, !0);
            return this._seekPos += 4, value;
        }
    }, {
        key: "readFloatArray",
        value: function readFloatArray(value) {
            for (var i = 0; i < value.length; ++i) value[i] = this._buffView.getFloat32(this._seekPos + 4 * i, !0);
            return this._seekPos += 4 * value.length, value;
        }
    }, {
        key: "readString",
        value: function readString() {
            for (var length = this.readInt(), value = "", i = 0; i < length; ++i) value += String.fromCharCode(this.readInt8());
            return value;
        }
    } ]), TerrainBuffer;
}(), TerrainLayerInfo = function TerrainLayerInfo() {
    _classCallCheck(this, TerrainLayerInfo), this.slot = 0, this.tileSize = 1, this.detailMap = "";
}, TerrainAsset = ccclass("cc.TerrainAsset")(_class$1W = function(_Asset) {
    function TerrainAsset() {
        var _this;
        return _classCallCheck(this, TerrainAsset), (_this = _possibleConstructorReturn(this, _getPrototypeOf(TerrainAsset).call(this)))._data = null, 
        _this._tileSize = 1, _this._blockCount = [ 1, 1 ], _this._weightMapSize = 128, _this._lightMapSize = 128, 
        _this._heights = new Uint16Array, _this._weights = new Uint8Array, _this._layerBuffer = [ -1, -1, -1, -1 ], 
        _this._layerInfos = [], _this.loaded = !1, _this;
    }
    return _inherits(TerrainAsset, Asset), _createClass(TerrainAsset, [ {
        key: "getLayer",
        value: function getLayer(xBlock, yBlock, layerId) {
            var index = 4 * (yBlock * this.blockCount[0] + xBlock) + layerId;
            return xBlock < this.blockCount[0] && yBlock < this.blockCount[1] && index < this._layerBuffer.length ? this._layerBuffer[index] : -1;
        }
    }, {
        key: "_setNativeData",
        value: function _setNativeData(_nativeData) {
            this._data = _nativeData;
        }
    }, {
        key: "_loadNativeData",
        value: function _loadNativeData(_nativeData) {
            var stream = new TerrainBuffer;
            stream.assign(_nativeData);
            var version = stream.readInt();
            if (16843025 === version) return !0;
            if (16842753 !== version && 16842754 !== version && 16842755 !== version) return !1;
            this.tileSize = stream.readFloat(), stream.readIntArray(this._blockCount), this.weightMapSize = stream.readInt16(), 
            this.lightMapSize = stream.readInt16();
            var heightBufferSize = stream.readInt();
            this.heights = new Uint16Array(heightBufferSize);
            for (var i = 0; i < this.heights.length; ++i) this.heights[i] = stream.readInt16();
            var WeightBufferSize = stream.readInt();
            this.weights = new Uint8Array(WeightBufferSize);
            for (var _i = 0; _i < this.weights.length; ++_i) this.weights[_i] = stream.readInt8();
            if (version >= 16842754) {
                var layerBufferSize = stream.readInt();
                this.layerBuffer = new Array(layerBufferSize);
                for (var _i2 = 0; _i2 < this.layerBuffer.length; ++_i2) this.layerBuffer[_i2] = stream.readInt16();
            }
            if (version >= 16842755) {
                var layerInfoSize = stream.readInt();
                this.layerInfos = new Array(layerInfoSize);
                for (var _i3 = 0; _i3 < this.layerInfos.length; ++_i3) this.layerInfos[_i3] = new TerrainLayerInfo, 
                this.layerInfos[_i3].slot = stream.readInt(), this.layerInfos[_i3].tileSize = stream.readFloat(), 
                this.layerInfos[_i3].detailMap = stream.readString();
            }
            return !0;
        }
    }, {
        key: "_exportNativeData",
        value: function _exportNativeData() {
            var stream = new TerrainBuffer;
            stream.writeInt32(16842755), stream.writeFloat(this.tileSize), stream.writeIntArray(this._blockCount), 
            stream.writeInt16(this.weightMapSize), stream.writeInt16(this.lightMapSize), stream.writeInt32(this.heights.length);
            for (var i = 0; i < this.heights.length; ++i) stream.writeInt16(this.heights[i]);
            stream.writeInt32(this.weights.length);
            for (var _i4 = 0; _i4 < this.weights.length; ++_i4) stream.writeInt8(this.weights[_i4]);
            stream.writeInt32(this.layerBuffer.length);
            for (var _i5 = 0; _i5 < this.layerBuffer.length; ++_i5) stream.writeInt16(this.layerBuffer[_i5]);
            stream.writeInt32(this.layerInfos.length);
            for (var _i6 = 0; _i6 < this.layerInfos.length; ++_i6) stream.writeInt32(this.layerInfos[_i6].slot), 
            stream.writeFloat(this.layerInfos[_i6].tileSize), stream.writeString(this.layerInfos[_i6].detailMap);
            return stream.buffer;
        }
    }, {
        key: "_exportDefaultNativeData",
        value: function _exportDefaultNativeData() {
            var stream = new TerrainBuffer;
            return stream.writeInt32(16843025), stream.buffer;
        }
    }, {
        key: "_nativeAsset",
        get: function get() {
            return this._data.buffer;
        },
        set: function set(value) {
            this._data && this._data.byteLength === value.byteLength ? (this._data.set(new Uint8Array(value)), 
            cc.loader._cache[this.nativeUrl] && (cc.loader._cache[this.nativeUrl].content = this._data.buffer)) : this._data = new Uint8Array(value), 
            this._loadNativeData(this._data), this.loaded = !0, this.emit("load");
        }
    }, {
        key: "tileSize",
        set: function set(value) {
            this._tileSize = value;
        },
        get: function get() {
            return this._tileSize;
        }
    }, {
        key: "blockCount",
        set: function set(value) {
            this._blockCount = value;
        },
        get: function get() {
            return this._blockCount;
        }
    }, {
        key: "lightMapSize",
        set: function set(value) {
            this._lightMapSize = value;
        },
        get: function get() {
            return this._lightMapSize;
        }
    }, {
        key: "weightMapSize",
        set: function set(value) {
            this._weightMapSize = value;
        },
        get: function get() {
            return this._weightMapSize;
        }
    }, {
        key: "heights",
        set: function set(value) {
            this._heights = value;
        },
        get: function get() {
            return this._heights;
        }
    }, {
        key: "weights",
        set: function set(value) {
            this._weights = value;
        },
        get: function get() {
            return this._weights;
        }
    }, {
        key: "layerBuffer",
        set: function set(value) {
            this._layerBuffer = value;
        },
        get: function get() {
            return this._layerBuffer;
        }
    }, {
        key: "layerInfos",
        set: function set(value) {
            this._layerInfos = value;
        },
        get: function get() {
            return this._layerInfos;
        }
    } ]), TerrainAsset;
}()) || _class$1W, TerrainInfo = ccclass("cc.TerrainInfo")((_descriptor$1z = _applyDecoratedDescriptor((_class2$1K = function() {
    function TerrainInfo() {
        _classCallCheck(this, TerrainInfo), _initializerDefineProperty(this, "tileSize", _descriptor$1z, this), 
        _initializerDefineProperty(this, "blockCount", _descriptor2$1j, this), _initializerDefineProperty(this, "weightMapSize", _descriptor3$16, this), 
        _initializerDefineProperty(this, "lightMapSize", _descriptor4$X, this);
    }
    return _createClass(TerrainInfo, [ {
        key: "size",
        get: function get() {
            var sz = new Size(0, 0);
            return sz.width = 32 * this.blockCount[0] * this.tileSize, sz.height = 32 * this.blockCount[1] * this.tileSize, 
            sz;
        }
    }, {
        key: "tileCount",
        get: function get() {
            var _tileCount = [ 0, 0 ];
            return _tileCount[0] = 32 * this.blockCount[0], _tileCount[1] = 32 * this.blockCount[1], 
            _tileCount;
        }
    }, {
        key: "vertexCount",
        get: function get() {
            var _vertexCount = this.tileCount;
            return _vertexCount[0] += 1, _vertexCount[1] += 1, _vertexCount;
        }
    } ]), TerrainInfo;
}()).prototype, "tileSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _descriptor2$1j = _applyDecoratedDescriptor(_class2$1K.prototype, "blockCount", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [ 1, 1 ];
    }
}), _descriptor3$16 = _applyDecoratedDescriptor(_class2$1K.prototype, "weightMapSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 128;
    }
}), _descriptor4$X = _applyDecoratedDescriptor(_class2$1K.prototype, "lightMapSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 128;
    }
}), _class$1X = _class2$1K)) || _class$1X, TerrainLayer = ccclass("cc.TerrainLayer")((_descriptor5$K = _applyDecoratedDescriptor((_class5$b = function TerrainLayer() {
    _classCallCheck(this, TerrainLayer), _initializerDefineProperty(this, "detailMap", _descriptor5$K, this), 
    _initializerDefineProperty(this, "tileSize", _descriptor6$x, this);
}).prototype, "detailMap", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor6$x = _applyDecoratedDescriptor(_class5$b.prototype, "tileSize", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 1;
    }
}), _class4$d = _class5$b)) || _class4$d, TerrainRenderable = function(_RenderableComponent) {
    function TerrainRenderable() {
        var _getPrototypeOf2, _this;
        _classCallCheck(this, TerrainRenderable);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        return (_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TerrainRenderable)).call.apply(_getPrototypeOf2, [ this ].concat(args))))._model = null, 
        _this._meshData = null, _this._brushMaterial = null, _this._currentMaterial = null, 
        _this._currentMaterialLayers = 0, _this;
    }
    return _inherits(TerrainRenderable, RenderableComponent), _createClass(TerrainRenderable, [ {
        key: "destroy",
        value: function destroy() {
            null != this._model && (cc.director.root.destroyModel(this._model), this._model = null), 
            _get(_getPrototypeOf(TerrainRenderable.prototype), "destroy", this).call(this);
        }
    }, {
        key: "_invalidMaterial",
        value: function _invalidMaterial() {
            null != this._currentMaterial && (this._clearMaterials(), this._currentMaterial = null, 
            null != this._model && (this._model.enabled = !1));
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial(block, init) {
            if (null != this._meshData && null != this._model) {
                var nLayers = block.getMaxLayer();
                if (null == this._currentMaterial || nLayers !== this._currentMaterialLayers) {
                    if (this._currentMaterial = new Material, this._currentMaterial.initialize({
                        effectAsset: cc.EffectAsset.get("builtin-terrain"),
                        defines: block._getMaterialDefines(nLayers)
                    }), null !== this._brushMaterial) this._currentMaterial.passes.push(this._brushMaterial.passes[0]);
                    init && this._model.initSubModel(0, this._meshData, this._currentMaterial), this.setMaterial(this._currentMaterial, 0), 
                    this._currentMaterialLayers = nLayers, this._model.enabled = !0;
                }
            }
        }
    }, {
        key: "_onMaterialModified",
        value: function _onMaterialModified(idx, mtl) {
            null != this._model && this._onRebuildPSO(idx, mtl || this._getBuiltinMaterial());
        }
    }, {
        key: "_onRebuildPSO",
        value: function _onRebuildPSO(idx, material) {
            this._model && this._model.setSubModelMaterial(idx, material);
        }
    }, {
        key: "_clearMaterials",
        value: function _clearMaterials() {
            null != this._model && this._onMaterialModified(0, null);
        }
    }, {
        key: "_getBuiltinMaterial",
        value: function _getBuiltinMaterial() {
            return builtinResMgr.get("missing-material");
        }
    } ]), TerrainRenderable;
}(), TerrainBlockInfo = ccclass("cc.TerrainBlockInfo")((_descriptor7$s = _applyDecoratedDescriptor((_class8$3 = function TerrainBlockInfo() {
    _classCallCheck(this, TerrainBlockInfo), _initializerDefineProperty(this, "layers", _descriptor7$s, this);
}).prototype, "layers", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [ -1, -1, -1, -1 ];
    }
}), _class7$3 = _class8$3)) || _class7$3, TerrainBlockLightmapInfo = ccclass("cc.TerrainBlockLightmapInfo")((_descriptor8$n = _applyDecoratedDescriptor((_class11$2 = function TerrainBlockLightmapInfo() {
    _classCallCheck(this, TerrainBlockLightmapInfo), _initializerDefineProperty(this, "texture", _descriptor8$n, this), 
    _initializerDefineProperty(this, "UOff", _descriptor9$j, this), _initializerDefineProperty(this, "VOff", _descriptor10$i, this), 
    _initializerDefineProperty(this, "UScale", _descriptor11$e, this), _initializerDefineProperty(this, "VScale", _descriptor12$d, this);
}).prototype, "texture", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor9$j = _applyDecoratedDescriptor(_class11$2.prototype, "UOff", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor10$i = _applyDecoratedDescriptor(_class11$2.prototype, "VOff", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor11$e = _applyDecoratedDescriptor(_class11$2.prototype, "UScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _descriptor12$d = _applyDecoratedDescriptor(_class11$2.prototype, "VScale", [ property ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return 0;
    }
}), _class10$2 = _class11$2)) || _class10$2, TerrainBlock = function() {
    function TerrainBlock(t, i, j) {
        _classCallCheck(this, TerrainBlock), this._terrain = void 0, this._info = void 0, 
        this._node = void 0, this._renderable = void 0, this._index = [ 1, 1 ], this._weightMap = null, 
        this._lightmapInfo = null, this._terrain = t, this._info = t.getBlockInfo(i, j), 
        this._index[0] = i, this._index[1] = j, this._lightmapInfo = t._getLightmapInfo(i, j), 
        this._node = new PrivateNode(""), this._node.setParent(this._terrain.node), this._node._objFlags |= cc.Object.Flags.DontSave, 
        this._renderable = this._node.addComponent(TerrainRenderable);
    }
    return _createClass(TerrainBlock, [ {
        key: "build",
        value: function build() {
            for (var gfxDevice = director.root.device, vertexData = new Float32Array(8712), index = 0, j = 0; j < 33; ++j) for (var i = 0; i < 33; ++i) {
                var x = 32 * this._index[0] + i, y = 32 * this._index[1] + j, position = this._terrain.getPosition(x, y), normal = this._terrain.getNormal(x, y), uv = new Vec2(i / 32, j / 32);
                vertexData[index++] = position.x, vertexData[index++] = position.y, vertexData[index++] = position.z, 
                vertexData[index++] = normal.x, vertexData[index++] = normal.y, vertexData[index++] = normal.z, 
                vertexData[index++] = uv.x, vertexData[index++] = uv.y;
            }
            var vertexBuffer = gfxDevice.createBuffer({
                usage: exports.GFXBufferUsageBit.VERTEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 8 * Float32Array.BYTES_PER_ELEMENT * 33 * 33,
                stride: 8 * Float32Array.BYTES_PER_ELEMENT
            });
            vertexBuffer.update(vertexData);
            var gfxAttributes = [ {
                name: exports.GFXAttributeName.ATTR_POSITION,
                format: exports.GFXFormat.RGB32F
            }, {
                name: exports.GFXAttributeName.ATTR_NORMAL,
                format: exports.GFXFormat.RGB32F
            }, {
                name: exports.GFXAttributeName.ATTR_TEX_COORD,
                format: exports.GFXFormat.RG32F
            } ];
            (this._renderable._meshData = new RenderingSubMesh([ vertexBuffer ], gfxAttributes, exports.GFXPrimitiveMode.TRIANGLE_LIST)).indexBuffer = this._terrain._getSharedIndexBuffer() || void 0, 
            this._renderable._model = cc.director.root.createModel(Model), this._renderable._model.initialize(this._node), 
            this._renderable._getRenderScene().addModel(this._renderable._model), this._updateWeightMap(), 
            this._updateMaterial(!0);
        }
    }, {
        key: "rebuild",
        value: function rebuild() {
            this._updateHeight(), this._updateWeightMap(), this._renderable._invalidMaterial(), 
            this._updateMaterial(!1);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            null != this._renderable && this._renderable.destroy(), null != this._node && this._node.destroy(), 
            null != this._weightMap && this._weightMap.destroy();
        }
    }, {
        key: "update",
        value: function update() {
            this._updateMaterial(!1);
            var mtl = this._renderable._currentMaterial;
            if (null != mtl) {
                var nlayers = this.getMaxLayer(), uvScale = new Vec4(1, 1, 1, 1);
                if (0 === nlayers) if (-1 !== this.layers[0]) {
                    var l0 = this._terrain.getLayer(this.layers[0]);
                    null != l0 && (uvScale.x = 1 / l0.tileSize), mtl.setProperty("detailMap0", null != l0 ? l0.detailMap : null);
                } else mtl.setProperty("detailMap0", cc.builtinResMgr.get("default-texture")); else if (1 === nlayers) {
                    var _l = this._terrain.getLayer(this.layers[0]), l1 = this._terrain.getLayer(this.layers[1]);
                    null != _l && (uvScale.x = 1 / _l.tileSize), null != l1 && (uvScale.y = 1 / l1.tileSize), 
                    mtl.setProperty("weightMap", this._weightMap), mtl.setProperty("detailMap0", null != _l ? _l.detailMap : null), 
                    mtl.setProperty("detailMap1", null != l1 ? l1.detailMap : null);
                } else if (2 === nlayers) {
                    var _l2 = this._terrain.getLayer(this.layers[0]), _l3 = this._terrain.getLayer(this.layers[1]), l2 = this._terrain.getLayer(this.layers[2]);
                    null != _l2 && (uvScale.x = 1 / _l2.tileSize), null != _l3 && (uvScale.y = 1 / _l3.tileSize), 
                    null != l2 && (uvScale.z = 1 / l2.tileSize), mtl.setProperty("weightMap", this._weightMap), 
                    mtl.setProperty("detailMap0", null != _l2 ? _l2.detailMap : null), mtl.setProperty("detailMap1", null != _l3 ? _l3.detailMap : null), 
                    mtl.setProperty("detailMap2", null != l2 ? l2.detailMap : null);
                } else if (3 === nlayers) {
                    var _l4 = this._terrain.getLayer(this.layers[0]), _l5 = this._terrain.getLayer(this.layers[1]), _l6 = this._terrain.getLayer(this.layers[2]), l3 = this._terrain.getLayer(this.layers[3]);
                    null != _l4 && (uvScale.x = 1 / _l4.tileSize), null != _l5 && (uvScale.y = 1 / _l5.tileSize), 
                    null != _l6 && (uvScale.z = 1 / _l6.tileSize), null != l3 && (uvScale.z = 1 / l3.tileSize), 
                    mtl.setProperty("weightMap", this._weightMap), mtl.setProperty("detailMap0", null != _l4 ? _l4.detailMap : null), 
                    mtl.setProperty("detailMap1", null != _l5 ? _l5.detailMap : null), mtl.setProperty("detailMap2", null != _l6 ? _l6.detailMap : null), 
                    mtl.setProperty("detailMap3", null != l3 ? l3.detailMap : null);
                }
                mtl.setProperty("UVScale", uvScale), null != this.lightmap && (mtl.setProperty("lightMap", this.lightmap), 
                mtl.setProperty("lightMapUVParam", this.lightmapUVParam));
            }
        }
    }, {
        key: "setBrushMaterial",
        value: function setBrushMaterial(mtl) {
            this._renderable._brushMaterial !== mtl && (this._renderable._brushMaterial = mtl, 
            this._renderable._invalidMaterial());
        }
    }, {
        key: "getTerrain",
        value: function getTerrain() {
            return this._terrain;
        }
    }, {
        key: "getIndex",
        value: function getIndex() {
            return this._index;
        }
    }, {
        key: "getRect",
        value: function getRect() {
            var rect = new Rect;
            return rect.x = 32 * this._index[0], rect.y = 32 * this._index[1], rect.width = 32, 
            rect.height = 32, rect;
        }
    }, {
        key: "setLayer",
        value: function setLayer(index, layerId) {
            this.layers[index] !== layerId && (this.layers[index] = layerId, this._renderable._invalidMaterial(), 
            this._updateMaterial(!1));
        }
    }, {
        key: "getLayer",
        value: function getLayer(index) {
            return this.layers[index];
        }
    }, {
        key: "getMaxLayer",
        value: function getMaxLayer() {
            return this.layers[3] >= 0 ? 3 : this.layers[2] >= 0 ? 2 : this.layers[1] >= 0 ? 1 : 0;
        }
    }, {
        key: "_getMaterialDefines",
        value: function _getMaterialDefines(nlayers) {
            if (null != this.lightmap) {
                if (0 === nlayers) return {
                    LAYERS: 1,
                    LIGHT_MAP: 1
                };
                if (1 === nlayers) return {
                    LAYERS: 2,
                    LIGHT_MAP: 1
                };
                if (2 === nlayers) return {
                    LAYERS: 3,
                    LIGHT_MAP: 1
                };
                if (3 === nlayers) return {
                    LAYERS: 4,
                    LIGHT_MAP: 1
                };
            } else {
                if (0 === nlayers) return {
                    LAYERS: 1
                };
                if (1 === nlayers) return {
                    LAYERS: 2
                };
                if (2 === nlayers) return {
                    LAYERS: 3
                };
                if (3 === nlayers) return {
                    LAYERS: 4
                };
            }
            return {
                LAYERS: 0
            };
        }
    }, {
        key: "_invalidMaterial",
        value: function _invalidMaterial() {
            this._renderable._invalidMaterial();
        }
    }, {
        key: "_updateMaterial",
        value: function _updateMaterial(init) {
            this._renderable._updateMaterial(this, init);
        }
    }, {
        key: "_updateHeight",
        value: function _updateHeight() {
            if (null != this._renderable._meshData) {
                for (var vertexData = new Float32Array(8712), index = 0, j = 0; j < 33; ++j) for (var i = 0; i < 33; ++i) {
                    var x = 32 * this._index[0] + i, y = 32 * this._index[1] + j, position = this._terrain.getPosition(x, y), normal = this._terrain.getNormal(x, y), uv = new Vec2(i / 33, j / 33);
                    vertexData[index++] = position.x, vertexData[index++] = position.y, vertexData[index++] = position.z, 
                    vertexData[index++] = normal.x, vertexData[index++] = normal.y, vertexData[index++] = normal.z, 
                    vertexData[index++] = uv.x, vertexData[index++] = uv.y;
                }
                this._renderable._meshData.vertexBuffers[0].update(vertexData);
            }
        }
    }, {
        key: "_updateWeightMap",
        value: function _updateWeightMap() {
            if (0 !== this.getMaxLayer()) {
                null == this._weightMap && (this._weightMap = new Texture2D, this._weightMap.create(this._terrain.weightMapSize, this._terrain.weightMapSize, PixelFormat.RGBA8888), 
                this._weightMap.setFilters(Filter.LINEAR, Filter.LINEAR), this._weightMap.setWrapMode(WrapMode$1.CLAMP_TO_EDGE, WrapMode$1.CLAMP_TO_EDGE));
                for (var weightData = new Uint8Array(this._terrain.weightMapSize * this._terrain.weightMapSize * 4), weightIndex = 0, j = 0; j < this._terrain.weightMapSize; ++j) for (var i = 0; i < this._terrain.weightMapSize; ++i) {
                    var x = this._index[0] * this._terrain.weightMapSize + i, y = this._index[1] * this._terrain.weightMapSize + j, w = this._terrain.getWeight(x, y);
                    weightData[4 * weightIndex + 0] = Math.floor(255 * w.x), weightData[4 * weightIndex + 1] = Math.floor(255 * w.y), 
                    weightData[4 * weightIndex + 2] = Math.floor(255 * w.z), weightData[4 * weightIndex + 3] = Math.floor(255 * w.w), 
                    weightIndex += 1;
                }
                this._weightMap.uploadData(weightData);
            } else null != this._weightMap && (this._weightMap.destroy(), this._weightMap = null);
        }
    }, {
        key: "_updateLightmap",
        value: function _updateLightmap(info) {
            this._lightmapInfo = info, this._invalidMaterial();
        }
    }, {
        key: "layers",
        get: function get() {
            return this._info.layers;
        }
    }, {
        key: "lightmap",
        get: function get() {
            return this._lightmapInfo ? this._lightmapInfo.texture : null;
        }
    }, {
        key: "lightmapUVParam",
        get: function get() {
            return null != this._lightmapInfo ? new Vec4(this._lightmapInfo.UOff, this._lightmapInfo.VOff, this._lightmapInfo.UScale, this._lightmapInfo.VScale) : new Vec4(0, 0, 0, 0);
        }
    } ]), TerrainBlock;
}(), Terrain = (_dec5$10 = ccclass("cc.Terrain"), _dec6$V = help("i18n:cc.TerrainComponent"), 
_dec7$L = property({
    type: TerrainAsset,
    visible: !1,
    animatable: !1
}), _dec8$F = property({
    type: TerrainLayer,
    visible: !0,
    animatable: !1
}), _dec9$v = property({
    visible: !1,
    animatable: !1
}), _dec10$n = property({
    visible: !1,
    animatable: !1
}), _dec11$m = property({
    type: TerrainAsset,
    visible: !0
}), _dec12$l = property({
    type: TerrainInfo,
    visible: !0
}), _dec5$10(_class13$1 = _dec6$V(_class13$1 = executeInEditMode(_class13$1 = disallowMultiple((_descriptor13$c = _applyDecoratedDescriptor((_class14$1 = function(_Component) {
    function Terrain() {
        var _this2;
        _classCallCheck(this, Terrain), _initializerDefineProperty(_this2 = _possibleConstructorReturn(this, _getPrototypeOf(Terrain).call(this)), "__asset", _descriptor13$c, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_layers", _descriptor14$a, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_blockInfos", _descriptor15$6, _assertThisInitialized(_this2)), 
        _initializerDefineProperty(_this2, "_lightmapInfos", _descriptor16$6, _assertThisInitialized(_this2)), 
        _this2._tileSize = 1, _this2._blockCount = [ 1, 1 ], _this2._weightMapSize = 128, 
        _this2._lightMapSize = 128, _this2._heights = new Uint16Array, _this2._weights = new Uint8Array, 
        _this2._normals = [], _this2._blocks = [], _this2._sharedIndexBuffer = null;
        for (var i = 0; i < 256; ++i) _this2._layers.push(null);
        return _this2;
    }
    return _inherits(Terrain, Component), _createClass(Terrain, [ {
        key: "build",
        value: function build(info) {
            return this._tileSize = info.tileSize, this._blockCount[0] = info.blockCount[0], 
            this._blockCount[1] = info.blockCount[1], this._weightMapSize = info.weightMapSize, 
            this._lightMapSize = info.lightMapSize, this._buildImp();
        }
    }, {
        key: "rebuild",
        value: function rebuild(info) {
            for (var blockInfos = [], i = 0; i < info.blockCount[0] * info.blockCount[1]; ++i) blockInfos.push(new TerrainBlockInfo);
            for (var w = Math.min(this._blockCount[0], info.blockCount[0]), h = Math.min(this._blockCount[1], info.blockCount[1]), j = 0; j < h; ++j) for (var _i2 = 0; _i2 < w; ++_i2) {
                var index0 = j * info.blockCount[0] + _i2, index1 = j * this.blockCount[0] + _i2;
                blockInfos[index0] = this._blockInfos[index1];
            }
            this._blockInfos = blockInfos;
            for (var _step, _iterator = _createForOfIteratorHelperLoose(this._blocks); !(_step = _iterator()).done; ) {
                _step.value.destroy();
            }
            this._blocks = [], this._rebuildHeights(info), this._rebuildWeights(info), this._tileSize = info.tileSize, 
            this._blockCount[0] = info.blockCount[0], this._blockCount[1] = info.blockCount[1], 
            this._weightMapSize = info.weightMapSize, this._lightMapSize = info.lightMapSize, 
            this._buildNormals();
            for (var _j2 = 0; _j2 < this._blockCount[1]; ++_j2) for (var _i3 = 0; _i3 < this._blockCount[0]; ++_i3) this._blocks.push(new TerrainBlock(this, _i3, _j2));
            for (var _step2, _iterator2 = _createForOfIteratorHelperLoose(this._blocks); !(_step2 = _iterator2()).done; ) {
                _step2.value.build();
            }
        }
    }, {
        key: "importHeightField",
        value: function importHeightField(hf, heightScale) {
            for (var index = 0, j = 0; j < this.vertexCount[1]; ++j) for (var i = 0; i < this.vertexCount[0]; ++i) {
                var u = i / this.tileCount[0], v = j / this.tileCount[1], h = hf.getAt(u * hf.w, v * hf.h) * heightScale;
                this._heights[index++] = h;
            }
            this._buildNormals();
            for (var _step3, _iterator3 = _createForOfIteratorHelperLoose(this._blocks); !(_step3 = _iterator3()).done; ) {
                _step3.value._updateHeight();
            }
        }
    }, {
        key: "exportHeightField",
        value: function exportHeightField(hf, heightScale) {
            for (var index = 0, j = 0; j < hf.h; ++j) for (var i = 0; i < hf.w; ++i) {
                var u = i / (hf.w - 1), v = j / (hf.h - 1), x = u * this.size.width, y = v * this.size.height, h = this.getHeightAt(x, y);
                null != h && (hf.data[index++] = h * heightScale);
            }
        }
    }, {
        key: "exportAsset",
        value: function exportAsset() {
            var asset = new TerrainAsset;
            asset.tileSize = this.tileSize, asset.blockCount = this.blockCount, asset.lightMapSize = this.lightMapSize, 
            asset.weightMapSize = this.weightMapSize, asset.heights = this.heights, asset.weights = this.weights, 
            asset.layerBuffer = new Array(4 * this._blocks.length);
            for (var i = 0; i < this._blocks.length; ++i) asset.layerBuffer[4 * i + 0] = this._blocks[i].layers[0], 
            asset.layerBuffer[4 * i + 1] = this._blocks[i].layers[1], asset.layerBuffer[4 * i + 2] = this._blocks[i].layers[2], 
            asset.layerBuffer[4 * i + 3] = this._blocks[i].layers[3];
            for (var _i6 = 0; _i6 < this._layers.length; ++_i6) {
                var temp = this._layers[_i6];
                if (temp && temp.detailMap && isValid(temp.detailMap)) {
                    var layer = new TerrainLayerInfo;
                    layer.slot = _i6, layer.tileSize = temp.tileSize, layer.detailMap = temp.detailMap._uuid, 
                    asset.layerInfos.push(layer);
                }
            }
            return asset;
        }
    }, {
        key: "onLoad",
        value: function onLoad() {
            for (var gfxDevice = cc.director.root.device, indexData = new Uint16Array(6144), index = 0, j = 0; j < 32; ++j) for (var i = 0; i < 32; ++i) {
                var a = 33 * j + i, b = 33 * j + i + 1, c = 33 * (j + 1) + i, d = 33 * (j + 1) + i + 1;
                indexData[index++] = a, indexData[index++] = c, indexData[index++] = b, indexData[index++] = b, 
                indexData[index++] = c, indexData[index++] = d;
            }
            this._sharedIndexBuffer = gfxDevice.createBuffer({
                usage: exports.GFXBufferUsageBit.INDEX | exports.GFXBufferUsageBit.TRANSFER_DST,
                memUsage: exports.GFXMemoryUsageBit.HOST | exports.GFXMemoryUsageBit.DEVICE,
                size: 32 * Uint16Array.BYTES_PER_ELEMENT * 32 * 6,
                stride: Uint16Array.BYTES_PER_ELEMENT
            }), this._sharedIndexBuffer.update(indexData);
        }
    }, {
        key: "onEnable",
        value: function onEnable() {
            0 === this._blocks.length && this._buildImp();
        }
    }, {
        key: "onDisable",
        value: function onDisable() {
            for (var _step4, _iterator4 = _createForOfIteratorHelperLoose(this._blocks); !(_step4 = _iterator4()).done; ) {
                _step4.value.destroy();
            }
            this._blocks = [];
        }
    }, {
        key: "onDestroy",
        value: function onDestroy() {
            for (var i = 0; i < this._layers.length; ++i) this._layers[i] = null;
            null != this._sharedIndexBuffer && this._sharedIndexBuffer.destroy();
        }
    }, {
        key: "onRestore",
        value: function onRestore() {
            this.onDisable(), this.onLoad(), this._buildImp(!0);
        }
    }, {
        key: "update",
        value: function update(deltaTime) {
            for (var _step5, _iterator5 = _createForOfIteratorHelperLoose(this._blocks); !(_step5 = _iterator5()).done; ) {
                _step5.value.update();
            }
        }
    }, {
        key: "addLayer",
        value: function addLayer(layer) {
            for (var i = 0; i < this._layers.length; ++i) if (null == this._layers[i]) return this._layers[i] = layer, 
            i;
            return -1;
        }
    }, {
        key: "setLayer",
        value: function setLayer(i, layer) {
            this._layers[i] = layer;
        }
    }, {
        key: "removeLayer",
        value: function removeLayer(id) {
            this._layers[id] = null;
        }
    }, {
        key: "getLayer",
        value: function getLayer(id) {
            return -1 === id ? null : this._layers[id];
        }
    }, {
        key: "getPosition",
        value: function getPosition(i, j) {
            var x = i * this._tileSize, z = j * this._tileSize, y = this.getHeight(i, j);
            return new Vec3(x, y, z);
        }
    }, {
        key: "getHeightField",
        value: function getHeightField() {
            return this._heights;
        }
    }, {
        key: "setHeight",
        value: function setHeight(i, j, h) {
            h = clamp(h, -64, 1 / 512 * 32767), this._heights[j * this.vertexCount[0] + i] = 32768 + h / (1 / 512);
        }
    }, {
        key: "getHeight",
        value: function getHeight(i, j) {
            return (this._heights[j * this.vertexCount[0] + i] - 32768) * (1 / 512);
        }
    }, {
        key: "getHeightClamp",
        value: function getHeightClamp(i, j) {
            return i = clamp(i, 0, this.vertexCount[0] - 1), j = clamp(j, 0, this.vertexCount[1] - 1), 
            this.getHeight(i, j);
        }
    }, {
        key: "getHeightAt",
        value: function getHeightAt(x, y) {
            var fx = x / this.tileSize, fy = y / this.tileSize, ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
            if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) return null;
            ix0 = clamp(ix0, 0, this.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this.vertexCount[1] - 1), 
            ix1 = clamp(ix1, 0, this.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this.vertexCount[1] - 1);
            var a = this.getHeight(ix0, iz0), b = this.getHeight(ix1, iz0), c = this.getHeight(ix0, iz1), d = this.getHeight(ix1, iz1), m = .5 * (b + c);
            return dx + dz <= 1 ? d = m + (m - a) : a = m + (m - d), (a * (1 - dx) + b * dx) * (1 - dz) + (c * (1 - dx) + d * dx) * dz;
        }
    }, {
        key: "_setNormal",
        value: function _setNormal(i, j, n) {
            var index = j * this.vertexCount[0] + i;
            this._normals[3 * index + 0] = n.x, this._normals[3 * index + 1] = n.y, this._normals[3 * index + 2] = n.z;
        }
    }, {
        key: "getNormal",
        value: function getNormal(i, j) {
            var index = j * this.vertexCount[0] + i, n = new Vec3;
            return n.x = this._normals[3 * index + 0], n.y = this._normals[3 * index + 1], n.z = this._normals[3 * index + 2], 
            n;
        }
    }, {
        key: "getNormalAt",
        value: function getNormalAt(x, y) {
            var fx = x / this.tileSize, fy = y / this.tileSize, ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
            if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) return null;
            ix0 = clamp(ix0, 0, this.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this.vertexCount[1] - 1), 
            ix1 = clamp(ix1, 0, this.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this.vertexCount[1] - 1);
            var a = this.getNormal(ix0, iz0), b = this.getNormal(ix1, iz0), c = this.getNormal(ix0, iz1), d = this.getNormal(ix1, iz1), m = new Vec3;
            Vec3.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d.set(m), d.subtract(a), d.add(m)) : (a.set(m), 
            a.subtract(d), a.add(m));
            var n1 = new Vec3, n2 = new Vec3, n = new Vec3;
            return Vec3.lerp(n1, a, b, dx), Vec3.lerp(n2, c, d, dx), Vec3.lerp(n, n1, n2, dz), 
            n;
        }
    }, {
        key: "setWeight",
        value: function setWeight(i, j, w) {
            var index = j * this._weightMapSize * this._blockCount[0] + i;
            this._weights[4 * index + 0] = 255 * w.x, this._weights[4 * index + 1] = 255 * w.y, 
            this._weights[4 * index + 2] = 255 * w.z, this._weights[4 * index + 3] = 255 * w.w;
        }
    }, {
        key: "getWeight",
        value: function getWeight(i, j) {
            var index = j * this._weightMapSize * this._blockCount[0] + i, w = new Vec4;
            return w.x = this._weights[4 * index + 0] / 255, w.y = this._weights[4 * index + 1] / 255, 
            w.z = this._weights[4 * index + 2] / 255, w.w = this._weights[4 * index + 3] / 255, 
            w;
        }
    }, {
        key: "getWeightAt",
        value: function getWeightAt(x, y) {
            var fx = x / this.tileSize, fy = y / this.tileSize, ix0 = Math.floor(fx), iz0 = Math.floor(fy), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = fx - ix0, dz = fy - iz0;
            if (ix0 < 0 || ix0 > this.vertexCount[0] - 1 || iz0 < 0 || iz0 > this.vertexCount[1] - 1) return null;
            ix0 = clamp(ix0, 0, this.vertexCount[0] - 1), iz0 = clamp(iz0, 0, this.vertexCount[1] - 1), 
            ix1 = clamp(ix1, 0, this.vertexCount[0] - 1), iz1 = clamp(iz1, 0, this.vertexCount[1] - 1);
            var a = this.getWeight(ix0, iz0), b = this.getWeight(ix1, iz0), c = this.getWeight(ix0, iz1), d = this.getWeight(ix1, iz1), m = new Vec4;
            Vec4.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d = new Vec4, Vec4.subtract(d, m, a).add(m)) : (a = new Vec4, 
            Vec4.subtract(a, m, d).add(m));
            var n1 = new Vec4, n2 = new Vec4, n = new Vec4;
            return Vec4.lerp(n1, a, b, dx), Vec4.lerp(n2, c, d, dx), Vec4.lerp(n, n1, n2, dz), 
            n;
        }
    }, {
        key: "getBlockInfo",
        value: function getBlockInfo(i, j) {
            return this._blockInfos[j * this._blockCount[0] + i];
        }
    }, {
        key: "getBlock",
        value: function getBlock(i, j) {
            return this._blocks[j * this._blockCount[0] + i];
        }
    }, {
        key: "getBlocks",
        value: function getBlocks() {
            return this._blocks;
        }
    }, {
        key: "rayCheck",
        value: function rayCheck(start, dir, step) {
            var worldSpace = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], MAX_COUNT = 2e3, trace = start;
            worldSpace && Vec3.subtract(trace, start, this.node.getWorldPosition());
            var delta = new Vec3;
            delta.set(dir), delta.multiplyScalar(step);
            var position = null;
            if (dir.equals(new Vec3(0, 1, 0))) {
                var y = this.getHeightAt(trace.x, trace.z);
                null != y && trace.y <= y && (position = new Vec3(trace.x, y, trace.z));
            } else if (dir.equals(new Vec3(0, -1, 0))) {
                var _y2 = this.getHeightAt(trace.x, trace.z);
                null != _y2 && trace.y >= _y2 && (position = new Vec3(trace.x, _y2, trace.z));
            } else {
                for (var i = 0; i++ < MAX_COUNT; ) {
                    var _y3 = this.getHeightAt(trace.x, trace.z);
                    if (null != _y3 && trace.y <= _y3) break;
                    trace.add(dir);
                }
                for (;i++ < MAX_COUNT; ) {
                    var _y4 = this.getHeightAt(trace.x, trace.z);
                    if (null != _y4 && trace.y <= _y4) {
                        position = new Vec3(trace.x, _y4, trace.z);
                        break;
                    }
                    trace.add(delta);
                }
            }
            return position;
        }
    }, {
        key: "_getSharedIndexBuffer",
        value: function _getSharedIndexBuffer() {
            return this._sharedIndexBuffer;
        }
    }, {
        key: "_resetLightmap",
        value: function _resetLightmap(enble) {
            if (this._lightmapInfos.length = 0, enble) for (var i = 0; i < this._blockCount[0] * this._blockCount[1]; ++i) this._lightmapInfos.push(new TerrainBlockLightmapInfo);
        }
    }, {
        key: "_updateLightmap",
        value: function _updateLightmap(blockId, tex, uOff, vOff, uScale, vScale) {
            this._lightmapInfos[blockId].texture = tex, this._lightmapInfos[blockId].UOff = uOff, 
            this._lightmapInfos[blockId].VOff = vOff, this._lightmapInfos[blockId].UScale = uScale, 
            this._lightmapInfos[blockId].VScale = vScale, this._blocks[blockId]._updateLightmap(this._lightmapInfos[blockId]);
        }
    }, {
        key: "_getLightmapInfo",
        value: function _getLightmapInfo(i, j) {
            var index = j * this._blockCount[0] + i;
            return index < this._lightmapInfos.length ? this._lightmapInfos[index] : null;
        }
    }, {
        key: "_calcNormal",
        value: function _calcNormal(x, z) {
            var right, up, flip = 1, here = this.getPosition(x, z);
            x < this.vertexCount[0] - 1 ? right = this.getPosition(x + 1, z) : (flip *= -1, 
            right = this.getPosition(x - 1, z)), z < this.vertexCount[1] - 1 ? up = this.getPosition(x, z + 1) : (flip *= -1, 
            up = this.getPosition(x, z - 1)), right.subtract(here), up.subtract(here);
            var normal = new Vec3;
            return normal.set(up), normal.cross(right), normal.multiplyScalar(flip), normal.normalize(), 
            normal;
        }
    }, {
        key: "_buildNormals",
        value: function _buildNormals() {
            for (var index = 0, y = 0; y < this.vertexCount[1]; ++y) for (var x = 0; x < this.vertexCount[0]; ++x) {
                var n = this._calcNormal(x, y);
                this._normals[3 * index + 0] = n.x, this._normals[3 * index + 1] = n.y, this._normals[3 * index + 2] = n.z, 
                index += 1;
            }
        }
    }, {
        key: "_buildImp",
        value: function _buildImp() {
            var _this3 = this, restore = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (this.valid) return !0;
            if (!restore && null != this.__asset) {
                this._tileSize = this.__asset.tileSize, this._blockCount = this.__asset.blockCount, 
                this._weightMapSize = this.__asset.weightMapSize, this._lightMapSize = this.__asset.lightMapSize, 
                this._heights = this.__asset.heights, this._weights = this.__asset.weights;
                for (var initial = !0, i = 0; i < this._layers.length; ++i) null != this._layers[i] && (initial = !1);
                if (initial && null != this._asset) for (var _step6, _loop = function _loop() {
                    var i = _step6.value, layer = new TerrainLayer;
                    layer.tileSize = i.tileSize, cc.loader.loadRes(i.detailMap, Texture2D, (function(err, asset) {
                        layer.detailMap = asset;
                    })), _this3._layers[i.slot] = layer;
                }, _iterator6 = _createForOfIteratorHelperLoose(this._asset.layerInfos); !(_step6 = _iterator6()).done; ) _loop();
            }
            if (0 === this._blockCount[0] || 0 === this._blockCount[1]) return !1;
            var vertexCount = this.vertexCount[0] * this.vertexCount[1];
            if (null === this._heights || this._heights.length !== vertexCount) {
                this._heights = new Uint16Array(vertexCount), this._normals = new Array(3 * vertexCount);
                for (var _i7 = 0; _i7 < vertexCount; ++_i7) this._heights[_i7] = 32768, this._normals[3 * _i7 + 0] = 0, 
                this._normals[3 * _i7 + 1] = 1, this._normals[3 * _i7 + 2] = 0;
            } else this._normals = new Array(3 * vertexCount), this._buildNormals();
            var weightMapComplexityU = this._weightMapSize * this._blockCount[0], weightMapComplexityV = this._weightMapSize * this._blockCount[1];
            if (this._weights.length !== weightMapComplexityU * weightMapComplexityV * 4) {
                this._weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4);
                for (var _i8 = 0; _i8 < weightMapComplexityU * weightMapComplexityV; ++_i8) this._weights[4 * _i8 + 0] = 255, 
                this._weights[4 * _i8 + 1] = 0, this._weights[4 * _i8 + 2] = 0, this._weights[4 * _i8 + 3] = 0;
            }
            if (this._blockInfos.length !== this._blockCount[0] * this._blockCount[1]) {
                this._blockInfos = [];
                for (var j = 0; j < this._blockCount[1]; ++j) for (var _i9 = 0; _i9 < this._blockCount[0]; ++_i9) {
                    var info = new TerrainBlockInfo;
                    null != this._asset && (info.layers[0] = this._asset.getLayer(_i9, j, 0), info.layers[1] = this._asset.getLayer(_i9, j, 1), 
                    info.layers[1] === info.layers[0] && (info.layers[1] = -1), info.layers[2] = this._asset.getLayer(_i9, j, 2), 
                    info.layers[2] === info.layers[0] && (info.layers[2] = -1), info.layers[3] = this._asset.getLayer(_i9, j, 3), 
                    info.layers[3] === info.layers[0] && (info.layers[3] = -1)), this._blockInfos.push(info);
                }
            }
            for (var _j3 = 0; _j3 < this._blockCount[1]; ++_j3) for (var _i10 = 0; _i10 < this._blockCount[0]; ++_i10) this._blocks.push(new TerrainBlock(this, _i10, _j3));
            for (var _step7, _iterator7 = _createForOfIteratorHelperLoose(this._blocks); !(_step7 = _iterator7()).done; ) {
                var _i11 = _step7.value;
                _i11.build();
            }
        }
    }, {
        key: "_rebuildHeights",
        value: function _rebuildHeights(info) {
            if (this.vertexCount[0] === info.vertexCount[0] && this.vertexCount[1] === info.vertexCount[1]) return !1;
            for (var heights = new Uint16Array(info.vertexCount[0] * info.vertexCount[1]), i = 0; i < heights.length; ++i) heights[i] = 32768;
            for (var w = Math.min(this.vertexCount[0], info.vertexCount[0]), h = Math.min(this.vertexCount[1], info.vertexCount[1]), j = 0; j < h; ++j) for (var _i12 = 0; _i12 < w; ++_i12) {
                var index0 = j * info.vertexCount[0] + _i12, index1 = j * this.vertexCount[0] + _i12;
                heights[index0] = this._heights[index1];
            }
            return this._heights = heights, !0;
        }
    }, {
        key: "_rebuildWeights",
        value: function _rebuildWeights(info) {
            var _this4 = this, oldWeightMapSize = this._weightMapSize, oldWeightMapComplexityU = this._weightMapSize * this._blockCount[0], oldWeightMapComplexityV = this._weightMapSize * this._blockCount[1], weightMapComplexityU = info.weightMapSize * info.blockCount[0], weightMapComplexityV = info.weightMapSize * info.blockCount[1];
            if (weightMapComplexityU === oldWeightMapComplexityU && weightMapComplexityV === oldWeightMapComplexityV) return !1;
            for (var weights = new Uint8Array(weightMapComplexityU * weightMapComplexityV * 4), i = 0; i < weightMapComplexityU * weightMapComplexityV; ++i) weights[4 * i + 0] = 255, 
            weights[4 * i + 1] = 0, weights[4 * i + 2] = 0, weights[4 * i + 3] = 0;
            for (var w = Math.min(info.blockCount[0], this._blockCount[0]), h = Math.min(info.blockCount[1], this._blockCount[1]), getOldWeight = function getOldWeight(_i, _j, _weights) {
                var index = _j * oldWeightMapComplexityU + _i, weight = new Vec4;
                return weight.x = _weights[4 * index + 0] / 255, weight.y = _weights[4 * index + 1] / 255, 
                weight.z = _weights[4 * index + 2] / 255, weight.w = _weights[4 * index + 3] / 255, 
                weight;
            }, sampleOldWeight = function sampleOldWeight(_x, _y, _xOff, _yOff, _weights) {
                var ix0 = Math.floor(_x), iz0 = Math.floor(_y), ix1 = ix0 + 1, iz1 = iz0 + 1, dx = _x - ix0, dz = _y - iz0, a = getOldWeight(ix0 + _xOff, iz0 + _yOff, _this4._weights), b = getOldWeight(ix1 + _xOff, iz0 + _yOff, _this4._weights), c = getOldWeight(ix0 + _xOff, iz1 + _yOff, _this4._weights), d = getOldWeight(ix1 + _xOff, iz1 + _yOff, _this4._weights), m = new Vec4;
                Vec4.add(m, b, c).multiplyScalar(.5), dx + dz <= 1 ? (d.set(m), d.subtract(a), d.add(m)) : (a.set(m), 
                a.subtract(d), a.add(m));
                var n1 = new Vec4, n2 = new Vec4, n = new Vec4;
                return Vec4.lerp(n1, a, b, dx), Vec4.lerp(n2, c, d, dx), Vec4.lerp(n, n1, n2, dz), 
                n;
            }, j = 0; j < h; ++j) for (var _i13 = 0; _i13 < w; ++_i13) for (var uOff = _i13 * oldWeightMapSize, vOff = j * oldWeightMapSize, v = 0; v < info.weightMapSize; ++v) for (var u = 0; u < info.weightMapSize; ++u) {
                var _w = void 0;
                if (info.weightMapSize === oldWeightMapSize) _w = getOldWeight(u + uOff, v + vOff, this._weights); else _w = sampleOldWeight(u / (info.weightMapSize - 1) * (oldWeightMapSize - 1), v / (info.weightMapSize - 1) * (oldWeightMapSize - 1), uOff, vOff, this._weights);
                var du = _i13 * info.weightMapSize + u, index = (j * info.weightMapSize + v) * weightMapComplexityU + du;
                weights[4 * index + 0] = 255 * _w.x, weights[4 * index + 1] = 255 * _w.y, weights[4 * index + 2] = 255 * _w.z, 
                weights[4 * index + 3] = 255 * _w.w;
            }
            return this._weights = weights, !0;
        }
    }, {
        key: "_asset",
        set: function set(value) {
            if (this.__asset !== value && (this.__asset = value, null != this.__asset && this.valid)) {
                for (var _step8, _iterator8 = _createForOfIteratorHelperLoose(this._blocks); !(_step8 = _iterator8()).done; ) {
                    _step8.value.destroy();
                }
                this._blocks = [], this._blockInfos = [], this._buildImp();
            }
        },
        get: function get() {
            return this.__asset;
        }
    }, {
        key: "size",
        get: function get() {
            var sz = new Size(0, 0);
            return sz.width = 32 * this.blockCount[0] * this.tileSize, sz.height = 32 * this.blockCount[1] * this.tileSize, 
            sz;
        }
    }, {
        key: "tileSize",
        get: function get() {
            return this._tileSize;
        }
    }, {
        key: "tileCount",
        get: function get() {
            return [ 32 * this.blockCount[0], 32 * this.blockCount[1] ];
        }
    }, {
        key: "vertexCount",
        get: function get() {
            var _vertexCount = this.tileCount;
            return _vertexCount[0] += 1, _vertexCount[1] += 1, _vertexCount;
        }
    }, {
        key: "blockCount",
        get: function get() {
            return this._blockCount;
        }
    }, {
        key: "lightMapSize",
        get: function get() {
            return this._lightMapSize;
        }
    }, {
        key: "weightMapSize",
        get: function get() {
            return this._weightMapSize;
        }
    }, {
        key: "heights",
        get: function get() {
            return this._heights;
        }
    }, {
        key: "weights",
        get: function get() {
            return this._weights;
        }
    }, {
        key: "valid",
        get: function get() {
            return this._blocks.length > 0;
        }
    }, {
        key: "info",
        get: function get() {
            var ti = new TerrainInfo;
            return ti.tileSize = this.tileSize, ti.blockCount[0] = this.blockCount[0], ti.blockCount[1] = this.blockCount[1], 
            ti.weightMapSize = this.weightMapSize, ti.lightMapSize = this.lightMapSize, ti;
        }
    } ]), Terrain;
}()).prototype, "__asset", [ _dec7$L ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return null;
    }
}), _descriptor14$a = _applyDecoratedDescriptor(_class14$1.prototype, "_layers", [ _dec8$F ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor15$6 = _applyDecoratedDescriptor(_class14$1.prototype, "_blockInfos", [ _dec9$v ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _descriptor16$6 = _applyDecoratedDescriptor(_class14$1.prototype, "_lightmapInfos", [ _dec10$n ], {
    configurable: !0,
    enumerable: !0,
    writable: !0,
    initializer: function initializer() {
        return [];
    }
}), _applyDecoratedDescriptor(_class14$1.prototype, "_asset", [ _dec11$m ], Object.getOwnPropertyDescriptor(_class14$1.prototype, "_asset"), _class14$1.prototype), 
_applyDecoratedDescriptor(_class14$1.prototype, "info", [ _dec12$l ], Object.getOwnPropertyDescriptor(_class14$1.prototype, "info"), _class14$1.prototype), 
_class13$1 = _class14$1)) || _class13$1) || _class13$1) || _class13$1) || _class13$1);

exports.Acceleration = Acceleration$1, exports.AffineTransform = AffineTransform, 
exports.AnimCurve = AnimCurve, exports.AnimationManager = AnimationManager, exports.AnimationState = AnimationState, 
exports.Asset = Asset, exports.AssetLibrary = AssetLibrary, exports.AudioSourceComponent = AudioSourceComponent, 
exports.BASELINE_RATIO = .26, exports.BaseNode = BaseNode, exports.BatchedSkinningModelComponent = BatchedSkinningModelComponent, 
exports.BatchingUtility = BatchingUtility, exports.BillboardComponent = BillboardComponent, 
exports.BitMask = BitMask, exports.BitmapFont = BitmapFont, exports.BlockInputEventsComponent = BlockInputEventsComponent, 
exports.BoxColliderComponent = BoxColliderComponent, exports.ButtonComponent = ButtonComponent, 
exports.CCBoolean = CCBoolean, exports.CCClass = CCClass, exports.CCFloat = CCFloat, 
exports.CCInteger = CCInteger, exports.CCObject = CCObject, exports.CCString = CCString, 
exports.CachedArray = CachedArray, exports.CanvasComponent = CanvasComponent, exports.CanvasPool = CanvasPool, 
exports.CapsuleColliderComponent = CapsuleColliderComponent, exports.ColliderComponent = ColliderComponent, 
exports.Color = Color, exports.CompactValueTypeArray = CompactValueTypeArray, exports.Component = Component, 
exports.ComponentModifier = ComponentModifier, exports.ConstantForce = ConstantForce, 
exports.CubicSplineNumberValue = CubicSplineNumberValue, exports.CubicSplineQuatValue = CubicSplineQuatValue, 
exports.CubicSplineVec2Value = CubicSplineVec2Value, exports.CubicSplineVec3Value = CubicSplineVec3Value, 
exports.CubicSplineVec4Value = CubicSplineVec4Value, exports.CurveRange = CurveRange, 
exports.CurveValueAdapter = CurveValueAdapter, exports.CylinderColliderComponent = CylinderColliderComponent, 
exports.DirectionalLightComponent = DirectionalLightComponent, exports.Director = Director, 
exports.Downloader = Downloader, exports.EPSILON = EPSILON, exports.EditBoxComponent = EditBoxComponent, 
exports.EffectAsset = EffectAsset, exports.Enum = Enum, exports.Event = Event, exports.EventAcceleration = EventAcceleration, 
exports.EventHandler = EventHandler, exports.EventInfo = EventInfo, exports.EventKeyboard = EventKeyboard, 
exports.EventMouse = EventMouse, exports.EventTarget = EventTarget, exports.EventTouch = EventTouch, 
exports.Eventify = Eventify, exports.Font = Font, exports.ForwardFlow = ForwardFlow, 
exports.ForwardPipeline = ForwardPipeline, exports.ForwardStage = ForwardStage, 
exports.GFXBindingLayout = GFXBindingLayout, exports.GFXBindingUnit = function GFXBindingUnit() {
    _classCallCheck(this, GFXBindingUnit), this.binding = 0, this.type = exports.GFXBindingType.UNKNOWN, 
    this.name = "", this.buffer = null, this.texView = null, this.sampler = null;
}, exports.GFXBlendState = GFXBlendState, exports.GFXBlendTarget = GFXBlendTarget, 
exports.GFXBuffer = GFXBuffer, exports.GFXBufferTextureCopy = GFXBufferTextureCopy, 
exports.GFXColorAttachment = function GFXColorAttachment() {
    _classCallCheck(this, GFXColorAttachment), this.format = exports.GFXFormat.UNKNOWN, 
    this.loadOp = exports.GFXLoadOp.CLEAR, this.storeOp = exports.GFXStoreOp.STORE, 
    this.sampleCount = 1, this.beginLayout = exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL, 
    this.endLayout = exports.GFXTextureLayout.COLOR_ATTACHMENT_OPTIMAL;
}, exports.GFXCommandAllocator = GFXCommandAllocator, exports.GFXCommandBuffer = GFXCommandBuffer, 
exports.GFXDepthStencilAttachment = function GFXDepthStencilAttachment() {
    _classCallCheck(this, GFXDepthStencilAttachment), this.format = exports.GFXFormat.UNKNOWN, 
    this.depthLoadOp = exports.GFXLoadOp.CLEAR, this.depthStoreOp = exports.GFXStoreOp.STORE, 
    this.stencilLoadOp = exports.GFXLoadOp.CLEAR, this.stencilStoreOp = exports.GFXStoreOp.STORE, 
    this.sampleCount = 1, this.beginLayout = exports.GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL, 
    this.endLayout = exports.GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
}, exports.GFXDepthStencilState = GFXDepthStencilState, exports.GFXDevice = GFXDevice, 
exports.GFXFormatInfos = GFXFormatInfos, exports.GFXFormatSize = GFXFormatSize, 
exports.GFXFormatSurfaceSize = GFXFormatSurfaceSize, exports.GFXFramebuffer = GFXFramebuffer, 
exports.GFXGetTypeSize = GFXGetTypeSize, exports.GFXInputAssembler = GFXInputAssembler, 
exports.GFXInputState = GFXInputState, exports.GFXObject = GFXObject, exports.GFXPipelineLayout = GFXPipelineLayout, 
exports.GFXPipelineState = GFXPipelineState, exports.GFXQueue = GFXQueue, exports.GFXRasterizerState = GFXRasterizerState, 
exports.GFXRenderPass = GFXRenderPass, exports.GFXSampler = GFXSampler, exports.GFXSamplerState = GFXSamplerState, 
exports.GFXShader = GFXShader, exports.GFXTexture = GFXTexture, exports.GFXTextureCopy = GFXTextureCopy, 
exports.GFXTextureSubres = GFXTextureSubres, exports.GFXTextureView = GFXTextureView, 
exports.GFXUniform = function GFXUniform() {
    _classCallCheck(this, GFXUniform), this.name = "", this.type = exports.GFXType.UNKNOWN, 
    this.count = 1;
}, exports.GFXUniformBlock = function GFXUniformBlock() {
    _classCallCheck(this, GFXUniformBlock), this.binding = -1, this.name = "", this.members = [];
}, exports.GFXUniformSampler = function GFXUniformSampler() {
    _classCallCheck(this, GFXUniformSampler), this.binding = -1, this.name = "", this.type = exports.GFXType.UNKNOWN, 
    this.count = 1;
}, exports.GFXWindow = GFXWindow, exports.GFX_DRAW_INFO_SIZE = 56, exports.GFX_MAX_ATTACHMENTS = 4, 
exports.GFX_MAX_BUFFER_BINDINGS = 24, exports.GFX_MAX_TEXTURE_UNITS = 16, exports.GFX_MAX_VERTEX_ATTRIBUTES = 16, 
exports.Game = Game, exports.GraphicsComponent = GraphicsComponent, exports.HeightField = HeightField, 
exports.HierachyModifier = HierachyModifier, exports.HtmlTextParser = HtmlTextParser, 
exports.ImageAsset = ImageAsset, exports.IsPowerOf2 = IsPowerOf2, exports.JavaScript = JavaScript, 
exports.JsonAsset = JsonAsset, exports.LabelAtlas = LabelAtlas, exports.LabelComponent = LabelComponent, 
exports.LabelOutlineComponent = LabelOutlineComponent, exports.Layers = Layers, 
exports.LayoutComponent = LayoutComponent, exports.LineComponent = LineComponent, 
exports.Loader = Loader, exports.LoadingItems = LoadingItems, exports.MaskComponent = MaskComponent, 
exports.Mat3 = Mat3, exports.Mat4 = Mat4, exports.Material = Material, exports.Mesh = Mesh, 
exports.MeshBuffer = MeshBuffer, exports.MeshColliderComponent = MeshColliderComponent, 
exports.MissingScript = MissingScript, exports.Node = Node$1, exports.NodeActivator = NodeActivator, 
exports.NodePool = NodePool, exports.PageViewComponent = PageViewComponent, exports.PageViewIndicatorComponent = PageViewIndicatorComponent, 
exports.ParticleSystemComponent = ParticleSystemComponent, exports.ParticleUtils = ParticleUtils, 
exports.PhysicMaterial = PhysicMaterial, exports.PhysicsRayResult = PhysicsRayResult, 
exports.PhysicsSystem = PhysicsSystem, exports.Pipeline = Pipeline, exports.Pool = Pool$1, 
exports.Prefab = Prefab, exports.PrefabInfo = PrefabInfo, exports.PrivateNode = PrivateNode, 
exports.Profiler = Profiler, exports.ProgressBarComponent = ProgressBarComponent, 
exports.Quat = Quat, exports.RatioSampler = RatioSampler, exports.RawAsset = RawAsset, 
exports.Rect = Rect, exports.RecyclePool = RecyclePool, exports.RenderFlow = RenderFlow, 
exports.RenderPipeline = RenderPipeline, exports.RenderPipelineAsset = RenderPipelineAsset, 
exports.RenderStage = RenderStage, exports.RenderTexture = RenderTexture, exports.RenderView = RenderView, 
exports.RenderableComponent = RenderableComponent, exports.ResolutionPolicy = ResolutionPolicy, 
exports.RichTextComponent = RichTextComponent, exports.RigidBodyComponent = RigidBodyComponent, 
exports.Scene = Scene, exports.SceneAsset = SceneAsset, exports.Scheduler = Scheduler, 
exports.Script = Script, exports.ScrollBarComponent = ScrollBarComponent, exports.ScrollViewComponent = ScrollViewComponent, 
exports.Size = Size, exports.SkelAnimDataHub = SkelAnimDataHub, exports.SkeletalAnimationComponent = SkeletalAnimationComponent, 
exports.SkeletalAnimationState = SkeletalAnimationState, exports.Skeleton = Skeleton, 
exports.SkinningModelComponent = SkinningModelComponent, exports.SkinningModelUnit = SkinningModelUnit, 
exports.SliderComponent = SliderComponent, exports.Socket = Socket, exports.SphereColliderComponent = SphereColliderComponent, 
exports.SphereLightComponent = SphereLightComponent, exports.SpotLightComponent = SpotLightComponent, 
exports.SpriteAtlas = SpriteAtlas, exports.SpriteComponent = SpriteComponent, exports.SpriteFrame = SpriteFrame, 
exports.StencilManager = StencilManager, exports.SubContextView = SubContextView, 
exports.System = System, exports.SystemEvent = SystemEvent, exports.TERRAIN_BLOCK_TILE_COMPLEXITY = 32, 
exports.TERRAIN_BLOCK_VERTEX_COMPLEXITY = 33, exports.TERRAIN_BLOCK_VERTEX_SIZE = 8, 
exports.TERRAIN_DATA_VERSION = 16842753, exports.TERRAIN_DATA_VERSION2 = 16842754, 
exports.TERRAIN_DATA_VERSION3 = 16842755, exports.TERRAIN_DATA_VERSION_DEFAULT = 16843025, 
exports.TERRAIN_EAST_INDEX = 3, exports.TERRAIN_HEIGHT_BASE = 32768, exports.TERRAIN_HEIGHT_FACTORY = 1 / 512, 
exports.TERRAIN_HEIGHT_FMAX = 1 / 512 * 32767, exports.TERRAIN_HEIGHT_FMIN = -64, 
exports.TERRAIN_MAX_BLEND_LAYERS = 4, exports.TERRAIN_MAX_LAYER_COUNT = 256, exports.TERRAIN_MAX_LEVELS = 4, 
exports.TERRAIN_NORTH_INDEX = 0, exports.TERRAIN_SOUTH_INDEX = 1, exports.TERRAIN_WEST_INDEX = 2, 
exports.TTFFont = TTFFont, exports.Terrain = Terrain, exports.TerrainAsset = TerrainAsset, 
exports.TerrainBlock = TerrainBlock, exports.TerrainBlockInfo = TerrainBlockInfo, 
exports.TerrainBlockLightmapInfo = TerrainBlockLightmapInfo, exports.TerrainInfo = TerrainInfo, 
exports.TerrainLayer = TerrainLayer, exports.TerrainLayerInfo = TerrainLayerInfo, 
exports.TextAsset = TextAsset, exports.Texture2D = Texture2D, exports.TextureCube = TextureCube, 
exports.ToggleComponent = ToggleComponent, exports.ToggleContainerComponent = ToggleContainerComponent, 
exports.ToneMapFlow = ToneMapFlow, exports.ToneMapStage = ToneMapStage, exports.Touch = Touch, 
exports.Tween = Tween, exports.TweenSystem = TweenSystem, exports.TypeScript = TypeScript, 
exports.UIComponent = UIComponent, exports.UICoordinateTrackerComponent = UICoordinateTrackerComponent, 
exports.UIModelComponent = UIModelComponent, exports.UIOpacityComponent = UIOpacityComponent, 
exports.UIRenderComponent = UIRenderComponent, exports.UIReorderComponent = UIReorderComponent, 
exports.UIStaticBatchComponent = UIStaticBatchComponent, exports.UITransformComponent = UITransformComponent, 
exports.UIVertexFormat = UIVertexFormat, exports.UniformCurveValueAdapter = UniformCurveValueAdapter, 
exports.ValueType = ValueType, exports.Vec2 = Vec2, exports.Vec3 = Vec3, exports.Vec4 = Vec4, 
exports.View = View, exports.ViewGroupComponent = ViewGroupComponent, exports.WebviewComponent = WebviewComponent, 
exports.WorldNode3DToLocalNodeUI = WorldNode3DToLocalNodeUI, exports.WorldNode3DToWorldNodeUI = WorldNode3DToWorldNodeUI, 
exports._decorator = _decorator, exports.absMax = absMax, exports.absMaxComponent = absMaxComponent, 
exports.animation = animation, exports.approx = approx, exports.assert = assert, 
exports.assertID = assertID, exports.barFilled = barFilled, exports.bezier = bezier, 
exports.bezierByTime = bezierByTime, exports.bits = bits, exports.bmfont = bmfont, 
exports.builtinResMgr = builtinResMgr, exports.ccenum = ccenum, exports.cclegacy = cclegacy, 
exports.clamp = clamp, exports.clamp01 = clamp01, exports.color = color, exports.computeRatioByType = computeRatioByType, 
exports.convertUtils = convertUtils, exports.deserialize = deserialize, exports.director = director, 
exports.easing = easing, exports.effects = effects, exports.equals = equals, exports.error = error, 
exports.errorID = errorID, exports.eventManager = eventManager, exports.find = find, 
exports.fragmentText = fragmentText, exports.game = game, exports.geometry = geometry, 
exports.getPathFromRoot = function getPathFromRoot(target, root) {
    for (var node = target, path = ""; null !== node && node !== root; ) path = "".concat(node.name, "/").concat(path), 
    node = node.parent;
    return path.slice(0, -1);
}, exports.getTypedArrayConstructor = getTypedArrayConstructor, exports.getWorldTransformUntilRoot = getWorldTransformUntilRoot, 
exports.graphics = graphicsAssembler, exports.graphicsAssembler = graphicsAssemblerManager, 
exports.instantiate = instantiate, exports.inverseLerp = inverseLerp, exports.isCustomTargetModifier = isCustomTargetModifier, 
exports.isDisplayStats = isDisplayStats, exports.isElementModifier = isElementModifier, 
exports.isPropertyModifier = isPropertyModifier, exports.isUnicodeCJK = isUnicodeCJK, 
exports.isUnicodeSpace = isUnicodeSpace, exports.isValid = isValid, exports.js = js$1, 
exports.labelAssembler = labelAssembler, exports.lerp = lerp, exports.letter = letter, 
exports.loader = loader, exports.log = log, exports.logID = logID, exports.macro = macro, 
exports.mask = maskAssembler, exports.maskEnd = maskEndAssembler, exports.mat4 = mat4, 
exports.math = math, exports.memop = index, exports.misc = misc, exports.murmurhash2_32_gc = murmurhash2_32_gc, 
exports.nextPow2 = nextPow2$1, exports.path = path, exports.pingPong = pingPong, 
exports.pipeline = pipeline, exports.primitives = primitives, exports.profiler = profiler, 
exports.pseudoRandom = pseudoRandom, exports.pseudoRandomRange = pseudoRandomRange, 
exports.pseudoRandomRangeInt = pseudoRandomRangeInt, exports.quat = quat, exports.radialFilled = radialFilled, 
exports.random = random, exports.randomRange = randomRange, exports.randomRangeInt = randomRangeInt, 
exports.rect = rect, exports.renderer = renderer, exports.repeat = repeat, exports.safeMeasureText = safeMeasureText, 
exports.sampleAnimationCurve = sampleAnimationCurve, exports.screen = screen$1, 
exports.setDefaultLogTimes = function setDefaultLogTimes(times) {
    times > 0 && (defaultLogTimes = times);
}, exports.setDisplayStats = setDisplayStats, exports.simple = simple, exports.size = size, 
exports.sliced = sliced, exports.spriteAssembler = spriteAssembler, exports.sys = sys, 
exports.systemEvent = systemEvent, exports.textureUtil = textureUtil, exports.toDegree = toDegree, 
exports.toRadian = toRadian, exports.ttf = ttf, exports.tween = tween, exports.tweenUtil = tweenUtil, 
exports.url = url, exports.utils = utils, exports.v2 = v2, exports.v3 = v3, exports.v4 = v4, 
exports.view = view, exports.warn = warn, exports.warnID = warnID, exports.widgetManager = widgetManager;
//# sourceMappingURL=5dd715c4ae060ce5ae416e97dd2d3baf.map
